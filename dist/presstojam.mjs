/*! DS Library v3.2.65 */

import { h, getCurrentInstance, inject, onMounted, onUnmounted, shallowRef, ref, computed, onBeforeMount, watch, Fragment, effectScope, isRef, createVNode, Text, reactive, openBlock, createElementBlock, renderSlot, createCommentVNode, createElementVNode, normalizeClass, resolveDirective, withDirectives, toDisplayString as toDisplayString$1, createBlock, Transition, withCtx, vShow, unref, createTextVNode, mergeProps, resolveComponent, resolveDynamicComponent, renderList, normalizeStyle, Teleport, onBeforeUnmount, normalizeProps, guardReactiveProps, toHandlers, vModelText, createSlots, withKeys, provide, withAsyncContext, withModifiers, Suspense, nextTick, defineComponent, watchEffect, onUpdated, pushScopeId, popScopeId } from 'vue';

/*!
  * shared v9.2.2
  * (c) 2022 kazuya kawaguchi
  * Released under the MIT License.
  */

/**
 * Original Utilities
 * written by kazuya kawaguchi
 */
const inBrowser = typeof window !== 'undefined';
let mark;
let measure;

if (process.env.NODE_ENV !== 'production') {
  const perf = inBrowser && window.performance;

  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = tag => perf.mark(tag);

    measure = (name, startTag, endTag) => {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
    };
  }
}

const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
/* eslint-disable */

function format(message, ...args) {
  if (args.length === 1 && isObject$1(args[0])) {
    args = args[0];
  }

  if (!args || !args.hasOwnProperty) {
    args = {};
  }

  return message.replace(RE_ARGS, (match, identifier) => {
    return args.hasOwnProperty(identifier) ? args[identifier] : '';
  });
}

const hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

const makeSymbol = name => hasSymbol ? Symbol(name) : name;

const generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({
  l: locale,
  k: key,
  s: source
});

const friendlyJSONstringify = json => JSON.stringify(json).replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029').replace(/\u0027/g, '\\u0027');

const isNumber$1 = val => typeof val === 'number' && isFinite(val);

const isDate = val => toTypeString(val) === '[object Date]';

const isRegExp = val => toTypeString(val) === '[object RegExp]';

const isEmptyObject = val => isPlainObject(val) && Object.keys(val).length === 0;

function warn$1(msg, err) {
  if (typeof console !== 'undefined') {
    console.warn(`[intlify] ` + msg);
    /* istanbul ignore if */

    if (err) {
      console.warn(err.stack);
    }
  }
}

const assign$1 = Object.assign;

let _globalThis;

const getGlobalThis = () => {
  // prettier-ignore
  return _globalThis || (_globalThis = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {});
};

function escapeHtml(rawText) {
  return rawText.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
}

const hasOwnProperty = Object.prototype.hasOwnProperty;

function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
/* eslint-enable */

/**
 * Useful Utilities By Evan you
 * Modified by kazuya kawaguchi
 * MIT License
 * https://github.com/vuejs/vue-next/blob/master/packages/shared/src/index.ts
 * https://github.com/vuejs/vue-next/blob/master/packages/shared/src/codeframe.ts
 */


const isArray$2 = Array.isArray;

const isFunction$1 = val => typeof val === 'function';

const isString = val => typeof val === 'string';

const isBoolean = val => typeof val === 'boolean';

const isObject$1 = val => // eslint-disable-line
val !== null && typeof val === 'object';

const objectToString = Object.prototype.toString;

const toTypeString = value => objectToString.call(value);

const isPlainObject = val => toTypeString(val) === '[object Object]'; // for converting list and named values to displayed strings.


const toDisplayString = val => {
  return val == null ? '' : isArray$2(val) || isPlainObject(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
};

const RANGE = 2;

function generateCodeFrame(source, start = 0, end = source.length) {
  const lines = source.split(/\r?\n/);
  let count = 0;
  const res = [];

  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;

    if (count >= start) {
      for (let j = i - RANGE; j <= i + RANGE || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        const line = j + 1;
        res.push(`${line}${' '.repeat(3 - String(line).length)}|  ${lines[j]}`);
        const lineLength = lines[j].length;

        if (j === i) {
          // push underline
          const pad = start - (count - lineLength) + 1;
          const length = Math.max(1, end > count ? lineLength - pad : end - start);
          res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + '^'.repeat(length));
          }

          count += lineLength + 1;
        }
      }

      break;
    }
  }

  return res.join('\n');
}
/**
 * Event emitter, forked from the below:
 * - original repository url: https://github.com/developit/mitt
 * - code url: https://github.com/developit/mitt/blob/master/src/index.ts
 * - author: Jason Miller (https://github.com/developit)
 * - license: MIT
 */

/**
 * Create a event emitter
 *
 * @returns An event emitter
 */


function createEmitter() {
  const events = new Map();
  const emitter = {
    events,

    on(event, handler) {
      const handlers = events.get(event);
      const added = handlers && handlers.push(handler);

      if (!added) {
        events.set(event, [handler]);
      }
    },

    off(event, handler) {
      const handlers = events.get(event);

      if (handlers) {
        handlers.splice(handlers.indexOf(handler) >>> 0, 1);
      }
    },

    emit(event, payload) {
      (events.get(event) || []).slice().map(handler => handler(payload));
      (events.get('*') || []).slice().map(handler => handler(event, payload));
    }

  };
  return emitter;
}

/*!
  * message-compiler v9.2.2
  * (c) 2022 kazuya kawaguchi
  * Released under the MIT License.
  */
const CompileErrorCodes = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 15
};
/** @internal */

const errorMessages$2 = {
  // tokenizer error messages
  [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
  [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
  [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
  [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
  [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
  [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
  [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
  [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
  [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
  [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
  // parser error messages
  [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
  [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`
};

function createCompileError(code, loc, options = {}) {
  const {
    domain,
    messages,
    args
  } = options;
  const msg = process.env.NODE_ENV !== 'production' ? format((messages || errorMessages$2)[code] || '', ...(args || [])) : code;
  const error = new SyntaxError(String(msg));
  error.code = code;

  if (loc) {
    error.location = loc;
  }

  error.domain = domain;
  return error;
}
/** @internal */


function defaultOnError(error) {
  throw error;
}

function createPosition(line, column, offset) {
  return {
    line,
    column,
    offset
  };
}

function createLocation(start, end, source) {
  const loc = {
    start,
    end
  };

  if (source != null) {
    loc.source = source;
  }

  return loc;
}

const CHAR_SP = ' ';
const CHAR_CR = '\r';
const CHAR_LF = '\n';
const CHAR_LS = String.fromCharCode(0x2028);
const CHAR_PS = String.fromCharCode(0x2029);

function createScanner(str) {
  const _buf = str;
  let _index = 0;
  let _line = 1;
  let _column = 1;
  let _peekOffset = 0;

  const isCRLF = index => _buf[index] === CHAR_CR && _buf[index + 1] === CHAR_LF;

  const isLF = index => _buf[index] === CHAR_LF;

  const isPS = index => _buf[index] === CHAR_PS;

  const isLS = index => _buf[index] === CHAR_LS;

  const isLineEnd = index => isCRLF(index) || isLF(index) || isPS(index) || isLS(index);

  const index = () => _index;

  const line = () => _line;

  const column = () => _column;

  const peekOffset = () => _peekOffset;

  const charAt = offset => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];

  const currentChar = () => charAt(_index);

  const currentPeek = () => charAt(_index + _peekOffset);

  function next() {
    _peekOffset = 0;

    if (isLineEnd(_index)) {
      _line++;
      _column = 0;
    }

    if (isCRLF(_index)) {
      _index++;
    }

    _index++;
    _column++;
    return _buf[_index];
  }

  function peek() {
    if (isCRLF(_index + _peekOffset)) {
      _peekOffset++;
    }

    _peekOffset++;
    return _buf[_index + _peekOffset];
  }

  function reset() {
    _index = 0;
    _line = 1;
    _column = 1;
    _peekOffset = 0;
  }

  function resetPeek(offset = 0) {
    _peekOffset = offset;
  }

  function skipToPeek() {
    const target = _index + _peekOffset; // eslint-disable-next-line no-unmodified-loop-condition

    while (target !== _index) {
      next();
    }

    _peekOffset = 0;
  }

  return {
    index,
    line,
    column,
    peekOffset,
    charAt,
    currentChar,
    currentPeek,
    next,
    peek,
    reset,
    resetPeek,
    skipToPeek
  };
}

const EOF = undefined;
const LITERAL_DELIMITER = "'";
const ERROR_DOMAIN$1 = 'tokenizer';

function createTokenizer(source, options = {}) {
  const location = options.location !== false;

  const _scnr = createScanner(source);

  const currentOffset = () => _scnr.index();

  const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());

  const _initLoc = currentPosition();

  const _initOffset = currentOffset();

  const _context = {
    currentType: 14
    /* EOF */
    ,
    offset: _initOffset,
    startLoc: _initLoc,
    endLoc: _initLoc,
    lastType: 14
    /* EOF */
    ,
    lastOffset: _initOffset,
    lastStartLoc: _initLoc,
    lastEndLoc: _initLoc,
    braceNest: 0,
    inLinked: false,
    text: ''
  };

  const context = () => _context;

  const {
    onError
  } = options;

  function emitError(code, pos, offset, ...args) {
    const ctx = context();
    pos.column += offset;
    pos.offset += offset;

    if (onError) {
      const loc = createLocation(ctx.startLoc, pos);
      const err = createCompileError(code, loc, {
        domain: ERROR_DOMAIN$1,
        args
      });
      onError(err);
    }
  }

  function getToken(context, type, value) {
    context.endLoc = currentPosition();
    context.currentType = type;
    const token = {
      type
    };

    if (location) {
      token.loc = createLocation(context.startLoc, context.endLoc);
    }

    if (value != null) {
      token.value = value;
    }

    return token;
  }

  const getEndToken = context => getToken(context, 14
  /* EOF */
  );

  function eat(scnr, ch) {
    if (scnr.currentChar() === ch) {
      scnr.next();
      return ch;
    } else {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
      return '';
    }
  }

  function peekSpaces(scnr) {
    let buf = '';

    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
      buf += scnr.currentPeek();
      scnr.peek();
    }

    return buf;
  }

  function skipSpaces(scnr) {
    const buf = peekSpaces(scnr);
    scnr.skipToPeek();
    return buf;
  }

  function isIdentifierStart(ch) {
    if (ch === EOF) {
      return false;
    }

    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc === 95 // _
    ;
  }

  function isNumberStart(ch) {
    if (ch === EOF) {
      return false;
    }

    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57; // 0-9
  }

  function isNamedIdentifierStart(scnr, context) {
    const {
      currentType
    } = context;

    if (currentType !== 2
    /* BraceLeft */
    ) {
      return false;
    }

    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }

  function isListIdentifierStart(scnr, context) {
    const {
      currentType
    } = context;

    if (currentType !== 2
    /* BraceLeft */
    ) {
      return false;
    }

    peekSpaces(scnr);
    const ch = scnr.currentPeek() === '-' ? scnr.peek() : scnr.currentPeek();
    const ret = isNumberStart(ch);
    scnr.resetPeek();
    return ret;
  }

  function isLiteralStart(scnr, context) {
    const {
      currentType
    } = context;

    if (currentType !== 2
    /* BraceLeft */
    ) {
      return false;
    }

    peekSpaces(scnr);
    const ret = scnr.currentPeek() === LITERAL_DELIMITER;
    scnr.resetPeek();
    return ret;
  }

  function isLinkedDotStart(scnr, context) {
    const {
      currentType
    } = context;

    if (currentType !== 8
    /* LinkedAlias */
    ) {
      return false;
    }

    peekSpaces(scnr);
    const ret = scnr.currentPeek() === "."
    /* LinkedDot */
    ;
    scnr.resetPeek();
    return ret;
  }

  function isLinkedModifierStart(scnr, context) {
    const {
      currentType
    } = context;

    if (currentType !== 9
    /* LinkedDot */
    ) {
      return false;
    }

    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }

  function isLinkedDelimiterStart(scnr, context) {
    const {
      currentType
    } = context;

    if (!(currentType === 8
    /* LinkedAlias */
    || currentType === 12
    /* LinkedModifier */
    )) {
      return false;
    }

    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ":"
    /* LinkedDelimiter */
    ;
    scnr.resetPeek();
    return ret;
  }

  function isLinkedReferStart(scnr, context) {
    const {
      currentType
    } = context;

    if (currentType !== 10
    /* LinkedDelimiter */
    ) {
      return false;
    }

    const fn = () => {
      const ch = scnr.currentPeek();

      if (ch === "{"
      /* BraceLeft */
      ) {
        return isIdentifierStart(scnr.peek());
      } else if (ch === "@"
      /* LinkedAlias */
      || ch === "%"
      /* Modulo */
      || ch === "|"
      /* Pipe */
      || ch === ":"
      /* LinkedDelimiter */
      || ch === "."
      /* LinkedDot */
      || ch === CHAR_SP || !ch) {
        return false;
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn();
      } else {
        // other characters
        return isIdentifierStart(ch);
      }
    };

    const ret = fn();
    scnr.resetPeek();
    return ret;
  }

  function isPluralStart(scnr) {
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === "|"
    /* Pipe */
    ;
    scnr.resetPeek();
    return ret;
  }

  function detectModuloStart(scnr) {
    const spaces = peekSpaces(scnr);
    const ret = scnr.currentPeek() === "%"
    /* Modulo */
    && scnr.peek() === "{"
    /* BraceLeft */
    ;
    scnr.resetPeek();
    return {
      isModulo: ret,
      hasSpace: spaces.length > 0
    };
  }

  function isTextStart(scnr, reset = true) {
    const fn = (hasSpace = false, prev = '', detectModulo = false) => {
      const ch = scnr.currentPeek();

      if (ch === "{"
      /* BraceLeft */
      ) {
        return prev === "%"
        /* Modulo */
        ? false : hasSpace;
      } else if (ch === "@"
      /* LinkedAlias */
      || !ch) {
        return prev === "%"
        /* Modulo */
        ? true : hasSpace;
      } else if (ch === "%"
      /* Modulo */
      ) {
        scnr.peek();
        return fn(hasSpace, "%"
        /* Modulo */
        , true);
      } else if (ch === "|"
      /* Pipe */
      ) {
        return prev === "%"
        /* Modulo */
        || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);
      } else if (ch === CHAR_SP) {
        scnr.peek();
        return fn(true, CHAR_SP, detectModulo);
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn(true, CHAR_LF, detectModulo);
      } else {
        return true;
      }
    };

    const ret = fn();
    reset && scnr.resetPeek();
    return ret;
  }

  function takeChar(scnr, fn) {
    const ch = scnr.currentChar();

    if (ch === EOF) {
      return EOF;
    }

    if (fn(ch)) {
      scnr.next();
      return ch;
    }

    return null;
  }

  function takeIdentifierChar(scnr) {
    const closure = ch => {
      const cc = ch.charCodeAt(0);
      return cc >= 97 && cc <= 122 || // a-z
      cc >= 65 && cc <= 90 || // A-Z
      cc >= 48 && cc <= 57 || // 0-9
      cc === 95 || // _
      cc === 36 // $
      ;
    };

    return takeChar(scnr, closure);
  }

  function takeDigit(scnr) {
    const closure = ch => {
      const cc = ch.charCodeAt(0);
      return cc >= 48 && cc <= 57; // 0-9
    };

    return takeChar(scnr, closure);
  }

  function takeHexDigit(scnr) {
    const closure = ch => {
      const cc = ch.charCodeAt(0);
      return cc >= 48 && cc <= 57 || // 0-9
      cc >= 65 && cc <= 70 || // A-F
      cc >= 97 && cc <= 102; // a-f
    };

    return takeChar(scnr, closure);
  }

  function getDigits(scnr) {
    let ch = '';
    let num = '';

    while (ch = takeDigit(scnr)) {
      num += ch;
    }

    return num;
  }

  function readModulo(scnr) {
    skipSpaces(scnr);
    const ch = scnr.currentChar();

    if (ch !== "%"
    /* Modulo */
    ) {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
    }

    scnr.next();
    return "%"
    /* Modulo */
    ;
  }

  function readText(scnr) {
    let buf = '';

    while (true) {
      const ch = scnr.currentChar();

      if (ch === "{"
      /* BraceLeft */
      || ch === "}"
      /* BraceRight */
      || ch === "@"
      /* LinkedAlias */
      || ch === "|"
      /* Pipe */
      || !ch) {
        break;
      } else if (ch === "%"
      /* Modulo */
      ) {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else {
          break;
        }
      } else if (ch === CHAR_SP || ch === CHAR_LF) {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else if (isPluralStart(scnr)) {
          break;
        } else {
          buf += ch;
          scnr.next();
        }
      } else {
        buf += ch;
        scnr.next();
      }
    }

    return buf;
  }

  function readNamedIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = '';
    let name = '';

    while (ch = takeIdentifierChar(scnr)) {
      name += ch;
    }

    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }

    return name;
  }

  function readListIdentifier(scnr) {
    skipSpaces(scnr);
    let value = '';

    if (scnr.currentChar() === '-') {
      scnr.next();
      value += `-${getDigits(scnr)}`;
    } else {
      value += getDigits(scnr);
    }

    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }

    return value;
  }

  function readLiteral(scnr) {
    skipSpaces(scnr);
    eat(scnr, `\'`);
    let ch = '';
    let literal = '';

    const fn = x => x !== LITERAL_DELIMITER && x !== CHAR_LF;

    while (ch = takeChar(scnr, fn)) {
      if (ch === '\\') {
        literal += readEscapeSequence(scnr);
      } else {
        literal += ch;
      }
    }

    const current = scnr.currentChar();

    if (current === CHAR_LF || current === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0); // TODO: Is it correct really?

      if (current === CHAR_LF) {
        scnr.next();
        eat(scnr, `\'`);
      }

      return literal;
    }

    eat(scnr, `\'`);
    return literal;
  }

  function readEscapeSequence(scnr) {
    const ch = scnr.currentChar();

    switch (ch) {
      case '\\':
      case `\'`:
        scnr.next();
        return `\\${ch}`;

      case 'u':
        return readUnicodeEscapeSequence(scnr, ch, 4);

      case 'U':
        return readUnicodeEscapeSequence(scnr, ch, 6);

      default:
        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
        return '';
    }
  }

  function readUnicodeEscapeSequence(scnr, unicode, digits) {
    eat(scnr, unicode);
    let sequence = '';

    for (let i = 0; i < digits; i++) {
      const ch = takeHexDigit(scnr);

      if (!ch) {
        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
        break;
      }

      sequence += ch;
    }

    return `\\${unicode}${sequence}`;
  }

  function readInvalidIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = '';
    let identifiers = '';

    const closure = ch => ch !== "{"
    /* BraceLeft */
    && ch !== "}"
    /* BraceRight */
    && ch !== CHAR_SP && ch !== CHAR_LF;

    while (ch = takeChar(scnr, closure)) {
      identifiers += ch;
    }

    return identifiers;
  }

  function readLinkedModifier(scnr) {
    let ch = '';
    let name = '';

    while (ch = takeIdentifierChar(scnr)) {
      name += ch;
    }

    return name;
  }

  function readLinkedRefer(scnr) {
    const fn = (detect = false, buf) => {
      const ch = scnr.currentChar();

      if (ch === "{"
      /* BraceLeft */
      || ch === "%"
      /* Modulo */
      || ch === "@"
      /* LinkedAlias */
      || ch === "|"
      /* Pipe */
      || !ch) {
        return buf;
      } else if (ch === CHAR_SP) {
        return buf;
      } else if (ch === CHAR_LF) {
        buf += ch;
        scnr.next();
        return fn(detect, buf);
      } else {
        buf += ch;
        scnr.next();
        return fn(true, buf);
      }
    };

    return fn(false, '');
  }

  function readPlural(scnr) {
    skipSpaces(scnr);
    const plural = eat(scnr, "|"
    /* Pipe */
    );
    skipSpaces(scnr);
    return plural;
  } // TODO: We need refactoring of token parsing ...


  function readTokenInPlaceholder(scnr, context) {
    let token = null;
    const ch = scnr.currentChar();

    switch (ch) {
      case "{"
      /* BraceLeft */
      :
        if (context.braceNest >= 1) {
          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
        }

        scnr.next();
        token = getToken(context, 2
        /* BraceLeft */
        , "{"
        /* BraceLeft */
        );
        skipSpaces(scnr);
        context.braceNest++;
        return token;

      case "}"
      /* BraceRight */
      :
        if (context.braceNest > 0 && context.currentType === 2
        /* BraceLeft */
        ) {
          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
        }

        scnr.next();
        token = getToken(context, 3
        /* BraceRight */
        , "}"
        /* BraceRight */
        );
        context.braceNest--;
        context.braceNest > 0 && skipSpaces(scnr);

        if (context.inLinked && context.braceNest === 0) {
          context.inLinked = false;
        }

        return token;

      case "@"
      /* LinkedAlias */
      :
        if (context.braceNest > 0) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }

        token = readTokenInLinked(scnr, context) || getEndToken(context);
        context.braceNest = 0;
        return token;

      default:
        let validNamedIdentifier = true;
        let validListIdentifier = true;
        let validLiteral = true;

        if (isPluralStart(scnr)) {
          if (context.braceNest > 0) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }

          token = getToken(context, 1
          /* Pipe */
          , readPlural(scnr)); // reset

          context.braceNest = 0;
          context.inLinked = false;
          return token;
        }

        if (context.braceNest > 0 && (context.currentType === 5
        /* Named */
        || context.currentType === 6
        /* List */
        || context.currentType === 7
        /* Literal */
        )) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          context.braceNest = 0;
          return readToken(scnr, context);
        }

        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context)) {
          token = getToken(context, 5
          /* Named */
          , readNamedIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }

        if (validListIdentifier = isListIdentifierStart(scnr, context)) {
          token = getToken(context, 6
          /* List */
          , readListIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }

        if (validLiteral = isLiteralStart(scnr, context)) {
          token = getToken(context, 7
          /* Literal */
          , readLiteral(scnr));
          skipSpaces(scnr);
          return token;
        }

        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
          // TODO: we should be re-designed invalid cases, when we will extend message syntax near the future ...
          token = getToken(context, 13
          /* InvalidPlace */
          , readInvalidIdentifier(scnr));
          emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
          skipSpaces(scnr);
          return token;
        }

        break;
    }

    return token;
  } // TODO: We need refactoring of token parsing ...


  function readTokenInLinked(scnr, context) {
    const {
      currentType
    } = context;
    let token = null;
    const ch = scnr.currentChar();

    if ((currentType === 8
    /* LinkedAlias */
    || currentType === 9
    /* LinkedDot */
    || currentType === 12
    /* LinkedModifier */
    || currentType === 10
    /* LinkedDelimiter */
    ) && (ch === CHAR_LF || ch === CHAR_SP)) {
      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
    }

    switch (ch) {
      case "@"
      /* LinkedAlias */
      :
        scnr.next();
        token = getToken(context, 8
        /* LinkedAlias */
        , "@"
        /* LinkedAlias */
        );
        context.inLinked = true;
        return token;

      case "."
      /* LinkedDot */
      :
        skipSpaces(scnr);
        scnr.next();
        return getToken(context, 9
        /* LinkedDot */
        , "."
        /* LinkedDot */
        );

      case ":"
      /* LinkedDelimiter */
      :
        skipSpaces(scnr);
        scnr.next();
        return getToken(context, 10
        /* LinkedDelimiter */
        , ":"
        /* LinkedDelimiter */
        );

      default:
        if (isPluralStart(scnr)) {
          token = getToken(context, 1
          /* Pipe */
          , readPlural(scnr)); // reset

          context.braceNest = 0;
          context.inLinked = false;
          return token;
        }

        if (isLinkedDotStart(scnr, context) || isLinkedDelimiterStart(scnr, context)) {
          skipSpaces(scnr);
          return readTokenInLinked(scnr, context);
        }

        if (isLinkedModifierStart(scnr, context)) {
          skipSpaces(scnr);
          return getToken(context, 12
          /* LinkedModifier */
          , readLinkedModifier(scnr));
        }

        if (isLinkedReferStart(scnr, context)) {
          skipSpaces(scnr);

          if (ch === "{"
          /* BraceLeft */
          ) {
            // scan the placeholder
            return readTokenInPlaceholder(scnr, context) || token;
          } else {
            return getToken(context, 11
            /* LinkedKey */
            , readLinkedRefer(scnr));
          }
        }

        if (currentType === 8
        /* LinkedAlias */
        ) {
          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }

        context.braceNest = 0;
        context.inLinked = false;
        return readToken(scnr, context);
    }
  } // TODO: We need refactoring of token parsing ...


  function readToken(scnr, context) {
    let token = {
      type: 14
      /* EOF */

    };

    if (context.braceNest > 0) {
      return readTokenInPlaceholder(scnr, context) || getEndToken(context);
    }

    if (context.inLinked) {
      return readTokenInLinked(scnr, context) || getEndToken(context);
    }

    const ch = scnr.currentChar();

    switch (ch) {
      case "{"
      /* BraceLeft */
      :
        return readTokenInPlaceholder(scnr, context) || getEndToken(context);

      case "}"
      /* BraceRight */
      :
        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
        scnr.next();
        return getToken(context, 3
        /* BraceRight */
        , "}"
        /* BraceRight */
        );

      case "@"
      /* LinkedAlias */
      :
        return readTokenInLinked(scnr, context) || getEndToken(context);

      default:
        if (isPluralStart(scnr)) {
          token = getToken(context, 1
          /* Pipe */
          , readPlural(scnr)); // reset

          context.braceNest = 0;
          context.inLinked = false;
          return token;
        }

        const {
          isModulo,
          hasSpace
        } = detectModuloStart(scnr);

        if (isModulo) {
          return hasSpace ? getToken(context, 0
          /* Text */
          , readText(scnr)) : getToken(context, 4
          /* Modulo */
          , readModulo(scnr));
        }

        if (isTextStart(scnr)) {
          return getToken(context, 0
          /* Text */
          , readText(scnr));
        }

        break;
    }

    return token;
  }

  function nextToken() {
    const {
      currentType,
      offset,
      startLoc,
      endLoc
    } = _context;
    _context.lastType = currentType;
    _context.lastOffset = offset;
    _context.lastStartLoc = startLoc;
    _context.lastEndLoc = endLoc;
    _context.offset = currentOffset();
    _context.startLoc = currentPosition();

    if (_scnr.currentChar() === EOF) {
      return getToken(_context, 14
      /* EOF */
      );
    }

    return readToken(_scnr, _context);
  }

  return {
    nextToken,
    currentOffset,
    currentPosition,
    context
  };
}

const ERROR_DOMAIN = 'parser'; // Backslash backslash, backslash quote, uHHHH, UHHHHHH.

const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;

function fromEscapeSequence(match, codePoint4, codePoint6) {
  switch (match) {
    case `\\\\`:
      return `\\`;

    case `\\\'`:
      return `\'`;

    default:
      {
        const codePoint = parseInt(codePoint4 || codePoint6, 16);

        if (codePoint <= 0xd7ff || codePoint >= 0xe000) {
          return String.fromCodePoint(codePoint);
        } // invalid ...
        // Replace them with U+FFFD REPLACEMENT CHARACTER.


        return '�';
      }
  }
}

function createParser(options = {}) {
  const location = options.location !== false;
  const {
    onError
  } = options;

  function emitError(tokenzer, code, start, offset, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset;
    end.column += offset;

    if (onError) {
      const loc = createLocation(start, end);
      const err = createCompileError(code, loc, {
        domain: ERROR_DOMAIN,
        args
      });
      onError(err);
    }
  }

  function startNode(type, offset, loc) {
    const node = {
      type,
      start: offset,
      end: offset
    };

    if (location) {
      node.loc = {
        start: loc,
        end: loc
      };
    }

    return node;
  }

  function endNode(node, offset, pos, type) {
    node.end = offset;

    if (type) {
      node.type = type;
    }

    if (location && node.loc) {
      node.loc.end = pos;
    }
  }

  function parseText(tokenizer, value) {
    const context = tokenizer.context();
    const node = startNode(3
    /* Text */
    , context.offset, context.startLoc);
    node.value = value;
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }

  function parseList(tokenizer, index) {
    const context = tokenizer.context();
    const {
      lastOffset: offset,
      lastStartLoc: loc
    } = context; // get brace left loc

    const node = startNode(5
    /* List */
    , offset, loc);
    node.index = parseInt(index, 10);
    tokenizer.nextToken(); // skip brach right

    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }

  function parseNamed(tokenizer, key) {
    const context = tokenizer.context();
    const {
      lastOffset: offset,
      lastStartLoc: loc
    } = context; // get brace left loc

    const node = startNode(4
    /* Named */
    , offset, loc);
    node.key = key;
    tokenizer.nextToken(); // skip brach right

    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }

  function parseLiteral(tokenizer, value) {
    const context = tokenizer.context();
    const {
      lastOffset: offset,
      lastStartLoc: loc
    } = context; // get brace left loc

    const node = startNode(9
    /* Literal */
    , offset, loc);
    node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
    tokenizer.nextToken(); // skip brach right

    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }

  function parseLinkedModifier(tokenizer) {
    const token = tokenizer.nextToken();
    const context = tokenizer.context();
    const {
      lastOffset: offset,
      lastStartLoc: loc
    } = context; // get linked dot loc

    const node = startNode(8
    /* LinkedModifier */
    , offset, loc);

    if (token.type !== 12
    /* LinkedModifier */
    ) {
      // empty modifier
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
      node.value = '';
      endNode(node, offset, loc);
      return {
        nextConsumeToken: token,
        node
      };
    } // check token


    if (token.value == null) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }

    node.value = token.value || '';
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node
    };
  }

  function parseLinkedKey(tokenizer, value) {
    const context = tokenizer.context();
    const node = startNode(7
    /* LinkedKey */
    , context.offset, context.startLoc);
    node.value = value;
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }

  function parseLinked(tokenizer) {
    const context = tokenizer.context();
    const linkedNode = startNode(6
    /* Linked */
    , context.offset, context.startLoc);
    let token = tokenizer.nextToken();

    if (token.type === 9
    /* LinkedDot */
    ) {
      const parsed = parseLinkedModifier(tokenizer);
      linkedNode.modifier = parsed.node;
      token = parsed.nextConsumeToken || tokenizer.nextToken();
    } // asset check token


    if (token.type !== 10
    /* LinkedDelimiter */
    ) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }

    token = tokenizer.nextToken(); // skip brace left

    if (token.type === 2
    /* BraceLeft */
    ) {
      token = tokenizer.nextToken();
    }

    switch (token.type) {
      case 11
      /* LinkedKey */
      :
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }

        linkedNode.key = parseLinkedKey(tokenizer, token.value || '');
        break;

      case 5
      /* Named */
      :
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }

        linkedNode.key = parseNamed(tokenizer, token.value || '');
        break;

      case 6
      /* List */
      :
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }

        linkedNode.key = parseList(tokenizer, token.value || '');
        break;

      case 7
      /* Literal */
      :
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }

        linkedNode.key = parseLiteral(tokenizer, token.value || '');
        break;

      default:
        // empty key
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
        const nextContext = tokenizer.context();
        const emptyLinkedKeyNode = startNode(7
        /* LinkedKey */
        , nextContext.offset, nextContext.startLoc);
        emptyLinkedKeyNode.value = '';
        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
        linkedNode.key = emptyLinkedKeyNode;
        endNode(linkedNode, nextContext.offset, nextContext.startLoc);
        return {
          nextConsumeToken: token,
          node: linkedNode
        };
    }

    endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node: linkedNode
    };
  }

  function parseMessage(tokenizer) {
    const context = tokenizer.context();
    const startOffset = context.currentType === 1
    /* Pipe */
    ? tokenizer.currentOffset() : context.offset;
    const startLoc = context.currentType === 1
    /* Pipe */
    ? context.endLoc : context.startLoc;
    const node = startNode(2
    /* Message */
    , startOffset, startLoc);
    node.items = [];
    let nextToken = null;

    do {
      const token = nextToken || tokenizer.nextToken();
      nextToken = null;

      switch (token.type) {
        case 0
        /* Text */
        :
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }

          node.items.push(parseText(tokenizer, token.value || ''));
          break;

        case 6
        /* List */
        :
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }

          node.items.push(parseList(tokenizer, token.value || ''));
          break;

        case 5
        /* Named */
        :
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }

          node.items.push(parseNamed(tokenizer, token.value || ''));
          break;

        case 7
        /* Literal */
        :
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }

          node.items.push(parseLiteral(tokenizer, token.value || ''));
          break;

        case 8
        /* LinkedAlias */
        :
          const parsed = parseLinked(tokenizer);
          node.items.push(parsed.node);
          nextToken = parsed.nextConsumeToken || null;
          break;
      }
    } while (context.currentType !== 14
    /* EOF */
    && context.currentType !== 1
    /* Pipe */
    ); // adjust message node loc


    const endOffset = context.currentType === 1
    /* Pipe */
    ? context.lastOffset : tokenizer.currentOffset();
    const endLoc = context.currentType === 1
    /* Pipe */
    ? context.lastEndLoc : tokenizer.currentPosition();
    endNode(node, endOffset, endLoc);
    return node;
  }

  function parsePlural(tokenizer, offset, loc, msgNode) {
    const context = tokenizer.context();
    let hasEmptyMessage = msgNode.items.length === 0;
    const node = startNode(1
    /* Plural */
    , offset, loc);
    node.cases = [];
    node.cases.push(msgNode);

    do {
      const msg = parseMessage(tokenizer);

      if (!hasEmptyMessage) {
        hasEmptyMessage = msg.items.length === 0;
      }

      node.cases.push(msg);
    } while (context.currentType !== 14
    /* EOF */
    );

    if (hasEmptyMessage) {
      emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
    }

    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }

  function parseResource(tokenizer) {
    const context = tokenizer.context();
    const {
      offset,
      startLoc
    } = context;
    const msgNode = parseMessage(tokenizer);

    if (context.currentType === 14
    /* EOF */
    ) {
      return msgNode;
    } else {
      return parsePlural(tokenizer, offset, startLoc, msgNode);
    }
  }

  function parse(source) {
    const tokenizer = createTokenizer(source, assign$1({}, options));
    const context = tokenizer.context();
    const node = startNode(0
    /* Resource */
    , context.offset, context.startLoc);

    if (location && node.loc) {
      node.loc.source = source;
    }

    node.body = parseResource(tokenizer); // assert whether achieved to EOF

    if (context.currentType !== 14
    /* EOF */
    ) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || '');
    }

    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }

  return {
    parse
  };
}

function getTokenCaption(token) {
  if (token.type === 14
  /* EOF */
  ) {
    return 'EOF';
  }

  const name = (token.value || '').replace(/\r?\n/gu, '\\n');
  return name.length > 10 ? name.slice(0, 9) + '…' : name;
}

function createTransformer(ast, options = {} // eslint-disable-line
) {
  const _context = {
    ast,
    helpers: new Set()
  };

  const context = () => _context;

  const helper = name => {
    _context.helpers.add(name);

    return name;
  };

  return {
    context,
    helper
  };
}

function traverseNodes(nodes, transformer) {
  for (let i = 0; i < nodes.length; i++) {
    traverseNode(nodes[i], transformer);
  }
}

function traverseNode(node, transformer) {
  // TODO: if we need pre-hook of transform, should be implemented to here
  switch (node.type) {
    case 1
    /* Plural */
    :
      traverseNodes(node.cases, transformer);
      transformer.helper("plural"
      /* PLURAL */
      );
      break;

    case 2
    /* Message */
    :
      traverseNodes(node.items, transformer);
      break;

    case 6
    /* Linked */
    :
      const linked = node;
      traverseNode(linked.key, transformer);
      transformer.helper("linked"
      /* LINKED */
      );
      transformer.helper("type"
      /* TYPE */
      );
      break;

    case 5
    /* List */
    :
      transformer.helper("interpolate"
      /* INTERPOLATE */
      );
      transformer.helper("list"
      /* LIST */
      );
      break;

    case 4
    /* Named */
    :
      transformer.helper("interpolate"
      /* INTERPOLATE */
      );
      transformer.helper("named"
      /* NAMED */
      );
      break;
  } // TODO: if we need post-hook of transform, should be implemented to here

} // transform AST


function transform(ast, options = {} // eslint-disable-line
) {
  const transformer = createTransformer(ast);
  transformer.helper("normalize"
  /* NORMALIZE */
  ); // traverse

  ast.body && traverseNode(ast.body, transformer); // set meta information

  const context = transformer.context();
  ast.helpers = Array.from(context.helpers);
}

function createCodeGenerator(ast, options) {
  const {
    sourceMap,
    filename,
    breakLineCode,
    needIndent: _needIndent
  } = options;
  const _context = {
    source: ast.loc.source,
    filename,
    code: '',
    column: 1,
    line: 1,
    offset: 0,
    map: undefined,
    breakLineCode,
    needIndent: _needIndent,
    indentLevel: 0
  };

  const context = () => _context;

  function push(code, node) {
    _context.code += code;
  }

  function _newline(n, withBreakLine = true) {
    const _breakLineCode = withBreakLine ? breakLineCode : '';

    push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
  }

  function indent(withNewLine = true) {
    const level = ++_context.indentLevel;
    withNewLine && _newline(level);
  }

  function deindent(withNewLine = true) {
    const level = --_context.indentLevel;
    withNewLine && _newline(level);
  }

  function newline() {
    _newline(_context.indentLevel);
  }

  const helper = key => `_${key}`;

  const needIndent = () => _context.needIndent;

  return {
    context,
    push,
    indent,
    deindent,
    newline,
    helper,
    needIndent
  };
}

function generateLinkedNode(generator, node) {
  const {
    helper
  } = generator;
  generator.push(`${helper("linked"
  /* LINKED */
  )}(`);
  generateNode(generator, node.key);

  if (node.modifier) {
    generator.push(`, `);
    generateNode(generator, node.modifier);
    generator.push(`, _type`);
  } else {
    generator.push(`, undefined, _type`);
  }

  generator.push(`)`);
}

function generateMessageNode(generator, node) {
  const {
    helper,
    needIndent
  } = generator;
  generator.push(`${helper("normalize"
  /* NORMALIZE */
  )}([`);
  generator.indent(needIndent());
  const length = node.items.length;

  for (let i = 0; i < length; i++) {
    generateNode(generator, node.items[i]);

    if (i === length - 1) {
      break;
    }

    generator.push(', ');
  }

  generator.deindent(needIndent());
  generator.push('])');
}

function generatePluralNode(generator, node) {
  const {
    helper,
    needIndent
  } = generator;

  if (node.cases.length > 1) {
    generator.push(`${helper("plural"
    /* PLURAL */
    )}([`);
    generator.indent(needIndent());
    const length = node.cases.length;

    for (let i = 0; i < length; i++) {
      generateNode(generator, node.cases[i]);

      if (i === length - 1) {
        break;
      }

      generator.push(', ');
    }

    generator.deindent(needIndent());
    generator.push(`])`);
  }
}

function generateResource(generator, node) {
  if (node.body) {
    generateNode(generator, node.body);
  } else {
    generator.push('null');
  }
}

function generateNode(generator, node) {
  const {
    helper
  } = generator;

  switch (node.type) {
    case 0
    /* Resource */
    :
      generateResource(generator, node);
      break;

    case 1
    /* Plural */
    :
      generatePluralNode(generator, node);
      break;

    case 2
    /* Message */
    :
      generateMessageNode(generator, node);
      break;

    case 6
    /* Linked */
    :
      generateLinkedNode(generator, node);
      break;

    case 8
    /* LinkedModifier */
    :
      generator.push(JSON.stringify(node.value), node);
      break;

    case 7
    /* LinkedKey */
    :
      generator.push(JSON.stringify(node.value), node);
      break;

    case 5
    /* List */
    :
      generator.push(`${helper("interpolate"
      /* INTERPOLATE */
      )}(${helper("list"
      /* LIST */
      )}(${node.index}))`, node);
      break;

    case 4
    /* Named */
    :
      generator.push(`${helper("interpolate"
      /* INTERPOLATE */
      )}(${helper("named"
      /* NAMED */
      )}(${JSON.stringify(node.key)}))`, node);
      break;

    case 9
    /* Literal */
    :
      generator.push(JSON.stringify(node.value), node);
      break;

    case 3
    /* Text */
    :
      generator.push(JSON.stringify(node.value), node);
      break;

    default:
      if (process.env.NODE_ENV !== 'production') {
        throw new Error(`unhandled codegen node type: ${node.type}`);
      }

  }
} // generate code from AST


const generate = (ast, options = {} // eslint-disable-line
) => {
  const mode = isString(options.mode) ? options.mode : 'normal';
  const filename = isString(options.filename) ? options.filename : 'message.intl';
  const sourceMap = !!options.sourceMap; // prettier-ignore

  const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === 'arrow' ? ';' : '\n';
  const needIndent = options.needIndent ? options.needIndent : mode !== 'arrow';
  const helpers = ast.helpers || [];
  const generator = createCodeGenerator(ast, {
    mode,
    filename,
    sourceMap,
    breakLineCode,
    needIndent
  });
  generator.push(mode === 'normal' ? `function __msg__ (ctx) {` : `(ctx) => {`);
  generator.indent(needIndent);

  if (helpers.length > 0) {
    generator.push(`const { ${helpers.map(s => `${s}: _${s}`).join(', ')} } = ctx`);
    generator.newline();
  }

  generator.push(`return `);
  generateNode(generator, ast);
  generator.deindent(needIndent);
  generator.push(`}`);
  const {
    code,
    map
  } = generator.context();
  return {
    ast,
    code,
    map: map ? map.toJSON() : undefined // eslint-disable-line @typescript-eslint/no-explicit-any

  };
};

function baseCompile(source, options = {}) {
  const assignedOptions = assign$1({}, options); // parse source codes

  const parser = createParser(assignedOptions);
  const ast = parser.parse(source); // transform ASTs

  transform(ast, assignedOptions); // generate javascript codes

  return generate(ast, assignedOptions);
}

/*!
  * devtools-if v9.2.2
  * (c) 2022 kazuya kawaguchi
  * Released under the MIT License.
  */
const IntlifyDevToolsHooks = {
  I18nInit: 'i18n:init',
  FunctionTranslate: 'function:translate'
};

/*!
  * core-base v9.2.2
  * (c) 2022 kazuya kawaguchi
  * Released under the MIT License.
  */
const pathStateMachine = [];
pathStateMachine[0
/* BEFORE_PATH */
] = {
  ["w"
  /* WORKSPACE */
  ]: [0
  /* BEFORE_PATH */
  ],
  ["i"
  /* IDENT */
  ]: [3
  /* IN_IDENT */
  , 0
  /* APPEND */
  ],
  ["["
  /* LEFT_BRACKET */
  ]: [4
  /* IN_SUB_PATH */
  ],
  ["o"
  /* END_OF_FAIL */
  ]: [7
  /* AFTER_PATH */
  ]
};
pathStateMachine[1
/* IN_PATH */
] = {
  ["w"
  /* WORKSPACE */
  ]: [1
  /* IN_PATH */
  ],
  ["."
  /* DOT */
  ]: [2
  /* BEFORE_IDENT */
  ],
  ["["
  /* LEFT_BRACKET */
  ]: [4
  /* IN_SUB_PATH */
  ],
  ["o"
  /* END_OF_FAIL */
  ]: [7
  /* AFTER_PATH */
  ]
};
pathStateMachine[2
/* BEFORE_IDENT */
] = {
  ["w"
  /* WORKSPACE */
  ]: [2
  /* BEFORE_IDENT */
  ],
  ["i"
  /* IDENT */
  ]: [3
  /* IN_IDENT */
  , 0
  /* APPEND */
  ],
  ["0"
  /* ZERO */
  ]: [3
  /* IN_IDENT */
  , 0
  /* APPEND */
  ]
};
pathStateMachine[3
/* IN_IDENT */
] = {
  ["i"
  /* IDENT */
  ]: [3
  /* IN_IDENT */
  , 0
  /* APPEND */
  ],
  ["0"
  /* ZERO */
  ]: [3
  /* IN_IDENT */
  , 0
  /* APPEND */
  ],
  ["w"
  /* WORKSPACE */
  ]: [1
  /* IN_PATH */
  , 1
  /* PUSH */
  ],
  ["."
  /* DOT */
  ]: [2
  /* BEFORE_IDENT */
  , 1
  /* PUSH */
  ],
  ["["
  /* LEFT_BRACKET */
  ]: [4
  /* IN_SUB_PATH */
  , 1
  /* PUSH */
  ],
  ["o"
  /* END_OF_FAIL */
  ]: [7
  /* AFTER_PATH */
  , 1
  /* PUSH */
  ]
};
pathStateMachine[4
/* IN_SUB_PATH */
] = {
  ["'"
  /* SINGLE_QUOTE */
  ]: [5
  /* IN_SINGLE_QUOTE */
  , 0
  /* APPEND */
  ],
  ["\""
  /* DOUBLE_QUOTE */
  ]: [6
  /* IN_DOUBLE_QUOTE */
  , 0
  /* APPEND */
  ],
  ["["
  /* LEFT_BRACKET */
  ]: [4
  /* IN_SUB_PATH */
  , 2
  /* INC_SUB_PATH_DEPTH */
  ],
  ["]"
  /* RIGHT_BRACKET */
  ]: [1
  /* IN_PATH */
  , 3
  /* PUSH_SUB_PATH */
  ],
  ["o"
  /* END_OF_FAIL */
  ]: 8
  /* ERROR */
  ,
  ["l"
  /* ELSE */
  ]: [4
  /* IN_SUB_PATH */
  , 0
  /* APPEND */
  ]
};
pathStateMachine[5
/* IN_SINGLE_QUOTE */
] = {
  ["'"
  /* SINGLE_QUOTE */
  ]: [4
  /* IN_SUB_PATH */
  , 0
  /* APPEND */
  ],
  ["o"
  /* END_OF_FAIL */
  ]: 8
  /* ERROR */
  ,
  ["l"
  /* ELSE */
  ]: [5
  /* IN_SINGLE_QUOTE */
  , 0
  /* APPEND */
  ]
};
pathStateMachine[6
/* IN_DOUBLE_QUOTE */
] = {
  ["\""
  /* DOUBLE_QUOTE */
  ]: [4
  /* IN_SUB_PATH */
  , 0
  /* APPEND */
  ],
  ["o"
  /* END_OF_FAIL */
  ]: 8
  /* ERROR */
  ,
  ["l"
  /* ELSE */
  ]: [6
  /* IN_DOUBLE_QUOTE */
  , 0
  /* APPEND */
  ]
};
/**
 * Check if an expression is a literal value.
 */

const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;

function isLiteral(exp) {
  return literalValueRE.test(exp);
}
/**
 * Strip quotes from a string
 */


function stripQuotes(str) {
  const a = str.charCodeAt(0);
  const b = str.charCodeAt(str.length - 1);
  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;
}
/**
 * Determine the type of a character in a keypath.
 */


function getPathCharType(ch) {
  if (ch === undefined || ch === null) {
    return "o"
    /* END_OF_FAIL */
    ;
  }

  const code = ch.charCodeAt(0);

  switch (code) {
    case 0x5b: // [

    case 0x5d: // ]

    case 0x2e: // .

    case 0x22: // "

    case 0x27:
      // '
      return ch;

    case 0x5f: // _

    case 0x24: // $

    case 0x2d:
      // -
      return "i"
      /* IDENT */
      ;

    case 0x09: // Tab (HT)

    case 0x0a: // Newline (LF)

    case 0x0d: // Return (CR)

    case 0xa0: // No-break space (NBSP)

    case 0xfeff: // Byte Order Mark (BOM)

    case 0x2028: // Line Separator (LS)

    case 0x2029:
      // Paragraph Separator (PS)
      return "w"
      /* WORKSPACE */
      ;
  }

  return "i"
  /* IDENT */
  ;
}
/**
 * Format a subPath, return its plain form if it is
 * a literal string or number. Otherwise prepend the
 * dynamic indicator (*).
 */


function formatSubPath(path) {
  const trimmed = path.trim(); // invalid leading 0

  if (path.charAt(0) === '0' && isNaN(parseInt(path))) {
    return false;
  }

  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*"
  /* ASTARISK */
  + trimmed;
}
/**
 * Parse a string path into an array of segments
 */


function parse$1(path) {
  const keys = [];
  let index = -1;
  let mode = 0
  /* BEFORE_PATH */
  ;
  let subPathDepth = 0;
  let c;
  let key; // eslint-disable-line

  let newChar;
  let type;
  let transition;
  let action;
  let typeMap;
  const actions = [];

  actions[0
  /* APPEND */
  ] = () => {
    if (key === undefined) {
      key = newChar;
    } else {
      key += newChar;
    }
  };

  actions[1
  /* PUSH */
  ] = () => {
    if (key !== undefined) {
      keys.push(key);
      key = undefined;
    }
  };

  actions[2
  /* INC_SUB_PATH_DEPTH */
  ] = () => {
    actions[0
    /* APPEND */
    ]();
    subPathDepth++;
  };

  actions[3
  /* PUSH_SUB_PATH */
  ] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = 4
      /* IN_SUB_PATH */
      ;
      actions[0
      /* APPEND */
      ]();
    } else {
      subPathDepth = 0;

      if (key === undefined) {
        return false;
      }

      key = formatSubPath(key);

      if (key === false) {
        return false;
      } else {
        actions[1
        /* PUSH */
        ]();
      }
    }
  };

  function maybeUnescapeQuote() {
    const nextChar = path[index + 1];

    if (mode === 5
    /* IN_SINGLE_QUOTE */
    && nextChar === "'"
    /* SINGLE_QUOTE */
    || mode === 6
    /* IN_DOUBLE_QUOTE */
    && nextChar === "\""
    /* DOUBLE_QUOTE */
    ) {
      index++;
      newChar = '\\' + nextChar;
      actions[0
      /* APPEND */
      ]();
      return true;
    }
  }

  while (mode !== null) {
    index++;
    c = path[index];

    if (c === '\\' && maybeUnescapeQuote()) {
      continue;
    }

    type = getPathCharType(c);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type] || typeMap["l"
    /* ELSE */
    ] || 8
    /* ERROR */
    ; // check parse error

    if (transition === 8
    /* ERROR */
    ) {
      return;
    }

    mode = transition[0];

    if (transition[1] !== undefined) {
      action = actions[transition[1]];

      if (action) {
        newChar = c;

        if (action() === false) {
          return;
        }
      }
    } // check parse finish


    if (mode === 7
    /* AFTER_PATH */
    ) {
      return keys;
    }
  }
} // path token cache


const cache = new Map();
/**
 * key-value message resolver
 *
 * @remarks
 * Resolves messages with the key-value structure. Note that messages with a hierarchical structure such as objects cannot be resolved
 *
 * @param obj - A target object to be resolved with path
 * @param path - A {@link Path | path} to resolve the value of message
 *
 * @returns A resolved {@link PathValue | path value}
 *
 * @VueI18nGeneral
 */

function resolveWithKeyValue(obj, path) {
  return isObject$1(obj) ? obj[path] : null;
}
/**
 * message resolver
 *
 * @remarks
 * Resolves messages. messages with a hierarchical structure such as objects can be resolved. This resolver is used in VueI18n as default.
 *
 * @param obj - A target object to be resolved with path
 * @param path - A {@link Path | path} to resolve the value of message
 *
 * @returns A resolved {@link PathValue | path value}
 *
 * @VueI18nGeneral
 */


function resolveValue(obj, path) {
  // check object
  if (!isObject$1(obj)) {
    return null;
  } // parse path


  let hit = cache.get(path);

  if (!hit) {
    hit = parse$1(path);

    if (hit) {
      cache.set(path, hit);
    }
  } // check hit


  if (!hit) {
    return null;
  } // resolve path value


  const len = hit.length;
  let last = obj;
  let i = 0;

  while (i < len) {
    const val = last[hit[i]];

    if (val === undefined) {
      return null;
    }

    last = val;
    i++;
  }

  return last;
}

const DEFAULT_MODIFIER = str => str;

const DEFAULT_MESSAGE = ctx => ''; // eslint-disable-line


const DEFAULT_MESSAGE_DATA_TYPE = 'text';

const DEFAULT_NORMALIZE = values => values.length === 0 ? '' : values.join('');

const DEFAULT_INTERPOLATE = toDisplayString;

function pluralDefault(choice, choicesLength) {
  choice = Math.abs(choice);

  if (choicesLength === 2) {
    // prettier-ignore
    return choice ? choice > 1 ? 1 : 0 : 1;
  }

  return choice ? Math.min(choice, 2) : 0;
}

function getPluralIndex(options) {
  // prettier-ignore
  const index = isNumber$1(options.pluralIndex) ? options.pluralIndex : -1; // prettier-ignore

  return options.named && (isNumber$1(options.named.count) || isNumber$1(options.named.n)) ? isNumber$1(options.named.count) ? options.named.count : isNumber$1(options.named.n) ? options.named.n : index : index;
}

function normalizeNamed(pluralIndex, props) {
  if (!props.count) {
    props.count = pluralIndex;
  }

  if (!props.n) {
    props.n = pluralIndex;
  }
}

function createMessageContext(options = {}) {
  const locale = options.locale;
  const pluralIndex = getPluralIndex(options);
  const pluralRule = isObject$1(options.pluralRules) && isString(locale) && isFunction$1(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
  const orgPluralRule = isObject$1(options.pluralRules) && isString(locale) && isFunction$1(options.pluralRules[locale]) ? pluralDefault : undefined;

  const plural = messages => {
    return messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];
  };

  const _list = options.list || [];

  const list = index => _list[index]; // eslint-disable-next-line @typescript-eslint/no-explicit-any


  const _named = options.named || {};

  isNumber$1(options.pluralIndex) && normalizeNamed(pluralIndex, _named);

  const named = key => _named[key];

  function message(key) {
    // prettier-ignore
    const msg = isFunction$1(options.messages) ? options.messages(key) : isObject$1(options.messages) ? options.messages[key] : false;
    return !msg ? options.parent ? options.parent.message(key) // resolve from parent messages
    : DEFAULT_MESSAGE : msg;
  }

  const _modifier = name => options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;

  const normalize = isPlainObject(options.processor) && isFunction$1(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate = isPlainObject(options.processor) && isFunction$1(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
  const type = isPlainObject(options.processor) && isString(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;

  const linked = (key, ...args) => {
    const [arg1, arg2] = args;
    let type = 'text';
    let modifier = '';

    if (args.length === 1) {
      if (isObject$1(arg1)) {
        modifier = arg1.modifier || modifier;
        type = arg1.type || type;
      } else if (isString(arg1)) {
        modifier = arg1 || modifier;
      }
    } else if (args.length === 2) {
      if (isString(arg1)) {
        modifier = arg1 || modifier;
      }

      if (isString(arg2)) {
        type = arg2 || type;
      }
    }

    let msg = message(key)(ctx); // The message in vnode resolved with linked are returned as an array by processor.nomalize

    if (type === 'vnode' && isArray$2(msg) && modifier) {
      msg = msg[0];
    }

    return modifier ? _modifier(modifier)(msg, type) : msg;
  };

  const ctx = {
    ["list"
    /* LIST */
    ]: list,
    ["named"
    /* NAMED */
    ]: named,
    ["plural"
    /* PLURAL */
    ]: plural,
    ["linked"
    /* LINKED */
    ]: linked,
    ["message"
    /* MESSAGE */
    ]: message,
    ["type"
    /* TYPE */
    ]: type,
    ["interpolate"
    /* INTERPOLATE */
    ]: interpolate,
    ["normalize"
    /* NORMALIZE */
    ]: normalize
  };
  return ctx;
}

let devtools = null;

function setDevToolsHook(hook) {
  devtools = hook;
}

function initI18nDevTools(i18n, version, meta) {
  // TODO: queue if devtools is undefined
  devtools && devtools.emit(IntlifyDevToolsHooks.I18nInit, {
    timestamp: Date.now(),
    i18n,
    version,
    meta
  });
}

const translateDevTools = /* #__PURE__*/createDevToolsHook(IntlifyDevToolsHooks.FunctionTranslate);

function createDevToolsHook(hook) {
  return payloads => devtools && devtools.emit(hook, payloads);
}

const CoreWarnCodes = {
  NOT_FOUND_KEY: 1,
  FALLBACK_TO_TRANSLATE: 2,
  CANNOT_FORMAT_NUMBER: 3,
  FALLBACK_TO_NUMBER_FORMAT: 4,
  CANNOT_FORMAT_DATE: 5,
  FALLBACK_TO_DATE_FORMAT: 6,
  __EXTEND_POINT__: 7
};
/** @internal */

const warnMessages$1 = {
  [CoreWarnCodes.NOT_FOUND_KEY]: `Not found '{key}' key in '{locale}' locale messages.`,
  [CoreWarnCodes.FALLBACK_TO_TRANSLATE]: `Fall back to translate '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.CANNOT_FORMAT_NUMBER]: `Cannot format a number value due to not supported Intl.NumberFormat.`,
  [CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT]: `Fall back to number format '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.CANNOT_FORMAT_DATE]: `Cannot format a date value due to not supported Intl.DateTimeFormat.`,
  [CoreWarnCodes.FALLBACK_TO_DATE_FORMAT]: `Fall back to datetime format '{key}' key with '{target}' locale.`
};

function getWarnMessage$1(code, ...args) {
  return format(warnMessages$1[code], ...args);
}
/**
 * Fallback with simple implemenation
 *
 * @remarks
 * A fallback locale function implemented with a simple fallback algorithm.
 *
 * Basically, it returns the value as specified in the `fallbackLocale` props, and is processed with the fallback inside intlify.
 *
 * @param ctx - A {@link CoreContext | context}
 * @param fallback - A {@link FallbackLocale | fallback locale}
 * @param start - A starting {@link Locale | locale}
 *
 * @returns Fallback locales
 *
 * @VueI18nGeneral
 */


function fallbackWithSimple(ctx, fallback, start // eslint-disable-line @typescript-eslint/no-unused-vars
) {
  // prettier-ignore
  return [...new Set([start, ...(isArray$2(fallback) ? fallback : isObject$1(fallback) ? Object.keys(fallback) : isString(fallback) ? [fallback] : [start])])];
}
/**
 * Fallback with locale chain
 *
 * @remarks
 * A fallback locale function implemented with a fallback chain algorithm. It's used in VueI18n as default.
 *
 * @param ctx - A {@link CoreContext | context}
 * @param fallback - A {@link FallbackLocale | fallback locale}
 * @param start - A starting {@link Locale | locale}
 *
 * @returns Fallback locales
 *
 * @VueI18nSee [Fallbacking](../guide/essentials/fallback)
 *
 * @VueI18nGeneral
 */


function fallbackWithLocaleChain(ctx, fallback, start) {
  const startLocale = isString(start) ? start : DEFAULT_LOCALE;
  const context = ctx;

  if (!context.__localeChainCache) {
    context.__localeChainCache = new Map();
  }

  let chain = context.__localeChainCache.get(startLocale);

  if (!chain) {
    chain = []; // first block defined by start

    let block = [start]; // while any intervening block found

    while (isArray$2(block)) {
      block = appendBlockToChain(chain, block, fallback);
    } // prettier-ignore
    // last block defined by default


    const defaults = isArray$2(fallback) || !isPlainObject(fallback) ? fallback : fallback['default'] ? fallback['default'] : null; // convert defaults to array

    block = isString(defaults) ? [defaults] : defaults;

    if (isArray$2(block)) {
      appendBlockToChain(chain, block, false);
    }

    context.__localeChainCache.set(startLocale, chain);
  }

  return chain;
}

function appendBlockToChain(chain, block, blocks) {
  let follow = true;

  for (let i = 0; i < block.length && isBoolean(follow); i++) {
    const locale = block[i];

    if (isString(locale)) {
      follow = appendLocaleToChain(chain, block[i], blocks);
    }
  }

  return follow;
}

function appendLocaleToChain(chain, locale, blocks) {
  let follow;
  const tokens = locale.split('-');

  do {
    const target = tokens.join('-');
    follow = appendItemToChain(chain, target, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && follow === true);

  return follow;
}

function appendItemToChain(chain, target, blocks) {
  let follow = false;

  if (!chain.includes(target)) {
    follow = true;

    if (target) {
      follow = target[target.length - 1] !== '!';
      const locale = target.replace(/!/g, '');
      chain.push(locale);

      if ((isArray$2(blocks) || isPlainObject(blocks)) && blocks[locale] // eslint-disable-line @typescript-eslint/no-explicit-any
      ) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        follow = blocks[locale];
      }
    }
  }

  return follow;
}
/* eslint-disable @typescript-eslint/no-explicit-any */

/**
 * Intlify core-base version
 * @internal
 */


const VERSION$1 = '9.2.2';
const NOT_REOSLVED = -1;
const DEFAULT_LOCALE = 'en-US';
const MISSING_RESOLVE_VALUE = '';

const capitalize = str => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;

function getDefaultLinkedModifiers() {
  return {
    upper: (val, type) => {
      // prettier-ignore
      return type === 'text' && isString(val) ? val.toUpperCase() : type === 'vnode' && isObject$1(val) && '__v_isVNode' in val ? val.children.toUpperCase() : val;
    },
    lower: (val, type) => {
      // prettier-ignore
      return type === 'text' && isString(val) ? val.toLowerCase() : type === 'vnode' && isObject$1(val) && '__v_isVNode' in val ? val.children.toLowerCase() : val;
    },
    capitalize: (val, type) => {
      // prettier-ignore
      return type === 'text' && isString(val) ? capitalize(val) : type === 'vnode' && isObject$1(val) && '__v_isVNode' in val ? capitalize(val.children) : val;
    }
  };
}

let _compiler;

function registerMessageCompiler(compiler) {
  _compiler = compiler;
}

let _resolver;
/**
 * Register the message resolver
 *
 * @param resolver - A {@link MessageResolver} function
 *
 * @VueI18nGeneral
 */


function registerMessageResolver(resolver) {
  _resolver = resolver;
}

let _fallbacker;
/**
 * Register the locale fallbacker
 *
 * @param fallbacker - A {@link LocaleFallbacker} function
 *
 * @VueI18nGeneral
 */


function registerLocaleFallbacker(fallbacker) {
  _fallbacker = fallbacker;
} // Additional Meta for Intlify DevTools


let _additionalMeta = null;

const setAdditionalMeta = meta => {
  _additionalMeta = meta;
};

const getAdditionalMeta = () => _additionalMeta;

let _fallbackContext = null;

const setFallbackContext = context => {
  _fallbackContext = context;
};

const getFallbackContext = () => _fallbackContext; // ID for CoreContext


let _cid = 0;

function createCoreContext(options = {}) {
  // setup options
  const version = isString(options.version) ? options.version : VERSION$1;
  const locale = isString(options.locale) ? options.locale : DEFAULT_LOCALE;
  const fallbackLocale = isArray$2(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || isString(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
  const messages = isPlainObject(options.messages) ? options.messages : {
    [locale]: {}
  };
  const datetimeFormats = isPlainObject(options.datetimeFormats) ? options.datetimeFormats : {
    [locale]: {}
  };
  const numberFormats = isPlainObject(options.numberFormats) ? options.numberFormats : {
    [locale]: {}
  };
  const modifiers = assign$1({}, options.modifiers || {}, getDefaultLinkedModifiers());
  const pluralRules = options.pluralRules || {};
  const missing = isFunction$1(options.missing) ? options.missing : null;
  const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const fallbackFormat = !!options.fallbackFormat;
  const unresolving = !!options.unresolving;
  const postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : null;
  const processor = isPlainObject(options.processor) ? options.processor : null;
  const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const escapeParameter = !!options.escapeParameter;
  const messageCompiler = isFunction$1(options.messageCompiler) ? options.messageCompiler : _compiler;
  const messageResolver = isFunction$1(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
  const localeFallbacker = isFunction$1(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
  const fallbackContext = isObject$1(options.fallbackContext) ? options.fallbackContext : undefined;
  const onWarn = isFunction$1(options.onWarn) ? options.onWarn : warn$1; // setup internal options

  const internalOptions = options;

  const __datetimeFormatters = isObject$1(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : new Map();

  const __numberFormatters = isObject$1(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : new Map();

  const __meta = isObject$1(internalOptions.__meta) ? internalOptions.__meta : {};

  _cid++;
  const context = {
    version,
    cid: _cid,
    locale,
    fallbackLocale,
    messages,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    messageResolver,
    localeFallbacker,
    fallbackContext,
    onWarn,
    __meta
  };
  {
    context.datetimeFormats = datetimeFormats;
    context.numberFormats = numberFormats;
    context.__datetimeFormatters = __datetimeFormatters;
    context.__numberFormatters = __numberFormatters;
  } // for vue-devtools timeline event

  if (process.env.NODE_ENV !== 'production') {
    context.__v_emitter = internalOptions.__v_emitter != null ? internalOptions.__v_emitter : undefined;
  } // NOTE: experimental !!


  if (process.env.NODE_ENV !== 'production' || __INTLIFY_PROD_DEVTOOLS__) {
    initI18nDevTools(context, version, __meta);
  }

  return context;
}
/** @internal */


function isTranslateFallbackWarn(fallback, key) {
  return fallback instanceof RegExp ? fallback.test(key) : fallback;
}
/** @internal */


function isTranslateMissingWarn(missing, key) {
  return missing instanceof RegExp ? missing.test(key) : missing;
}
/** @internal */


function handleMissing(context, key, locale, missingWarn, type) {
  const {
    missing,
    onWarn
  } = context; // for vue-devtools timeline event

  if (process.env.NODE_ENV !== 'production') {
    const emitter = context.__v_emitter;

    if (emitter) {
      emitter.emit("missing"
      /* MISSING */
      , {
        locale,
        key,
        type,
        groupId: `${type}:${key}`
      });
    }
  }

  if (missing !== null) {
    const ret = missing(context, locale, key, type);
    return isString(ret) ? ret : key;
  } else {
    if (process.env.NODE_ENV !== 'production' && isTranslateMissingWarn(missingWarn, key)) {
      onWarn(getWarnMessage$1(CoreWarnCodes.NOT_FOUND_KEY, {
        key,
        locale
      }));
    }

    return key;
  }
}
/** @internal */


function updateFallbackLocale(ctx, locale, fallback) {
  const context = ctx;
  context.__localeChainCache = new Map();
  ctx.localeFallbacker(ctx, fallback, locale);
}
/* eslint-enable @typescript-eslint/no-explicit-any */


const RE_HTML_TAG = /<\/?[\w\s="/.':;#-\/]+>/;
const WARN_MESSAGE = `Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.`;

function checkHtmlMessage(source, options) {
  const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;

  if (warnHtmlMessage && RE_HTML_TAG.test(source)) {
    warn$1(format(WARN_MESSAGE, {
      source
    }));
  }
}

const defaultOnCacheKey = source => source;

let compileCache = Object.create(null);

function compileToFunction(source, options = {}) {
  {
    // check HTML message
    process.env.NODE_ENV !== 'production' && checkHtmlMessage(source, options); // check caches

    const onCacheKey = options.onCacheKey || defaultOnCacheKey;
    const key = onCacheKey(source);
    const cached = compileCache[key];

    if (cached) {
      return cached;
    } // compile error detecting


    let occurred = false;
    const onError = options.onError || defaultOnError;

    options.onError = err => {
      occurred = true;
      onError(err);
    }; // compile


    const {
      code
    } = baseCompile(source, options); // evaluate function

    const msg = new Function(`return ${code}`)(); // if occurred compile error, don't cache

    return !occurred ? compileCache[key] = msg : msg;
  }
}

let code$2 = CompileErrorCodes.__EXTEND_POINT__;

const inc$2 = () => ++code$2;

const CoreErrorCodes = {
  INVALID_ARGUMENT: code$2,
  INVALID_DATE_ARGUMENT: inc$2(),
  INVALID_ISO_DATE_ARGUMENT: inc$2(),
  __EXTEND_POINT__: inc$2() // 18

};

function createCoreError(code) {
  return createCompileError(code, null, process.env.NODE_ENV !== 'production' ? {
    messages: errorMessages$1
  } : undefined);
}
/** @internal */


const errorMessages$1 = {
  [CoreErrorCodes.INVALID_ARGUMENT]: 'Invalid arguments',
  [CoreErrorCodes.INVALID_DATE_ARGUMENT]: 'The date provided is an invalid Date object.' + 'Make sure your Date represents a valid date.',
  [CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT]: 'The argument provided is not a valid ISO date string'
};

const NOOP_MESSAGE_FUNCTION = () => '';

const isMessageFunction = val => isFunction$1(val); // implementation of `translate` function


function translate(context, ...args) {
  const {
    fallbackFormat,
    postTranslation,
    unresolving,
    messageCompiler,
    fallbackLocale,
    messages
  } = context;
  const [key, options] = parseTranslateArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
  const resolvedMessage = !!options.resolvedMessage; // prettier-ignore

  const defaultMsgOrKey = isString(options.default) || isBoolean(options.default) // default by function option
  ? !isBoolean(options.default) ? options.default : !messageCompiler ? () => key : key : fallbackFormat // default by `fallbackFormat` option
  ? !messageCompiler ? () => key : key : '';
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== '';
  const locale = isString(options.locale) ? options.locale : context.locale; // escape params

  escapeParameter && escapeParams(options); // resolve message format
  // eslint-disable-next-line prefer-const

  let [formatScope, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [key, locale, messages[locale] || {}]; // NOTE:
  //  Fix to work around `ssrTransfrom` bug in Vite.
  //  https://github.com/vitejs/vite/issues/4306
  //  To get around this, use temporary variables.
  //  https://github.com/nuxt/framework/issues/1461#issuecomment-954606243

  let format = formatScope; // if you use default message, set it as message format!

  let cacheBaseKey = key;

  if (!resolvedMessage && !(isString(format) || isMessageFunction(format))) {
    if (enableDefaultMsg) {
      format = defaultMsgOrKey;
      cacheBaseKey = format;
    }
  } // checking message format and target locale


  if (!resolvedMessage && (!(isString(format) || isMessageFunction(format)) || !isString(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key;
  }

  if (process.env.NODE_ENV !== 'production' && isString(format) && context.messageCompiler == null) {
    warn$1(`The message format compilation is not supported in this build. ` + `Because message compiler isn't included. ` + `You need to pre-compilation all message format. ` + `So translate function return '${key}'.`);
    return key;
  } // setup compile error detecting


  let occurred = false;

  const errorDetector = () => {
    occurred = true;
  }; // compile message format


  const msg = !isMessageFunction(format) ? compileMessageFormat(context, key, targetLocale, format, cacheBaseKey, errorDetector) : format; // if occurred compile error, return the message format

  if (occurred) {
    return format;
  } // evaluate message with context


  const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context, msg, msgContext); // if use post translation option, proceed it with handler

  const ret = postTranslation ? postTranslation(messaged, key) : messaged; // NOTE: experimental !!

  if (process.env.NODE_ENV !== 'production' || __INTLIFY_PROD_DEVTOOLS__) {
    // prettier-ignore
    const payloads = {
      timestamp: Date.now(),
      key: isString(key) ? key : isMessageFunction(format) ? format.key : '',
      locale: targetLocale || (isMessageFunction(format) ? format.locale : ''),
      format: isString(format) ? format : isMessageFunction(format) ? format.source : '',
      message: ret
    };
    payloads.meta = assign$1({}, context.__meta, getAdditionalMeta() || {});
    translateDevTools(payloads);
  }

  return ret;
}

function escapeParams(options) {
  if (isArray$2(options.list)) {
    options.list = options.list.map(item => isString(item) ? escapeHtml(item) : item);
  } else if (isObject$1(options.named)) {
    Object.keys(options.named).forEach(key => {
      if (isString(options.named[key])) {
        options.named[key] = escapeHtml(options.named[key]);
      }
    });
  }
}

function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
  const {
    messages,
    onWarn,
    messageResolver: resolveValue,
    localeFallbacker
  } = context;
  const locales = localeFallbacker(context, fallbackLocale, locale); // eslint-disable-line @typescript-eslint/no-explicit-any

  let message = {};
  let targetLocale;
  let format = null;
  let from = locale;
  let to = null;
  const type = 'translate';

  for (let i = 0; i < locales.length; i++) {
    targetLocale = to = locales[i];

    if (process.env.NODE_ENV !== 'production' && locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key)) {
      onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_TRANSLATE, {
        key,
        target: targetLocale
      }));
    } // for vue-devtools timeline event


    if (process.env.NODE_ENV !== 'production' && locale !== targetLocale) {
      const emitter = context.__v_emitter;

      if (emitter) {
        emitter.emit("fallback"
        /* FALBACK */
        , {
          type,
          key,
          from,
          to,
          groupId: `${type}:${key}`
        });
      }
    }

    message = messages[targetLocale] || {}; // for vue-devtools timeline event

    let start = null;
    let startTag;
    let endTag;

    if (process.env.NODE_ENV !== 'production' && inBrowser) {
      start = window.performance.now();
      startTag = 'intlify-message-resolve-start';
      endTag = 'intlify-message-resolve-end';
      mark && mark(startTag);
    }

    if ((format = resolveValue(message, key)) === null) {
      // if null, resolve with object key path
      format = message[key]; // eslint-disable-line @typescript-eslint/no-explicit-any
    } // for vue-devtools timeline event


    if (process.env.NODE_ENV !== 'production' && inBrowser) {
      const end = window.performance.now();
      const emitter = context.__v_emitter;

      if (emitter && start && format) {
        emitter.emit("message-resolve"
        /* MESSAGE_RESOLVE */
        , {
          type: "message-resolve"
          /* MESSAGE_RESOLVE */
          ,
          key,
          message: format,
          time: end - start,
          groupId: `${type}:${key}`
        });
      }

      if (startTag && endTag && mark && measure) {
        mark(endTag);
        measure('intlify message resolve', startTag, endTag);
      }
    }

    if (isString(format) || isFunction$1(format)) break;
    const missingRet = handleMissing(context, // eslint-disable-line @typescript-eslint/no-explicit-any
    key, targetLocale, missingWarn, type);

    if (missingRet !== key) {
      format = missingRet;
    }

    from = to;
  }

  return [format, targetLocale, message];
}

function compileMessageFormat(context, key, targetLocale, format, cacheBaseKey, errorDetector) {
  const {
    messageCompiler,
    warnHtmlMessage
  } = context;

  if (isMessageFunction(format)) {
    const msg = format;
    msg.locale = msg.locale || targetLocale;
    msg.key = msg.key || key;
    return msg;
  }

  if (messageCompiler == null) {
    const msg = () => format;

    msg.locale = targetLocale;
    msg.key = key;
    return msg;
  } // for vue-devtools timeline event


  let start = null;
  let startTag;
  let endTag;

  if (process.env.NODE_ENV !== 'production' && inBrowser) {
    start = window.performance.now();
    startTag = 'intlify-message-compilation-start';
    endTag = 'intlify-message-compilation-end';
    mark && mark(startTag);
  }

  const msg = messageCompiler(format, getCompileOptions(context, targetLocale, cacheBaseKey, format, warnHtmlMessage, errorDetector)); // for vue-devtools timeline event

  if (process.env.NODE_ENV !== 'production' && inBrowser) {
    const end = window.performance.now();
    const emitter = context.__v_emitter;

    if (emitter && start) {
      emitter.emit("message-compilation"
      /* MESSAGE_COMPILATION */
      , {
        type: "message-compilation"
        /* MESSAGE_COMPILATION */
        ,
        message: format,
        time: end - start,
        groupId: `${'translate'}:${key}`
      });
    }

    if (startTag && endTag && mark && measure) {
      mark(endTag);
      measure('intlify message compilation', startTag, endTag);
    }
  }

  msg.locale = targetLocale;
  msg.key = key;
  msg.source = format;
  return msg;
}

function evaluateMessage(context, msg, msgCtx) {
  // for vue-devtools timeline event
  let start = null;
  let startTag;
  let endTag;

  if (process.env.NODE_ENV !== 'production' && inBrowser) {
    start = window.performance.now();
    startTag = 'intlify-message-evaluation-start';
    endTag = 'intlify-message-evaluation-end';
    mark && mark(startTag);
  }

  const messaged = msg(msgCtx); // for vue-devtools timeline event

  if (process.env.NODE_ENV !== 'production' && inBrowser) {
    const end = window.performance.now();
    const emitter = context.__v_emitter;

    if (emitter && start) {
      emitter.emit("message-evaluation"
      /* MESSAGE_EVALUATION */
      , {
        type: "message-evaluation"
        /* MESSAGE_EVALUATION */
        ,
        value: messaged,
        time: end - start,
        groupId: `${'translate'}:${msg.key}`
      });
    }

    if (startTag && endTag && mark && measure) {
      mark(endTag);
      measure('intlify message evaluation', startTag, endTag);
    }
  }

  return messaged;
}
/** @internal */


function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options = {};

  if (!isString(arg1) && !isNumber$1(arg1) && !isMessageFunction(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  } // prettier-ignore


  const key = isNumber$1(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;

  if (isNumber$1(arg2)) {
    options.plural = arg2;
  } else if (isString(arg2)) {
    options.default = arg2;
  } else if (isPlainObject(arg2) && !isEmptyObject(arg2)) {
    options.named = arg2;
  } else if (isArray$2(arg2)) {
    options.list = arg2;
  }

  if (isNumber$1(arg3)) {
    options.plural = arg3;
  } else if (isString(arg3)) {
    options.default = arg3;
  } else if (isPlainObject(arg3)) {
    assign$1(options, arg3);
  }

  return [key, options];
}

function getCompileOptions(context, locale, key, source, warnHtmlMessage, errorDetector) {
  return {
    warnHtmlMessage,
    onError: err => {
      errorDetector && errorDetector(err);

      if (process.env.NODE_ENV !== 'production') {
        const message = `Message compilation error: ${err.message}`;
        const codeFrame = err.location && generateCodeFrame(source, err.location.start.offset, err.location.end.offset);
        const emitter = context.__v_emitter;

        if (emitter) {
          emitter.emit("compile-error"
          /* COMPILE_ERROR */
          , {
            message: source,
            error: err.message,
            start: err.location && err.location.start.offset,
            end: err.location && err.location.end.offset,
            groupId: `${'translate'}:${key}`
          });
        }

        console.error(codeFrame ? `${message}\n${codeFrame}` : message);
      } else {
        throw err;
      }
    },
    onCacheKey: source => generateFormatCacheKey(locale, key, source)
  };
}

function getMessageContextOptions(context, locale, message, options) {
  const {
    modifiers,
    pluralRules,
    messageResolver: resolveValue,
    fallbackLocale,
    fallbackWarn,
    missingWarn,
    fallbackContext
  } = context;

  const resolveMessage = key => {
    let val = resolveValue(message, key); // fallback to root context

    if (val == null && fallbackContext) {
      const [,, message] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);
      val = resolveValue(message, key);
    }

    if (isString(val)) {
      let occurred = false;

      const errorDetector = () => {
        occurred = true;
      };

      const msg = compileMessageFormat(context, key, locale, val, key, errorDetector);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      // TODO: should be implemented warning message
      return NOOP_MESSAGE_FUNCTION;
    }
  };

  const ctxOptions = {
    locale,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };

  if (context.processor) {
    ctxOptions.processor = context.processor;
  }

  if (options.list) {
    ctxOptions.list = options.list;
  }

  if (options.named) {
    ctxOptions.named = options.named;
  }

  if (isNumber$1(options.plural)) {
    ctxOptions.pluralIndex = options.plural;
  }

  return ctxOptions;
}

const intlDefined = typeof Intl !== 'undefined';
const Availabilities = {
  dateTimeFormat: intlDefined && typeof Intl.DateTimeFormat !== 'undefined',
  numberFormat: intlDefined && typeof Intl.NumberFormat !== 'undefined'
}; // implementation of `datetime` function

function datetime(context, ...args) {
  const {
    datetimeFormats,
    unresolving,
    fallbackLocale,
    onWarn,
    localeFallbacker
  } = context;
  const {
    __datetimeFormatters
  } = context;

  if (process.env.NODE_ENV !== 'production' && !Availabilities.dateTimeFormat) {
    onWarn(getWarnMessage$1(CoreWarnCodes.CANNOT_FORMAT_DATE));
    return MISSING_RESOLVE_VALUE;
  }

  const [key, value, options, overrides] = parseDateTimeArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = isString(options.locale) ? options.locale : context.locale;
  const locales = localeFallbacker(context, // eslint-disable-line @typescript-eslint/no-explicit-any
  fallbackLocale, locale);

  if (!isString(key) || key === '') {
    return new Intl.DateTimeFormat(locale, overrides).format(value);
  } // resolve format


  let datetimeFormat = {};
  let targetLocale;
  let format = null;
  let from = locale;
  let to = null;
  const type = 'datetime format';

  for (let i = 0; i < locales.length; i++) {
    targetLocale = to = locales[i];

    if (process.env.NODE_ENV !== 'production' && locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key)) {
      onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_DATE_FORMAT, {
        key,
        target: targetLocale
      }));
    } // for vue-devtools timeline event


    if (process.env.NODE_ENV !== 'production' && locale !== targetLocale) {
      const emitter = context.__v_emitter;

      if (emitter) {
        emitter.emit("fallback"
        /* FALBACK */
        , {
          type,
          key,
          from,
          to,
          groupId: `${type}:${key}`
        });
      }
    }

    datetimeFormat = datetimeFormats[targetLocale] || {};
    format = datetimeFormat[key];
    if (isPlainObject(format)) break;
    handleMissing(context, key, targetLocale, missingWarn, type); // eslint-disable-line @typescript-eslint/no-explicit-any

    from = to;
  } // checking format and target locale


  if (!isPlainObject(format) || !isString(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }

  let id = `${targetLocale}__${key}`;

  if (!isEmptyObject(overrides)) {
    id = `${id}__${JSON.stringify(overrides)}`;
  }

  let formatter = __datetimeFormatters.get(id);

  if (!formatter) {
    formatter = new Intl.DateTimeFormat(targetLocale, assign$1({}, format, overrides));

    __datetimeFormatters.set(id, formatter);
  }

  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
/** @internal */


const DATETIME_FORMAT_OPTIONS_KEYS = ['localeMatcher', 'weekday', 'era', 'year', 'month', 'day', 'hour', 'minute', 'second', 'timeZoneName', 'formatMatcher', 'hour12', 'timeZone', 'dateStyle', 'timeStyle', 'calendar', 'dayPeriod', 'numberingSystem', 'hourCycle', 'fractionalSecondDigits'];
/** @internal */

function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = {};
  let overrides = {};
  let value;

  if (isString(arg1)) {
    // Only allow ISO strings - other date formats are often supported,
    // but may cause different results in different browsers.
    const matches = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);

    if (!matches) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    } // Some browsers can not parse the iso datetime separated by space,
    // this is a compromise solution by replace the 'T'/' ' with 'T'


    const dateTime = matches[3] ? matches[3].trim().startsWith('T') ? `${matches[1].trim()}${matches[3].trim()}` : `${matches[1].trim()}T${matches[3].trim()}` : matches[1].trim();
    value = new Date(dateTime);

    try {
      // This will fail if the date is not valid
      value.toISOString();
    } catch (e) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (isDate(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
    }

    value = arg1;
  } else if (isNumber$1(arg1)) {
    value = arg1;
  } else {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }

  if (isString(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach(key => {
      if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }

  if (isString(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }

  if (isPlainObject(arg4)) {
    overrides = arg4;
  }

  return [options.key || '', value, options, overrides];
}
/** @internal */


function clearDateTimeFormat(ctx, locale, format) {
  const context = ctx;

  for (const key in format) {
    const id = `${locale}__${key}`;

    if (!context.__datetimeFormatters.has(id)) {
      continue;
    }

    context.__datetimeFormatters.delete(id);
  }
} // implementation of `number` function


function number(context, ...args) {
  const {
    numberFormats,
    unresolving,
    fallbackLocale,
    onWarn,
    localeFallbacker
  } = context;
  const {
    __numberFormatters
  } = context;

  if (process.env.NODE_ENV !== 'production' && !Availabilities.numberFormat) {
    onWarn(getWarnMessage$1(CoreWarnCodes.CANNOT_FORMAT_NUMBER));
    return MISSING_RESOLVE_VALUE;
  }

  const [key, value, options, overrides] = parseNumberArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = isString(options.locale) ? options.locale : context.locale;
  const locales = localeFallbacker(context, // eslint-disable-line @typescript-eslint/no-explicit-any
  fallbackLocale, locale);

  if (!isString(key) || key === '') {
    return new Intl.NumberFormat(locale, overrides).format(value);
  } // resolve format


  let numberFormat = {};
  let targetLocale;
  let format = null;
  let from = locale;
  let to = null;
  const type = 'number format';

  for (let i = 0; i < locales.length; i++) {
    targetLocale = to = locales[i];

    if (process.env.NODE_ENV !== 'production' && locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key)) {
      onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT, {
        key,
        target: targetLocale
      }));
    } // for vue-devtools timeline event


    if (process.env.NODE_ENV !== 'production' && locale !== targetLocale) {
      const emitter = context.__v_emitter;

      if (emitter) {
        emitter.emit("fallback"
        /* FALBACK */
        , {
          type,
          key,
          from,
          to,
          groupId: `${type}:${key}`
        });
      }
    }

    numberFormat = numberFormats[targetLocale] || {};
    format = numberFormat[key];
    if (isPlainObject(format)) break;
    handleMissing(context, key, targetLocale, missingWarn, type); // eslint-disable-line @typescript-eslint/no-explicit-any

    from = to;
  } // checking format and target locale


  if (!isPlainObject(format) || !isString(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }

  let id = `${targetLocale}__${key}`;

  if (!isEmptyObject(overrides)) {
    id = `${id}__${JSON.stringify(overrides)}`;
  }

  let formatter = __numberFormatters.get(id);

  if (!formatter) {
    formatter = new Intl.NumberFormat(targetLocale, assign$1({}, format, overrides));

    __numberFormatters.set(id, formatter);
  }

  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
/** @internal */


const NUMBER_FORMAT_OPTIONS_KEYS = ['localeMatcher', 'style', 'currency', 'currencyDisplay', 'currencySign', 'useGrouping', 'minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits', 'minimumSignificantDigits', 'maximumSignificantDigits', 'compactDisplay', 'notation', 'signDisplay', 'unit', 'unitDisplay', 'roundingMode', 'roundingPriority', 'roundingIncrement', 'trailingZeroDisplay'];
/** @internal */

function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = {};
  let overrides = {};

  if (!isNumber$1(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }

  const value = arg1;

  if (isString(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach(key => {
      if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }

  if (isString(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }

  if (isPlainObject(arg4)) {
    overrides = arg4;
  }

  return [options.key || '', value, options, overrides];
}
/** @internal */


function clearNumberFormat(ctx, locale, format) {
  const context = ctx;

  for (const key in format) {
    const id = `${locale}__${key}`;

    if (!context.__numberFormatters.has(id)) {
      continue;
    }

    context.__numberFormatters.delete(id);
  }
} // TODO: we could not exports for Node native ES Moudles yet...


{
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== 'boolean') {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}

function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  // @ts-ignore
  return typeof navigator !== 'undefined' && typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {};
}
const isProxyAvailable = typeof Proxy === 'function';

const HOOK_SETUP = 'devtools-plugin:setup';
const HOOK_PLUGIN_SETTINGS_SET = 'plugin:settings:set';

let supported;
let perf;
function isPerformanceSupported() {
  var _a;

  if (supported !== undefined) {
    return supported;
  }

  if (typeof window !== 'undefined' && window.performance) {
    supported = true;
    perf = window.performance;
  } else if (typeof global !== 'undefined' && ((_a = global.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
    supported = true;
    perf = global.perf_hooks.performance;
  } else {
    supported = false;
  }

  return supported;
}
function now() {
  return isPerformanceSupported() ? perf.now() : Date.now();
}

class ApiProxy {
  constructor(plugin, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin;
    this.hook = hook;
    const defaultSettings = {};

    if (plugin.settings) {
      for (const id in plugin.settings) {
        const item = plugin.settings[id];
        defaultSettings[id] = item.defaultValue;
      }
    }

    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
    let currentSettings = Object.assign({}, defaultSettings);

    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data = JSON.parse(raw);
      Object.assign(currentSettings, data);
    } catch (e) {// noop
    }

    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },

      setSettings(value) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
        } catch (e) {// noop
        }

        currentSettings = value;
      },

      now() {
        return now();
      }

    };

    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value);
        }
      });
    }

    this.proxiedOn = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target.on[prop];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop,
              args
            });
          };
        }
      }
    });
    this.proxiedTarget = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target[prop];
        } else if (prop === 'on') {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop,
              args,
              resolve: () => {}
            });
            return this.fallbacks[prop](...args);
          };
        } else {
          return (...args) => {
            return new Promise(resolve => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve
              });
            });
          };
        }
      }
    });
  }

  async setRealTarget(target) {
    this.target = target;

    for (const item of this.onQueue) {
      this.target.on[item.method](...item.args);
    }

    for (const item of this.targetQueue) {
      item.resolve(await this.target[item.method](...item.args));
    }
  }

}

function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;

  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy
    });
    if (proxy) setupFn(proxy.proxiedTarget);
  }
}

/*!
  * vue-devtools v9.2.2
  * (c) 2022 kazuya kawaguchi
  * Released under the MIT License.
  */
const VueDevToolsLabels = {
  ["vue-devtools-plugin-vue-i18n"
  /* PLUGIN */
  ]: 'Vue I18n devtools',
  ["vue-i18n-resource-inspector"
  /* CUSTOM_INSPECTOR */
  ]: 'I18n Resources',
  ["vue-i18n-timeline"
  /* TIMELINE */
  ]: 'Vue I18n'
};
const VueDevToolsPlaceholders = {
  ["vue-i18n-resource-inspector"
  /* CUSTOM_INSPECTOR */
  ]: 'Search for scopes ...'
};
const VueDevToolsTimelineColors = {
  ["vue-i18n-timeline"
  /* TIMELINE */
  ]: 0xffcd19
};

/*!
  * vue-i18n v9.2.2
  * (c) 2022 kazuya kawaguchi
  * Released under the MIT License.
  */
/**
 * Vue I18n Version
 *
 * @remarks
 * Semver format. Same format as the package.json `version` field.
 *
 * @VueI18nGeneral
 */

const VERSION = '9.2.2';
/**
 * This is only called in esm-bundler builds.
 * istanbul-ignore-next
 */

function initFeatureFlags() {
  let needWarn = false;

  if (typeof __VUE_I18N_FULL_INSTALL__ !== 'boolean') {
    needWarn = true;
    getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
  }

  if (typeof __VUE_I18N_LEGACY_API__ !== 'boolean') {
    needWarn = true;
    getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
  }

  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== 'boolean') {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }

  if (process.env.NODE_ENV !== 'production' && needWarn) {
    console.warn(`You are running the esm-bundler build of vue-i18n. It is recommended to ` + `configure your bundler to explicitly replace feature flag globals ` + `with boolean literals to get proper tree-shaking in the final bundle.`);
  }
}

let code$1 = CoreWarnCodes.__EXTEND_POINT__;

const inc$1 = () => ++code$1;

const I18nWarnCodes = {
  FALLBACK_TO_ROOT: code$1,
  NOT_SUPPORTED_PRESERVE: inc$1(),
  NOT_SUPPORTED_FORMATTER: inc$1(),
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
  NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
  COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
  NOT_FOUND_PARENT_SCOPE: inc$1() // 13

};
const warnMessages = {
  [I18nWarnCodes.FALLBACK_TO_ROOT]: `Fall back to {type} '{key}' with root locale.`,
  [I18nWarnCodes.NOT_SUPPORTED_PRESERVE]: `Not supported 'preserve'.`,
  [I18nWarnCodes.NOT_SUPPORTED_FORMATTER]: `Not supported 'formatter'.`,
  [I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE]: `Not supported 'preserveDirectiveContent'.`,
  [I18nWarnCodes.NOT_SUPPORTED_GET_CHOICE_INDEX]: `Not supported 'getChoiceIndex'.`,
  [I18nWarnCodes.COMPONENT_NAME_LEGACY_COMPATIBLE]: `Component name legacy compatible: '{name}' -> 'i18n'`,
  [I18nWarnCodes.NOT_FOUND_PARENT_SCOPE]: `Not found parent scope. use the global scope.`
};

function getWarnMessage(code, ...args) {
  return format(warnMessages[code], ...args);
}

let code = CompileErrorCodes.__EXTEND_POINT__;

const inc = () => ++code;

const I18nErrorCodes = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: code,
  // legacy module errors
  INVALID_ARGUMENT: inc(),
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: inc(),
  NOT_INSLALLED: inc(),
  NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
  // directive module errors
  REQUIRED_VALUE: inc(),
  INVALID_VALUE: inc(),
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
  NOT_INSLALLED_WITH_PROVIDE: inc(),
  // unexpected error
  UNEXPECTED_ERROR: inc(),
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
  // for enhancement
  __EXTEND_POINT__: inc() // 29

};

function createI18nError(code, ...args) {
  return createCompileError(code, null, process.env.NODE_ENV !== 'production' ? {
    messages: errorMessages,
    args
  } : undefined);
}

const errorMessages = {
  [I18nErrorCodes.UNEXPECTED_RETURN_TYPE]: 'Unexpected return type in composer',
  [I18nErrorCodes.INVALID_ARGUMENT]: 'Invalid argument',
  [I18nErrorCodes.MUST_BE_CALL_SETUP_TOP]: 'Must be called at the top of a `setup` function',
  [I18nErrorCodes.NOT_INSLALLED]: 'Need to install with `app.use` function',
  [I18nErrorCodes.UNEXPECTED_ERROR]: 'Unexpected error',
  [I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE]: 'Not available in legacy mode',
  [I18nErrorCodes.REQUIRED_VALUE]: `Required in value: {0}`,
  [I18nErrorCodes.INVALID_VALUE]: `Invalid value`,
  [I18nErrorCodes.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: `Cannot setup vue-devtools plugin`,
  [I18nErrorCodes.NOT_INSLALLED_WITH_PROVIDE]: 'Need to install with `provide` function',
  [I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N]: 'Not compatible legacy VueI18n.',
  [I18nErrorCodes.BRIDGE_SUPPORT_VUE_2_ONLY]: 'vue-i18n-bridge support Vue 2.x only',
  [I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION]: 'Must define ‘i18n’ option or custom block in Composition API with using local scope in Legacy API mode',
  [I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: 'Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly'
};
const TransrateVNodeSymbol = /* #__PURE__*/makeSymbol('__transrateVNode');
const DatetimePartsSymbol = /* #__PURE__*/makeSymbol('__datetimeParts');
const NumberPartsSymbol = /* #__PURE__*/makeSymbol('__numberParts');
const EnableEmitter = /* #__PURE__*/makeSymbol('__enableEmitter');
const DisableEmitter = /* #__PURE__*/makeSymbol('__disableEmitter');
const SetPluralRulesSymbol = makeSymbol('__setPluralRules');
makeSymbol('__intlifyMeta');
const InejctWithOption = /* #__PURE__*/makeSymbol('__injectWithOption');
/* eslint-disable @typescript-eslint/no-explicit-any */

/**
 * Transform flat json in obj to normal json in obj
 */

function handleFlatJson(obj) {
  // check obj
  if (!isObject$1(obj)) {
    return obj;
  }

  for (const key in obj) {
    // check key
    if (!hasOwn(obj, key)) {
      continue;
    } // handle for normal json


    if (!key.includes('.')) {
      // recursive process value if value is also a object
      if (isObject$1(obj[key])) {
        handleFlatJson(obj[key]);
      }
    } // handle for flat json, transform to normal json
    else {
      // go to the last object
      const subKeys = key.split('.');
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;

      for (let i = 0; i < lastIndex; i++) {
        if (!(subKeys[i] in currentObj)) {
          currentObj[subKeys[i]] = {};
        }

        currentObj = currentObj[subKeys[i]];
      } // update last object value, delete old property


      currentObj[subKeys[lastIndex]] = obj[key];
      delete obj[key]; // recursive process value if value is also a object

      if (isObject$1(currentObj[subKeys[lastIndex]])) {
        handleFlatJson(currentObj[subKeys[lastIndex]]);
      }
    }
  }

  return obj;
}

function getLocaleMessages(locale, options) {
  const {
    messages,
    __i18n,
    messageResolver,
    flatJson
  } = options; // prettier-ignore

  const ret = isPlainObject(messages) ? messages : isArray$2(__i18n) ? {} : {
    [locale]: {}
  }; // merge locale messages of i18n custom block

  if (isArray$2(__i18n)) {
    __i18n.forEach(custom => {
      if ('locale' in custom && 'resource' in custom) {
        const {
          locale,
          resource
        } = custom;

        if (locale) {
          ret[locale] = ret[locale] || {};
          deepCopy(resource, ret[locale]);
        } else {
          deepCopy(resource, ret);
        }
      } else {
        isString(custom) && deepCopy(JSON.parse(custom), ret);
      }
    });
  } // handle messages for flat json


  if (messageResolver == null && flatJson) {
    for (const key in ret) {
      if (hasOwn(ret, key)) {
        handleFlatJson(ret[key]);
      }
    }
  }

  return ret;
}

const isNotObjectOrIsArray = val => !isObject$1(val) || isArray$2(val); // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types


function deepCopy(src, des) {
  // src and des should both be objects, and non of then can be a array
  if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }

  for (const key in src) {
    if (hasOwn(src, key)) {
      if (isNotObjectOrIsArray(src[key]) || isNotObjectOrIsArray(des[key])) {
        // replace with src[key] when:
        // src[key] or des[key] is not a object, or
        // src[key] or des[key] is a array
        des[key] = src[key];
      } else {
        // src[key] and des[key] are both object, merge them
        deepCopy(src[key], des[key]);
      }
    }
  }
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function getComponentOptions(instance) {
  return instance.type;
}

function adjustI18nResources(global, options, componentOptions // eslint-disable-line @typescript-eslint/no-explicit-any
) {
  let messages = isObject$1(options.messages) ? options.messages : {};

  if ('__i18nGlobal' in componentOptions) {
    messages = getLocaleMessages(global.locale.value, {
      messages,
      __i18n: componentOptions.__i18nGlobal
    });
  } // merge locale messages


  const locales = Object.keys(messages);

  if (locales.length) {
    locales.forEach(locale => {
      global.mergeLocaleMessage(locale, messages[locale]);
    });
  }

  {
    // merge datetime formats
    if (isObject$1(options.datetimeFormats)) {
      const locales = Object.keys(options.datetimeFormats);

      if (locales.length) {
        locales.forEach(locale => {
          global.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
        });
      }
    } // merge number formats


    if (isObject$1(options.numberFormats)) {
      const locales = Object.keys(options.numberFormats);

      if (locales.length) {
        locales.forEach(locale => {
          global.mergeNumberFormat(locale, options.numberFormats[locale]);
        });
      }
    }
  }
}

function createTextNode(key) {
  return createVNode(Text, null, key, 0);
}
/* eslint-enable @typescript-eslint/no-explicit-any */

/* eslint-disable @typescript-eslint/no-explicit-any */
// extend VNode interface


const DEVTOOLS_META = '__INTLIFY_META__';
let composerID = 0;

function defineCoreMissingHandler(missing) {
  return (ctx, locale, key, type) => {
    return missing(locale, key, getCurrentInstance() || undefined, type);
  };
} // for Intlify DevTools


const getMetaInfo = () => {
  const instance = getCurrentInstance();
  let meta = null; // eslint-disable-line @typescript-eslint/no-explicit-any

  return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? {
    [DEVTOOLS_META]: meta
  } // eslint-disable-line @typescript-eslint/no-explicit-any
  : null;
};
/**
 * Create composer interface factory
 *
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function createComposer(options = {}, VueI18nLegacy) {
  const {
    __root
  } = options;

  const _isGlobal = __root === undefined;

  let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;

  const _locale = ref( // prettier-ignore
  __root && _inheritLocale ? __root.locale.value : isString(options.locale) ? options.locale : DEFAULT_LOCALE);

  const _fallbackLocale = ref( // prettier-ignore
  __root && _inheritLocale ? __root.fallbackLocale.value : isString(options.fallbackLocale) || isArray$2(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value);

  const _messages = ref(getLocaleMessages(_locale.value, options)); // prettier-ignore


  const _datetimeFormats = ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : {
    [_locale.value]: {}
  }); // prettier-ignore


  const _numberFormats = ref(isPlainObject(options.numberFormats) ? options.numberFormats : {
    [_locale.value]: {}
  }); // warning suppress options
  // prettier-ignore


  let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true; // prettier-ignore


  let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true; // prettier-ignore


  let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true; // configure fall back to root


  let _fallbackFormat = !!options.fallbackFormat; // runtime missing


  let _missing = isFunction$1(options.missing) ? options.missing : null;

  let _runtimeMissing = isFunction$1(options.missing) ? defineCoreMissingHandler(options.missing) : null; // postTranslation handler


  let _postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : null; // prettier-ignore


  let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;

  let _escapeParameter = !!options.escapeParameter; // custom linked modifiers
  // prettier-ignore


  const _modifiers = __root ? __root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {}; // pluralRules


  let _pluralRules = options.pluralRules || __root && __root.pluralRules; // runtime context
  // eslint-disable-next-line prefer-const


  let _context;

  const getCoreContext = () => {
    _isGlobal && setFallbackContext(null);
    const ctxOptions = {
      version: VERSION,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? undefined : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? undefined : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      messageResolver: options.messageResolver,
      __meta: {
        framework: 'vue'
      }
    };
    {
      ctxOptions.datetimeFormats = _datetimeFormats.value;
      ctxOptions.numberFormats = _numberFormats.value;
      ctxOptions.__datetimeFormatters = isPlainObject(_context) ? _context.__datetimeFormatters : undefined;
      ctxOptions.__numberFormatters = isPlainObject(_context) ? _context.__numberFormatters : undefined;
    }

    if (process.env.NODE_ENV !== 'production') {
      ctxOptions.__v_emitter = isPlainObject(_context) ? _context.__v_emitter : undefined;
    }

    const ctx = createCoreContext(ctxOptions);
    _isGlobal && setFallbackContext(ctx);
    return ctx;
  };

  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value); // track reactivity

  function trackReactivityValues() {
    return [_locale.value, _fallbackLocale.value, _messages.value, _datetimeFormats.value, _numberFormats.value];
  } // locale


  const locale = computed({
    get: () => _locale.value,
    set: val => {
      _locale.value = val;
      _context.locale = _locale.value;
    }
  }); // fallbackLocale

  const fallbackLocale = computed({
    get: () => _fallbackLocale.value,
    set: val => {
      _fallbackLocale.value = val;
      _context.fallbackLocale = _fallbackLocale.value;
      updateFallbackLocale(_context, _locale.value, val);
    }
  }); // messages

  const messages = computed(() => _messages.value); // datetimeFormats

  const datetimeFormats = /* #__PURE__*/computed(() => _datetimeFormats.value); // numberFormats

  const numberFormats = /* #__PURE__*/computed(() => _numberFormats.value); // getPostTranslationHandler

  function getPostTranslationHandler() {
    return isFunction$1(_postTranslation) ? _postTranslation : null;
  } // setPostTranslationHandler


  function setPostTranslationHandler(handler) {
    _postTranslation = handler;
    _context.postTranslation = handler;
  } // getMissingHandler


  function getMissingHandler() {
    return _missing;
  } // setMissingHandler


  function setMissingHandler(handler) {
    if (handler !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler);
    }

    _missing = handler;
    _context.missing = _runtimeMissing;
  }

  function isResolvedTranslateMessage(type, arg // eslint-disable-line @typescript-eslint/no-explicit-any
  ) {
    return type !== 'translate' || !arg.resolvedMessage;
  }

  const wrapWithDeps = (fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
    trackReactivityValues(); // track reactive dependency
    // NOTE: experimental !!

    let ret;

    if (process.env.NODE_ENV !== 'production' || __INTLIFY_PROD_DEVTOOLS__) {
      try {
        setAdditionalMeta(getMetaInfo());

        if (!_isGlobal) {
          _context.fallbackContext = __root ? getFallbackContext() : undefined;
        }

        ret = fn(_context);
      } finally {
        setAdditionalMeta(null);

        if (!_isGlobal) {
          _context.fallbackContext = undefined;
        }
      }
    } else {
      ret = fn(_context);
    }

    if (isNumber$1(ret) && ret === NOT_REOSLVED) {
      const [key, arg2] = argumentParser();

      if (process.env.NODE_ENV !== 'production' && __root && isString(key) && isResolvedTranslateMessage(warnType, arg2)) {
        if (_fallbackRoot && (isTranslateFallbackWarn(_fallbackWarn, key) || isTranslateMissingWarn(_missingWarn, key))) {
          warn$1(getWarnMessage(I18nWarnCodes.FALLBACK_TO_ROOT, {
            key,
            type: warnType
          }));
        } // for vue-devtools timeline event


        if (process.env.NODE_ENV !== 'production') {
          const {
            __v_emitter: emitter
          } = _context;

          if (emitter && _fallbackRoot) {
            emitter.emit("fallback"
            /* FALBACK */
            , {
              type: warnType,
              key,
              to: 'global',
              groupId: `${warnType}:${key}`
            });
          }
        }
      }

      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      /* istanbul ignore next */
      throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
    }
  }; // t


  function t(...args) {
    return wrapWithDeps(context => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), 'translate', root => Reflect.apply(root.t, root, [...args]), key => key, val => isString(val));
  } // rt


  function rt(...args) {
    const [arg1, arg2, arg3] = args;

    if (arg3 && !isObject$1(arg3)) {
      throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
    }

    return t(...[arg1, arg2, assign$1({
      resolvedMessage: true
    }, arg3 || {})]);
  } // d


  function d(...args) {
    return wrapWithDeps(context => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), 'datetime format', root => Reflect.apply(root.d, root, [...args]), () => MISSING_RESOLVE_VALUE, val => isString(val));
  } // n


  function n(...args) {
    return wrapWithDeps(context => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), 'number format', root => Reflect.apply(root.n, root, [...args]), () => MISSING_RESOLVE_VALUE, val => isString(val));
  } // for custom processor


  function normalize(values) {
    return values.map(val => isString(val) || isNumber$1(val) || isBoolean(val) ? createTextNode(String(val)) : val);
  }

  const interpolate = val => val;

  const processor = {
    normalize,
    interpolate,
    type: 'vnode'
  }; // transrateVNode, using for `i18n-t` component

  function transrateVNode(...args) {
    return wrapWithDeps(context => {
      let ret;
      const _context = context;

      try {
        _context.processor = processor;
        ret = Reflect.apply(translate, null, [_context, ...args]);
      } finally {
        _context.processor = null;
      }

      return ret;
    }, () => parseTranslateArgs(...args), 'translate', // eslint-disable-next-line @typescript-eslint/no-explicit-any
    root => root[TransrateVNodeSymbol](...args), key => [createTextNode(key)], val => isArray$2(val));
  } // numberParts, using for `i18n-n` component


  function numberParts(...args) {
    return wrapWithDeps(context => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), 'number format', // eslint-disable-next-line @typescript-eslint/no-explicit-any
    root => root[NumberPartsSymbol](...args), () => [], val => isString(val) || isArray$2(val));
  } // datetimeParts, using for `i18n-d` component


  function datetimeParts(...args) {
    return wrapWithDeps(context => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), 'datetime format', // eslint-disable-next-line @typescript-eslint/no-explicit-any
    root => root[DatetimePartsSymbol](...args), () => [], val => isString(val) || isArray$2(val));
  }

  function setPluralRules(rules) {
    _pluralRules = rules;
    _context.pluralRules = _pluralRules;
  } // te


  function te(key, locale) {
    const targetLocale = isString(locale) ? locale : _locale.value;
    const message = getLocaleMessage(targetLocale);
    return _context.messageResolver(message, key) !== null;
  }

  function resolveMessages(key) {
    let messages = null;
    const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);

    for (let i = 0; i < locales.length; i++) {
      const targetLocaleMessages = _messages.value[locales[i]] || {};

      const messageValue = _context.messageResolver(targetLocaleMessages, key);

      if (messageValue != null) {
        messages = messageValue;
        break;
      }
    }

    return messages;
  } // tm


  function tm(key) {
    const messages = resolveMessages(key); // prettier-ignore

    return messages != null ? messages : __root ? __root.tm(key) || {} : {};
  } // getLocaleMessage


  function getLocaleMessage(locale) {
    return _messages.value[locale] || {};
  } // setLocaleMessage


  function setLocaleMessage(locale, message) {
    _messages.value[locale] = message;
    _context.messages = _messages.value;
  } // mergeLocaleMessage


  function mergeLocaleMessage(locale, message) {
    _messages.value[locale] = _messages.value[locale] || {};
    deepCopy(message, _messages.value[locale]);
    _context.messages = _messages.value;
  } // getDateTimeFormat


  function getDateTimeFormat(locale) {
    return _datetimeFormats.value[locale] || {};
  } // setDateTimeFormat


  function setDateTimeFormat(locale, format) {
    _datetimeFormats.value[locale] = format;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale, format);
  } // mergeDateTimeFormat


  function mergeDateTimeFormat(locale, format) {
    _datetimeFormats.value[locale] = assign$1(_datetimeFormats.value[locale] || {}, format);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale, format);
  } // getNumberFormat


  function getNumberFormat(locale) {
    return _numberFormats.value[locale] || {};
  } // setNumberFormat


  function setNumberFormat(locale, format) {
    _numberFormats.value[locale] = format;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale, format);
  } // mergeNumberFormat


  function mergeNumberFormat(locale, format) {
    _numberFormats.value[locale] = assign$1(_numberFormats.value[locale] || {}, format);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale, format);
  } // for debug


  composerID++; // watch root locale & fallbackLocale

  if (__root && inBrowser) {
    watch(__root.locale, val => {
      if (_inheritLocale) {
        _locale.value = val;
        _context.locale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
    watch(__root.fallbackLocale, val => {
      if (_inheritLocale) {
        _fallbackLocale.value = val;
        _context.fallbackLocale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
  } // define basic composition API!


  const composer = {
    id: composerID,
    locale,
    fallbackLocale,

    get inheritLocale() {
      return _inheritLocale;
    },

    set inheritLocale(val) {
      _inheritLocale = val;

      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },

    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },

    messages,

    get modifiers() {
      return _modifiers;
    },

    get pluralRules() {
      return _pluralRules || {};
    },

    get isGlobal() {
      return _isGlobal;
    },

    get missingWarn() {
      return _missingWarn;
    },

    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },

    get fallbackWarn() {
      return _fallbackWarn;
    },

    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },

    get fallbackRoot() {
      return _fallbackRoot;
    },

    set fallbackRoot(val) {
      _fallbackRoot = val;
    },

    get fallbackFormat() {
      return _fallbackFormat;
    },

    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },

    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },

    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },

    get escapeParameter() {
      return _escapeParameter;
    },

    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },

    t,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [SetPluralRulesSymbol]: setPluralRules
  };
  {
    composer.datetimeFormats = datetimeFormats;
    composer.numberFormats = numberFormats;
    composer.rt = rt;
    composer.te = te;
    composer.tm = tm;
    composer.d = d;
    composer.n = n;
    composer.getDateTimeFormat = getDateTimeFormat;
    composer.setDateTimeFormat = setDateTimeFormat;
    composer.mergeDateTimeFormat = mergeDateTimeFormat;
    composer.getNumberFormat = getNumberFormat;
    composer.setNumberFormat = setNumberFormat;
    composer.mergeNumberFormat = mergeNumberFormat;
    composer[InejctWithOption] = options.__injectWithOption;
    composer[TransrateVNodeSymbol] = transrateVNode;
    composer[DatetimePartsSymbol] = datetimeParts;
    composer[NumberPartsSymbol] = numberParts;
  } // for vue-devtools timeline event

  if (process.env.NODE_ENV !== 'production') {
    composer[EnableEmitter] = emitter => {
      _context.__v_emitter = emitter;
    };

    composer[DisableEmitter] = () => {
      _context.__v_emitter = undefined;
    };
  }

  return composer;
}
/* eslint-enable @typescript-eslint/no-explicit-any */

/* eslint-disable @typescript-eslint/no-explicit-any */

/**
 * Convert to I18n Composer Options from VueI18n Options
 *
 * @internal
 */


function convertComposerOptions(options) {
  const locale = isString(options.locale) ? options.locale : DEFAULT_LOCALE;
  const fallbackLocale = isString(options.fallbackLocale) || isArray$2(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
  const missing = isFunction$1(options.missing) ? options.missing : undefined;
  const missingWarn = isBoolean(options.silentTranslationWarn) || isRegExp(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
  const fallbackWarn = isBoolean(options.silentFallbackWarn) || isRegExp(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
  const fallbackRoot = isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  const fallbackFormat = !!options.formatFallbackMessages;
  const modifiers = isPlainObject(options.modifiers) ? options.modifiers : {};
  const pluralizationRules = options.pluralizationRules;
  const postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : undefined;
  const warnHtmlMessage = isString(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== 'off' : true;
  const escapeParameter = !!options.escapeParameterHtml;
  const inheritLocale = isBoolean(options.sync) ? options.sync : true;

  if (process.env.NODE_ENV !== 'production' && options.formatter) {
    warn$1(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_FORMATTER));
  }

  if (process.env.NODE_ENV !== 'production' && options.preserveDirectiveContent) {
    warn$1(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
  }

  let messages = options.messages;

  if (isPlainObject(options.sharedMessages)) {
    const sharedMessages = options.sharedMessages;
    const locales = Object.keys(sharedMessages);
    messages = locales.reduce((messages, locale) => {
      const message = messages[locale] || (messages[locale] = {});
      assign$1(message, sharedMessages[locale]);
      return messages;
    }, messages || {});
  }

  const {
    __i18n,
    __root,
    __injectWithOption
  } = options;
  const datetimeFormats = options.datetimeFormats;
  const numberFormats = options.numberFormats;
  const flatJson = options.flatJson;
  return {
    locale,
    fallbackLocale,
    messages,
    flatJson,
    datetimeFormats,
    numberFormats,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackRoot,
    fallbackFormat,
    modifiers,
    pluralRules: pluralizationRules,
    postTranslation,
    warnHtmlMessage,
    escapeParameter,
    messageResolver: options.messageResolver,
    inheritLocale,
    __i18n,
    __root,
    __injectWithOption
  };
}
/**
 * create VueI18n interface factory
 *
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function createVueI18n(options = {}, VueI18nLegacy) {
  {
    const composer = createComposer(convertComposerOptions(options)); // defines VueI18n

    const vueI18n = {
      // id
      id: composer.id,

      // locale
      get locale() {
        return composer.locale.value;
      },

      set locale(val) {
        composer.locale.value = val;
      },

      // fallbackLocale
      get fallbackLocale() {
        return composer.fallbackLocale.value;
      },

      set fallbackLocale(val) {
        composer.fallbackLocale.value = val;
      },

      // messages
      get messages() {
        return composer.messages.value;
      },

      // datetimeFormats
      get datetimeFormats() {
        return composer.datetimeFormats.value;
      },

      // numberFormats
      get numberFormats() {
        return composer.numberFormats.value;
      },

      // availableLocales
      get availableLocales() {
        return composer.availableLocales;
      },

      // formatter
      get formatter() {
        process.env.NODE_ENV !== 'production' && warn$1(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_FORMATTER)); // dummy

        return {
          interpolate() {
            return [];
          }

        };
      },

      set formatter(val) {
        process.env.NODE_ENV !== 'production' && warn$1(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_FORMATTER));
      },

      // missing
      get missing() {
        return composer.getMissingHandler();
      },

      set missing(handler) {
        composer.setMissingHandler(handler);
      },

      // silentTranslationWarn
      get silentTranslationWarn() {
        return isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
      },

      set silentTranslationWarn(val) {
        composer.missingWarn = isBoolean(val) ? !val : val;
      },

      // silentFallbackWarn
      get silentFallbackWarn() {
        return isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
      },

      set silentFallbackWarn(val) {
        composer.fallbackWarn = isBoolean(val) ? !val : val;
      },

      // modifiers
      get modifiers() {
        return composer.modifiers;
      },

      // formatFallbackMessages
      get formatFallbackMessages() {
        return composer.fallbackFormat;
      },

      set formatFallbackMessages(val) {
        composer.fallbackFormat = val;
      },

      // postTranslation
      get postTranslation() {
        return composer.getPostTranslationHandler();
      },

      set postTranslation(handler) {
        composer.setPostTranslationHandler(handler);
      },

      // sync
      get sync() {
        return composer.inheritLocale;
      },

      set sync(val) {
        composer.inheritLocale = val;
      },

      // warnInHtmlMessage
      get warnHtmlInMessage() {
        return composer.warnHtmlMessage ? 'warn' : 'off';
      },

      set warnHtmlInMessage(val) {
        composer.warnHtmlMessage = val !== 'off';
      },

      // escapeParameterHtml
      get escapeParameterHtml() {
        return composer.escapeParameter;
      },

      set escapeParameterHtml(val) {
        composer.escapeParameter = val;
      },

      // preserveDirectiveContent
      get preserveDirectiveContent() {
        process.env.NODE_ENV !== 'production' && warn$1(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
        return true;
      },

      set preserveDirectiveContent(val) {
        process.env.NODE_ENV !== 'production' && warn$1(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
      },

      // pluralizationRules
      get pluralizationRules() {
        return composer.pluralRules || {};
      },

      // for internal
      __composer: composer,

      // t
      t(...args) {
        const [arg1, arg2, arg3] = args;
        const options = {};
        let list = null;
        let named = null;

        if (!isString(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }

        const key = arg1;

        if (isString(arg2)) {
          options.locale = arg2;
        } else if (isArray$2(arg2)) {
          list = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }

        if (isArray$2(arg3)) {
          list = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        } // return composer.t(key, (list || named || {}) as any, options)


        return Reflect.apply(composer.t, composer, [key, list || named || {}, options]);
      },

      rt(...args) {
        return Reflect.apply(composer.rt, composer, [...args]);
      },

      // tc
      tc(...args) {
        const [arg1, arg2, arg3] = args;
        const options = {
          plural: 1
        };
        let list = null;
        let named = null;

        if (!isString(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }

        const key = arg1;

        if (isString(arg2)) {
          options.locale = arg2;
        } else if (isNumber$1(arg2)) {
          options.plural = arg2;
        } else if (isArray$2(arg2)) {
          list = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }

        if (isString(arg3)) {
          options.locale = arg3;
        } else if (isArray$2(arg3)) {
          list = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        } // return composer.t(key, (list || named || {}) as any, options)


        return Reflect.apply(composer.t, composer, [key, list || named || {}, options]);
      },

      // te
      te(key, locale) {
        return composer.te(key, locale);
      },

      // tm
      tm(key) {
        return composer.tm(key);
      },

      // getLocaleMessage
      getLocaleMessage(locale) {
        return composer.getLocaleMessage(locale);
      },

      // setLocaleMessage
      setLocaleMessage(locale, message) {
        composer.setLocaleMessage(locale, message);
      },

      // mergeLocaleMessage
      mergeLocaleMessage(locale, message) {
        composer.mergeLocaleMessage(locale, message);
      },

      // d
      d(...args) {
        return Reflect.apply(composer.d, composer, [...args]);
      },

      // getDateTimeFormat
      getDateTimeFormat(locale) {
        return composer.getDateTimeFormat(locale);
      },

      // setDateTimeFormat
      setDateTimeFormat(locale, format) {
        composer.setDateTimeFormat(locale, format);
      },

      // mergeDateTimeFormat
      mergeDateTimeFormat(locale, format) {
        composer.mergeDateTimeFormat(locale, format);
      },

      // n
      n(...args) {
        return Reflect.apply(composer.n, composer, [...args]);
      },

      // getNumberFormat
      getNumberFormat(locale) {
        return composer.getNumberFormat(locale);
      },

      // setNumberFormat
      setNumberFormat(locale, format) {
        composer.setNumberFormat(locale, format);
      },

      // mergeNumberFormat
      mergeNumberFormat(locale, format) {
        composer.mergeNumberFormat(locale, format);
      },

      // getChoiceIndex
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getChoiceIndex(choice, choicesLength) {
        process.env.NODE_ENV !== 'production' && warn$1(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_GET_CHOICE_INDEX));
        return -1;
      },

      // for internal
      __onComponentInstanceCreated(target) {
        const {
          componentInstanceCreatedListener
        } = options;

        if (componentInstanceCreatedListener) {
          componentInstanceCreatedListener(target, vueI18n);
        }
      }

    }; // for vue-devtools timeline event

    if (process.env.NODE_ENV !== 'production') {
      vueI18n.__enableEmitter = emitter => {
        const __composer = composer;
        __composer[EnableEmitter] && __composer[EnableEmitter](emitter);
      };

      vueI18n.__disableEmitter = () => {
        const __composer = composer;
        __composer[DisableEmitter] && __composer[DisableEmitter]();
      };
    }

    return vueI18n;
  }
}
/* eslint-enable @typescript-eslint/no-explicit-any */


const baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (val
    /* ComponetI18nScope */
    ) => val === 'parent' || val === 'global',
    default: 'parent'
    /* ComponetI18nScope */

  },
  i18n: {
    type: Object
  }
};

function getInterpolateArg( // eslint-disable-next-line @typescript-eslint/no-explicit-any
{
  slots
}, // SetupContext,
keys) {
  if (keys.length === 1 && keys[0] === 'default') {
    // default slot with list
    const ret = slots.default ? slots.default() : []; // eslint-disable-next-line @typescript-eslint/no-explicit-any

    return ret.reduce((slot, current) => {
      return slot = [...slot, ...(isArray$2(current.children) ? current.children : [current])];
    }, []);
  } else {
    // named slots
    return keys.reduce((arg, key) => {
      const slot = slots[key];

      if (slot) {
        arg[key] = slot();
      }

      return arg;
    }, {});
  }
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function getFragmentableTag(tag) {
  return Fragment;
}
/**
 * Translation Component
 *
 * @remarks
 * See the following items for property about details
 *
 * @VueI18nSee [TranslationProps](component#translationprops)
 * @VueI18nSee [BaseFormatProps](component#baseformatprops)
 * @VueI18nSee [Component Interpolation](../guide/advanced/component)
 *
 * @example
 * ```html
 * <div id="app">
 *   <!-- ... -->
 *   <i18n path="term" tag="label" for="tos">
 *     <a :href="url" target="_blank">{{ $t('tos') }}</a>
 *   </i18n>
 *   <!-- ... -->
 * </div>
 * ```
 * ```js
 * import { createApp } from 'vue'
 * import { createI18n } from 'vue-i18n'
 *
 * const messages = {
 *   en: {
 *     tos: 'Term of Service',
 *     term: 'I accept xxx {0}.'
 *   },
 *   ja: {
 *     tos: '利用規約',
 *     term: '私は xxx の{0}に同意します。'
 *   }
 * }
 *
 * const i18n = createI18n({
 *   locale: 'en',
 *   messages
 * })
 *
 * const app = createApp({
 *   data: {
 *     url: '/term'
 *   }
 * }).use(i18n).mount('#app')
 * ```
 *
 * @VueI18nComponent
 */


const Translation =
/* defineComponent */
{
  /* eslint-disable */
  name: 'i18n-t',
  props: assign$1({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      validator: val => isNumber$1(val) || !isNaN(val)
    }
  }, baseFormatProps),

  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const {
      slots,
      attrs
    } = context; // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050

    const i18n = props.i18n || useI18n$1({
      useScope: props.scope,
      __useComponent: true
    });
    return () => {
      const keys = Object.keys(slots).filter(key => key !== '_');
      const options = {};

      if (props.locale) {
        options.locale = props.locale;
      }

      if (props.plural !== undefined) {
        options.plural = isString(props.plural) ? +props.plural : props.plural;
      }

      const arg = getInterpolateArg(context, keys); // eslint-disable-next-line @typescript-eslint/no-explicit-any

      const children = i18n[TransrateVNodeSymbol](props.keypath, arg, options);
      const assignedAttrs = assign$1({}, attrs);
      const tag = isString(props.tag) || isObject$1(props.tag) ? props.tag : getFragmentableTag();
      return h(tag, assignedAttrs, children);
    };
  }

};

function isVNode(target) {
  return isArray$2(target) && !isString(target[0]);
}

function renderFormatter(props, context, slotKeys, partFormatter) {
  const {
    slots,
    attrs
  } = context;
  return () => {
    const options = {
      part: true
    };
    let overrides = {};

    if (props.locale) {
      options.locale = props.locale;
    }

    if (isString(props.format)) {
      options.key = props.format;
    } else if (isObject$1(props.format)) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      if (isString(props.format.key)) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        options.key = props.format.key;
      } // Filter out number format options only


      overrides = Object.keys(props.format).reduce((options, prop) => {
        return slotKeys.includes(prop) ? assign$1({}, options, {
          [prop]: props.format[prop]
        }) // eslint-disable-line @typescript-eslint/no-explicit-any
        : options;
      }, {});
    }

    const parts = partFormatter(...[props.value, options, overrides]);
    let children = [options.key];

    if (isArray$2(parts)) {
      children = parts.map((part, index) => {
        const slot = slots[part.type];
        const node = slot ? slot({
          [part.type]: part.value,
          index,
          parts
        }) : [part.value];

        if (isVNode(node)) {
          node[0].key = `${part.type}-${index}`;
        }

        return node;
      });
    } else if (isString(parts)) {
      children = [parts];
    }

    const assignedAttrs = assign$1({}, attrs);
    const tag = isString(props.tag) || isObject$1(props.tag) ? props.tag : getFragmentableTag();
    return h(tag, assignedAttrs, children);
  };
}
/**
 * Number Format Component
 *
 * @remarks
 * See the following items for property about details
 *
 * @VueI18nSee [FormattableProps](component#formattableprops)
 * @VueI18nSee [BaseFormatProps](component#baseformatprops)
 * @VueI18nSee [Custom Formatting](../guide/essentials/number#custom-formatting)
 *
 * @VueI18nDanger
 * Not supported IE, due to no support `Intl.NumberFormat#formatToParts` in [IE](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/formatToParts)
 *
 * If you want to use it, you need to use [polyfill](https://github.com/formatjs/formatjs/tree/main/packages/intl-numberformat)
 *
 * @VueI18nComponent
 */


const NumberFormat =
/* defineComponent */
{
  /* eslint-disable */
  name: 'i18n-n',
  props: assign$1({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),

  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n = props.i18n || useI18n$1({
      useScope: 'parent',
      __useComponent: true
    });
    return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => // eslint-disable-next-line @typescript-eslint/no-explicit-any
    i18n[NumberPartsSymbol](...args));
  }

};
/**
 * Datetime Format Component
 *
 * @remarks
 * See the following items for property about details
 *
 * @VueI18nSee [FormattableProps](component#formattableprops)
 * @VueI18nSee [BaseFormatProps](component#baseformatprops)
 * @VueI18nSee [Custom Formatting](../guide/essentials/datetime#custom-formatting)
 *
 * @VueI18nDanger
 * Not supported IE, due to no support `Intl.DateTimeFormat#formatToParts` in [IE](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/formatToParts)
 *
 * If you want to use it, you need to use [polyfill](https://github.com/formatjs/formatjs/tree/main/packages/intl-datetimeformat)
 *
 * @VueI18nComponent
 */

const DatetimeFormat =
/*defineComponent */
{
  /* eslint-disable */
  name: 'i18n-d',
  props: assign$1({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),

  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n = props.i18n || useI18n$1({
      useScope: 'parent',
      __useComponent: true
    });
    return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => // eslint-disable-next-line @typescript-eslint/no-explicit-any
    i18n[DatetimePartsSymbol](...args));
  }

};

function getComposer$2(i18n, instance) {
  const i18nInternal = i18n;

  if (i18n.mode === 'composition') {
    return i18nInternal.__getInstance(instance) || i18n.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance);

    return vueI18n != null ? vueI18n.__composer : i18n.global.__composer;
  }
}

function vTDirective(i18n) {
  const _process = binding => {
    const {
      instance,
      modifiers,
      value
    } = binding;
    /* istanbul ignore if */

    if (!instance || !instance.$) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }

    const composer = getComposer$2(i18n, instance.$);

    if (process.env.NODE_ENV !== 'production' && modifiers.preserve) {
      warn$1(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_PRESERVE));
    }

    const parsedValue = parseValue$1(value);
    return [Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]), composer];
  };

  const register = (el, binding) => {
    const [textContent, composer] = _process(binding);

    if (inBrowser && i18n.global === composer) {
      // global scope only
      el.__i18nWatcher = watch(composer.locale, () => {
        binding.instance && binding.instance.$forceUpdate();
      });
    }

    el.__composer = composer;
    el.textContent = textContent;
  };

  const unregister = el => {
    if (inBrowser && el.__i18nWatcher) {
      el.__i18nWatcher();

      el.__i18nWatcher = undefined;
      delete el.__i18nWatcher;
    }

    if (el.__composer) {
      el.__composer = undefined;
      delete el.__composer;
    }
  };

  const update = (el, {
    value
  }) => {
    if (el.__composer) {
      const composer = el.__composer;
      const parsedValue = parseValue$1(value);
      el.textContent = Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]);
    }
  };

  const getSSRProps = binding => {
    const [textContent] = _process(binding);

    return {
      textContent
    };
  };

  return {
    created: register,
    unmounted: unregister,
    beforeUpdate: update,
    getSSRProps
  };
}

function parseValue$1(value) {
  if (isString(value)) {
    return {
      path: value
    };
  } else if (isPlainObject(value)) {
    if (!('path' in value)) {
      throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, 'path');
    }

    return value;
  } else {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
}

function makeParams(value) {
  const {
    path,
    locale,
    args,
    choice,
    plural
  } = value;
  const options = {};
  const named = args || {};

  if (isString(locale)) {
    options.locale = locale;
  }

  if (isNumber$1(choice)) {
    options.plural = choice;
  }

  if (isNumber$1(plural)) {
    options.plural = plural;
  }

  return [path, named, options];
}

function apply(app, i18n, ...options) {
  const pluginOptions = isPlainObject(options[0]) ? options[0] : {};
  const useI18nComponentName = !!pluginOptions.useI18nComponentName;
  const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;

  if (process.env.NODE_ENV !== 'production' && globalInstall && useI18nComponentName) {
    warn$1(getWarnMessage(I18nWarnCodes.COMPONENT_NAME_LEGACY_COMPATIBLE, {
      name: Translation.name
    }));
  }

  if (globalInstall) {
    // install components
    app.component(!useI18nComponentName ? Translation.name : 'i18n', Translation);
    app.component(NumberFormat.name, NumberFormat);
    app.component(DatetimeFormat.name, DatetimeFormat);
  } // install directive


  {
    app.directive('t', vTDirective(i18n));
  }
}

const VUE_I18N_COMPONENT_TYPES = 'vue-i18n: composer properties';
let devtoolsApi;

async function enableDevTools(app, i18n) {
  return new Promise((resolve, reject) => {
    try {
      setupDevtoolsPlugin({
        id: "vue-devtools-plugin-vue-i18n"
        /* PLUGIN */
        ,
        label: VueDevToolsLabels["vue-devtools-plugin-vue-i18n"
        /* PLUGIN */
        ],
        packageName: 'vue-i18n',
        homepage: 'https://vue-i18n.intlify.dev',
        logo: 'https://vue-i18n.intlify.dev/vue-i18n-devtools-logo.png',
        componentStateTypes: [VUE_I18N_COMPONENT_TYPES],
        app: app // eslint-disable-line @typescript-eslint/no-explicit-any

      }, api => {
        devtoolsApi = api;
        api.on.visitComponentTree(({
          componentInstance,
          treeNode
        }) => {
          updateComponentTreeTags(componentInstance, treeNode, i18n);
        });
        api.on.inspectComponent(({
          componentInstance,
          instanceData
        }) => {
          if (componentInstance.vnode.el && componentInstance.vnode.el.__VUE_I18N__ && instanceData) {
            if (i18n.mode === 'legacy') {
              // ignore global scope on legacy mode
              if (componentInstance.vnode.el.__VUE_I18N__ !== i18n.global.__composer) {
                inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);
              }
            } else {
              inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);
            }
          }
        });
        api.addInspector({
          id: "vue-i18n-resource-inspector"
          /* CUSTOM_INSPECTOR */
          ,
          label: VueDevToolsLabels["vue-i18n-resource-inspector"
          /* CUSTOM_INSPECTOR */
          ],
          icon: 'language',
          treeFilterPlaceholder: VueDevToolsPlaceholders["vue-i18n-resource-inspector"
          /* CUSTOM_INSPECTOR */
          ]
        });
        api.on.getInspectorTree(payload => {
          if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector"
          /* CUSTOM_INSPECTOR */
          ) {
            registerScope(payload, i18n);
          }
        });
        const roots = new Map();
        api.on.getInspectorState(async payload => {
          if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector"
          /* CUSTOM_INSPECTOR */
          ) {
            api.unhighlightElement();
            inspectScope(payload, i18n);

            if (payload.nodeId === 'global') {
              if (!roots.has(payload.app)) {
                const [root] = await api.getComponentInstances(payload.app);
                roots.set(payload.app, root);
              }

              api.highlightElement(roots.get(payload.app));
            } else {
              const instance = getComponentInstance(payload.nodeId, i18n);
              instance && api.highlightElement(instance);
            }
          }
        });
        api.on.editInspectorState(payload => {
          if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector"
          /* CUSTOM_INSPECTOR */
          ) {
            editScope(payload, i18n);
          }
        });
        api.addTimelineLayer({
          id: "vue-i18n-timeline"
          /* TIMELINE */
          ,
          label: VueDevToolsLabels["vue-i18n-timeline"
          /* TIMELINE */
          ],
          color: VueDevToolsTimelineColors["vue-i18n-timeline"
          /* TIMELINE */
          ]
        });
        resolve(true);
      });
    } catch (e) {
      console.error(e);
      reject(false);
    }
  });
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function getI18nScopeLable(instance) {
  return instance.type.name || instance.type.displayName || instance.type.__file || 'Anonymous';
}

function updateComponentTreeTags(instance, // eslint-disable-line @typescript-eslint/no-explicit-any
treeNode, i18n) {
  // prettier-ignore
  const global = i18n.mode === 'composition' ? i18n.global : i18n.global.__composer;

  if (instance && instance.vnode.el && instance.vnode.el.__VUE_I18N__) {
    // add custom tags local scope only
    if (instance.vnode.el.__VUE_I18N__ !== global) {
      const tag = {
        label: `i18n (${getI18nScopeLable(instance)} Scope)`,
        textColor: 0x000000,
        backgroundColor: 0xffcd19
      };
      treeNode.tags.push(tag);
    }
  }
}

function inspectComposer(instanceData, composer) {
  const type = VUE_I18N_COMPONENT_TYPES;
  instanceData.state.push({
    type,
    key: 'locale',
    editable: true,
    value: composer.locale.value
  });
  instanceData.state.push({
    type,
    key: 'availableLocales',
    editable: false,
    value: composer.availableLocales
  });
  instanceData.state.push({
    type,
    key: 'fallbackLocale',
    editable: true,
    value: composer.fallbackLocale.value
  });
  instanceData.state.push({
    type,
    key: 'inheritLocale',
    editable: true,
    value: composer.inheritLocale
  });
  instanceData.state.push({
    type,
    key: 'messages',
    editable: false,
    value: getLocaleMessageValue(composer.messages.value)
  });
  {
    instanceData.state.push({
      type,
      key: 'datetimeFormats',
      editable: false,
      value: composer.datetimeFormats.value
    });
    instanceData.state.push({
      type,
      key: 'numberFormats',
      editable: false,
      value: composer.numberFormats.value
    });
  }
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function getLocaleMessageValue(messages) {
  const value = {};
  Object.keys(messages).forEach(key => {
    const v = messages[key];

    if (isFunction$1(v) && 'source' in v) {
      value[key] = getMessageFunctionDetails(v);
    } else if (isObject$1(v)) {
      value[key] = getLocaleMessageValue(v);
    } else {
      value[key] = v;
    }
  });
  return value;
}

const ESC = {
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  '&': '&amp;'
};

function escape(s) {
  return s.replace(/[<>"&]/g, escapeChar);
}

function escapeChar(a) {
  return ESC[a] || a;
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function getMessageFunctionDetails(func) {
  const argString = func.source ? `("${escape(func.source)}")` : `(?)`;
  return {
    _custom: {
      type: 'function',
      display: `<span>ƒ</span> ${argString}`
    }
  };
}

function registerScope(payload, i18n) {
  payload.rootNodes.push({
    id: 'global',
    label: 'Global Scope'
  }); // prettier-ignore

  const global = i18n.mode === 'composition' ? i18n.global : i18n.global.__composer;

  for (const [keyInstance, instance] of i18n.__instances) {
    // prettier-ignore
    const composer = i18n.mode === 'composition' ? instance : instance.__composer;

    if (global === composer) {
      continue;
    }

    payload.rootNodes.push({
      id: composer.id.toString(),
      label: `${getI18nScopeLable(keyInstance)} Scope`
    });
  }
}

function getComponentInstance(nodeId, i18n) {
  let instance = null;

  if (nodeId !== 'global') {
    for (const [component, composer] of i18n.__instances.entries()) {
      if (composer.id.toString() === nodeId) {
        instance = component;
        break;
      }
    }
  }

  return instance;
}

function getComposer$1(nodeId, i18n) {
  if (nodeId === 'global') {
    return i18n.mode === 'composition' ? i18n.global : i18n.global.__composer;
  } else {
    const instance = Array.from(i18n.__instances.values()).find(item => item.id.toString() === nodeId);

    if (instance) {
      return i18n.mode === 'composition' ? instance : instance.__composer;
    } else {
      return null;
    }
  }
}

function inspectScope(payload, i18n // eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
  const composer = getComposer$1(payload.nodeId, i18n);

  if (composer) {
    // TODO:
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    payload.state = makeScopeInspectState(composer);
  }

  return null;
}

function makeScopeInspectState(composer) {
  const state = {};
  const localeType = 'Locale related info';
  const localeStates = [{
    type: localeType,
    key: 'locale',
    editable: true,
    value: composer.locale.value
  }, {
    type: localeType,
    key: 'fallbackLocale',
    editable: true,
    value: composer.fallbackLocale.value
  }, {
    type: localeType,
    key: 'availableLocales',
    editable: false,
    value: composer.availableLocales
  }, {
    type: localeType,
    key: 'inheritLocale',
    editable: true,
    value: composer.inheritLocale
  }];
  state[localeType] = localeStates;
  const localeMessagesType = 'Locale messages info';
  const localeMessagesStates = [{
    type: localeMessagesType,
    key: 'messages',
    editable: false,
    value: getLocaleMessageValue(composer.messages.value)
  }];
  state[localeMessagesType] = localeMessagesStates;
  {
    const datetimeFormatsType = 'Datetime formats info';
    const datetimeFormatsStates = [{
      type: datetimeFormatsType,
      key: 'datetimeFormats',
      editable: false,
      value: composer.datetimeFormats.value
    }];
    state[datetimeFormatsType] = datetimeFormatsStates;
    const numberFormatsType = 'Datetime formats info';
    const numberFormatsStates = [{
      type: numberFormatsType,
      key: 'numberFormats',
      editable: false,
      value: composer.numberFormats.value
    }];
    state[numberFormatsType] = numberFormatsStates;
  }
  return state;
}

function addTimelineEvent(event, payload) {
  if (devtoolsApi) {
    let groupId;

    if (payload && 'groupId' in payload) {
      groupId = payload.groupId;
      delete payload.groupId;
    }

    devtoolsApi.addTimelineEvent({
      layerId: "vue-i18n-timeline"
      /* TIMELINE */
      ,
      event: {
        title: event,
        groupId,
        time: Date.now(),
        meta: {},
        data: payload || {},
        logType: event === "compile-error"
        /* COMPILE_ERROR */
        ? 'error' : event === "fallback"
        /* FALBACK */
        || event === "missing"
        /* MISSING */
        ? 'warning' : 'default'
      }
    });
  }
}

function editScope(payload, i18n) {
  const composer = getComposer$1(payload.nodeId, i18n);

  if (composer) {
    const [field] = payload.path;

    if (field === 'locale' && isString(payload.state.value)) {
      composer.locale.value = payload.state.value;
    } else if (field === 'fallbackLocale' && (isString(payload.state.value) || isArray$2(payload.state.value) || isObject$1(payload.state.value))) {
      composer.fallbackLocale.value = payload.state.value;
    } else if (field === 'inheritLocale' && isBoolean(payload.state.value)) {
      composer.inheritLocale = payload.state.value;
    }
  }
}
/**
 * Supports compatibility for legacy vue-i18n APIs
 * This mixin is used when we use vue-i18n@v9.x or later
 */


function defineMixin(vuei18n, composer, i18n) {
  return {
    beforeCreate() {
      const instance = getCurrentInstance();
      /* istanbul ignore if */

      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }

      const options = this.$options;

      if (options.i18n) {
        const optionsI18n = options.i18n;

        if (options.__i18n) {
          optionsI18n.__i18n = options.__i18n;
        }

        optionsI18n.__root = composer;

        if (this === this.$root) {
          this.$i18n = mergeToRoot(vuei18n, optionsI18n);
        } else {
          optionsI18n.__injectWithOption = true;
          this.$i18n = createVueI18n(optionsI18n);
        }
      } else if (options.__i18n) {
        if (this === this.$root) {
          this.$i18n = mergeToRoot(vuei18n, options);
        } else {
          this.$i18n = createVueI18n({
            __i18n: options.__i18n,
            __injectWithOption: true,
            __root: composer
          });
        }
      } else {
        // set global
        this.$i18n = vuei18n;
      }

      if (options.__i18nGlobal) {
        adjustI18nResources(composer, options, options);
      }

      vuei18n.__onComponentInstanceCreated(this.$i18n);

      i18n.__setInstance(instance, this.$i18n); // defines vue-i18n legacy APIs


      this.$t = (...args) => this.$i18n.t(...args);

      this.$rt = (...args) => this.$i18n.rt(...args);

      this.$tc = (...args) => this.$i18n.tc(...args);

      this.$te = (key, locale) => this.$i18n.te(key, locale);

      this.$d = (...args) => this.$i18n.d(...args);

      this.$n = (...args) => this.$i18n.n(...args);

      this.$tm = key => this.$i18n.tm(key);
    },

    mounted() {
      /* istanbul ignore if */
      if ((process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) && !false && this.$el && this.$i18n) {
        this.$el.__VUE_I18N__ = this.$i18n.__composer;
        const emitter = this.__v_emitter = createEmitter();
        const _vueI18n = this.$i18n;
        _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);
        emitter.on('*', addTimelineEvent);
      }
    },

    unmounted() {
      const instance = getCurrentInstance();
      /* istanbul ignore if */

      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      /* istanbul ignore if */


      if ((process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) && !false && this.$el && this.$el.__VUE_I18N__) {
        if (this.__v_emitter) {
          this.__v_emitter.off('*', addTimelineEvent);

          delete this.__v_emitter;
        }

        if (this.$i18n) {
          const _vueI18n = this.$i18n;
          _vueI18n.__disableEmitter && _vueI18n.__disableEmitter();
          delete this.$el.__VUE_I18N__;
        }
      }

      delete this.$t;
      delete this.$rt;
      delete this.$tc;
      delete this.$te;
      delete this.$d;
      delete this.$n;
      delete this.$tm;

      i18n.__deleteInstance(instance);

      delete this.$i18n;
    }

  };
}

function mergeToRoot(root, options) {
  root.locale = options.locale || root.locale;
  root.fallbackLocale = options.fallbackLocale || root.fallbackLocale;
  root.missing = options.missing || root.missing;
  root.silentTranslationWarn = options.silentTranslationWarn || root.silentFallbackWarn;
  root.silentFallbackWarn = options.silentFallbackWarn || root.silentFallbackWarn;
  root.formatFallbackMessages = options.formatFallbackMessages || root.formatFallbackMessages;
  root.postTranslation = options.postTranslation || root.postTranslation;
  root.warnHtmlInMessage = options.warnHtmlInMessage || root.warnHtmlInMessage;
  root.escapeParameterHtml = options.escapeParameterHtml || root.escapeParameterHtml;
  root.sync = options.sync || root.sync;

  root.__composer[SetPluralRulesSymbol](options.pluralizationRules || root.pluralizationRules);

  const messages = getLocaleMessages(root.locale, {
    messages: options.messages,
    __i18n: options.__i18n
  });
  Object.keys(messages).forEach(locale => root.mergeLocaleMessage(locale, messages[locale]));

  if (options.datetimeFormats) {
    Object.keys(options.datetimeFormats).forEach(locale => root.mergeDateTimeFormat(locale, options.datetimeFormats[locale]));
  }

  if (options.numberFormats) {
    Object.keys(options.numberFormats).forEach(locale => root.mergeNumberFormat(locale, options.numberFormats[locale]));
  }

  return root;
}
/**
 * Injection key for {@link useI18n}
 *
 * @remarks
 * The global injection key for I18n instances with `useI18n`. this injection key is used in Web Components.
 * Specify the i18n instance created by {@link createI18n} together with `provide` function.
 *
 * @VueI18nGeneral
 */


const I18nInjectionKey = /* #__PURE__*/makeSymbol('global-vue-i18n'); // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types

function createI18n$1(options = {}, VueI18nLegacy) {
  // prettier-ignore
  const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean(options.legacy) ? options.legacy : __VUE_I18N_LEGACY_API__; // prettier-ignore


  const __globalInjection = isBoolean(options.globalInjection) ? options.globalInjection : true; // prettier-ignore


  const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode ? !!options.allowComposition : true;

  const __instances = new Map();

  const [globalScope, __global] = createGlobal(options, __legacyMode);
  const symbol = makeSymbol(process.env.NODE_ENV !== 'production' ? 'vue-i18n' : '');

  function __getInstance(component) {
    return __instances.get(component) || null;
  }

  function __setInstance(component, instance) {
    __instances.set(component, instance);
  }

  function __deleteInstance(component) {
    __instances.delete(component);
  }

  {
    const i18n = {
      // mode
      get mode() {
        return __VUE_I18N_LEGACY_API__ && __legacyMode ? 'legacy' : 'composition';
      },

      // allowComposition
      get allowComposition() {
        return __allowComposition;
      },

      // install plugin
      async install(app, ...options) {
        if ((process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) && !false) {
          app.__VUE_I18N__ = i18n;
        } // setup global provider


        app.__VUE_I18N_SYMBOL__ = symbol;
        app.provide(app.__VUE_I18N_SYMBOL__, i18n); // global method and properties injection for Composition API

        if (!__legacyMode && __globalInjection) {
          injectGlobalFields(app, i18n.global);
        } // install built-in components and directive


        if (__VUE_I18N_FULL_INSTALL__) {
          apply(app, i18n, ...options);
        } // setup mixin for Legacy API


        if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
          app.mixin(defineMixin(__global, __global.__composer, i18n));
        } // release global scope


        const unmountApp = app.unmount;

        app.unmount = () => {
          i18n.dispose();
          unmountApp();
        }; // setup vue-devtools plugin


        if ((process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) && !false) {
          const ret = await enableDevTools(app, i18n);

          if (!ret) {
            throw createI18nError(I18nErrorCodes.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN);
          }

          const emitter = createEmitter();

          if (__legacyMode) {
            const _vueI18n = __global;
            _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);
          } else {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const _composer = __global;
            _composer[EnableEmitter] && _composer[EnableEmitter](emitter);
          }

          emitter.on('*', addTimelineEvent);
        }
      },

      // global accessor
      get global() {
        return __global;
      },

      dispose() {
        globalScope.stop();
      },

      // @internal
      __instances,
      // @internal
      __getInstance,
      // @internal
      __setInstance,
      // @internal
      __deleteInstance
    };
    return i18n;
  }
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function useI18n$1(options = {}) {
  const instance = getCurrentInstance();

  if (instance == null) {
    throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
  }

  if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(I18nErrorCodes.NOT_INSLALLED);
  }

  const i18n = getI18nInstance(instance);
  const global = getGlobalComposer(i18n);
  const componentOptions = getComponentOptions(instance);
  const scope = getScope$2(options, componentOptions);

  if (__VUE_I18N_LEGACY_API__) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if (i18n.mode === 'legacy' && !options.__useComponent) {
      if (!i18n.allowComposition) {
        throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
      }

      return useI18nForLegacy(instance, scope, global, options);
    }
  }

  if (scope === 'global') {
    adjustI18nResources(global, options, componentOptions);
    return global;
  }

  if (scope === 'parent') {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let composer = getComposer(i18n, instance, options.__useComponent);

    if (composer == null) {
      if (process.env.NODE_ENV !== 'production') {
        warn$1(getWarnMessage(I18nWarnCodes.NOT_FOUND_PARENT_SCOPE));
      }

      composer = global;
    }

    return composer;
  }

  const i18nInternal = i18n;

  let composer = i18nInternal.__getInstance(instance);

  if (composer == null) {
    const composerOptions = assign$1({}, options);

    if ('__i18n' in componentOptions) {
      composerOptions.__i18n = componentOptions.__i18n;
    }

    if (global) {
      composerOptions.__root = global;
    }

    composer = createComposer(composerOptions);
    setupLifeCycle(i18nInternal, instance, composer);

    i18nInternal.__setInstance(instance, composer);
  }

  return composer;
}

function createGlobal(options, legacyMode, VueI18nLegacy // eslint-disable-line @typescript-eslint/no-explicit-any
) {
  const scope = effectScope();
  {
    const obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options)) : scope.run(() => createComposer(options));

    if (obj == null) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }

    return [scope, obj];
  }
}

function getI18nInstance(instance) {
  {
    const i18n = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
    /* istanbul ignore if */

    if (!i18n) {
      throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSLALLED_WITH_PROVIDE);
    }

    return i18n;
  }
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function getScope$2(options, componentOptions) {
  // prettier-ignore
  return isEmptyObject(options) ? '__i18n' in componentOptions ? 'local' : 'global' : !options.useScope ? 'local' : options.useScope;
}

function getGlobalComposer(i18n) {
  // prettier-ignore
  return i18n.mode === 'composition' ? i18n.global : i18n.global.__composer;
}

function getComposer(i18n, target, useComponent = false) {
  let composer = null;
  const root = target.root;
  let current = target.parent;

  while (current != null) {
    const i18nInternal = i18n;

    if (i18n.mode === 'composition') {
      composer = i18nInternal.__getInstance(current);
    } else {
      if (__VUE_I18N_LEGACY_API__) {
        const vueI18n = i18nInternal.__getInstance(current);

        if (vueI18n != null) {
          composer = vueI18n.__composer;

          if (useComponent && composer && !composer[InejctWithOption] // eslint-disable-line @typescript-eslint/no-explicit-any
          ) {
            composer = null;
          }
        }
      }
    }

    if (composer != null) {
      break;
    }

    if (root === current) {
      break;
    }

    current = current.parent;
  }

  return composer;
}

function setupLifeCycle(i18n, target, composer) {
  let emitter = null;
  {
    onMounted(() => {
      // inject composer instance to DOM for intlify-devtools
      if ((process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) && !false && target.vnode.el) {
        target.vnode.el.__VUE_I18N__ = composer;
        emitter = createEmitter(); // eslint-disable-next-line @typescript-eslint/no-explicit-any

        const _composer = composer;
        _composer[EnableEmitter] && _composer[EnableEmitter](emitter);
        emitter.on('*', addTimelineEvent);
      }
    }, target);
    onUnmounted(() => {
      // remove composer instance from DOM for intlify-devtools
      if ((process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) && !false && target.vnode.el && target.vnode.el.__VUE_I18N__) {
        emitter && emitter.off('*', addTimelineEvent); // eslint-disable-next-line @typescript-eslint/no-explicit-any

        const _composer = composer;
        _composer[DisableEmitter] && _composer[DisableEmitter]();
        delete target.vnode.el.__VUE_I18N__;
      }

      i18n.__deleteInstance(target);
    }, target);
  }
}

function useI18nForLegacy(instance, scope, root, options = {} // eslint-disable-line @typescript-eslint/no-explicit-any
) {
  const isLocale = scope === 'local';

  const _composer = shallowRef(null);

  if (isLocale && instance.proxy && !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
    throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  }

  const _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;

  const _locale = ref( // prettier-ignore
  isLocale && _inheritLocale ? root.locale.value : isString(options.locale) ? options.locale : DEFAULT_LOCALE);

  const _fallbackLocale = ref( // prettier-ignore
  isLocale && _inheritLocale ? root.fallbackLocale.value : isString(options.fallbackLocale) || isArray$2(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value);

  const _messages = ref(getLocaleMessages(_locale.value, options)); // prettier-ignore


  const _datetimeFormats = ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : {
    [_locale.value]: {}
  }); // prettier-ignore


  const _numberFormats = ref(isPlainObject(options.numberFormats) ? options.numberFormats : {
    [_locale.value]: {}
  }); // prettier-ignore


  const _missingWarn = isLocale ? root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true; // prettier-ignore


  const _fallbackWarn = isLocale ? root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true; // prettier-ignore


  const _fallbackRoot = isLocale ? root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true; // configure fall back to root


  const _fallbackFormat = !!options.fallbackFormat; // runtime missing


  const _missing = isFunction$1(options.missing) ? options.missing : null; // postTranslation handler


  const _postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : null; // prettier-ignore


  const _warnHtmlMessage = isLocale ? root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;

  const _escapeParameter = !!options.escapeParameter; // prettier-ignore


  const _modifiers = isLocale ? root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {}; // pluralRules


  const _pluralRules = options.pluralRules || isLocale && root.pluralRules; // track reactivity


  function trackReactivityValues() {
    return [_locale.value, _fallbackLocale.value, _messages.value, _datetimeFormats.value, _numberFormats.value];
  } // locale


  const locale = computed({
    get: () => {
      return _composer.value ? _composer.value.locale.value : _locale.value;
    },
    set: val => {
      if (_composer.value) {
        _composer.value.locale.value = val;
      }

      _locale.value = val;
    }
  }); // fallbackLocale

  const fallbackLocale = computed({
    get: () => {
      return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
    },
    set: val => {
      if (_composer.value) {
        _composer.value.fallbackLocale.value = val;
      }

      _fallbackLocale.value = val;
    }
  }); // messages

  const messages = computed(() => {
    if (_composer.value) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return _composer.value.messages.value;
    } else {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return _messages.value;
    }
  });
  const datetimeFormats = computed(() => _datetimeFormats.value);
  const numberFormats = computed(() => _numberFormats.value);

  function getPostTranslationHandler() {
    return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
  }

  function setPostTranslationHandler(handler) {
    if (_composer.value) {
      _composer.value.setPostTranslationHandler(handler);
    }
  }

  function getMissingHandler() {
    return _composer.value ? _composer.value.getMissingHandler() : _missing;
  }

  function setMissingHandler(handler) {
    if (_composer.value) {
      _composer.value.setMissingHandler(handler);
    }
  }

  function warpWithDeps(fn) {
    trackReactivityValues();
    return fn();
  }

  function t(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => '');
  }

  function rt(...args) {
    return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : '';
  }

  function d(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => '');
  }

  function n(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => '');
  }

  function tm(key) {
    return _composer.value ? _composer.value.tm(key) : {};
  }

  function te(key, locale) {
    return _composer.value ? _composer.value.te(key, locale) : false;
  }

  function getLocaleMessage(locale) {
    return _composer.value ? _composer.value.getLocaleMessage(locale) : {};
  }

  function setLocaleMessage(locale, message) {
    if (_composer.value) {
      _composer.value.setLocaleMessage(locale, message);

      _messages.value[locale] = message;
    }
  }

  function mergeLocaleMessage(locale, message) {
    if (_composer.value) {
      _composer.value.mergeLocaleMessage(locale, message);
    }
  }

  function getDateTimeFormat(locale) {
    return _composer.value ? _composer.value.getDateTimeFormat(locale) : {};
  }

  function setDateTimeFormat(locale, format) {
    if (_composer.value) {
      _composer.value.setDateTimeFormat(locale, format);

      _datetimeFormats.value[locale] = format;
    }
  }

  function mergeDateTimeFormat(locale, format) {
    if (_composer.value) {
      _composer.value.mergeDateTimeFormat(locale, format);
    }
  }

  function getNumberFormat(locale) {
    return _composer.value ? _composer.value.getNumberFormat(locale) : {};
  }

  function setNumberFormat(locale, format) {
    if (_composer.value) {
      _composer.value.setNumberFormat(locale, format);

      _numberFormats.value[locale] = format;
    }
  }

  function mergeNumberFormat(locale, format) {
    if (_composer.value) {
      _composer.value.mergeNumberFormat(locale, format);
    }
  }

  const wrapper = {
    get id() {
      return _composer.value ? _composer.value.id : -1;
    },

    locale,
    fallbackLocale,
    messages,
    datetimeFormats,
    numberFormats,

    get inheritLocale() {
      return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
    },

    set inheritLocale(val) {
      if (_composer.value) {
        _composer.value.inheritLocale = val;
      }
    },

    get availableLocales() {
      return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
    },

    get modifiers() {
      return _composer.value ? _composer.value.modifiers : _modifiers;
    },

    get pluralRules() {
      return _composer.value ? _composer.value.pluralRules : _pluralRules;
    },

    get isGlobal() {
      return _composer.value ? _composer.value.isGlobal : false;
    },

    get missingWarn() {
      return _composer.value ? _composer.value.missingWarn : _missingWarn;
    },

    set missingWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },

    get fallbackWarn() {
      return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
    },

    set fallbackWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },

    get fallbackRoot() {
      return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
    },

    set fallbackRoot(val) {
      if (_composer.value) {
        _composer.value.fallbackRoot = val;
      }
    },

    get fallbackFormat() {
      return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
    },

    set fallbackFormat(val) {
      if (_composer.value) {
        _composer.value.fallbackFormat = val;
      }
    },

    get warnHtmlMessage() {
      return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
    },

    set warnHtmlMessage(val) {
      if (_composer.value) {
        _composer.value.warnHtmlMessage = val;
      }
    },

    get escapeParameter() {
      return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
    },

    set escapeParameter(val) {
      if (_composer.value) {
        _composer.value.escapeParameter = val;
      }
    },

    t,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    rt,
    d,
    n,
    tm,
    te,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getDateTimeFormat,
    setDateTimeFormat,
    mergeDateTimeFormat,
    getNumberFormat,
    setNumberFormat,
    mergeNumberFormat
  };

  function sync(composer) {
    composer.locale.value = _locale.value;
    composer.fallbackLocale.value = _fallbackLocale.value;
    Object.keys(_messages.value).forEach(locale => {
      composer.mergeLocaleMessage(locale, _messages.value[locale]);
    });
    Object.keys(_datetimeFormats.value).forEach(locale => {
      composer.mergeDateTimeFormat(locale, _datetimeFormats.value[locale]);
    });
    Object.keys(_numberFormats.value).forEach(locale => {
      composer.mergeNumberFormat(locale, _numberFormats.value[locale]);
    });
    composer.escapeParameter = _escapeParameter;
    composer.fallbackFormat = _fallbackFormat;
    composer.fallbackRoot = _fallbackRoot;
    composer.fallbackWarn = _fallbackWarn;
    composer.missingWarn = _missingWarn;
    composer.warnHtmlMessage = _warnHtmlMessage;
  }

  onBeforeMount(() => {
    if (instance.proxy == null || instance.proxy.$i18n == null) {
      throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    } // eslint-disable-next-line @typescript-eslint/no-explicit-any


    const composer = _composer.value = instance.proxy.$i18n.__composer;

    if (scope === 'global') {
      _locale.value = composer.locale.value;
      _fallbackLocale.value = composer.fallbackLocale.value;
      _messages.value = composer.messages.value;
      _datetimeFormats.value = composer.datetimeFormats.value;
      _numberFormats.value = composer.numberFormats.value;
    } else if (isLocale) {
      sync(composer);
    }
  });
  return wrapper;
}

const globalExportProps = ['locale', 'fallbackLocale', 'availableLocales'];
const globalExportMethods = ['t', 'rt', 'd', 'n', 'tm'];

function injectGlobalFields(app, composer) {
  const i18n = Object.create(null);
  globalExportProps.forEach(prop => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop);

    if (!desc) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }

    const wrap = isRef(desc.value) // check computed props
    ? {
      get() {
        return desc.value.value;
      },

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(val) {
        desc.value.value = val;
      }

    } : {
      get() {
        return desc.get && desc.get();
      }

    };
    Object.defineProperty(i18n, prop, wrap);
  });
  app.config.globalProperties.$i18n = i18n;
  globalExportMethods.forEach(method => {
    const desc = Object.getOwnPropertyDescriptor(composer, method);

    if (!desc || !desc.value) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }

    Object.defineProperty(app.config.globalProperties, `$${method}`, desc);
  });
} // register message compiler at vue-i18n


registerMessageCompiler(compileToFunction); // register message resolver at vue-i18n

registerMessageResolver(resolveValue); // register fallback locale at vue-i18n

registerLocaleFallbacker(fallbackWithLocaleChain);
{
  initFeatureFlags();
} // NOTE: experimental !!

if (process.env.NODE_ENV !== 'production' || __INTLIFY_PROD_DEVTOOLS__) {
  const target = getGlobalThis();
  target.__INTLIFY__ = true;
  setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}

if (process.env.NODE_ENV !== 'production') ;

let i18n;
function createI18n(options) {
  const dateTimeFormats = {
    'en': {
      short: {
        year: 'numeric',
        day: 'numeric',
        month: 'short',
        timeZone: 'GMT'
      },
      long: {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        weekday: 'long',
        hour: 'numeric',
        minute: 'numeric',
        timeZone: 'GMT'
      }
    }
  };
  let messages = options.i18n && options.i18n.messages ? options.i18n.messages : {};
  i18n = createI18n$1({
    locale: 'en',
    messages,
    silentTranslationWarn: true,
    legacy: false,
    dateTimeFormats
  });
  return i18n;
}
function useI18n() {
  return i18n;
}
function t(key) {
  return i18n.global.t(key);
}
function te(key) {
  return i18n.global.te(key);
}

var DomHandler = {
  innerWidth(el) {
    if (el) {
      let width = el.offsetWidth;
      let style = getComputedStyle(el);
      width += parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
      return width;
    }

    return 0;
  },

  width(el) {
    if (el) {
      let width = el.offsetWidth;
      let style = getComputedStyle(el);
      width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
      return width;
    }

    return 0;
  },

  getWindowScrollTop() {
    let doc = document.documentElement;
    return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
  },

  getWindowScrollLeft() {
    let doc = document.documentElement;
    return (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
  },

  getOuterWidth(el, margin) {
    if (el) {
      let width = el.offsetWidth;

      if (margin) {
        let style = getComputedStyle(el);
        width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);
      }

      return width;
    }

    return 0;
  },

  getOuterHeight(el, margin) {
    if (el) {
      let height = el.offsetHeight;

      if (margin) {
        let style = getComputedStyle(el);
        height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);
      }

      return height;
    }

    return 0;
  },

  getClientHeight(el, margin) {
    if (el) {
      let height = el.clientHeight;

      if (margin) {
        let style = getComputedStyle(el);
        height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);
      }

      return height;
    }

    return 0;
  },

  getViewport() {
    let win = window,
        d = document,
        e = d.documentElement,
        g = d.getElementsByTagName('body')[0],
        w = win.innerWidth || e.clientWidth || g.clientWidth,
        h = win.innerHeight || e.clientHeight || g.clientHeight;
    return {
      width: w,
      height: h
    };
  },

  getOffset(el) {
    if (el) {
      let rect = el.getBoundingClientRect();
      return {
        top: rect.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),
        left: rect.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0)
      };
    }

    return {
      top: 'auto',
      left: 'auto'
    };
  },

  index(element) {
    if (element) {
      let children = element.parentNode.childNodes;
      let num = 0;

      for (let i = 0; i < children.length; i++) {
        if (children[i] === element) return num;
        if (children[i].nodeType === 1) num++;
      }
    }

    return -1;
  },

  addMultipleClasses(element, className) {
    if (element && className) {
      if (element.classList) {
        let styles = className.split(' ');

        for (let i = 0; i < styles.length; i++) {
          element.classList.add(styles[i]);
        }
      } else {
        let styles = className.split(' ');

        for (let i = 0; i < styles.length; i++) {
          element.className += ' ' + styles[i];
        }
      }
    }
  },

  addClass(element, className) {
    if (element && className) {
      if (element.classList) element.classList.add(className);else element.className += ' ' + className;
    }
  },

  removeClass(element, className) {
    if (element && className) {
      if (element.classList) element.classList.remove(className);else element.className = element.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
    }
  },

  hasClass(element, className) {
    if (element) {
      if (element.classList) return element.classList.contains(className);else return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);
    }

    return false;
  },

  find(element, selector) {
    return element ? element.querySelectorAll(selector) : [];
  },

  findSingle(element, selector) {
    if (element) {
      return element.querySelector(selector);
    }

    return null;
  },

  getHeight(el) {
    if (el) {
      let height = el.offsetHeight;
      let style = getComputedStyle(el);
      height -= parseFloat(style.paddingTop) + parseFloat(style.paddingBottom) + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
      return height;
    }

    return 0;
  },

  getWidth(el) {
    if (el) {
      let width = el.offsetWidth;
      let style = getComputedStyle(el);
      width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) + parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
      return width;
    }

    return 0;
  },

  absolutePosition(element, target) {
    if (element) {
      let elementDimensions = element.offsetParent ? {
        width: element.offsetWidth,
        height: element.offsetHeight
      } : this.getHiddenElementDimensions(element);
      let elementOuterHeight = elementDimensions.height;
      let elementOuterWidth = elementDimensions.width;
      let targetOuterHeight = target.offsetHeight;
      let targetOuterWidth = target.offsetWidth;
      let targetOffset = target.getBoundingClientRect();
      let windowScrollTop = this.getWindowScrollTop();
      let windowScrollLeft = this.getWindowScrollLeft();
      let viewport = this.getViewport();
      let top, left;

      if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {
        top = targetOffset.top + windowScrollTop - elementOuterHeight;
        element.style.transformOrigin = 'bottom';

        if (top < 0) {
          top = windowScrollTop;
        }
      } else {
        top = targetOuterHeight + targetOffset.top + windowScrollTop;
        element.style.transformOrigin = 'top';
      }

      if (targetOffset.left + elementOuterWidth > viewport.width) left = Math.max(0, targetOffset.left + windowScrollLeft + targetOuterWidth - elementOuterWidth);else left = targetOffset.left + windowScrollLeft;
      element.style.top = top + 'px';
      element.style.left = left + 'px';
    }
  },

  relativePosition(element, target) {
    if (element) {
      let elementDimensions = element.offsetParent ? {
        width: element.offsetWidth,
        height: element.offsetHeight
      } : this.getHiddenElementDimensions(element);
      const targetHeight = target.offsetHeight;
      const targetOffset = target.getBoundingClientRect();
      const viewport = this.getViewport();
      let top, left;

      if (targetOffset.top + targetHeight + elementDimensions.height > viewport.height) {
        top = -1 * elementDimensions.height;
        element.style.transformOrigin = 'bottom';

        if (targetOffset.top + top < 0) {
          top = -1 * targetOffset.top;
        }
      } else {
        top = targetHeight;
        element.style.transformOrigin = 'top';
      }

      if (elementDimensions.width > viewport.width) {
        // element wider then viewport and cannot fit on screen (align at left side of viewport)
        left = targetOffset.left * -1;
      } else if (targetOffset.left + elementDimensions.width > viewport.width) {
        // element wider then viewport but can be fit on screen (align at right side of viewport)
        left = (targetOffset.left + elementDimensions.width - viewport.width) * -1;
      } else {
        // element fits on screen (align with target)
        left = 0;
      }

      element.style.top = top + 'px';
      element.style.left = left + 'px';
    }
  },

  getParents(element, parents = []) {
    return element['parentNode'] === null ? parents : this.getParents(element.parentNode, parents.concat([element.parentNode]));
  },

  getScrollableParents(element) {
    let scrollableParents = [];

    if (element) {
      let parents = this.getParents(element);
      const overflowRegex = /(auto|scroll)/;

      const overflowCheck = node => {
        let styleDeclaration = window['getComputedStyle'](node, null);
        return overflowRegex.test(styleDeclaration.getPropertyValue('overflow')) || overflowRegex.test(styleDeclaration.getPropertyValue('overflowX')) || overflowRegex.test(styleDeclaration.getPropertyValue('overflowY'));
      };

      for (let parent of parents) {
        let scrollSelectors = parent.nodeType === 1 && parent.dataset['scrollselectors'];

        if (scrollSelectors) {
          let selectors = scrollSelectors.split(',');

          for (let selector of selectors) {
            let el = this.findSingle(parent, selector);

            if (el && overflowCheck(el)) {
              scrollableParents.push(el);
            }
          }
        }

        if (parent.nodeType !== 9 && overflowCheck(parent)) {
          scrollableParents.push(parent);
        }
      }
    }

    return scrollableParents;
  },

  getHiddenElementOuterHeight(element) {
    if (element) {
      element.style.visibility = 'hidden';
      element.style.display = 'block';
      let elementHeight = element.offsetHeight;
      element.style.display = 'none';
      element.style.visibility = 'visible';
      return elementHeight;
    }

    return 0;
  },

  getHiddenElementOuterWidth(element) {
    if (element) {
      element.style.visibility = 'hidden';
      element.style.display = 'block';
      let elementWidth = element.offsetWidth;
      element.style.display = 'none';
      element.style.visibility = 'visible';
      return elementWidth;
    }

    return 0;
  },

  getHiddenElementDimensions(element) {
    if (element) {
      let dimensions = {};
      element.style.visibility = 'hidden';
      element.style.display = 'block';
      dimensions.width = element.offsetWidth;
      dimensions.height = element.offsetHeight;
      element.style.display = 'none';
      element.style.visibility = 'visible';
      return dimensions;
    }

    return 0;
  },

  fadeIn(element, duration) {
    if (element) {
      element.style.opacity = 0;
      let last = +new Date();
      let opacity = 0;

      let tick = function () {
        opacity = +element.style.opacity + (new Date().getTime() - last) / duration;
        element.style.opacity = opacity;
        last = +new Date();

        if (+opacity < 1) {
          window.requestAnimationFrame && requestAnimationFrame(tick) || setTimeout(tick, 16);
        }
      };

      tick();
    }
  },

  fadeOut(element, ms) {
    if (element) {
      let opacity = 1,
          interval = 50,
          duration = ms,
          gap = interval / duration;
      let fading = setInterval(() => {
        opacity -= gap;

        if (opacity <= 0) {
          opacity = 0;
          clearInterval(fading);
        }

        element.style.opacity = opacity;
      }, interval);
    }
  },

  getUserAgent() {
    return navigator.userAgent;
  },

  appendChild(element, target) {
    if (this.isElement(target)) target.appendChild(element);else if (target.el && target.elElement) target.elElement.appendChild(element);else throw new Error('Cannot append ' + target + ' to ' + element);
  },

  scrollInView(container, item) {
    let borderTopValue = getComputedStyle(container).getPropertyValue('borderTopWidth');
    let borderTop = borderTopValue ? parseFloat(borderTopValue) : 0;
    let paddingTopValue = getComputedStyle(container).getPropertyValue('paddingTop');
    let paddingTop = paddingTopValue ? parseFloat(paddingTopValue) : 0;
    let containerRect = container.getBoundingClientRect();
    let itemRect = item.getBoundingClientRect();
    let offset = itemRect.top + document.body.scrollTop - (containerRect.top + document.body.scrollTop) - borderTop - paddingTop;
    let scroll = container.scrollTop;
    let elementHeight = container.clientHeight;
    let itemHeight = this.getOuterHeight(item);

    if (offset < 0) {
      container.scrollTop = scroll + offset;
    } else if (offset + itemHeight > elementHeight) {
      container.scrollTop = scroll + offset - elementHeight + itemHeight;
    }
  },

  clearSelection() {
    if (window.getSelection) {
      if (window.getSelection().empty) {
        window.getSelection().empty();
      } else if (window.getSelection().removeAllRanges && window.getSelection().rangeCount > 0 && window.getSelection().getRangeAt(0).getClientRects().length > 0) {
        window.getSelection().removeAllRanges();
      }
    } else if (document['selection'] && document['selection'].empty) {
      try {
        document['selection'].empty();
      } catch (error) {//ignore IE bug
      }
    }
  },

  getSelection() {
    if (window.getSelection) return window.getSelection().toString();else if (document.getSelection) return document.getSelection().toString();else if (document['selection']) return document['selection'].createRange().text;
    return null;
  },

  calculateScrollbarWidth() {
    if (this.calculatedScrollbarWidth != null) return this.calculatedScrollbarWidth;
    let scrollDiv = document.createElement('div');
    scrollDiv.className = 'p-scrollbar-measure';
    document.body.appendChild(scrollDiv);
    let scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    document.body.removeChild(scrollDiv);
    this.calculatedScrollbarWidth = scrollbarWidth;
    return scrollbarWidth;
  },

  getBrowser() {
    if (!this.browser) {
      let matched = this.resolveUserAgent();
      this.browser = {};

      if (matched.browser) {
        this.browser[matched.browser] = true;
        this.browser['version'] = matched.version;
      }

      if (this.browser['chrome']) {
        this.browser['webkit'] = true;
      } else if (this.browser['webkit']) {
        this.browser['safari'] = true;
      }
    }

    return this.browser;
  },

  resolveUserAgent() {
    let ua = navigator.userAgent.toLowerCase();
    let match = /(chrome)[ ]([\w.]+)/.exec(ua) || /(webkit)[ ]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ ]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
    return {
      browser: match[1] || '',
      version: match[2] || '0'
    };
  },

  isVisible(element) {
    return element && element.offsetParent != null;
  },

  invokeElementMethod(element, methodName, args) {
    element[methodName].apply(element, args);
  },

  isExist(element) {
    return element !== null && typeof element !== 'undefined' && element.nodeName && element.parentNode;
  },

  isClient() {
    return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
  },

  focus(el, options) {
    el && document.activeElement !== el && el.focus(options);
  },

  getFocusableElements(element, selector = '') {
    let focusableElements = this.find(element, `button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
                [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
                input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
                select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
                textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
                [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector},
                [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${selector}`);
    let visibleFocusableElements = [];

    for (let focusableElement of focusableElements) {
      if (getComputedStyle(focusableElement).display != 'none' && getComputedStyle(focusableElement).visibility != 'hidden') visibleFocusableElements.push(focusableElement);
    }

    return visibleFocusableElements;
  },

  getFirstFocusableElement(element, selector) {
    const focusableElements = this.getFocusableElements(element, selector);
    return focusableElements.length > 0 ? focusableElements[0] : null;
  },

  getLastFocusableElement(element, selector) {
    const focusableElements = this.getFocusableElements(element, selector);
    return focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : null;
  },

  isClickable(element) {
    const targetNode = element.nodeName;
    const parentNode = element.parentElement && element.parentElement.nodeName;
    return targetNode == 'INPUT' || targetNode == 'BUTTON' || targetNode == 'A' || parentNode == 'INPUT' || parentNode == 'BUTTON' || parentNode == 'A' || this.hasClass(element, 'p-button') || this.hasClass(element.parentElement, 'p-button') || this.hasClass(element.parentElement, 'p-checkbox') || this.hasClass(element.parentElement, 'p-radiobutton');
  },

  applyStyle(element, style) {
    if (typeof style === 'string') {
      element.style.cssText = style;
    } else {
      for (let prop in style) {
        element.style[prop] = style[prop];
      }
    }
  },

  isIOS() {
    return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window['MSStream'];
  },

  isAndroid() {
    return /(android)/i.test(navigator.userAgent);
  },

  isTouchDevice() {
    return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
  },

  exportCSV(csv, filename) {
    let blob = new Blob([csv], {
      type: 'application/csv;charset=utf-8;'
    });

    if (window.navigator.msSaveOrOpenBlob) {
      navigator.msSaveOrOpenBlob(blob, filename + '.csv');
    } else {
      let link = document.createElement('a');

      if (link.download !== undefined) {
        link.setAttribute('href', URL.createObjectURL(blob));
        link.setAttribute('download', filename + '.csv');
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      } else {
        csv = 'data:text/csv;charset=utf-8,' + csv;
        window.open(encodeURI(csv));
      }
    }
  }

};

class ConnectedOverlayScrollHandler {
  constructor(element, listener = () => {}) {
    this.element = element;
    this.listener = listener;
  }

  bindScrollListener() {
    this.scrollableParents = DomHandler.getScrollableParents(this.element);

    for (let i = 0; i < this.scrollableParents.length; i++) {
      this.scrollableParents[i].addEventListener('scroll', this.listener);
    }
  }

  unbindScrollListener() {
    if (this.scrollableParents) {
      for (let i = 0; i < this.scrollableParents.length; i++) {
        this.scrollableParents[i].removeEventListener('scroll', this.listener);
      }
    }
  }

  destroy() {
    this.unbindScrollListener();
    this.element = null;
    this.listener = null;
    this.scrollableParents = null;
  }

}

var ObjectUtils = {
  equals(obj1, obj2, field) {
    if (field) return this.resolveFieldData(obj1, field) === this.resolveFieldData(obj2, field);else return this.deepEquals(obj1, obj2);
  },

  deepEquals(a, b) {
    if (a === b) return true;

    if (a && b && typeof a == 'object' && typeof b == 'object') {
      var arrA = Array.isArray(a),
          arrB = Array.isArray(b),
          i,
          length,
          key;

      if (arrA && arrB) {
        length = a.length;
        if (length != b.length) return false;

        for (i = length; i-- !== 0;) if (!this.deepEquals(a[i], b[i])) return false;

        return true;
      }

      if (arrA != arrB) return false;
      var dateA = a instanceof Date,
          dateB = b instanceof Date;
      if (dateA != dateB) return false;
      if (dateA && dateB) return a.getTime() == b.getTime();
      var regexpA = a instanceof RegExp,
          regexpB = b instanceof RegExp;
      if (regexpA != regexpB) return false;
      if (regexpA && regexpB) return a.toString() == b.toString();
      var keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) return false;

      for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

      for (i = length; i-- !== 0;) {
        key = keys[i];
        if (!this.deepEquals(a[key], b[key])) return false;
      }

      return true;
    }

    return a !== a && b !== b;
  },

  resolveFieldData(data, field) {
    if (data && Object.keys(data).length && field) {
      if (this.isFunction(field)) {
        return field(data);
      } else if (field.indexOf('.') === -1) {
        return data[field];
      } else {
        let fields = field.split('.');
        let value = data;

        for (var i = 0, len = fields.length; i < len; ++i) {
          if (value == null) {
            return null;
          }

          value = value[fields[i]];
        }

        return value;
      }
    } else {
      return null;
    }
  },

  isFunction(obj) {
    return !!(obj && obj.constructor && obj.call && obj.apply);
  },

  getItemValue(obj, ...params) {
    return this.isFunction(obj) ? obj(...params) : obj;
  },

  filter(value, fields, filterValue) {
    var filteredItems = [];

    if (value) {
      for (let item of value) {
        for (let field of fields) {
          if (String(this.resolveFieldData(item, field)).toLowerCase().indexOf(filterValue.toLowerCase()) > -1) {
            filteredItems.push(item);
            break;
          }
        }
      }
    }

    return filteredItems;
  },

  reorderArray(value, from, to) {
    let target;

    if (value && from !== to) {
      if (to >= value.length) {
        target = to - value.length;

        while (target-- + 1) {
          value.push(undefined);
        }
      }

      value.splice(to, 0, value.splice(from, 1)[0]);
    }
  },

  findIndexInList(value, list) {
    let index = -1;

    if (list) {
      for (let i = 0; i < list.length; i++) {
        if (list[i] === value) {
          index = i;
          break;
        }
      }
    }

    return index;
  },

  contains(value, list) {
    if (value != null && list && list.length) {
      for (let val of list) {
        if (this.equals(value, val)) return true;
      }
    }

    return false;
  },

  insertIntoOrderedArray(item, index, arr, sourceArr) {
    if (arr.length > 0) {
      let injected = false;

      for (let i = 0; i < arr.length; i++) {
        let currentItemIndex = this.findIndexInList(arr[i], sourceArr);

        if (currentItemIndex > index) {
          arr.splice(i, 0, item);
          injected = true;
          break;
        }
      }

      if (!injected) {
        arr.push(item);
      }
    } else {
      arr.push(item);
    }
  },

  removeAccents(str) {
    if (str && str.search(/[\xC0-\xFF]/g) > -1) {
      str = str.replace(/[\xC0-\xC5]/g, 'A').replace(/[\xC6]/g, 'AE').replace(/[\xC7]/g, 'C').replace(/[\xC8-\xCB]/g, 'E').replace(/[\xCC-\xCF]/g, 'I').replace(/[\xD0]/g, 'D').replace(/[\xD1]/g, 'N').replace(/[\xD2-\xD6\xD8]/g, 'O').replace(/[\xD9-\xDC]/g, 'U').replace(/[\xDD]/g, 'Y').replace(/[\xDE]/g, 'P').replace(/[\xE0-\xE5]/g, 'a').replace(/[\xE6]/g, 'ae').replace(/[\xE7]/g, 'c').replace(/[\xE8-\xEB]/g, 'e').replace(/[\xEC-\xEF]/g, 'i').replace(/[\xF1]/g, 'n').replace(/[\xF2-\xF6\xF8]/g, 'o').replace(/[\xF9-\xFC]/g, 'u').replace(/[\xFE]/g, 'p').replace(/[\xFD\xFF]/g, 'y');
    }

    return str;
  },

  getVNodeProp(vnode, prop) {
    let props = vnode.props;

    if (props) {
      let kebapProp = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
      let propName = Object.prototype.hasOwnProperty.call(props, kebapProp) ? kebapProp : prop;
      return vnode.type.props[prop].type === Boolean && props[propName] === '' ? true : props[propName];
    }

    return null;
  },

  isEmpty(value) {
    return value === null || value === undefined || value === '' || Array.isArray(value) && value.length === 0 || !(value instanceof Date) && typeof value === 'object' && Object.keys(value).length === 0;
  },

  isNotEmpty(value) {
    return !this.isEmpty(value);
  },

  isPrintableCharacter(char = '') {
    return this.isNotEmpty(char) && char.length === 1 && char.match(/\S| /);
  },

  /**
   * Firefox-v103 does not currently support the "findLast" method. It is stated that this method will be supported with Firefox-v104.
   * https://caniuse.com/mdn-javascript_builtins_array_findlast
   */
  findLast(arr, callback) {
    let item;

    if (this.isNotEmpty(arr)) {
      try {
        item = arr.findLast(callback);
      } catch {
        item = [...arr].reverse().find(callback);
      }
    }

    return item;
  },

  /**
   * Firefox-v103 does not currently support the "findLastIndex" method. It is stated that this method will be supported with Firefox-v104.
   * https://caniuse.com/mdn-javascript_builtins_array_findlastindex
   */
  findLastIndex(arr, callback) {
    let index = -1;

    if (this.isNotEmpty(arr)) {
      try {
        index = arr.findLastIndex(callback);
      } catch {
        index = arr.lastIndexOf([...arr].reverse().find(callback));
      }
    }

    return index;
  }

};

function handler() {
  let zIndexes = [];

  const generateZIndex = (key, baseZIndex) => {
    let lastZIndex = zIndexes.length > 0 ? zIndexes[zIndexes.length - 1] : {
      key,
      value: baseZIndex
    };
    let newZIndex = lastZIndex.value + (lastZIndex.key === key ? 0 : baseZIndex) + 1;
    zIndexes.push({
      key,
      value: newZIndex
    });
    return newZIndex;
  };

  const revertZIndex = zIndex => {
    zIndexes = zIndexes.filter(obj => obj.value !== zIndex);
  };

  const getCurrentZIndex = () => {
    return zIndexes.length > 0 ? zIndexes[zIndexes.length - 1].value : 0;
  };

  const getZIndex = el => {
    return el ? parseInt(el.style.zIndex, 10) || 0 : 0;
  };

  return {
    get: getZIndex,
    set: (key, el, baseZIndex) => {
      if (el) {
        el.style.zIndex = String(generateZIndex(key, baseZIndex));
      }
    },
    clear: el => {
      if (el) {
        revertZIndex(getZIndex(el));
        el.style.zIndex = '';
      }
    },
    getCurrent: () => getCurrentZIndex()
  };
}

var ZIndexUtils = handler();
var lastId = 0;

function UniqueComponentId(prefix = 'pv_id_') {
  lastId++;
  return `${prefix}${lastId}`;
}

function primebus() {
  const allHandlers = new Map();
  return {
    on(type, handler) {
      let handlers = allHandlers.get(type);
      if (!handlers) handlers = [handler];else handlers.push(handler);
      allHandlers.set(type, handlers);
    },

    off(type, handler) {
      let handlers = allHandlers.get(type);

      if (handlers) {
        handlers.splice(handlers.indexOf(handler) >>> 0, 1);
      }
    },

    emit(type, evt) {
      let handlers = allHandlers.get(type);

      if (handlers) {
        handlers.slice().map(handler => {
          handler(evt);
        });
      }
    }

  };
}

const FilterMatchMode = {
  STARTS_WITH: 'startsWith',
  CONTAINS: 'contains',
  NOT_CONTAINS: 'notContains',
  ENDS_WITH: 'endsWith',
  EQUALS: 'equals',
  NOT_EQUALS: 'notEquals',
  IN: 'in',
  LESS_THAN: 'lt',
  LESS_THAN_OR_EQUAL_TO: 'lte',
  GREATER_THAN: 'gt',
  GREATER_THAN_OR_EQUAL_TO: 'gte',
  BETWEEN: 'between',
  DATE_IS: 'dateIs',
  DATE_IS_NOT: 'dateIsNot',
  DATE_BEFORE: 'dateBefore',
  DATE_AFTER: 'dateAfter'
};
const FilterOperator = {
  AND: 'and',
  OR: 'or'
};
const FilterService = {
  filter(value, fields, filterValue, filterMatchMode, filterLocale) {
    let filteredItems = [];

    if (value) {
      for (let item of value) {
        for (let field of fields) {
          let fieldValue = ObjectUtils.resolveFieldData(item, field);

          if (this.filters[filterMatchMode](fieldValue, filterValue, filterLocale)) {
            filteredItems.push(item);
            break;
          }
        }
      }
    }

    return filteredItems;
  },

  filters: {
    startsWith(value, filter, filterLocale) {
      if (filter === undefined || filter === null || filter.trim() === '') {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      let filterValue = ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);
      let stringValue = ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.slice(0, filterValue.length) === filterValue;
    },

    contains(value, filter, filterLocale) {
      if (filter === undefined || filter === null || typeof filter === 'string' && filter.trim() === '') {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      let filterValue = ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);
      let stringValue = ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.indexOf(filterValue) !== -1;
    },

    notContains(value, filter, filterLocale) {
      if (filter === undefined || filter === null || typeof filter === 'string' && filter.trim() === '') {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      let filterValue = ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);
      let stringValue = ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.indexOf(filterValue) === -1;
    },

    endsWith(value, filter, filterLocale) {
      if (filter === undefined || filter === null || filter.trim() === '') {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      let filterValue = ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);
      let stringValue = ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale);
      return stringValue.indexOf(filterValue, stringValue.length - filterValue.length) !== -1;
    },

    equals(value, filter, filterLocale) {
      if (filter === undefined || filter === null || typeof filter === 'string' && filter.trim() === '') {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      if (value.getTime && filter.getTime) return value.getTime() === filter.getTime();else return ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale) == ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);
    },

    notEquals(value, filter, filterLocale) {
      if (filter === undefined || filter === null || typeof filter === 'string' && filter.trim() === '') {
        return false;
      }

      if (value === undefined || value === null) {
        return true;
      }

      if (value.getTime && filter.getTime) return value.getTime() !== filter.getTime();else return ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale) != ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);
    },

    in(value, filter) {
      if (filter === undefined || filter === null || filter.length === 0) {
        return true;
      }

      for (let i = 0; i < filter.length; i++) {
        if (ObjectUtils.equals(value, filter[i])) {
          return true;
        }
      }

      return false;
    },

    between(value, filter) {
      if (filter == null || filter[0] == null || filter[1] == null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      if (value.getTime) return filter[0].getTime() <= value.getTime() && value.getTime() <= filter[1].getTime();else return filter[0] <= value && value <= filter[1];
    },

    lt(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      if (value.getTime && filter.getTime) return value.getTime() < filter.getTime();else return value < filter;
    },

    lte(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      if (value.getTime && filter.getTime) return value.getTime() <= filter.getTime();else return value <= filter;
    },

    gt(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      if (value.getTime && filter.getTime) return value.getTime() > filter.getTime();else return value > filter;
    },

    gte(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      if (value.getTime && filter.getTime) return value.getTime() >= filter.getTime();else return value >= filter;
    },

    dateIs(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      return value.toDateString() === filter.toDateString();
    },

    dateIsNot(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      return value.toDateString() !== filter.toDateString();
    },

    dateBefore(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      return value.getTime() < filter.getTime();
    },

    dateAfter(value, filter) {
      if (filter === undefined || filter === null) {
        return true;
      }

      if (value === undefined || value === null) {
        return false;
      }

      return value.getTime() > filter.getTime();
    }

  },

  register(rule, fn) {
    this.filters[rule] = fn;
  }

};

const defaultOptions = {
  ripple: false,
  inputStyle: 'outlined',
  locale: {
    startsWith: 'Starts with',
    contains: 'Contains',
    notContains: 'Not contains',
    endsWith: 'Ends with',
    equals: 'Equals',
    notEquals: 'Not equals',
    noFilter: 'No Filter',
    lt: 'Less than',
    lte: 'Less than or equal to',
    gt: 'Greater than',
    gte: 'Greater than or equal to',
    dateIs: 'Date is',
    dateIsNot: 'Date is not',
    dateBefore: 'Date is before',
    dateAfter: 'Date is after',
    clear: 'Clear',
    apply: 'Apply',
    matchAll: 'Match All',
    matchAny: 'Match Any',
    addRule: 'Add Rule',
    removeRule: 'Remove Rule',
    accept: 'Yes',
    reject: 'No',
    choose: 'Choose',
    upload: 'Upload',
    cancel: 'Cancel',
    completed: 'Completed',
    pending: 'Pending',
    dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
    monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    chooseYear: 'Choose Year',
    chooseMonth: 'Choose Month',
    chooseDate: 'Choose Date',
    prevDecade: 'Previous Decade',
    nextDecade: 'Next Decade',
    prevYear: 'Previous Year',
    nextYear: 'Next Year',
    prevMonth: 'Previous Month',
    nextMonth: 'Next Month',
    prevHour: 'Previous Hour',
    nextHour: 'Next Hour',
    prevMinute: 'Previous Minute',
    nextMinute: 'Next Minute',
    prevSecond: 'Previous Second',
    nextSecond: 'Next Second',
    am: 'am',
    pm: 'pm',
    today: 'Today',
    weekHeader: 'Wk',
    firstDayOfWeek: 0,
    dateFormat: 'mm/dd/yy',
    weak: 'Weak',
    medium: 'Medium',
    strong: 'Strong',
    passwordPrompt: 'Enter a password',
    emptyFilterMessage: 'No results found',
    // @deprecated Use 'emptySearchMessage' option instead.
    searchMessage: '{0} results are available',
    selectionMessage: '{0} items selected',
    emptySelectionMessage: 'No selected item',
    emptySearchMessage: 'No results found',
    emptyMessage: 'No available options',
    aria: {
      trueLabel: 'True',
      falseLabel: 'False',
      nullLabel: 'Not Selected',
      star: '1 star',
      stars: '{star} stars',
      selectAll: 'All items selected',
      unselectAll: 'All items unselected',
      close: 'Close',
      previous: 'Previous',
      next: 'Next',
      navigation: 'Navigation'
    }
  },
  filterMatchModeOptions: {
    text: [FilterMatchMode.STARTS_WITH, FilterMatchMode.CONTAINS, FilterMatchMode.NOT_CONTAINS, FilterMatchMode.ENDS_WITH, FilterMatchMode.EQUALS, FilterMatchMode.NOT_EQUALS],
    numeric: [FilterMatchMode.EQUALS, FilterMatchMode.NOT_EQUALS, FilterMatchMode.LESS_THAN, FilterMatchMode.LESS_THAN_OR_EQUAL_TO, FilterMatchMode.GREATER_THAN, FilterMatchMode.GREATER_THAN_OR_EQUAL_TO],
    date: [FilterMatchMode.DATE_IS, FilterMatchMode.DATE_IS_NOT, FilterMatchMode.DATE_BEFORE, FilterMatchMode.DATE_AFTER]
  },
  zIndex: {
    modal: 1100,
    overlay: 1000,
    menu: 1000,
    tooltip: 1100
  }
};
const PrimeVueSymbol = Symbol();

var PrimeVue = {
  install: (app, options) => {
    let configOptions = options ? { ...defaultOptions,
      ...options
    } : { ...defaultOptions
    };
    const PrimeVue = {
      config: reactive(configOptions)
    };
    app.config.globalProperties.$primevue = PrimeVue;
    app.provide(PrimeVueSymbol, PrimeVue);
  }
};

let _configs = {};
function initConfigs(configs) {
  if (!configs.profile) {
    throw "Profile must be set in settings";
  }

  if (!configs.base) {
    throw "Url Base must be set in settings";
  }

  if (!configs.url) {
    throw "API url must be set in settings";
  }

  _configs = configs;
}
var configs = {
  set: function (key, val) {
    _configs[key] = val;
  },
  get: function (key, def = null) {
    const keys = key.split(".");
    const fkey = keys.pop();
    let obj = _configs;

    for (let key of keys) {
      if (!obj.hasOwnProperty(key)) return def;
      obj = obj[key];
    }

    return obj.hasOwnProperty(fkey) ? obj[fkey] : def;
  }
};

var configs$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  initConfigs: initConfigs,
  'default': configs
});

let _has_cookie = false;

function runCsrfCookie(url) {
  if (!_has_cookie) {
    _has_cookie = true;
    fetch(url + "/sanctum/csrf-cookie", {
      method: 'GET',
      mode: 'cors',
      cache: 'no-cache',
      credentials: 'include'
    }).then(response => {}).catch(e => {});
  }
}

class Client {
  constructor(url, headers = null) {
    this._main_url = url;
    this._custom_headers = {};

    if (headers) {
      for (let name in headers) {
        this._custom_headers[name] = headers[name];
      }
    }

    runCsrfCookie(this._main_url);
  }

  createClientException(type, detail, status, response) {
    return {
      "origin": "client",
      type,
      detail,
      status,
      response
    };
  }

  createHeaders(dynamic_headers = null) {
    const headers = new Headers();

    for (let i in this._custom_headers) {
      headers.set(i, this._custom_headers[i]);
    }

    if (dynamic_headers) {
      for (let i in dynamic_headers) {
        headers.set(i, dynamic_headers[i]);
      }
    }

    return headers;
  }

  createParams(data) {
    const params = new URLSearchParams();

    for (let i in data) {
      if (Array.isArray(data[i]) || typeof data[i] == 'object' && data[i] !== null) {
        params.append(i, JSON.stringify(data[i]));
      } else params.append(i, data[i]);
    }

    return params;
  }

  createOptions(method, headers, body = null) {
    return {
      method: method,
      mode: 'cors',
      cache: 'no-cache',
      credentials: 'include',
      headers: headers,
      body: body
    };
  }

  switchTokens() {
    const options = this.createOptions("PUT", this.createHeaders({
      "x-force-auth-cookies": 1
    }));
    return fetch(this._main_url + "/user/switch-tokens", options);
  }

  call(url, options) {
    return fetch(this._main_url + url, options).then(response => {
      if (response.ok) {
        return response.json();
      } else {
        return response.json().then(json => {
          throw this.createClientException("error", "apierror", response.status, json);
        });
      }
    });
  }

  get(url, data) {
    if (data) {
      const params = this.createParams(data);
      if (url.indexOf("?") == -1) url += "?";else url += "&";
      url += params.toString();
    }

    return this.call(url, this.createOptions('GET', this.createHeaders()));
  }

  getprimary(url, data) {
    return this.get(url, data);
  }

  save(url, method, data, dynamic_headers = null) {
    const headers = this.createHeaders(dynamic_headers);
    let body = null;

    if (data) {
      body = data;
    }

    const options = this.createOptions(method, headers, body); //call our fetch response and return

    return this.call(url, options);
  }

  post(url, data, headers = null) {
    if (!(data instanceof FormData)) {
      if (!headers) headers = {};
      data = JSON.stringify(data);
      headers["Content-Type"] = "application/json";
    }

    return this.save(url, "POST", data, headers);
  }

  put(url, data, headers = null) {
    if (data instanceof FormData) {
      data = Object.fromEntries(data.entries());
    }

    data = JSON.stringify(data);
    if (!headers) headers = {};
    headers["Content-Type"] = "application/json";
    return this.save(url, 'PUT', data, headers);
  }

  delete(url, data) {
    const headers = {
      "Content-Type": "application/json"
    };
    return this.save(url, 'DELETE', JSON.stringify(data), headers);
  }

  getAsset(url) {
    const options = this.createOptions("GET");
    return fetch(this._main_url + url, options).then(response => {
      if (response.ok) {
        return response.blob();
      } else {
        throw response;
      }
    });
  }

}
function getClient() {
  console.log("URL is ", configs.get("url"));
  return new Client(configs.get("url"), configs.get("client.custom_headers", {}));
}

class Entity {
  constructor() {
    this._name = "";
    this._cells = {};
    this._min_rows = null;
    this._max_rows = null;
    this._children = null;
    this._sort = null;
    this._min_rows = null;
    this._max_rows = null;
    this._parent = null;
    this._perms = [];
    const keys = Object.keys(this);
    keys.forEach(property => {
      if (property[0] == "_") {
        Object.defineProperty(this, property.substring(1), {
          get: function () {
            return this[property];
          },
          set: function (newValue) {
            this[property] = newValue;
          }
        });
      }
    });
  }

  addCell(cell) {
    this._cells[cell.name] = cell;
    cell.entity = this;
  }

  getCell(name) {
    if (!this._cells[cell.name]) {
      console.warn("Cell name " + cell.name + "doesn't exist", "entity.js getCell");
    }

    return this._cells[cell.name];
  }

}

const Errors = {
  OK: 0,
  MIN_VALUE: 1,
  MAX_VALUE: 2,
  HAS: 3,
  HAS_NOT: 4
};

class Field {
  constructor(name) {
    this._name = name;
    this._default_val = null;
    this._immutable = false;
    this._min = null;
    this._max = null;
    this._contains = [];
    this._notcontains = [];
    this._model = "";
    this._background = false;
    this._system = false;
    this._summary = false;
    this._where = null;
    this._entity = null;
    this._slug;
    this._disabled = false;
    this._multiple = false;
  }

  buildGetterSetters() {
    const keys = Object.keys(this);
    keys.forEach(property => {
      if (property[0] == "_") {
        Object.defineProperty(this, property.substring(1), {
          get: function () {
            return this[property];
          },
          set: function (newValue) {
            this[property] = newValue;
          }
        });
      }
    });
  }

  apply(obj) {
    for (let x in obj) {
      if (obj[x] === null) continue;
      if (x == "type") this._type = obj[x].toLowerCase();else if (x == "contains" || x == "notcontains") {
        if (obj[x]) this["_" + x] = obj[x].split("|");
      } else this["_" + x] = obj[x];
    }
  }

  clean(val) {
    return val;
  }

  calcValue(value) {
    if (!value) return "";else return value;
  }

  validateSize(val) {
    if (this._min !== null && val < this._min) return Errors.MIN_VALUE;else if (this._max !== null && val > this._max) return Errors.MAX_VALUE;else return Errors.OK;
  }

  validate(val) {
    if (val === undefined || val === null) return;
    let err;

    if (isNaN(val)) {
      const length = val ? val.length : 0;
      err = this.validateSize(length);
    } else {
      err = this.validateSize(val);
    }

    if (err != Errors.OK) return err;

    for (let nhas of this._notcontains) {
      if (val.match(nhas)) return Errors.HAS_NOT;
    }

    if (this._contains.length == 0) return Errors.OK;

    for (let has of this._contains) {
      if (val.match(has)) return Errors.OK;
    }

    return Errors.HAS;
  }

  getErrorVal(error) {
    if (error == Errors.MIN_VALUE) return this.min;else if (error == Errors.MAX_VALUE) return this._max;else if (error == Errors.HAS) return this._contains.join(" | ");else if (error == Errors.HAS_NOT) return this._notcontains;
  }

  display(val) {
    return val;
  }

}

const ReferenceTypes = {
  'PRIMARY': 0,
  'PARENT': 1,
  'OWNER': 2,
  'REFERENCE': 3,
  'RECURSIVE': 4,
  'CIRCULAR': 5
};
class ID extends Field {
  constructor(name, obj) {
    super(name);
    this._reference_type;
    this._reference;
    this._default_val = 0;
    this.reverse_references = [];
    this._common;
    this._custom_fields = [];
    this.buildGetterSetters();
    if (obj) this.apply(obj);
  }

  get reference() {
    return this._reference;
  }

  isReferenceType() {
    return this._reference_type == ReferenceTypes.REFERENCE || this._reference_type == ReferenceTypes.CIRCULAR;
  }

  isCircular() {
    return this._reference_type == ReferenceTypes.CIRCULAR;
  }

  get recursive() {
    return this._reference_type == ReferenceTypes.RECURSIVE;
  }

  get reference_type() {
    return this._reference_type;
  }

  get type() {
    return "id";
  }

}

class Flag extends Field {
  constructor(name, obj) {
    super(name);
    if (obj) this.apply(obj);
    this.buildGetterSetters();
  }

  clean(val) {
    return val ? 1 : 0;
  }

  display(val) {
    if (this._contains.length > 0) return this._contains[val];else return '';
  }

  useIcons() {
    return !this._contains.length ? true : false;
  }

  get type() {
    return "flag";
  }

}

class Asset extends Field {
  constructor(name, obj) {
    super(name);
    this._type;
    if (obj) this.apply(obj);
    this.buildGetterSetters();
  }

  get type() {
    return "asset";
  }

}

class Time extends Field {
  constructor(name, obj) {
    super(name);
    this._format = {
      date: true,
      time: false
    };
    this._range = false;
    this._invalid_dates = [];
    this.buildGetterSetters();
    if (obj) this.apply(obj);

    if (!this._contains.length) {
      this._contains.push('Y-m-d H:i:s');
    }
  }

  convertMysqlToUTC(val) {
    if (val.indexOf(" ") == -1) {
      if (val.indexOf(":") > 0) {
        val = "0000-00-00T" + val;
      } else {
        //date only
        val += "T12:00:00";
      }
    } else {
      val.replace(" ", "T");
    }

    val += ".00Z";
    return val;
  }

  buildString(date_obj) {
    if (!date_obj) return null;
    console.log("Format is", this._format);

    if (!this._format.time && date_obj) {
      if (date_obj.getHours() == 0) date_obj.setUTCHours(date_obj.getUTCHours() + 12);
    }

    let str = date_obj.toISOString();
    str = str.split(".")[0];
    str = str.replace("T", " ");
    return str;
  }

  validate(val) {
    return 0;
  }

  clean(val) {
    if (typeof val === 'string') {
      const date = new Date(this.convertMysqlToUTC(val));
      return date;
    } else {
      return val;
    }
  }

  get type() {
    return "time";
  }

}

class Number$1 extends Field {
  constructor(name, obj) {
    super(name);
    this._round = 0;
    this._range = false;
    this.buildGetterSetters();
    if (obj) this.apply(obj);
  }

  clean(val) {
    if (this._round) val = parseFloat(val);else if (val !== null && typeof val !== 'undefined') val = parseInt(val);
    if (isNaN(val)) val = null;
    return val;
  }

  get round() {
    return this._round;
  }

  set round(round) {
    this._round = round;
  }

  get type() {
    return "number";
  }

}

class String$1 extends Field {
  constructor(name, obj) {
    super(name);
    this._encrypted = false;
    this._list = null;
    this._multiple = false;
    this.buildGetterSetters();
    if (obj) this.apply(obj);
  }

  getOptions() {
    let opts = [];

    if (Array.isArray(this._list)) {
      for (const item of this._list) {
        const key = "models." + this._model + ".fields." + this._name + ".options." + item;
        const label = te(key) ? t(key) : item;
        opts.push({
          value: item,
          label: label
        });
      }
    } else {
      for (const key in this._list) {
        const tkey = "models." + this._model + ".fields." + this._name + ".options." + this._list[key];
        const label = te(tkey) ? t(tkey) : key;
        opts.push({
          value: key,
          label: label
        });
      }
    }

    return opts;
  }

  clean(val) {
    if (this._list) {
      if (Array.isArray(this._list)) {
        if (this._list.includes(val)) return val;
      } else if (this._list[val]) {
        return val;
      } else {
        return null;
      }
    } else {
      return val ? val.trim() : val;
    }
  }

  isEnum() {
    return this._list ? true : false;
  }

  get type() {
    return "string";
  }

}

class JsonGroup extends Field {
  constructor(name, obj) {
    super(name);
    this._fields = {};
    this.buildGetterSetters();
    if (obj) this.apply(obj);
  }

  buildJSON(bind) {
    let obj = {};
    const group = bind.getGroup();

    for (const i in this._fields) {
      const cbind = group.getBind(this._name + "-" + i);
      if (!cbind.active.value) continue;

      if (cbind.cell.type == "json") {
        obj[i] = this.cbind.cell.buildJSON(cbind);
      } else {
        obj[i] = cbind.value;
      }
    }

    return obj;
  }

  clean(val) {
    if (typeof val === 'string') {
      return JSON.parse(val);
    } else {
      return val;
    }
  }

  get type() {
    return "json";
  }

}

function createField(field, obj, schema_model) {
  let cell;
  if (obj.type == "id") cell = new ID(field, obj);else if (obj.type == "number") cell = new Number$1(field, obj);else if (obj.type == "asset") cell = new Asset(field, obj);else if (obj.type == "flag") cell = new Flag(field, obj);else if (obj.type == "time") cell = new Time(field, obj);else if (obj.type == "json") cell = new JsonGroup(field, obj);else cell = new String$1(field, obj);
  cell.model = schema_model;

  if (obj.type == "json") {
    for (const field in cell.fields) {
      cell.fields[field] = createField(field, cell.fields[field]);
      cell.fields[field].model = schema_model;
    }
  }

  return cell;
}

const _entities = {};
function regEntity(i, entity) {
  _entities[i] = entity;
}
function getEntity(i) {
  if (!_entities[i]) {
    console.warn("Trying to get entity: " + i + " which isn't registerd in entity store", "entitystore.js", _entities);
  }

  return _entities[i];
}
function getEntities() {
  return _entities;
}
function loadSiteMap(response) {
  for (let i in response) {
    const entity = new Entity();
    entity.name = i;
    entity.audit = response[i].audit;
    if (response[i].perms) entity.perms = response[i].perms;
    entity.import = response[i].import;
    entity.export = response[i].export;
    entity.min_rows = response[i].min_rows;
    entity.max_rows = response[i].max_rows;
    const schema = response[i].schema; //set up some shortcuts

    if (schema['--parent']) {
      entity.parent = schema['--parent'].reference;
    }

    entity.children = schema["--id"].reference;
    entity.sort = schema["--sort"] ? true : false;

    for (let x in schema) {
      //const field = schema[x];
      //if (settings[i] && settings[i][x]) {
      //setFieldSettings(field, settings[i][x]);
      //}
      entity.addCell(createField(x, schema[x], i));
    }

    regEntity(i, entity);
  }
}
function hasEntity(name) {
  return _entities[name] ? true : false;
}
function defaultEntity() {
  for (const name in _entities) {
    if (!_entities[name].parent && _entities[name].perms && _entities[name].perms.includes("get") && _entities[name].max_rows != 1) return name;
  }
}
function getRoot(entity) {
  while (entity.parent) {
    entity = getEntity(entity.parent);
  }

  return entity;
}

var script$1N = {
  name: 'Card'
};
const _hoisted_1$$ = {
  class: "p-card p-component"
};
const _hoisted_2$R = {
  key: 0,
  class: "p-card-header"
};
const _hoisted_3$F = {
  class: "p-card-body"
};
const _hoisted_4$z = {
  key: 0,
  class: "p-card-title"
};
const _hoisted_5$u = {
  key: 1,
  class: "p-card-subtitle"
};
const _hoisted_6$o = {
  class: "p-card-content"
};
const _hoisted_7$g = {
  key: 2,
  class: "p-card-footer"
};

function render$E(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$$, [_ctx.$slots.header ? (openBlock(), createElementBlock("div", _hoisted_2$R, [renderSlot(_ctx.$slots, "header")])) : createCommentVNode("", true), createElementVNode("div", _hoisted_3$F, [_ctx.$slots.title ? (openBlock(), createElementBlock("div", _hoisted_4$z, [renderSlot(_ctx.$slots, "title")])) : createCommentVNode("", true), _ctx.$slots.subtitle ? (openBlock(), createElementBlock("div", _hoisted_5$u, [renderSlot(_ctx.$slots, "subtitle")])) : createCommentVNode("", true), createElementVNode("div", _hoisted_6$o, [renderSlot(_ctx.$slots, "content")]), _ctx.$slots.footer ? (openBlock(), createElementBlock("div", _hoisted_7$g, [renderSlot(_ctx.$slots, "footer")])) : createCommentVNode("", true)])]);
}

function styleInject$v(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$G = "\n.p-card-header img {\n    width: 100%;\n}\n";
styleInject$v(css_248z$G);
script$1N.render = render$E;

var script$1M = {
  name: 'InputText',
  emits: ['update:modelValue'],
  props: {
    modelValue: null
  },
  methods: {
    onInput(event) {
      this.$emit('update:modelValue', event.target.value);
    }

  },
  computed: {
    filled() {
      return this.modelValue != null && this.modelValue.toString().length > 0;
    }

  }
};
const _hoisted_1$_ = ["value"];

function render$D(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("input", {
    class: normalizeClass(['p-inputtext p-component', {
      'p-filled': $options.filled
    }]),
    value: $props.modelValue,
    onInput: _cache[0] || (_cache[0] = (...args) => $options.onInput && $options.onInput(...args))
  }, null, 42, _hoisted_1$_);
}

script$1M.render = render$D;

let timeout;

function bindEvents(el) {
  el.addEventListener('mousedown', onMouseDown);
}

function unbindEvents(el) {
  el.removeEventListener('mousedown', onMouseDown);
}

function create(el) {
  let ink = document.createElement('span');
  ink.className = 'p-ink';
  ink.setAttribute('role', 'presentation');
  el.appendChild(ink);
  ink.addEventListener('animationend', onAnimationEnd);
}

function remove(el) {
  let ink = getInk(el);

  if (ink) {
    unbindEvents(el);
    ink.removeEventListener('animationend', onAnimationEnd);
    ink.remove();
  }
}

function onMouseDown(event) {
  let target = event.currentTarget;
  let ink = getInk(target);

  if (!ink || getComputedStyle(ink, null).display === 'none') {
    return;
  }

  DomHandler.removeClass(ink, 'p-ink-active');

  if (!DomHandler.getHeight(ink) && !DomHandler.getWidth(ink)) {
    let d = Math.max(DomHandler.getOuterWidth(target), DomHandler.getOuterHeight(target));
    ink.style.height = d + 'px';
    ink.style.width = d + 'px';
  }

  let offset = DomHandler.getOffset(target);
  let x = event.pageX - offset.left + document.body.scrollTop - DomHandler.getWidth(ink) / 2;
  let y = event.pageY - offset.top + document.body.scrollLeft - DomHandler.getHeight(ink) / 2;
  ink.style.top = y + 'px';
  ink.style.left = x + 'px';
  DomHandler.addClass(ink, 'p-ink-active');
  timeout = setTimeout(() => {
    if (ink) {
      DomHandler.removeClass(ink, 'p-ink-active');
    }
  }, 401);
}

function onAnimationEnd(event) {
  if (timeout) {
    clearTimeout(timeout);
  }

  DomHandler.removeClass(event.currentTarget, 'p-ink-active');
}

function getInk(el) {
  for (let i = 0; i < el.children.length; i++) {
    if (typeof el.children[i].className === 'string' && el.children[i].className.indexOf('p-ink') !== -1) {
      return el.children[i];
    }
  }

  return null;
}

const Ripple = {
  mounted(el, binding) {
    if (binding.instance.$primevue && binding.instance.$primevue.config && binding.instance.$primevue.config.ripple) {
      create(el);
      bindEvents(el);
    }
  },

  unmounted(el) {
    remove(el);
  }

};

var script$1L = {
  name: 'Button',
  props: {
    label: {
      type: String,
      default: null
    },
    icon: {
      type: String,
      default: null
    },
    iconPos: {
      type: String,
      default: 'left'
    },
    iconClass: {
      type: String,
      default: null
    },
    badge: {
      type: String,
      default: null
    },
    badgeClass: {
      type: String,
      default: null
    },
    loading: {
      type: Boolean,
      default: false
    },
    loadingIcon: {
      type: String,
      default: 'pi pi-spinner pi-spin'
    }
  },
  computed: {
    buttonClass() {
      return {
        'p-button p-component': true,
        'p-button-icon-only': this.icon && !this.label,
        'p-button-vertical': (this.iconPos === 'top' || this.iconPos === 'bottom') && this.label,
        'p-disabled': this.$attrs.disabled || this.loading,
        'p-button-loading': this.loading,
        'p-button-loading-label-only': this.loading && !this.icon && this.label
      };
    },

    iconStyleClass() {
      return [this.loading ? 'p-button-loading-icon ' + this.loadingIcon : this.icon, 'p-button-icon', this.iconClass, {
        'p-button-icon-left': this.iconPos === 'left' && this.label,
        'p-button-icon-right': this.iconPos === 'right' && this.label,
        'p-button-icon-top': this.iconPos === 'top' && this.label,
        'p-button-icon-bottom': this.iconPos === 'bottom' && this.label
      }];
    },

    badgeStyleClass() {
      return ['p-badge p-component', this.badgeClass, {
        'p-badge-no-gutter': this.badge && String(this.badge).length === 1
      }];
    },

    disabled() {
      return this.$attrs.disabled || this.loading;
    },

    defaultAriaLabel() {
      return this.label ? this.label + (this.badge ? ' ' + this.badge : '') : this.$attrs['aria-label'];
    }

  },
  directives: {
    ripple: Ripple
  }
};
const _hoisted_1$Z = ["aria-label", "disabled"];
const _hoisted_2$Q = {
  class: "p-button-label"
};

function render$C(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_ripple = resolveDirective("ripple");

  return withDirectives((openBlock(), createElementBlock("button", {
    class: normalizeClass($options.buttonClass),
    type: "button",
    "aria-label": $options.defaultAriaLabel,
    disabled: $options.disabled
  }, [renderSlot(_ctx.$slots, "default", {}, () => [$props.loading && !$props.icon ? (openBlock(), createElementBlock("span", {
    key: 0,
    class: normalizeClass($options.iconStyleClass)
  }, null, 2)) : createCommentVNode("", true), $props.icon ? (openBlock(), createElementBlock("span", {
    key: 1,
    class: normalizeClass($options.iconStyleClass)
  }, null, 2)) : createCommentVNode("", true), createElementVNode("span", _hoisted_2$Q, toDisplayString$1($props.label || ' '), 1), $props.badge ? (openBlock(), createElementBlock("span", {
    key: 2,
    class: normalizeClass($options.badgeStyleClass)
  }, toDisplayString$1($props.badge), 3)) : createCommentVNode("", true)])], 10, _hoisted_1$Z)), [[_directive_ripple]]);
}

script$1L.render = render$C;

var script$1K = {
  name: 'Message',
  emits: ['close'],
  props: {
    severity: {
      type: String,
      default: 'info'
    },
    closable: {
      type: Boolean,
      default: true
    },
    sticky: {
      type: Boolean,
      default: true
    },
    life: {
      type: Number,
      default: 3000
    },
    icon: {
      type: String,
      default: null
    },
    closeIcon: {
      type: String,
      default: 'pi pi-times'
    }
  },
  timeout: null,

  data() {
    return {
      visible: true
    };
  },

  mounted() {
    if (!this.sticky) {
      setTimeout(() => {
        this.visible = false;
      }, this.life);
    }
  },

  methods: {
    close(event) {
      this.visible = false;
      this.$emit('close', event);
    }

  },
  computed: {
    containerClass() {
      return 'p-message p-component p-message-' + this.severity;
    },

    iconClass() {
      return ['p-message-icon pi', this.icon ? this.icon : {
        'pi-info-circle': this.severity === 'info',
        'pi-check': this.severity === 'success',
        'pi-exclamation-triangle': this.severity === 'warn',
        'pi-times-circle': this.severity === 'error'
      }];
    }

  },
  directives: {
    ripple: Ripple
  }
};
const _hoisted_1$Y = {
  class: "p-message-wrapper"
};
const _hoisted_2$P = {
  class: "p-message-text"
};

function render$B(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_ripple = resolveDirective("ripple");

  return openBlock(), createBlock(Transition, {
    name: "p-message",
    appear: ""
  }, {
    default: withCtx(() => [withDirectives(createElementVNode("div", {
      class: normalizeClass($options.containerClass),
      role: "alert"
    }, [createElementVNode("div", _hoisted_1$Y, [createElementVNode("span", {
      class: normalizeClass($options.iconClass)
    }, null, 2), createElementVNode("div", _hoisted_2$P, [renderSlot(_ctx.$slots, "default")]), $props.closable ? withDirectives((openBlock(), createElementBlock("button", {
      key: 0,
      class: "p-message-close p-link",
      onClick: _cache[0] || (_cache[0] = $event => $options.close($event)),
      type: "button"
    }, [createElementVNode("i", {
      class: normalizeClass(['p-message-close-icon', $props.closeIcon])
    }, null, 2)])), [[_directive_ripple]]) : createCommentVNode("", true)])], 2), [[vShow, $data.visible]])]),
    _: 3
  });
}

function styleInject$u(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$F = "\n.p-message-wrapper {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n.p-message-close {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n}\n.p-message-close.p-link {\n    margin-left: auto;\n    overflow: hidden;\n    position: relative;\n}\n.p-message-enter-from {\n    opacity: 0;\n}\n.p-message-enter-active {\n    -webkit-transition: opacity 0.3s;\n    transition: opacity 0.3s;\n}\n.p-message.p-message-leave-from {\n    max-height: 1000px;\n}\n.p-message.p-message-leave-to {\n    max-height: 0;\n    opacity: 0;\n    margin: 0 !important;\n}\n.p-message-leave-active {\n    overflow: hidden;\n    -webkit-transition: max-height 0.3s cubic-bezier(0, 1, 0, 1), opacity 0.3s, margin 0.15s;\n    transition: max-height 0.3s cubic-bezier(0, 1, 0, 1), opacity 0.3s, margin 0.15s;\n}\n.p-message-leave-active .p-message-close {\n    display: none;\n}\n";
styleInject$u(css_248z$F);
script$1K.render = render$B;

const _hoisted_1$X = /*#__PURE__*/createElementVNode("h2", null, "Login", -1 /* HOISTED */);
const _hoisted_2$O = { class: "field row" };
const _hoisted_3$E = { class: "p-float-label" };
const _hoisted_4$y = /*#__PURE__*/createElementVNode("label", { for: "lusername" }, "Username", -1 /* HOISTED */);
const _hoisted_5$t = { class: "field row" };
const _hoisted_6$n = { class: "p-float-label" };
const _hoisted_7$f = /*#__PURE__*/createElementVNode("label", { for: "lpassword" }, "Password", -1 /* HOISTED */);
const _hoisted_8$c = { class: "row" };



var script$1J = {
  setup(__props) {

const Client = inject("client");
const expected_user = configs.get("profile");
const base = configs.get("base");



const error = ref('');
const email = ref('');
const password = ref('');



function submit() {
    error.value = "";

    const formData = new FormData();
    formData.append("email", email.value);
    formData.append("password", password.value);

    Client.post("/user/login/" + expected_user, formData)
    .then(() => {
        return Client.get("/user/check-user")
        //location.href = base + "/";
    })
    .then(response => {
        if (response.name == expected_user) {
            location.href = base + "/";
        } else {
            throw "Login failed";
        }
    })
    .catch(e => {
        error.value = "Incorrect username / password";
    });
} 

return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("form", null, [
    _hoisted_1$X,
    withDirectives(createVNode(unref(script$1K), { severity: "error" }, {
      default: withCtx(() => [
        createTextVNode(toDisplayString$1(error.value), 1 /* TEXT */)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */), [
      [vShow, error.value]
    ]),
    createElementVNode("div", _hoisted_2$O, [
      createElementVNode("span", _hoisted_3$E, [
        createVNode(unref(script$1M), {
          id: "lusername",
          type: "text",
          modelValue: email.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((email).value = $event))
        }, null, 8 /* PROPS */, ["modelValue"]),
        _hoisted_4$y
      ])
    ]),
    createElementVNode("div", _hoisted_5$t, [
      createElementVNode("span", _hoisted_6$n, [
        createVNode(unref(script$1M), {
          id: "lpassword",
          type: "password",
          modelValue: password.value,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((password).value = $event))
        }, null, 8 /* PROPS */, ["modelValue"]),
        _hoisted_7$f
      ])
    ]),
    createElementVNode("div", _hoisted_8$c, [
      createVNode(unref(script$1L), {
        label: _ctx.$t('btns.login'),
        onClick: submit
      }, null, 8 /* PROPS */, ["label"])
    ])
  ]))
}
}

};

function styleInject$t(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$E = "\n.login-vue-vue-type-style-index-0-id-7787bfd2-lang_ptj-login__B9jGx {\r\n        width : 450px;\r\n        margin-left : auto;\r\n        margin-right : auto;\n}\n.login-vue-vue-type-style-index-0-id-7787bfd2-lang_ptj-login__B9jGx > form > div {\r\n        margin-bottom :28px;\n}\n.login-vue-vue-type-style-index-0-id-7787bfd2-lang_ptj-login__B9jGx input {\r\n        width : 100%;\n}\r\n";
styleInject$t(css_248z$E);

script$1J.__file = "presstojam/src/components/account/login.vue";

var script$1I = {
  name: 'Checkbox',
  emits: ['click', 'update:modelValue', 'change', 'input', 'focus', 'blur'],
  props: {
    value: null,
    modelValue: null,
    binary: Boolean,
    name: {
      type: String,
      default: null
    },
    trueValue: {
      type: null,
      default: true
    },
    falseValue: {
      type: null,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    required: {
      type: Boolean,
      default: false
    },
    tabindex: {
      type: Number,
      default: null
    },
    inputId: {
      type: String,
      default: null
    },
    inputClass: {
      type: String,
      default: null
    },
    inputStyle: {
      type: null,
      default: null
    },
    inputProps: {
      type: null,
      default: null
    },
    'aria-labelledby': {
      type: String,
      default: null
    },
    'aria-label': {
      type: String,
      default: null
    }
  },

  data() {
    return {
      focused: false
    };
  },

  methods: {
    onClick(event) {
      if (!this.disabled) {
        let newModelValue;

        if (this.binary) {
          newModelValue = this.checked ? this.falseValue : this.trueValue;
        } else {
          if (this.checked) newModelValue = this.modelValue.filter(val => !ObjectUtils.equals(val, this.value));else newModelValue = this.modelValue ? [...this.modelValue, this.value] : [this.value];
        }

        this.$emit('click', event);
        this.$emit('update:modelValue', newModelValue);
        this.$emit('change', event);
        this.$emit('input', newModelValue);
        this.$refs.input.focus();
      }
    },

    onFocus(event) {
      this.focused = true;
      this.$emit('focus', event);
    },

    onBlur(event) {
      this.focused = false;
      this.$emit('blur', event);
    }

  },
  computed: {
    checked() {
      return this.binary ? this.modelValue === this.trueValue : ObjectUtils.contains(this.value, this.modelValue);
    },

    containerClass() {
      return ['p-checkbox p-component', {
        'p-checkbox-checked': this.checked,
        'p-checkbox-disabled': this.disabled,
        'p-checkbox-focused': this.focused
      }];
    }

  }
};
const _hoisted_1$W = {
  class: "p-hidden-accessible"
};
const _hoisted_2$N = ["id", "value", "name", "checked", "tabindex", "disabled", "readonly", "required", "aria-labelledby", "aria-label"];

function render$A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass($options.containerClass),
    onClick: _cache[2] || (_cache[2] = $event => $options.onClick($event))
  }, [createElementVNode("div", _hoisted_1$W, [createElementVNode("input", mergeProps({
    ref: "input",
    id: $props.inputId,
    type: "checkbox",
    value: $props.value,
    class: $props.inputClass,
    style: $props.inputStyle,
    name: $props.name,
    checked: $options.checked,
    tabindex: $props.tabindex,
    disabled: $props.disabled,
    readonly: $props.readonly,
    required: $props.required,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    onFocus: _cache[0] || (_cache[0] = $event => $options.onFocus($event)),
    onBlur: _cache[1] || (_cache[1] = $event => $options.onBlur($event))
  }, $props.inputProps), null, 16, _hoisted_2$N)]), createElementVNode("div", {
    ref: "box",
    class: normalizeClass(['p-checkbox-box', {
      'p-highlight': $options.checked,
      'p-disabled': $props.disabled,
      'p-focus': $data.focused
    }])
  }, [createElementVNode("span", {
    class: normalizeClass(['p-checkbox-icon', {
      'pi pi-check': $options.checked
    }])
  }, null, 2)], 2)], 2);
}

script$1I.render = render$A;

const _hoisted_1$V = { class: "ptj-register" };
const _hoisted_2$M = /*#__PURE__*/createElementVNode("h2", null, "Register", -1 /* HOISTED */);
const _hoisted_3$D = { class: "row" };
const _hoisted_4$x = { class: "p-float-label" };
const _hoisted_5$s = /*#__PURE__*/createElementVNode("label", { for: "cusername" }, "Username", -1 /* HOISTED */);
const _hoisted_6$m = { class: "row" };
const _hoisted_7$e = { class: "p-float-label" };
const _hoisted_8$b = /*#__PURE__*/createElementVNode("label", { for: "cpassword" }, "Password", -1 /* HOISTED */);
const _hoisted_9$6 = { class: "row" };
const _hoisted_10$6 = { class: "p-float-label" };
const _hoisted_11$6 = /*#__PURE__*/createElementVNode("label", { for: "cconfirm_password" }, "Confirm Password", -1 /* HOISTED */);
const _hoisted_12$6 = { class: "row" };
const _hoisted_13$5 = /*#__PURE__*/createElementVNode("label", null, "I accept the terms and conditions", -1 /* HOISTED */);
const _hoisted_14$4 = { class: "row" };


   
var script$1H = {
  setup(__props) {

   const Client = inject("client");
   const expected_user = configs.get("profile");

   const error = ref('');
   const username = ref('');
   const password = ref('');
   const conf_password = ref('');
   const terms = ref(0);

   const base = configs.get("base");
   
   
   
   function submit() {
       error.value = "";
       
       if (!username.value) {
        error.value = "You must enter a username";
        return;
       }
       if (!password.value) {
        error.value = "You must enter a password";
        return;
       }

       if (password.value != conf_password.value) {
        error.value = "Passwords must match";
        return;
       }

       if (!terms.value) {
        error.value = "You must accept the terms and conditions";
        return;
       }

       const formData = new FormData();
       formData.append("email", username.value);
       formData.append("password", password.value);
       formData.append("terms", (terms.value) ? 1 : 0);
       return Client.post("/user/register/" + expected_user, formData)
       .then(() => {
            location.href = base + "/";
       })
       .catch(e => {
        console.log(e);
            if (typeof e.response === 'string' || e.response instanceof String) {
                error.value = e.response;
            } else {
                let err = JSON.parse(e.response.error);
                if (err.terms) error.value = "You must accept the terms and conditions";
            }
        });
   } 
   
return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("form", _hoisted_1$V, [
    _hoisted_2$M,
    withDirectives(createVNode(unref(script$1K), { severity: "error" }, {
      default: withCtx(() => [
        createTextVNode(toDisplayString$1(error.value), 1 /* TEXT */)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */), [
      [vShow, error.value]
    ]),
    createElementVNode("div", _hoisted_3$D, [
      createElementVNode("span", _hoisted_4$x, [
        createVNode(unref(script$1M), {
          id: "cusername",
          type: "text",
          modelValue: username.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((username).value = $event))
        }, null, 8 /* PROPS */, ["modelValue"]),
        _hoisted_5$s
      ])
    ]),
    createElementVNode("div", _hoisted_6$m, [
      createElementVNode("span", _hoisted_7$e, [
        createVNode(unref(script$1M), {
          id: "cpassword",
          type: "password",
          modelValue: password.value,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((password).value = $event))
        }, null, 8 /* PROPS */, ["modelValue"]),
        _hoisted_8$b
      ])
    ]),
    createElementVNode("div", _hoisted_9$6, [
      createElementVNode("span", _hoisted_10$6, [
        createVNode(unref(script$1M), {
          id: "cconfirm_password",
          type: "password",
          modelValue: conf_password.value,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => ((conf_password).value = $event))
        }, null, 8 /* PROPS */, ["modelValue"]),
        _hoisted_11$6
      ])
    ]),
    createElementVNode("div", _hoisted_12$6, [
      createVNode(unref(script$1I), {
        modelValue: terms.value,
        "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => ((terms).value = $event)),
        binary: true
      }, null, 8 /* PROPS */, ["modelValue"]),
      _hoisted_13$5
    ]),
    createElementVNode("div", _hoisted_14$4, [
      createVNode(unref(script$1L), {
        label: _ctx.$t('btns.create'),
        onClick: submit
      }, null, 8 /* PROPS */, ["label"])
    ])
  ]))
}
}

};

var css_248z$D = "\n.register-vue-vue-type-style-index-0-id-c6c7206c-lang_ptj-login__lZnG- {\r\n           width : 450px;\r\n           margin-left : auto;\r\n           margin-right : auto;\n}\n.register-vue-vue-type-style-index-0-id-c6c7206c-lang_ptj-login__lZnG- > form > div {\r\n           margin-bottom :28px;\n}\n.register-vue-vue-type-style-index-0-id-c6c7206c-lang_ptj-login__lZnG- input {\r\n           width : 100%;\n}\r\n   ";
styleInject$t(css_248z$D);

script$1H.__file = "presstojam/src/components/account/register.vue";

const _hoisted_1$U = { class: "ptj-register" };
const _hoisted_2$L = /*#__PURE__*/createElementVNode("h2", null, "Forgotten Password", -1 /* HOISTED */);
const _hoisted_3$C = { class: "row" };
const _hoisted_4$w = { class: "p-float-label" };
const _hoisted_5$r = /*#__PURE__*/createElementVNode("label", { for: "fusername" }, "Username", -1 /* HOISTED */);
const _hoisted_6$l = { class: "row" };
   
   
   
var script$1G = {
  setup(__props) {

   const Client = inject("client");
   const expected_user = configs.get("profile");
   configs.get("base");
 
   const username = ref('');
   const error = ref('');

   
    function submit() {
        error.value = "";

        const formData = new FormData();
        formData.append("email", username.value);
       
        return Client.post("/user/login/" + expected_user + "/forgotpassword", formData)
        .catch(e => {
            error.value = "This user doesn't exist";
        });
    } 
   
return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("form", _hoisted_1$U, [
    _hoisted_2$L,
    withDirectives(createElementVNode("div", { class: "ptj-form-error" }, toDisplayString$1(error.value), 513 /* TEXT, NEED_PATCH */), [
      [vShow, error.value]
    ]),
    createElementVNode("div", _hoisted_3$C, [
      createElementVNode("span", _hoisted_4$w, [
        createVNode(unref(script$1M), {
          id: "fusername",
          type: "text",
          modelValue: username.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((username).value = $event))
        }, null, 8 /* PROPS */, ["modelValue"]),
        _hoisted_5$r
      ])
    ]),
    createElementVNode("div", _hoisted_6$l, [
      createVNode(unref(script$1L), {
        label: _ctx.$t('btns.forgot', 'send new password'),
        onClick: submit
      }, null, 8 /* PROPS */, ["label"])
    ])
  ]))
}
}

};

var css_248z$C = "\n.forgottenpassword-vue-vue-type-style-index-0-id-fd7580c4-lang_ptj-login__ILNqj {\r\n           width : 450px;\r\n           margin-left : auto;\r\n           margin-right : auto;\n}\n.forgottenpassword-vue-vue-type-style-index-0-id-fd7580c4-lang_ptj-login__ILNqj > form > div {\r\n           margin-bottom :28px;\n}\n.forgottenpassword-vue-vue-type-style-index-0-id-fd7580c4-lang_ptj-login__ILNqj input {\r\n           width : 100%;\n}\r\n   ";
styleInject$t(css_248z$C);

script$1G.__file = "presstojam/src/components/account/forgottenpassword.vue";

const _hoisted_1$T = /*#__PURE__*/createTextVNode(" Account ");
const _hoisted_2$K = { class: "ptj-login" };
const _hoisted_3$B = { class: "row" };
const _hoisted_4$v = /*#__PURE__*/createTextVNode(" | ");
const _hoisted_5$q = /*#__PURE__*/createTextVNode(" | ");
   
   
   
var script$1F = {
  setup(__props) {

   inject("client");
   configs.get("profile");
   
   const state = ref('login');

   function toggleState(istate) {
       state.value = istate;
   }
  
   
   
return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$1N), null, {
    title: withCtx(() => [
      _hoisted_1$T
    ]),
    content: withCtx(() => [
      createElementVNode("div", _hoisted_2$K, [
        withDirectives(createVNode(script$1J, null, null, 512 /* NEED_PATCH */), [
          [vShow, state.value=='login']
        ]),
        withDirectives(createVNode(script$1H, null, null, 512 /* NEED_PATCH */), [
          [vShow, state.value=='create']
        ]),
        withDirectives(createVNode(script$1G, null, null, 512 /* NEED_PATCH */), [
          [vShow, state.value=='forgotpassword']
        ]),
        createElementVNode("div", _hoisted_3$B, [
          createElementVNode("a", {
            onClick: _cache[0] || (_cache[0] = $event => (toggleState('login')))
          }, "Login"),
          _hoisted_4$v,
          createElementVNode("a", {
            onClick: _cache[1] || (_cache[1] = $event => (toggleState('create')))
          }, "Register"),
          _hoisted_5$q,
          createElementVNode("a", {
            onClick: _cache[2] || (_cache[2] = $event => (toggleState('forgotpassword')))
          }, "Forgotten password?")
        ])
      ])
    ]),
    _: 1 /* STABLE */
  }))
}
}

};

var css_248z$B = "\n.account-vue-vue-type-style-index-0-id-4e65ef54-lang_ptj-login__YiA4y {\r\n           width : 450px;\r\n           margin-left : auto;\r\n           margin-right : auto;\n}\r\n   \r\n   ";
styleInject$t(css_248z$B);

script$1F.__file = "presstojam/src/components/account/account.vue";

var account = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': script$1F
});

function render$z(_ctx, _cache) {
  const _component_router_view = resolveComponent("router-view");

  return (openBlock(), createBlock(_component_router_view, null, {
    default: withCtx(({ Component, route }) => [
      createVNode(Transition, {
        name: "fade",
        mode: "out-in"
      }, {
        default: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent(Component), {
            atts: route.params,
            key: route.model + route.id
          }, null, 8 /* PROPS */, ["atts"]))
        ]),
        _: 2 /* DYNAMIC */
      }, 1024 /* DYNAMIC_SLOTS */)
    ]),
    _: 1 /* STABLE */
  }))
}

var css_248z$A = "\n.routes-vue-vue-type-style-index-0-id-16a8c88f-lang_fade-enter-active__WCBJs, .routes-vue-vue-type-style-index-0-id-16a8c88f-lang_fade-leave-active__fjMS2 {\r\n  transition-property: opacity;\r\n  transition-duration: .25s;\n}\n.routes-vue-vue-type-style-index-0-id-16a8c88f-lang_fade-enter-active__WCBJs {\r\n  transition-delay: .25s;\n}\n.routes-vue-vue-type-style-index-0-id-16a8c88f-lang_fade-enter__T5pru, .routes-vue-vue-type-style-index-0-id-16a8c88f-lang_fade-leave-active__fjMS2 {\r\n  opacity: 0\n}\r\n";
styleInject$t(css_248z$A);

const script$1E = {};

script$1E.render = render$z;
script$1E.__file = "presstojam/src/components/routes.vue";

var script$1$7 = {
  name: 'MenubarSub',
  emits: ['item-mouseenter', 'item-click'],
  props: {
    items: {
      type: Array,
      default: null
    },
    root: {
      type: Boolean,
      default: false
    },
    popup: {
      type: Boolean,
      default: false
    },
    mobileActive: {
      type: Boolean,
      default: false
    },
    template: {
      type: Function,
      default: null
    },
    exact: {
      type: Boolean,
      default: true
    },
    level: {
      type: Number,
      default: 0
    },
    menuId: {
      type: String,
      default: null
    },
    focusedItemId: {
      type: String,
      default: null
    },
    activeItemPath: {
      type: Object,
      default: null
    }
  },
  list: null,
  methods: {
    getItemId(processedItem) {
      return `${this.menuId}_${processedItem.key}`;
    },

    getItemKey(processedItem) {
      return this.getItemId(processedItem);
    },

    getItemProp(processedItem, name) {
      return processedItem && processedItem.item ? ObjectUtils.getItemValue(processedItem.item[name]) : undefined;
    },

    getItemLabel(processedItem) {
      return this.getItemProp(processedItem, 'label');
    },

    isItemActive(processedItem) {
      return this.activeItemPath.some(path => path.key === processedItem.key);
    },

    isItemVisible(processedItem) {
      return this.getItemProp(processedItem, 'visible') !== false;
    },

    isItemDisabled(processedItem) {
      return this.getItemProp(processedItem, 'disabled');
    },

    isItemFocused(processedItem) {
      return this.focusedItemId === this.getItemId(processedItem);
    },

    isItemGroup(processedItem) {
      return ObjectUtils.isNotEmpty(processedItem.items);
    },

    onItemClick(event, processedItem) {
      const command = this.getItemProp(processedItem, 'command');
      command && command({
        originalEvent: event,
        item: processedItem.item
      });
      this.$emit('item-click', {
        originalEvent: event,
        processedItem,
        isFocus: true
      });
    },

    onItemMouseEnter(event, processedItem) {
      this.$emit('item-mouseenter', {
        originalEvent: event,
        processedItem
      });
    },

    onItemActionClick(event, navigate) {
      navigate && navigate(event);
    },

    getAriaSetSize() {
      return this.items.filter(processedItem => this.isItemVisible(processedItem) && !this.getItemProp(processedItem, 'separator')).length;
    },

    getAriaPosInset(index) {
      return index - this.items.slice(0, index).filter(processedItem => this.isItemVisible(processedItem) && this.getItemProp(processedItem, 'separator')).length + 1;
    },

    getItemClass(processedItem) {
      return ['p-menuitem', this.getItemProp(processedItem, 'class'), {
        'p-menuitem-active p-highlight': this.isItemActive(processedItem),
        'p-focus': this.isItemFocused(processedItem),
        'p-disabled': this.isItemDisabled(processedItem)
      }];
    },

    getItemActionClass(processedItem, routerProps) {
      return ['p-menuitem-link', {
        'router-link-active': routerProps && routerProps.isActive,
        'router-link-active-exact': this.exact && routerProps && routerProps.isExactActive
      }];
    },

    getItemIconClass(processedItem) {
      return ['p-menuitem-icon', this.getItemProp(processedItem, 'icon')];
    },

    getSeparatorItemClass(processedItem) {
      return ['p-menuitem-separator', this.getItemProp(processedItem, 'class')];
    },

    getSubmenuIcon() {
      return ['p-submenu-icon pi', {
        'pi-angle-right': !this.root,
        'pi-angle-down': this.root
      }];
    }

  },
  computed: {
    containerClass() {
      return {
        'p-submenu-list': !this.root,
        'p-menubar-root-list': this.root
      };
    }

  },
  directives: {
    ripple: Ripple
  }
};
const _hoisted_1$1$7 = ["id", "aria-label", "aria-disabled", "aria-expanded", "aria-haspopup", "aria-level", "aria-setsize", "aria-posinset"];
const _hoisted_2$1$7 = ["onClick", "onMouseenter"];
const _hoisted_3$1$6 = ["href", "onClick"];
const _hoisted_4$1$4 = {
  class: "p-menuitem-text"
};
const _hoisted_5$1$4 = ["href", "target"];
const _hoisted_6$k = {
  class: "p-menuitem-text"
};
const _hoisted_7$d = ["id"];

function render$1$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_router_link = resolveComponent("router-link");

  const _component_MenubarSub = resolveComponent("MenubarSub", true);

  const _directive_ripple = resolveDirective("ripple");

  return openBlock(), createElementBlock("ul", null, [(openBlock(true), createElementBlock(Fragment, null, renderList($props.items, (processedItem, index) => {
    return openBlock(), createElementBlock(Fragment, {
      key: $options.getItemKey(processedItem)
    }, [$options.isItemVisible(processedItem) && !$options.getItemProp(processedItem, 'separator') ? (openBlock(), createElementBlock("li", {
      key: 0,
      id: $options.getItemId(processedItem),
      style: normalizeStyle($options.getItemProp(processedItem, 'style')),
      class: normalizeClass($options.getItemClass(processedItem)),
      role: "menuitem",
      "aria-label": $options.getItemLabel(processedItem),
      "aria-disabled": $options.isItemDisabled(processedItem) || undefined,
      "aria-expanded": $options.isItemGroup(processedItem) ? $options.isItemActive(processedItem) : undefined,
      "aria-haspopup": $options.isItemGroup(processedItem) && !$options.getItemProp(processedItem, 'to') ? 'menu' : undefined,
      "aria-level": $props.level + 1,
      "aria-setsize": $options.getAriaSetSize(),
      "aria-posinset": $options.getAriaPosInset(index)
    }, [createElementVNode("div", {
      class: "p-menuitem-content",
      onClick: $event => $options.onItemClick($event, processedItem),
      onMouseenter: $event => $options.onItemMouseEnter($event, processedItem)
    }, [!$props.template ? (openBlock(), createElementBlock(Fragment, {
      key: 0
    }, [$options.getItemProp(processedItem, 'to') && !$options.isItemDisabled(processedItem) ? (openBlock(), createBlock(_component_router_link, {
      key: 0,
      to: $options.getItemProp(processedItem, 'to'),
      custom: ""
    }, {
      default: withCtx(({
        navigate,
        href,
        isActive,
        isExactActive
      }) => [withDirectives((openBlock(), createElementBlock("a", {
        href: href,
        class: normalizeClass($options.getItemActionClass(processedItem, {
          isActive,
          isExactActive
        })),
        tabindex: "-1",
        "aria-hidden": "true",
        onClick: $event => $options.onItemActionClick($event, navigate)
      }, [$options.getItemProp(processedItem, 'icon') ? (openBlock(), createElementBlock("span", {
        key: 0,
        class: normalizeClass($options.getItemIconClass(processedItem))
      }, null, 2)) : createCommentVNode("", true), createElementVNode("span", _hoisted_4$1$4, toDisplayString$1($options.getItemLabel(processedItem)), 1)], 10, _hoisted_3$1$6)), [[_directive_ripple]])]),
      _: 2
    }, 1032, ["to"])) : withDirectives((openBlock(), createElementBlock("a", {
      key: 1,
      href: $options.getItemProp(processedItem, 'url'),
      class: normalizeClass($options.getItemActionClass(processedItem)),
      target: $options.getItemProp(processedItem, 'target'),
      tabindex: "-1",
      "aria-hidden": "true"
    }, [$options.getItemProp(processedItem, 'icon') ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass($options.getItemIconClass(processedItem))
    }, null, 2)) : createCommentVNode("", true), createElementVNode("span", _hoisted_6$k, toDisplayString$1($options.getItemLabel(processedItem)), 1), $options.getItemProp(processedItem, 'items') ? (openBlock(), createElementBlock("span", {
      key: 1,
      class: normalizeClass($options.getSubmenuIcon())
    }, null, 2)) : createCommentVNode("", true)], 10, _hoisted_5$1$4)), [[_directive_ripple]])], 64)) : (openBlock(), createBlock(resolveDynamicComponent($props.template), {
      key: 1,
      item: processedItem.item
    }, null, 8, ["item"]))], 40, _hoisted_2$1$7), $options.isItemVisible(processedItem) && $options.isItemGroup(processedItem) ? (openBlock(), createBlock(_component_MenubarSub, {
      key: 0,
      menuId: $props.menuId,
      role: "menu",
      class: "p-submenu-list",
      focusedItemId: $props.focusedItemId,
      items: processedItem.items,
      mobileActive: $props.mobileActive,
      activeItemPath: $props.activeItemPath,
      template: $props.template,
      exact: $props.exact,
      level: $props.level + 1,
      onItemClick: _cache[0] || (_cache[0] = $event => _ctx.$emit('item-click', $event)),
      onItemMouseenter: _cache[1] || (_cache[1] = $event => _ctx.$emit('item-mouseenter', $event))
    }, null, 8, ["menuId", "focusedItemId", "items", "mobileActive", "activeItemPath", "template", "exact", "level"])) : createCommentVNode("", true)], 14, _hoisted_1$1$7)) : createCommentVNode("", true), $options.isItemVisible(processedItem) && $options.getItemProp(processedItem, 'separator') ? (openBlock(), createElementBlock("li", {
      key: 1,
      id: $options.getItemId(processedItem),
      style: normalizeStyle($options.getItemProp(processedItem, 'style')),
      class: normalizeClass($options.getSeparatorItemClass(processedItem)),
      role: "separator"
    }, null, 14, _hoisted_7$d)) : createCommentVNode("", true)], 64);
  }), 128))]);
}

script$1$7.render = render$1$7;
var script$1D = {
  name: 'Menubar',
  emits: ['focus', 'blur'],
  props: {
    model: {
      type: Array,
      default: null
    },
    exact: {
      type: Boolean,
      default: true
    },
    buttonProps: {
      type: null,
      default: null
    },
    'aria-labelledby': {
      type: String,
      default: null
    },
    'aria-label': {
      type: String,
      default: null
    }
  },

  data() {
    return {
      mobileActive: false,
      focused: false,
      focusedItemInfo: {
        index: -1,
        level: 0,
        parentKey: ''
      },
      activeItemPath: [],
      dirty: false
    };
  },

  watch: {
    activeItemPath(newPath) {
      if (ObjectUtils.isNotEmpty(newPath)) {
        this.bindOutsideClickListener();
        this.bindResizeListener();
      } else {
        this.unbindOutsideClickListener();
        this.unbindResizeListener();
      }
    }

  },
  outsideClickListener: null,
  container: null,
  menubar: null,

  beforeUnmount() {
    this.mobileActive = false;
    this.unbindOutsideClickListener();
    this.unbindResizeListener();

    if (this.container) {
      ZIndexUtils.clear(this.container);
    }

    this.container = null;
  },

  methods: {
    getItemProp(item, name) {
      return item ? ObjectUtils.getItemValue(item[name]) : undefined;
    },

    getItemLabel(item) {
      return this.getItemProp(item, 'label');
    },

    isItemDisabled(item) {
      return this.getItemProp(item, 'disabled');
    },

    isItemGroup(item) {
      return ObjectUtils.isNotEmpty(this.getItemProp(item, 'items'));
    },

    isItemSeparator(item) {
      return this.getItemProp(item, 'separator');
    },

    getProccessedItemLabel(processedItem) {
      return processedItem ? this.getItemLabel(processedItem.item) : undefined;
    },

    isProccessedItemGroup(processedItem) {
      return processedItem && ObjectUtils.isNotEmpty(processedItem.items);
    },

    toggle(event) {
      if (this.mobileActive) {
        this.mobileActive = false;
        ZIndexUtils.clear(this.menubar);
        this.hide();
      } else {
        this.mobileActive = true;
        ZIndexUtils.set('menu', this.menubar, this.$primevue.config.zIndex.menu);
        setTimeout(() => {
          this.show();
        }, 0);
      }

      this.bindOutsideClickListener();
      event.preventDefault();
    },

    show() {
      this.focusedItemInfo = {
        index: this.findFirstFocusedItemIndex(),
        level: 0,
        parentKey: ''
      };
      DomHandler.focus(this.menubar);
    },

    hide(event, isFocus) {
      if (this.mobileActive) {
        setTimeout(() => {
          DomHandler.focus(this.$refs.menubutton);
        }, 0);
      }

      this.activeItemPath = [];
      this.focusedItemInfo = {
        index: -1,
        level: 0,
        parentKey: ''
      };
      isFocus && DomHandler.focus(this.menubar);
      this.dirty = false;
    },

    onFocus(event) {
      this.focused = true;
      this.focusedItemInfo = this.focusedItemInfo.index !== -1 ? this.focusedItemInfo : {
        index: this.findFirstFocusedItemIndex(),
        level: 0,
        parentKey: ''
      };
      this.$emit('focus', event);
    },

    onBlur(event) {
      this.focused = false;
      this.focusedItemInfo = {
        index: -1,
        level: 0,
        parentKey: ''
      };
      this.searchValue = '';
      this.dirty = false;
      this.$emit('blur', event);
    },

    onKeyDown(event) {
      const metaKey = event.metaKey || event.ctrlKey;

      switch (event.code) {
        case 'ArrowDown':
          this.onArrowDownKey(event);
          break;

        case 'ArrowUp':
          this.onArrowUpKey(event);
          break;

        case 'ArrowLeft':
          this.onArrowLeftKey(event);
          break;

        case 'ArrowRight':
          this.onArrowRightKey(event);
          break;

        case 'Home':
          this.onHomeKey(event);
          break;

        case 'End':
          this.onEndKey(event);
          break;

        case 'Space':
          this.onSpaceKey(event);
          break;

        case 'Enter':
          this.onEnterKey(event);
          break;

        case 'Escape':
          this.onEscapeKey(event);
          break;

        case 'Tab':
          this.onTabKey(event);
          break;

        case 'PageDown':
        case 'PageUp':
        case 'Backspace':
        case 'ShiftLeft':
        case 'ShiftRight':
          //NOOP
          break;

        default:
          if (!metaKey && ObjectUtils.isPrintableCharacter(event.key)) {
            this.searchItems(event, event.key);
          }

          break;
      }
    },

    onItemChange(event) {
      const {
        processedItem,
        isFocus
      } = event;
      if (ObjectUtils.isEmpty(processedItem)) return;
      const {
        index,
        key,
        level,
        parentKey,
        items
      } = processedItem;
      const grouped = ObjectUtils.isNotEmpty(items);
      const activeItemPath = this.activeItemPath.filter(p => p.parentKey !== parentKey && p.parentKey !== key);
      grouped && activeItemPath.push(processedItem);
      this.focusedItemInfo = {
        index,
        level,
        parentKey
      };
      this.activeItemPath = activeItemPath;
      grouped && (this.dirty = true);
      isFocus && DomHandler.focus(this.menubar);
    },

    onItemClick(event) {
      const {
        originalEvent,
        processedItem
      } = event;
      const grouped = this.isProccessedItemGroup(processedItem);
      const root = ObjectUtils.isEmpty(processedItem.parent);
      const selected = this.isSelected(processedItem);

      if (selected) {
        const {
          index,
          key,
          level,
          parentKey
        } = processedItem;
        this.activeItemPath = this.activeItemPath.filter(p => key !== p.key && key.startsWith(p.key));
        this.focusedItemInfo = {
          index,
          level,
          parentKey
        };
        this.dirty = !root;
        DomHandler.focus(this.menubar);
      } else {
        if (grouped) {
          this.onItemChange(event);
        } else {
          this.hide(originalEvent, true);
          this.mobileActive = false;
        }
      }
    },

    onItemMouseEnter(event) {
      if (!this.mobileActive && this.dirty) {
        this.onItemChange(event);
      }
    },

    menuButtonClick(event) {
      this.toggle(event);
    },

    menuButtonKeydown(event) {
      (event.code === 'Enter' || event.code === 'Space') && this.menuButtonClick(event);
    },

    onArrowDownKey(event) {
      const processedItem = this.visibleItems[this.focusedItemInfo.index];
      const root = processedItem ? ObjectUtils.isEmpty(processedItem.parent) : null;

      if (root) {
        const grouped = this.isProccessedItemGroup(processedItem);

        if (grouped) {
          this.onItemChange({
            originalEvent: event,
            processedItem
          });
          this.focusedItemInfo = {
            index: -1,
            parentKey: processedItem.key
          };
          this.onArrowRightKey(event);
        }
      } else {
        const itemIndex = this.focusedItemInfo.index !== -1 ? this.findNextItemIndex(this.focusedItemInfo.index) : this.findFirstFocusedItemIndex();
        this.changeFocusedItemIndex(event, itemIndex);
        event.preventDefault();
      }
    },

    onArrowUpKey(event) {
      const processedItem = this.visibleItems[this.focusedItemInfo.index];
      const root = ObjectUtils.isEmpty(processedItem.parent);

      if (root) {
        const grouped = this.isProccessedItemGroup(processedItem);

        if (grouped) {
          this.onItemChange({
            originalEvent: event,
            processedItem
          });
          this.focusedItemInfo = {
            index: -1,
            parentKey: processedItem.key
          };
          const itemIndex = this.findLastItemIndex();
          this.changeFocusedItemIndex(event, itemIndex);
        }
      } else {
        const parentItem = this.activeItemPath.find(p => p.key === processedItem.parentKey);

        if (this.focusedItemInfo.index === 0) {
          this.focusedItemInfo = {
            index: -1,
            parentKey: parentItem ? parentItem.parentKey : ''
          };
          this.searchValue = '';
          this.onArrowLeftKey(event);
          this.activeItemPath = this.activeItemPath.filter(p => p.parentKey !== this.focusedItemInfo.parentKey);
        } else {
          const itemIndex = this.focusedItemInfo.index !== -1 ? this.findPrevItemIndex(this.focusedItemInfo.index) : this.findLastFocusedItemIndex();
          this.changeFocusedItemIndex(event, itemIndex);
        }
      }

      event.preventDefault();
    },

    onArrowLeftKey(event) {
      const processedItem = this.visibleItems[this.focusedItemInfo.index];
      const parentItem = processedItem ? this.activeItemPath.find(p => p.key === processedItem.parentKey) : null;

      if (parentItem) {
        this.onItemChange({
          originalEvent: event,
          processedItem: parentItem
        });
        this.activeItemPath = this.activeItemPath.filter(p => p.parentKey !== this.focusedItemInfo.parentKey);
        event.preventDefault();
      } else {
        const itemIndex = this.focusedItemInfo.index !== -1 ? this.findPrevItemIndex(this.focusedItemInfo.index) : this.findLastFocusedItemIndex();
        this.changeFocusedItemIndex(event, itemIndex);
        event.preventDefault();
      }
    },

    onArrowRightKey(event) {
      const processedItem = this.visibleItems[this.focusedItemInfo.index];
      const parentItem = processedItem ? this.activeItemPath.find(p => p.key === processedItem.parentKey) : null;

      if (parentItem) {
        const grouped = this.isProccessedItemGroup(processedItem);

        if (grouped) {
          this.onItemChange({
            originalEvent: event,
            processedItem
          });
          this.focusedItemInfo = {
            index: -1,
            parentKey: processedItem.key
          };
          this.onArrowDownKey(event);
        }
      } else {
        const itemIndex = this.focusedItemInfo.index !== -1 ? this.findNextItemIndex(this.focusedItemInfo.index) : this.findFirstFocusedItemIndex();
        this.changeFocusedItemIndex(event, itemIndex);
        event.preventDefault();
      }
    },

    onHomeKey(event) {
      this.changeFocusedItemIndex(event, this.findFirstItemIndex());
      event.preventDefault();
    },

    onEndKey(event) {
      this.changeFocusedItemIndex(event, this.findLastItemIndex());
      event.preventDefault();
    },

    onEnterKey(event) {
      if (this.focusedItemInfo.index !== -1) {
        const element = DomHandler.findSingle(this.menubar, `li[id="${`${this.focusedItemId}`}"]`);
        const anchorElement = element && DomHandler.findSingle(element, '.p-menuitem-link');
        anchorElement ? anchorElement.click() : element && element.click();
        const processedItem = this.visibleItems[this.focusedItemInfo.index];
        const grouped = this.isProccessedItemGroup(processedItem);
        !grouped && (this.focusedItemInfo.index = this.findFirstFocusedItemIndex());
      }

      event.preventDefault();
    },

    onSpaceKey(event) {
      this.onEnterKey(event);
    },

    onEscapeKey(event) {
      this.hide(event, true);
      this.focusedItemInfo.index = this.findFirstFocusedItemIndex();
      event.preventDefault();
    },

    onTabKey(event) {
      if (this.focusedItemInfo.index !== -1) {
        const processedItem = this.visibleItems[this.focusedItemInfo.index];
        const grouped = this.isProccessedItemGroup(processedItem);
        !grouped && this.onItemChange({
          originalEvent: event,
          processedItem
        });
      }

      this.hide();
    },

    bindOutsideClickListener() {
      if (!this.outsideClickListener) {
        this.outsideClickListener = event => {
          const isOutsideContainer = this.menubar !== event.target && !this.menubar.contains(event.target);
          const isOutsideMenuButton = this.mobileActive && this.$refs.menubutton !== event.target && !this.$refs.menubutton.contains(event.target);

          if (isOutsideContainer) {
            isOutsideMenuButton ? this.mobileActive = false : this.hide();
          }
        };

        document.addEventListener('click', this.outsideClickListener);
      }
    },

    unbindOutsideClickListener() {
      if (this.outsideClickListener) {
        document.removeEventListener('click', this.outsideClickListener);
        this.outsideClickListener = null;
      }
    },

    bindResizeListener() {
      if (!this.resizeListener) {
        this.resizeListener = event => {
          if (!DomHandler.isTouchDevice()) {
            this.hide(event, true);
          }

          this.mobileActive = false;
        };

        window.addEventListener('resize', this.resizeListener);
      }
    },

    unbindResizeListener() {
      if (this.resizeListener) {
        window.removeEventListener('resize', this.resizeListener);
        this.resizeListener = null;
      }
    },

    isItemMatched(processedItem) {
      return this.isValidItem(processedItem) && this.getProccessedItemLabel(processedItem).toLocaleLowerCase().startsWith(this.searchValue.toLocaleLowerCase());
    },

    isValidItem(processedItem) {
      return !!processedItem && !this.isItemDisabled(processedItem.item) && !this.isItemSeparator(processedItem.item);
    },

    isValidSelectedItem(processedItem) {
      return this.isValidItem(processedItem) && this.isSelected(processedItem);
    },

    isSelected(processedItem) {
      return this.activeItemPath.some(p => p.key === processedItem.key);
    },

    findFirstItemIndex() {
      return this.visibleItems.findIndex(processedItem => this.isValidItem(processedItem));
    },

    findLastItemIndex() {
      return ObjectUtils.findLastIndex(this.visibleItems, processedItem => this.isValidItem(processedItem));
    },

    findNextItemIndex(index) {
      const matchedItemIndex = index < this.visibleItems.length - 1 ? this.visibleItems.slice(index + 1).findIndex(processedItem => this.isValidItem(processedItem)) : -1;
      return matchedItemIndex > -1 ? matchedItemIndex + index + 1 : index;
    },

    findPrevItemIndex(index) {
      const matchedItemIndex = index > 0 ? ObjectUtils.findLastIndex(this.visibleItems.slice(0, index), processedItem => this.isValidItem(processedItem)) : -1;
      return matchedItemIndex > -1 ? matchedItemIndex : index;
    },

    findSelectedItemIndex() {
      return this.visibleItems.findIndex(processedItem => this.isValidSelectedItem(processedItem));
    },

    findFirstFocusedItemIndex() {
      const selectedIndex = this.findSelectedItemIndex();
      return selectedIndex < 0 ? this.findFirstItemIndex() : selectedIndex;
    },

    findLastFocusedItemIndex() {
      const selectedIndex = this.findSelectedItemIndex();
      return selectedIndex < 0 ? this.findLastItemIndex() : selectedIndex;
    },

    searchItems(event, char) {
      this.searchValue = (this.searchValue || '') + char;
      let itemIndex = -1;
      let matched = false;

      if (this.focusedItemInfo.index !== -1) {
        itemIndex = this.visibleItems.slice(this.focusedItemInfo.index).findIndex(processedItem => this.isItemMatched(processedItem));
        itemIndex = itemIndex === -1 ? this.visibleItems.slice(0, this.focusedItemInfo.index).findIndex(processedItem => this.isItemMatched(processedItem)) : itemIndex + this.focusedItemInfo.index;
      } else {
        itemIndex = this.visibleItems.findIndex(processedItem => this.isItemMatched(processedItem));
      }

      if (itemIndex !== -1) {
        matched = true;
      }

      if (itemIndex === -1 && this.focusedItemInfo.index === -1) {
        itemIndex = this.findFirstFocusedItemIndex();
      }

      if (itemIndex !== -1) {
        this.changeFocusedItemIndex(event, itemIndex);
      }

      if (this.searchTimeout) {
        clearTimeout(this.searchTimeout);
      }

      this.searchTimeout = setTimeout(() => {
        this.searchValue = '';
        this.searchTimeout = null;
      }, 500);
      return matched;
    },

    changeFocusedItemIndex(event, index) {
      if (this.focusedItemInfo.index !== index) {
        this.focusedItemInfo.index = index;
        this.scrollInView();
      }
    },

    scrollInView(index = -1) {
      const id = index !== -1 ? `${this.id}_${index}` : this.focusedItemId;
      const element = DomHandler.findSingle(this.menubar, `li[id="${id}"]`);

      if (element) {
        element.scrollIntoView && element.scrollIntoView({
          block: 'nearest',
          inline: 'start'
        });
      }
    },

    createProcessedItems(items, level = 0, parent = {}, parentKey = '') {
      const processedItems = [];
      items && items.forEach((item, index) => {
        const key = (parentKey !== '' ? parentKey + '_' : '') + index;
        const newItem = {
          item,
          index,
          level,
          key,
          parent,
          parentKey
        };
        newItem['items'] = this.createProcessedItems(item.items, level + 1, newItem, key);
        processedItems.push(newItem);
      });
      return processedItems;
    },

    containerRef(el) {
      this.container = el;
    },

    menubarRef(el) {
      this.menubar = el ? el.$el : undefined;
    }

  },
  computed: {
    containerClass() {
      return ['p-menubar p-component', {
        'p-menubar-mobile-active': this.mobileActive
      }];
    },

    processedItems() {
      return this.createProcessedItems(this.model || []);
    },

    visibleItems() {
      const processedItem = this.activeItemPath.find(p => p.key === this.focusedItemInfo.parentKey);
      return processedItem ? processedItem.items : this.processedItems;
    },

    id() {
      return this.$attrs.id || UniqueComponentId();
    },

    focusedItemId() {
      return this.focusedItemInfo.index !== -1 ? `${this.id}${ObjectUtils.isNotEmpty(this.focusedItemInfo.parentKey) ? '_' + this.focusedItemInfo.parentKey : ''}_${this.focusedItemInfo.index}` : null;
    }

  },
  components: {
    MenubarSub: script$1$7
  }
};
const _hoisted_1$S = {
  key: 0,
  class: "p-menubar-start"
};
const _hoisted_2$J = ["aria-haspopup", "aria-expanded", "aria-controls", "aria-label"];

const _hoisted_3$A = /*#__PURE__*/createElementVNode("i", {
  class: "pi pi-bars"
}, null, -1);

const _hoisted_4$u = [_hoisted_3$A];
const _hoisted_5$p = {
  key: 2,
  class: "p-menubar-end"
};

function render$y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_MenubarSub = resolveComponent("MenubarSub");

  return openBlock(), createElementBlock("div", {
    ref: $options.containerRef,
    class: normalizeClass($options.containerClass)
  }, [_ctx.$slots.start ? (openBlock(), createElementBlock("div", _hoisted_1$S, [renderSlot(_ctx.$slots, "start")])) : createCommentVNode("", true), $props.model.length > 0 ? (openBlock(), createElementBlock("a", mergeProps({
    key: 1,
    ref: "menubutton",
    role: "button",
    tabindex: "0",
    class: "p-menubar-button",
    "aria-haspopup": $props.model.length && $props.model.length > 0 ? true : false,
    "aria-expanded": $data.mobileActive,
    "aria-controls": $options.id,
    "aria-label": _ctx.$primevue.config.locale.aria.navigation,
    onClick: _cache[0] || (_cache[0] = $event => $options.menuButtonClick($event)),
    onKeydown: _cache[1] || (_cache[1] = $event => $options.menuButtonKeydown($event))
  }, $props.buttonProps), _hoisted_4$u, 16, _hoisted_2$J)) : createCommentVNode("", true), createVNode(_component_MenubarSub, {
    ref: $options.menubarRef,
    id: $options.id,
    class: "p-menubar-root-list",
    role: "menubar",
    items: $options.processedItems,
    template: _ctx.$slots.item,
    root: true,
    mobileActive: $data.mobileActive,
    tabindex: "0",
    "aria-activedescendant": $data.focused ? $options.focusedItemId : undefined,
    menuId: $options.id,
    focusedItemId: $data.focused ? $options.focusedItemId : undefined,
    activeItemPath: $data.activeItemPath,
    exact: $props.exact,
    level: 0,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    onFocus: $options.onFocus,
    onBlur: $options.onBlur,
    onKeydown: $options.onKeyDown,
    onItemClick: $options.onItemClick,
    onItemMouseenter: $options.onItemMouseEnter
  }, null, 8, ["id", "items", "template", "mobileActive", "aria-activedescendant", "menuId", "focusedItemId", "activeItemPath", "exact", "aria-labelledby", "aria-label", "onFocus", "onBlur", "onKeydown", "onItemClick", "onItemMouseenter"]), _ctx.$slots.end ? (openBlock(), createElementBlock("div", _hoisted_5$p, [renderSlot(_ctx.$slots, "end")])) : createCommentVNode("", true)], 2);
}

function styleInject$s(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$z = "\n.p-menubar {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n.p-menubar ul {\n    margin: 0;\n    padding: 0;\n    list-style: none;\n}\n.p-menubar .p-menuitem-link {\n    cursor: pointer;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    text-decoration: none;\n    overflow: hidden;\n    position: relative;\n}\n.p-menubar .p-menuitem-text {\n    line-height: 1;\n}\n.p-menubar .p-menuitem {\n    position: relative;\n}\n.p-menubar-root-list {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -ms-flex-wrap: wrap;\n        flex-wrap: wrap;\n}\n.p-menubar-root-list > li ul {\n    display: none;\n    z-index: 1;\n}\n.p-menubar-root-list > .p-menuitem-active > .p-submenu-list {\n    display: block;\n}\n.p-menubar .p-submenu-list {\n    display: none;\n    position: absolute;\n    z-index: 1;\n}\n.p-menubar .p-submenu-list > .p-menuitem-active > .p-submenu-list {\n    display: block;\n    left: 100%;\n    top: 0;\n}\n.p-menubar .p-submenu-list .p-menuitem .p-menuitem-content .p-menuitem-link .p-submenu-icon {\n    margin-left: auto;\n}\n.p-menubar .p-menubar-end {\n    margin-left: auto;\n    -ms-flex-item-align: center;\n        align-self: center;\n}\n.p-menubar-button {\n    display: none;\n    cursor: pointer;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    text-decoration: none;\n}\n";
styleInject$s(css_248z$z);
script$1D.render = render$y;

var OverlayEventBus = primebus();

var script$1C = {
  name: 'Portal',
  props: {
    appendTo: {
      type: String,
      default: 'body'
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },

  data() {
    return {
      mounted: false
    };
  },

  mounted() {
    this.mounted = DomHandler.isClient();
  },

  computed: {
    inline() {
      return this.disabled || this.appendTo === 'self';
    }

  }
};

function render$x(_ctx, _cache, $props, $setup, $data, $options) {
  return $options.inline ? renderSlot(_ctx.$slots, "default", {
    key: 0
  }) : $data.mounted ? (openBlock(), createBlock(Teleport, {
    key: 1,
    to: $props.appendTo
  }, [renderSlot(_ctx.$slots, "default")], 8, ["to"])) : createCommentVNode("", true);
}

script$1C.render = render$x;

var script$1$6 = {
  name: 'Menuitem',
  inheritAttrs: false,
  emits: ['item-click'],
  props: {
    item: null,
    template: null,
    exact: null,
    id: null,
    focusedOptionId: null
  },
  methods: {
    getItemProp(processedItem, name) {
      return processedItem && processedItem.item ? ObjectUtils.getItemValue(processedItem.item[name]) : undefined;
    },

    onItemActionClick(event, navigate) {
      navigate && navigate(event);
    },

    onItemClick(event) {
      const command = this.getItemProp(this.item, 'command');
      command && command({
        originalEvent: event,
        item: this.item.item
      });
      this.$emit('item-click', {
        originalEvent: event,
        item: this.item,
        id: this.id
      });
    },

    containerClass() {
      return ['p-menuitem', this.item.class, {
        'p-focus': this.id === this.focusedOptionId,
        'p-disabled': this.disabled()
      }];
    },

    linkClass(routerProps) {
      return ['p-menuitem-link', {
        'router-link-active': routerProps && routerProps.isActive,
        'router-link-active-exact': this.exact && routerProps && routerProps.isExactActive
      }];
    },

    visible() {
      return typeof this.item.visible === 'function' ? this.item.visible() : this.item.visible !== false;
    },

    disabled() {
      return typeof this.item.disabled === 'function' ? this.item.disabled() : this.item.disabled;
    },

    label() {
      return typeof this.item.label === 'function' ? this.item.label() : this.item.label;
    }

  },
  directives: {
    ripple: Ripple
  }
};
const _hoisted_1$1$6 = ["id", "aria-label", "aria-disabled"];
const _hoisted_2$1$6 = ["href", "onClick"];
const _hoisted_3$1$5 = {
  class: "p-menuitem-text"
};
const _hoisted_4$t = ["href", "target"];
const _hoisted_5$o = {
  class: "p-menuitem-text"
};

function render$1$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_router_link = resolveComponent("router-link");

  const _directive_ripple = resolveDirective("ripple");

  return $options.visible() ? (openBlock(), createElementBlock("li", {
    key: 0,
    id: $props.id,
    class: normalizeClass($options.containerClass()),
    role: "menuitem",
    style: normalizeStyle($props.item.style),
    "aria-label": $options.label(),
    "aria-disabled": $options.disabled()
  }, [createElementVNode("div", {
    class: "p-menuitem-content",
    onClick: _cache[0] || (_cache[0] = $event => $options.onItemClick($event))
  }, [!$props.template ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [$props.item.to && !$options.disabled() ? (openBlock(), createBlock(_component_router_link, {
    key: 0,
    to: $props.item.to,
    custom: ""
  }, {
    default: withCtx(({
      navigate,
      href,
      isActive,
      isExactActive
    }) => [withDirectives((openBlock(), createElementBlock("a", {
      href: href,
      class: normalizeClass($options.linkClass({
        isActive,
        isExactActive
      })),
      tabindex: "-1",
      "aria-hidden": "true",
      onClick: $event => $options.onItemActionClick($event, navigate)
    }, [$props.item.icon ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass(['p-menuitem-icon', $props.item.icon])
    }, null, 2)) : createCommentVNode("", true), createElementVNode("span", _hoisted_3$1$5, toDisplayString$1($options.label()), 1)], 10, _hoisted_2$1$6)), [[_directive_ripple]])]),
    _: 1
  }, 8, ["to"])) : withDirectives((openBlock(), createElementBlock("a", {
    key: 1,
    href: $props.item.url,
    class: normalizeClass($options.linkClass()),
    target: $props.item.target,
    tabindex: "-1",
    "aria-hidden": "true"
  }, [$props.item.icon ? (openBlock(), createElementBlock("span", {
    key: 0,
    class: normalizeClass(['p-menuitem-icon', $props.item.icon])
  }, null, 2)) : createCommentVNode("", true), createElementVNode("span", _hoisted_5$o, toDisplayString$1($options.label()), 1)], 10, _hoisted_4$t)), [[_directive_ripple]])], 64)) : (openBlock(), createBlock(resolveDynamicComponent($props.template), {
    key: 1,
    item: $props.item
  }, null, 8, ["item"]))])], 14, _hoisted_1$1$6)) : createCommentVNode("", true);
}

script$1$6.render = render$1$6;
var script$1B = {
  name: 'Menu',
  inheritAttrs: false,
  emits: ['show', 'hide', 'focus', 'blur'],
  props: {
    popup: {
      type: Boolean,
      default: false
    },
    model: {
      type: Array,
      default: null
    },
    appendTo: {
      type: String,
      default: 'body'
    },
    autoZIndex: {
      type: Boolean,
      default: true
    },
    baseZIndex: {
      type: Number,
      default: 0
    },
    exact: {
      type: Boolean,
      default: true
    },
    tabindex: {
      type: Number,
      default: 0
    },
    'aria-label': {
      type: String,
      default: null
    },
    'aria-labelledby': {
      type: String,
      default: null
    }
  },

  data() {
    return {
      overlayVisible: false,
      focused: false,
      focusedOptionIndex: -1,
      selectedOptionIndex: -1
    };
  },

  target: null,
  outsideClickListener: null,
  scrollHandler: null,
  resizeListener: null,
  container: null,
  list: null,

  mounted() {
    if (!this.popup) {
      this.bindResizeListener();
      this.bindOutsideClickListener();
    }
  },

  beforeUnmount() {
    this.unbindResizeListener();
    this.unbindOutsideClickListener();

    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }

    this.target = null;

    if (this.container && this.autoZIndex) {
      ZIndexUtils.clear(this.container);
    }

    this.container = null;
  },

  methods: {
    itemClick(event) {
      const item = event.item;

      if (this.disabled(item)) {
        return;
      }

      if (item.command) {
        item.command(event);
      }

      if (item.to && event.navigate) {
        event.navigate(event.originalEvent);
      }

      if (this.overlayVisible) this.hide();

      if (!this.popup && this.focusedOptionIndex !== event.id) {
        this.focusedOptionIndex = event.id;
      }
    },

    onListFocus(event) {
      this.focused = true;

      if (!this.popup) {
        if (this.selectedOptionIndex !== -1) {
          this.changeFocusedOptionIndex(this.selectedOptionIndex);
          this.selectedOptionIndex = -1;
        } else this.changeFocusedOptionIndex(0);
      }

      this.$emit('focus', event);
    },

    onListBlur(event) {
      this.focused = false;
      this.focusedOptionIndex = -1;
      this.$emit('blur', event);
    },

    onListKeyDown(event) {
      switch (event.code) {
        case 'ArrowDown':
          this.onArrowDownKey(event);
          break;

        case 'ArrowUp':
          this.onArrowUpKey(event);
          break;

        case 'Home':
          this.onHomeKey(event);
          break;

        case 'End':
          this.onEndKey(event);
          break;

        case 'Enter':
          this.onEnterKey(event);
          break;

        case 'Space':
          this.onSpaceKey(event);
          break;

        case 'Tab':
          this.overlayVisible && this.hide();
          break;
      }
    },

    onArrowDownKey(event) {
      const optionIndex = this.findNextOptionIndex(this.focusedOptionIndex);
      this.changeFocusedOptionIndex(optionIndex);
      event.preventDefault();
    },

    onArrowUpKey(event) {
      if (event.altKey && this.popup) {
        DomHandler.focus(this.target);
        this.hide();
        event.preventDefault();
      } else {
        const optionIndex = this.findPrevOptionIndex(this.focusedOptionIndex);
        this.changeFocusedOptionIndex(optionIndex);
        event.preventDefault();
      }
    },

    onHomeKey(event) {
      this.changeFocusedOptionIndex(0);
      event.preventDefault();
    },

    onEndKey(event) {
      this.changeFocusedOptionIndex(DomHandler.find(this.container, 'li.p-menuitem:not(.p-disabled)').length - 1);
      event.preventDefault();
    },

    onEnterKey(event) {
      const element = DomHandler.findSingle(this.list, `li[id="${`${this.focusedOptionIndex}`}"]`);
      const anchorElement = element && DomHandler.findSingle(element, '.p-menuitem-link');
      this.popup && DomHandler.focus(this.target);
      anchorElement ? anchorElement.click() : element && element.click();
      event.preventDefault();
    },

    onSpaceKey(event) {
      this.onEnterKey(event);
    },

    findNextOptionIndex(index) {
      const links = DomHandler.find(this.container, 'li.p-menuitem:not(.p-disabled)');
      const matchedOptionIndex = [...links].findIndex(link => link.id === index);
      return matchedOptionIndex > -1 ? matchedOptionIndex + 1 : 0;
    },

    findPrevOptionIndex(index) {
      const links = DomHandler.find(this.container, 'li.p-menuitem:not(.p-disabled)');
      const matchedOptionIndex = [...links].findIndex(link => link.id === index);
      return matchedOptionIndex > -1 ? matchedOptionIndex - 1 : 0;
    },

    changeFocusedOptionIndex(index) {
      const links = DomHandler.find(this.container, 'li.p-menuitem:not(.p-disabled)');
      let order = index > links.length ? links.length - 1 : index < 0 ? 0 : index;
      order > -1 && links.length > 0 && (this.focusedOptionIndex = links[order].getAttribute('id'));
    },

    toggle(event) {
      if (this.overlayVisible) this.hide();else this.show(event);
    },

    show(event) {
      this.overlayVisible = true;
      this.target = event.currentTarget;
    },

    hide() {
      this.overlayVisible = false;
      this.target = null;
    },

    onEnter(el) {
      this.alignOverlay();
      this.bindOutsideClickListener();
      this.bindResizeListener();
      this.bindScrollListener();

      if (this.autoZIndex) {
        ZIndexUtils.set('menu', el, this.baseZIndex + this.$primevue.config.zIndex.menu);
      }

      if (this.popup) {
        DomHandler.focus(this.list);
        this.changeFocusedOptionIndex(0);
      }

      this.$emit('show');
    },

    onLeave() {
      this.unbindOutsideClickListener();
      this.unbindResizeListener();
      this.unbindScrollListener();
      this.$emit('hide');
    },

    onAfterLeave(el) {
      if (this.autoZIndex) {
        ZIndexUtils.clear(el);
      }
    },

    alignOverlay() {
      DomHandler.absolutePosition(this.container, this.target);
      this.container.style.minWidth = DomHandler.getOuterWidth(this.target) + 'px';
    },

    bindOutsideClickListener() {
      if (!this.outsideClickListener) {
        this.outsideClickListener = event => {
          const isOutsideContainer = this.container && !this.container.contains(event.target);
          const isOutsideTarget = !(this.target && (this.target === event.target || this.target.contains(event.target)));

          if (this.overlayVisible && isOutsideContainer && isOutsideTarget) {
            this.hide();
          } else if (!this.popup && isOutsideContainer && isOutsideTarget) {
            this.focusedOptionIndex = -1;
          }
        };

        document.addEventListener('click', this.outsideClickListener);
      }
    },

    unbindOutsideClickListener() {
      if (this.outsideClickListener) {
        document.removeEventListener('click', this.outsideClickListener);
        this.outsideClickListener = null;
      }
    },

    bindScrollListener() {
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.target, () => {
          if (this.overlayVisible) {
            this.hide();
          }
        });
      }

      this.scrollHandler.bindScrollListener();
    },

    unbindScrollListener() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    },

    bindResizeListener() {
      if (!this.resizeListener) {
        this.resizeListener = () => {
          if (this.overlayVisible && !DomHandler.isTouchDevice()) {
            this.hide();
          }
        };

        window.addEventListener('resize', this.resizeListener);
      }
    },

    unbindResizeListener() {
      if (this.resizeListener) {
        window.removeEventListener('resize', this.resizeListener);
        this.resizeListener = null;
      }
    },

    visible(item) {
      return typeof item.visible === 'function' ? item.visible() : item.visible !== false;
    },

    disabled(item) {
      return typeof item.disabled === 'function' ? item.disabled() : item.disabled;
    },

    label(item) {
      return typeof item.label === 'function' ? item.label() : item.label;
    },

    separatorClass(item) {
      return ['p-menuitem-separator', item.class];
    },

    onOverlayClick(event) {
      OverlayEventBus.emit('overlay-click', {
        originalEvent: event,
        target: this.target
      });
    },

    containerRef(el) {
      this.container = el;
    },

    listRef(el) {
      this.list = el;
    }

  },
  computed: {
    containerClass() {
      return ['p-menu p-component', {
        'p-menu-overlay': this.popup,
        'p-input-filled': this.$primevue.config.inputStyle === 'filled',
        'p-ripple-disabled': this.$primevue.config.ripple === false
      }];
    },

    id() {
      return this.$attrs.id || UniqueComponentId();
    },

    focusedOptionId() {
      return this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : null;
    }

  },
  components: {
    PVMenuitem: script$1$6,
    Portal: script$1C
  }
};
const _hoisted_1$R = ["id"];
const _hoisted_2$I = ["id", "tabindex", "aria-activedescendant", "aria-label", "aria-labelledby"];
const _hoisted_3$z = ["id"];

function render$w(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PVMenuitem = resolveComponent("PVMenuitem");

  const _component_Portal = resolveComponent("Portal");

  return openBlock(), createBlock(_component_Portal, {
    appendTo: $props.appendTo,
    disabled: !$props.popup
  }, {
    default: withCtx(() => [createVNode(Transition, {
      name: "p-connected-overlay",
      onEnter: $options.onEnter,
      onLeave: $options.onLeave,
      onAfterLeave: $options.onAfterLeave
    }, {
      default: withCtx(() => [($props.popup ? $data.overlayVisible : true) ? (openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        ref: $options.containerRef,
        id: $options.id,
        class: $options.containerClass
      }, _ctx.$attrs, {
        onClick: _cache[3] || (_cache[3] = (...args) => $options.onOverlayClick && $options.onOverlayClick(...args))
      }), [createElementVNode("ul", {
        ref: $options.listRef,
        id: $options.id + '_list',
        class: "p-menu-list p-reset",
        role: "menu",
        tabindex: $props.tabindex,
        "aria-activedescendant": $data.focused ? $options.focusedOptionId : undefined,
        "aria-label": _ctx.ariaLabel,
        "aria-labelledby": _ctx.ariaLabelledby,
        onFocus: _cache[0] || (_cache[0] = (...args) => $options.onListFocus && $options.onListFocus(...args)),
        onBlur: _cache[1] || (_cache[1] = (...args) => $options.onListBlur && $options.onListBlur(...args)),
        onKeydown: _cache[2] || (_cache[2] = (...args) => $options.onListKeyDown && $options.onListKeyDown(...args))
      }, [(openBlock(true), createElementBlock(Fragment, null, renderList($props.model, (item, i) => {
        return openBlock(), createElementBlock(Fragment, {
          key: $options.label(item) + i.toString()
        }, [item.items && $options.visible(item) && !item.separator ? (openBlock(), createElementBlock(Fragment, {
          key: 0
        }, [item.items ? (openBlock(), createElementBlock("li", {
          key: 0,
          id: $options.id + '_' + i,
          class: "p-submenu-header",
          role: "none"
        }, [renderSlot(_ctx.$slots, "item", {
          item: item
        }, () => [createTextVNode(toDisplayString$1($options.label(item)), 1)])], 8, _hoisted_3$z)) : createCommentVNode("", true), (openBlock(true), createElementBlock(Fragment, null, renderList(item.items, (child, j) => {
          return openBlock(), createElementBlock(Fragment, {
            key: child.label + i + '_' + j
          }, [$options.visible(child) && !child.separator ? (openBlock(), createBlock(_component_PVMenuitem, {
            key: 0,
            id: $options.id + '_' + i + '_' + j,
            item: child,
            template: _ctx.$slots.item,
            exact: $props.exact,
            focusedOptionId: $options.focusedOptionId,
            onItemClick: $options.itemClick
          }, null, 8, ["id", "item", "template", "exact", "focusedOptionId", "onItemClick"])) : $options.visible(child) && child.separator ? (openBlock(), createElementBlock("li", {
            key: 'separator' + i + j,
            class: normalizeClass($options.separatorClass(item)),
            style: normalizeStyle(child.style),
            role: "separator"
          }, null, 6)) : createCommentVNode("", true)], 64);
        }), 128))], 64)) : $options.visible(item) && item.separator ? (openBlock(), createElementBlock("li", {
          key: 'separator' + i.toString(),
          class: normalizeClass($options.separatorClass(item)),
          style: normalizeStyle(item.style),
          role: "separator"
        }, null, 6)) : (openBlock(), createBlock(_component_PVMenuitem, {
          key: $options.label(item) + i.toString(),
          id: $options.id + '_' + i,
          item: item,
          template: _ctx.$slots.item,
          exact: $props.exact,
          focusedOptionId: $options.focusedOptionId,
          onItemClick: $options.itemClick
        }, null, 8, ["id", "item", "template", "exact", "focusedOptionId", "onItemClick"]))], 64);
      }), 128))], 40, _hoisted_2$I)], 16, _hoisted_1$R)) : createCommentVNode("", true)]),
      _: 3
    }, 8, ["onEnter", "onLeave", "onAfterLeave"])]),
    _: 3
  }, 8, ["appendTo", "disabled"]);
}

function styleInject$r(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$y = "\n.p-menu-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.p-menu ul {\n    margin: 0;\n    padding: 0;\n    list-style: none;\n}\n.p-menu .p-menuitem-link {\n    cursor: pointer;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    text-decoration: none;\n    overflow: hidden;\n    position: relative;\n}\n.p-menu .p-menuitem-text {\n    line-height: 1;\n}\n";
styleInject$r(css_248z$y);
script$1B.render = render$w;

const _hoisted_1$Q = ["href", "onClick"];
const _hoisted_2$H = { key: 1 };
const _hoisted_3$y = ["href", "onClick"];
const _hoisted_4$s = ["onClick"];
const _hoisted_5$n = { key: 1 };
const _hoisted_6$j = ["onClick"];


var script$1A = {
  props: {
    name : [String, Object]
},
  setup(__props) {



const _profile = configs.get("profile");
const client = inject("client");

const items = ref([]);
const account_items = ref([]);
const report_items = ref([]);
const menu = ref();
const report_menu = ref();

let routes = getEntities();

let arr = [];
let carr = [];

for(const i in routes) {
    const route = routes[i];
    if (!route.parent) {
        if (route.min_rows == 1 && route.max_rows == 1 && route.cells['--owner'] && route.cells['--owner'].reference == _profile) {
            carr.push({
                label : route.name,
                model : i,
                is_report : false
            });
            
        } else if (route.perms && route.perms.includes("get")) {
            arr.push({
                label : route.name,
                model : i,
                is_report : false
            });

            report_items.value.push({
            label : route.name,
            model : i
        });
        }

        
    }
    
}

arr.push({
    'label' : 'Reports',
    reports : report_items,
    is_report : true
});

items.value = arr;

carr.push({
    label : 'Logout',
    command() {
        logout();
    }
});

account_items.value = carr;
/*
        items.value.push({
            label : 'Logout',
            command() {
                logout();
            }
        })
*/

function logout()  {
    return client.post("/user/logout", {'x-force-auth-cookies' : 1})
    .then(() => {
        location.href = configs.get("base") + "/";
    });
}

const toggle = (event) => {
    menu.value.toggle(event);
};


const toggleReports = (event) => {
    report_menu.value.toggle(event);
};

return (_ctx, _cache) => {
  const _component_router_link = resolveComponent("router-link");

  return (openBlock(), createBlock(unref(script$1D), { model: items.value }, {
    item: withCtx(({item}) => [
      (item.is_report == false)
        ? (openBlock(), createBlock(_component_router_link, {
            key: 0,
            to: { name : 'repo', params : { 'model' : item.model }}
          }, {
            default: withCtx(({href, route, navigate, isActive, isExactActive}) => [
              createElementVNode("a", {
                href: href,
                onClick: navigate,
                class: normalizeClass(["p-menuitem-link p-menuitem-content", {'active-link': isActive, 'active-link-exact': isExactActive}])
              }, toDisplayString$1(item.label), 11 /* TEXT, CLASS, PROPS */, _hoisted_1$Q)
            ]),
            _: 2 /* DYNAMIC */
          }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["to"]))
        : (openBlock(), createElementBlock("div", _hoisted_2$H, [
            createElementVNode("a", {
              class: "p-menuitem-link p-menuitem-content",
              onClick: toggleReports
            }, "Reports"),
            createVNode(unref(script$1B), {
              id: "report_menu",
              ref_key: "report_menu",
              ref: report_menu,
              model: report_items.value,
              popup: true
            }, {
              item: withCtx(({item}) => [
                createVNode(_component_router_link, {
                  to: { name : 'report', params : { 'model' : item.model }}
                }, {
                  default: withCtx(({href, route, navigate, isActive, isExactActive}) => [
                    createElementVNode("a", {
                      href: href,
                      onClick: navigate,
                      class: normalizeClass(["p-menuitem-link p-menuitem-content", {'active-link': isActive, 'active-link-exact': isExactActive}])
                    }, toDisplayString$1(item.label), 11 /* TEXT, CLASS, PROPS */, _hoisted_3$y)
                  ]),
                  _: 2 /* DYNAMIC */
                }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["to"])
              ]),
              _: 2 /* DYNAMIC */
            }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["model"])
          ]))
    ]),
    end: withCtx(() => [
      createVNode(unref(script$1L), {
        type: "button",
        label: "Toggle",
        onClick: toggle,
        "aria-haspopup": "true",
        "aria-controls": "overlay_menu"
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString$1(__props.name), 1 /* TEXT */)
        ]),
        _: 1 /* STABLE */
      }),
      createVNode(unref(script$1B), {
        id: "overlay_menu",
        ref_key: "menu",
        ref: menu,
        model: account_items.value,
        popup: true
      }, {
        item: withCtx(({item}) => [
          (item.model)
            ? (openBlock(), createBlock(_component_router_link, {
                key: 0,
                to: { name : 'single', params : { 'model' : item.model }}
              }, {
                default: withCtx(({href, route, navigate, isActive, isExactActive}) => [
                  createElementVNode("a", {
                    onClick: navigate,
                    class: normalizeClass(["p-menuitem-link p-menuitem-content", {'active-link': isActive, 'active-link-exact': isExactActive}])
                  }, toDisplayString$1(item.label), 11 /* TEXT, CLASS, PROPS */, _hoisted_4$s)
                ]),
                _: 2 /* DYNAMIC */
              }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["to"]))
            : (openBlock(), createElementBlock("div", _hoisted_5$n, [
                createElementVNode("a", {
                  onClick: item.command,
                  class: "p-menuitem-link p-menuitem-content"
                }, toDisplayString$1(item.label), 9 /* TEXT, PROPS */, _hoisted_6$j)
              ]))
        ]),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["model"])
    ]),
    _: 1 /* STABLE */
  }, 8 /* PROPS */, ["model"]))
}
}

};

script$1A.__file = "presstojam/src/components/nav/nav.vue";

let element,
    firstVNode,
    lastVNode,
    shiftKey = false;

function firstHiddenFocus() {
  if (shiftKey) {
    lastVNode.focus();
  } else {
    const firstFocusableEl = DomHandler.getFirstFocusableElement(element, ':not(.p-hidden-focusable)');
    DomHandler.focus(firstFocusableEl);
  }
}

function lastHiddenFocus() {
  if (shiftKey) {
    const lastFocusableEl = DomHandler.getLastFocusableElement(element, ':not(.p-hidden-focusable)');
    DomHandler.focus(lastFocusableEl);
  } else {
    firstVNode.focus();
  }
}

function createHiddenElement(callback) {
  const el = document.createElement('span');
  el.classList = 'p-hidden-accessible p-hidden-focusable';
  el.tabIndex = '0';
  el.setAttribute('aria-hidden', 'true');
  el.setAttribute('role', 'presentation');
  el.addEventListener('focus', callback);
  return el;
}

function createHiddenElements(el) {
  firstVNode = createHiddenElement(firstHiddenFocus);
  lastVNode = createHiddenElement(lastHiddenFocus);
  el.prepend(firstVNode);
  el.append(lastVNode);
}

function bind$1(el) {
  el.$_pfocustrap_keydownlistener = e => {
    if (e.code === 'Tab') {
      shiftKey = e.shiftKey;
    }
  };

  el.addEventListener('keydown', el.$_pfocustrap_keydownlistener);
}

function unbind(el) {
  if (el.$_pfocustrap_keydownlistener) {
    el.removeEventListener('keydown', el.$_pfocustrap_keydownlistener);
    el.$_pfocustrap_keydownlistener = null;
  }
}

const FocusTrap = {
  mounted(el, binding, vnode) {
    const firstFocusableEl = DomHandler.getFirstFocusableElement(el, ':not(.p-hidden-focusable)');

    if (firstFocusableEl) {
      el.$_pfocustrapFocusTrapDisabled = false;

      if (binding.value && typeof binding.value === 'object') {
        el.$_pfocustrapFocusTrapDisabled = binding.value.focusTrapDisabled;
      }

      if (!el.$_pfocustrapFocusTrapDisabled) {
        element = el;
        createHiddenElements(el);
        bind$1(el);
      }
    }
  },

  unmounted(el) {
    element = null;
    firstVNode = null;
    lastVNode = null;
    shiftKey = false;
    unbind(el);
  }

};

var script$1z = {
  name: 'Dialog',
  inheritAttrs: false,
  emits: ['update:visible', 'show', 'hide', 'after-hide', 'maximize', 'unmaximize', 'dragend'],
  props: {
    header: {
      type: null,
      default: null
    },
    footer: {
      type: null,
      default: null
    },
    visible: {
      type: Boolean,
      default: false
    },
    modal: {
      type: Boolean,
      default: null
    },
    contentStyle: {
      type: null,
      default: null
    },
    contentClass: {
      type: String,
      default: null
    },
    contentProps: {
      type: null,
      default: null
    },
    rtl: {
      type: Boolean,
      default: null
    },
    maximizable: {
      type: Boolean,
      default: false
    },
    dismissableMask: {
      type: Boolean,
      default: false
    },
    closable: {
      type: Boolean,
      default: true
    },
    closeOnEscape: {
      type: Boolean,
      default: true
    },
    showHeader: {
      type: Boolean,
      default: true
    },
    baseZIndex: {
      type: Number,
      default: 0
    },
    autoZIndex: {
      type: Boolean,
      default: true
    },
    position: {
      type: String,
      default: 'center'
    },
    breakpoints: {
      type: Object,
      default: null
    },
    draggable: {
      type: Boolean,
      default: true
    },
    keepInViewport: {
      type: Boolean,
      default: true
    },
    minX: {
      type: Number,
      default: 0
    },
    minY: {
      type: Number,
      default: 0
    },
    appendTo: {
      type: String,
      default: 'body'
    },
    closeIcon: {
      type: String,
      default: 'pi pi-times'
    },
    maximizeIcon: {
      type: String,
      default: 'pi pi-window-maximize'
    },
    minimizeIcon: {
      type: String,
      default: 'pi pi-window-minimize'
    },
    closeButtonProps: {
      type: null,
      default: null
    },
    _instance: null
  },

  provide() {
    return {
      dialogRef: computed(() => this._instance)
    };
  },

  data() {
    return {
      containerVisible: this.visible,
      maximized: false
    };
  },

  documentKeydownListener: null,
  container: null,
  mask: null,
  content: null,
  headerContainer: null,
  footerContainer: null,
  maximizableButton: null,
  closeButton: null,
  styleElement: null,
  dragging: null,
  documentDragListener: null,
  documentDragEndListener: null,
  lastPageX: null,
  lastPageY: null,

  updated() {
    if (this.visible) {
      this.containerVisible = this.visible;
    }
  },

  beforeUnmount() {
    this.unbindDocumentState();
    this.unbindGlobalListeners();
    this.destroyStyle();

    if (this.mask && this.autoZIndex) {
      ZIndexUtils.clear(this.mask);
    }

    this.container = null;
    this.mask = null;
  },

  mounted() {
    if (this.breakpoints) {
      this.createStyle();
    }
  },

  methods: {
    close() {
      this.$emit('update:visible', false);
    },

    onBeforeEnter(el) {
      el.setAttribute(this.attributeSelector, '');
    },

    onEnter() {
      this.$emit('show');
      this.focus();
      this.enableDocumentSettings();
      this.bindGlobalListeners();

      if (this.autoZIndex) {
        ZIndexUtils.set('modal', this.mask, this.baseZIndex + this.$primevue.config.zIndex.modal);
      }
    },

    onBeforeLeave() {
      if (this.modal) {
        DomHandler.addClass(this.mask, 'p-component-overlay-leave');
      }
    },

    onLeave() {
      this.$emit('hide');
    },

    onAfterLeave() {
      if (this.autoZIndex) {
        ZIndexUtils.clear(this.mask);
      }

      this.containerVisible = false;
      this.unbindDocumentState();
      this.unbindGlobalListeners();
      this.$emit('after-hide');
    },

    onMaskClick(event) {
      if (this.dismissableMask && this.closable && this.modal && this.mask === event.target) {
        this.close();
      }
    },

    focus() {
      const findFocusableElement = container => {
        return container.querySelector('[autofocus]');
      };

      let focusTarget = this.$slots.default && findFocusableElement(this.content);

      if (!focusTarget) {
        focusTarget = this.$slots.header && findFocusableElement(this.headerContainer);

        if (!focusTarget) {
          focusTarget = this.$slots.footer && findFocusableElement(this.footerContainer);

          if (!focusTarget) {
            focusTarget = findFocusableElement(this.container);
          }
        }
      }

      focusTarget && focusTarget.focus();
    },

    maximize(event) {
      if (this.maximized) {
        this.maximized = false;
        this.$emit('unmaximize', event);
      } else {
        this.maximized = true;
        this.$emit('maximize', event);
      }

      if (!this.modal) {
        if (this.maximized) DomHandler.addClass(document.body, 'p-overflow-hidden');else DomHandler.removeClass(document.body, 'p-overflow-hidden');
      }
    },

    enableDocumentSettings() {
      if (this.modal || this.maximizable && this.maximized) {
        DomHandler.addClass(document.body, 'p-overflow-hidden');
      }
    },

    unbindDocumentState() {
      if (this.modal || this.maximizable && this.maximized) {
        DomHandler.removeClass(document.body, 'p-overflow-hidden');
      }
    },

    onKeyDown(event) {
      if (event.code === 'Escape' && this.closeOnEscape) {
        this.close();
      }
    },

    bindDocumentKeyDownListener() {
      if (!this.documentKeydownListener) {
        this.documentKeydownListener = this.onKeyDown.bind(this);
        window.document.addEventListener('keydown', this.documentKeydownListener);
      }
    },

    unbindDocumentKeyDownListener() {
      if (this.documentKeydownListener) {
        window.document.removeEventListener('keydown', this.documentKeydownListener);
        this.documentKeydownListener = null;
      }
    },

    getPositionClass() {
      const positions = ['left', 'right', 'top', 'topleft', 'topright', 'bottom', 'bottomleft', 'bottomright'];
      const pos = positions.find(item => item === this.position);
      return pos ? `p-dialog-${pos}` : '';
    },

    containerRef(el) {
      this.container = el;
    },

    maskRef(el) {
      this.mask = el;
    },

    contentRef(el) {
      this.content = el;
    },

    headerContainerRef(el) {
      this.headerContainer = el;
    },

    footerContainerRef(el) {
      this.footerContainer = el;
    },

    maximizableRef(el) {
      this.maximizableButton = el;
    },

    closeButtonRef(el) {
      this.closeButton = el;
    },

    createStyle() {
      if (!this.styleElement) {
        this.styleElement = document.createElement('style');
        this.styleElement.type = 'text/css';
        document.head.appendChild(this.styleElement);
        let innerHTML = '';

        for (let breakpoint in this.breakpoints) {
          innerHTML += `
                        @media screen and (max-width: ${breakpoint}) {
                            .p-dialog[${this.attributeSelector}] {
                                width: ${this.breakpoints[breakpoint]} !important;
                            }
                        }
                    `;
        }

        this.styleElement.innerHTML = innerHTML;
      }
    },

    destroyStyle() {
      if (this.styleElement) {
        document.head.removeChild(this.styleElement);
        this.styleElement = null;
      }
    },

    initDrag(event) {
      if (DomHandler.hasClass(event.target, 'p-dialog-header-icon') || DomHandler.hasClass(event.target.parentElement, 'p-dialog-header-icon')) {
        return;
      }

      if (this.draggable) {
        this.dragging = true;
        this.lastPageX = event.pageX;
        this.lastPageY = event.pageY;
        this.container.style.margin = '0';
        DomHandler.addClass(document.body, 'p-unselectable-text');
      }
    },

    bindGlobalListeners() {
      if (this.draggable) {
        this.bindDocumentDragListener();
        this.bindDocumentDragEndListener();
      }

      if (this.closeOnEscape && this.closable) {
        this.bindDocumentKeyDownListener();
      }
    },

    unbindGlobalListeners() {
      this.unbindDocumentDragListener();
      this.unbindDocumentDragEndListener();
      this.unbindDocumentKeyDownListener();
    },

    bindDocumentDragListener() {
      this.documentDragListener = event => {
        if (this.dragging) {
          let width = DomHandler.getOuterWidth(this.container);
          let height = DomHandler.getOuterHeight(this.container);
          let deltaX = event.pageX - this.lastPageX;
          let deltaY = event.pageY - this.lastPageY;
          let offset = this.container.getBoundingClientRect();
          let leftPos = offset.left + deltaX;
          let topPos = offset.top + deltaY;
          let viewport = DomHandler.getViewport();
          this.container.style.position = 'fixed';

          if (this.keepInViewport) {
            if (leftPos >= this.minX && leftPos + width < viewport.width) {
              this.lastPageX = event.pageX;
              this.container.style.left = leftPos + 'px';
            }

            if (topPos >= this.minY && topPos + height < viewport.height) {
              this.lastPageY = event.pageY;
              this.container.style.top = topPos + 'px';
            }
          } else {
            this.lastPageX = event.pageX;
            this.container.style.left = leftPos + 'px';
            this.lastPageY = event.pageY;
            this.container.style.top = topPos + 'px';
          }
        }
      };

      window.document.addEventListener('mousemove', this.documentDragListener);
    },

    unbindDocumentDragListener() {
      if (this.documentDragListener) {
        window.document.removeEventListener('mousemove', this.documentDragListener);
        this.documentDragListener = null;
      }
    },

    bindDocumentDragEndListener() {
      this.documentDragEndListener = event => {
        if (this.dragging) {
          this.dragging = false;
          DomHandler.removeClass(document.body, 'p-unselectable-text');
          this.$emit('dragend', event);
        }
      };

      window.document.addEventListener('mouseup', this.documentDragEndListener);
    },

    unbindDocumentDragEndListener() {
      if (this.documentDragEndListener) {
        window.document.removeEventListener('mouseup', this.documentDragEndListener);
        this.documentDragEndListener = null;
      }
    }

  },
  computed: {
    maskClass() {
      return ['p-dialog-mask', {
        'p-component-overlay p-component-overlay-enter': this.modal
      }, this.getPositionClass()];
    },

    dialogClass() {
      return ['p-dialog p-component', {
        'p-dialog-rtl': this.rtl,
        'p-dialog-maximized': this.maximizable && this.maximized,
        'p-input-filled': this.$primevue.config.inputStyle === 'filled',
        'p-ripple-disabled': this.$primevue.config.ripple === false
      }];
    },

    maximizeIconClass() {
      return ['p-dialog-header-maximize-icon', {
        [this.maximizeIcon]: !this.maximized,
        [this.minimizeIcon]: this.maximized
      }];
    },

    ariaId() {
      return UniqueComponentId();
    },

    ariaLabelledById() {
      return this.header != null || this.$attrs['aria-labelledby'] !== null ? this.ariaId + '_header' : null;
    },

    closeAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.close : undefined;
    },

    attributeSelector() {
      return UniqueComponentId();
    },

    contentStyleClass() {
      return ['p-dialog-content', this.contentClass];
    }

  },
  directives: {
    ripple: Ripple,
    focustrap: FocusTrap
  },
  components: {
    Portal: script$1C
  }
};
const _hoisted_1$P = ["aria-labelledby", "aria-modal"];
const _hoisted_2$G = ["id"];
const _hoisted_3$x = {
  class: "p-dialog-header-icons"
};
const _hoisted_4$r = ["tabindex"];
const _hoisted_5$m = ["aria-label"];

function render$v(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Portal = resolveComponent("Portal");

  const _directive_ripple = resolveDirective("ripple");

  const _directive_focustrap = resolveDirective("focustrap");

  return openBlock(), createBlock(_component_Portal, {
    appendTo: $props.appendTo
  }, {
    default: withCtx(() => [$data.containerVisible ? (openBlock(), createElementBlock("div", {
      key: 0,
      ref: $options.maskRef,
      class: normalizeClass($options.maskClass),
      onClick: _cache[3] || (_cache[3] = (...args) => $options.onMaskClick && $options.onMaskClick(...args))
    }, [createVNode(Transition, {
      name: "p-dialog",
      onBeforeEnter: $options.onBeforeEnter,
      onEnter: $options.onEnter,
      onBeforeLeave: $options.onBeforeLeave,
      onLeave: $options.onLeave,
      onAfterLeave: $options.onAfterLeave,
      appear: ""
    }, {
      default: withCtx(() => [$props.visible ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        ref: $options.containerRef,
        class: $options.dialogClass,
        role: "dialog",
        "aria-labelledby": $options.ariaLabelledById,
        "aria-modal": $props.modal
      }, _ctx.$attrs), [$props.showHeader ? (openBlock(), createElementBlock("div", {
        key: 0,
        ref: $options.headerContainerRef,
        class: "p-dialog-header",
        onMousedown: _cache[2] || (_cache[2] = (...args) => $options.initDrag && $options.initDrag(...args))
      }, [renderSlot(_ctx.$slots, "header", {}, () => [$props.header ? (openBlock(), createElementBlock("span", {
        key: 0,
        id: $options.ariaLabelledById,
        class: "p-dialog-title"
      }, toDisplayString$1($props.header), 9, _hoisted_2$G)) : createCommentVNode("", true)]), createElementVNode("div", _hoisted_3$x, [$props.maximizable ? withDirectives((openBlock(), createElementBlock("button", {
        key: 0,
        ref: $options.maximizableRef,
        autofocus: "",
        class: "p-dialog-header-icon p-dialog-header-maximize p-link",
        onClick: _cache[0] || (_cache[0] = (...args) => $options.maximize && $options.maximize(...args)),
        type: "button",
        tabindex: $props.maximizable ? '0' : '-1'
      }, [createElementVNode("span", {
        class: normalizeClass($options.maximizeIconClass)
      }, null, 2)], 8, _hoisted_4$r)), [[_directive_ripple]]) : createCommentVNode("", true), $props.closable ? withDirectives((openBlock(), createElementBlock("button", mergeProps({
        key: 1,
        ref: $options.closeButtonRef,
        autofocus: "",
        class: "p-dialog-header-icon p-dialog-header-close p-link",
        onClick: _cache[1] || (_cache[1] = (...args) => $options.close && $options.close(...args)),
        "aria-label": $options.closeAriaLabel,
        type: "button"
      }, $props.closeButtonProps), [createElementVNode("span", {
        class: normalizeClass(['p-dialog-header-close-icon', $props.closeIcon])
      }, null, 2)], 16, _hoisted_5$m)), [[_directive_ripple]]) : createCommentVNode("", true)])], 544)) : createCommentVNode("", true), createElementVNode("div", mergeProps({
        ref: $options.contentRef,
        class: $options.contentStyleClass,
        style: $props.contentStyle
      }, $props.contentProps), [renderSlot(_ctx.$slots, "default")], 16), $props.footer || _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
        key: 1,
        ref: $options.footerContainerRef,
        class: "p-dialog-footer"
      }, [renderSlot(_ctx.$slots, "footer", {}, () => [createTextVNode(toDisplayString$1($props.footer), 1)])], 512)) : createCommentVNode("", true)], 16, _hoisted_1$P)), [[_directive_focustrap, {
        focusTrapDisabled: !$props.modal
      }]]) : createCommentVNode("", true)]),
      _: 3
    }, 8, ["onBeforeEnter", "onEnter", "onBeforeLeave", "onLeave", "onAfterLeave"])], 2)) : createCommentVNode("", true)]),
    _: 3
  }, 8, ["appendTo"]);
}

function styleInject$q(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$x = "\n.p-dialog-mask {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    pointer-events: none;\n}\n.p-dialog-mask.p-component-overlay {\n    pointer-events: auto;\n}\n.p-dialog {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n        -ms-flex-direction: column;\n            flex-direction: column;\n    pointer-events: auto;\n    max-height: 90%;\n    -webkit-transform: scale(1);\n            transform: scale(1);\n}\n.p-dialog-content {\n    overflow-y: auto;\n}\n.p-dialog-header {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: justify;\n        -ms-flex-pack: justify;\n            justify-content: space-between;\n    -ms-flex-negative: 0;\n        flex-shrink: 0;\n}\n.p-dialog-footer {\n    -ms-flex-negative: 0;\n        flex-shrink: 0;\n}\n.p-dialog .p-dialog-header-icons {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n.p-dialog .p-dialog-header-icon {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    overflow: hidden;\n    position: relative;\n}\n\n/* Fluid */\n.p-fluid .p-dialog-footer .p-button {\n    width: auto;\n}\n\n/* Animation */\n/* Center */\n.p-dialog-enter-active {\n    -webkit-transition: all 150ms cubic-bezier(0, 0, 0.2, 1);\n    transition: all 150ms cubic-bezier(0, 0, 0.2, 1);\n}\n.p-dialog-leave-active {\n    -webkit-transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);\n    transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);\n}\n.p-dialog-enter-from,\n.p-dialog-leave-to {\n    opacity: 0;\n    -webkit-transform: scale(0.7);\n            transform: scale(0.7);\n}\n\n/* Top, Bottom, Left, Right, Top* and Bottom* */\n.p-dialog-top .p-dialog,\n.p-dialog-bottom .p-dialog,\n.p-dialog-left .p-dialog,\n.p-dialog-right .p-dialog,\n.p-dialog-topleft .p-dialog,\n.p-dialog-topright .p-dialog,\n.p-dialog-bottomleft .p-dialog,\n.p-dialog-bottomright .p-dialog {\n    margin: 0.75rem;\n    -webkit-transform: translate3d(0px, 0px, 0px);\n            transform: translate3d(0px, 0px, 0px);\n}\n.p-dialog-top .p-dialog-enter-active,\n.p-dialog-top .p-dialog-leave-active,\n.p-dialog-bottom .p-dialog-enter-active,\n.p-dialog-bottom .p-dialog-leave-active,\n.p-dialog-left .p-dialog-enter-active,\n.p-dialog-left .p-dialog-leave-active,\n.p-dialog-right .p-dialog-enter-active,\n.p-dialog-right .p-dialog-leave-active,\n.p-dialog-topleft .p-dialog-enter-active,\n.p-dialog-topleft .p-dialog-leave-active,\n.p-dialog-topright .p-dialog-enter-active,\n.p-dialog-topright .p-dialog-leave-active,\n.p-dialog-bottomleft .p-dialog-enter-active,\n.p-dialog-bottomleft .p-dialog-leave-active,\n.p-dialog-bottomright .p-dialog-enter-active,\n.p-dialog-bottomright .p-dialog-leave-active {\n    -webkit-transition: all 0.3s ease-out;\n    transition: all 0.3s ease-out;\n}\n.p-dialog-top .p-dialog-enter-from,\n.p-dialog-top .p-dialog-leave-to {\n    -webkit-transform: translate3d(0px, -100%, 0px);\n            transform: translate3d(0px, -100%, 0px);\n}\n.p-dialog-bottom .p-dialog-enter-from,\n.p-dialog-bottom .p-dialog-leave-to {\n    -webkit-transform: translate3d(0px, 100%, 0px);\n            transform: translate3d(0px, 100%, 0px);\n}\n.p-dialog-left .p-dialog-enter-from,\n.p-dialog-left .p-dialog-leave-to,\n.p-dialog-topleft .p-dialog-enter-from,\n.p-dialog-topleft .p-dialog-leave-to,\n.p-dialog-bottomleft .p-dialog-enter-from,\n.p-dialog-bottomleft .p-dialog-leave-to {\n    -webkit-transform: translate3d(-100%, 0px, 0px);\n            transform: translate3d(-100%, 0px, 0px);\n}\n.p-dialog-right .p-dialog-enter-from,\n.p-dialog-right .p-dialog-leave-to,\n.p-dialog-topright .p-dialog-enter-from,\n.p-dialog-topright .p-dialog-leave-to,\n.p-dialog-bottomright .p-dialog-enter-from,\n.p-dialog-bottomright .p-dialog-leave-to {\n    -webkit-transform: translate3d(100%, 0px, 0px);\n            transform: translate3d(100%, 0px, 0px);\n}\n\n/* Maximize */\n.p-dialog-maximized {\n    -webkit-transition: none;\n    transition: none;\n    -webkit-transform: none;\n            transform: none;\n    width: 100vw !important;\n    height: 100vh !important;\n    top: 0px !important;\n    left: 0px !important;\n    max-height: 100%;\n    height: 100%;\n}\n.p-dialog-maximized .p-dialog-content {\n    -webkit-box-flex: 1;\n        -ms-flex-positive: 1;\n            flex-grow: 1;\n}\n\n/* Position */\n.p-dialog-left {\n    -webkit-box-pack: start;\n        -ms-flex-pack: start;\n            justify-content: flex-start;\n}\n.p-dialog-right {\n    -webkit-box-pack: end;\n        -ms-flex-pack: end;\n            justify-content: flex-end;\n}\n.p-dialog-top {\n    -webkit-box-align: start;\n        -ms-flex-align: start;\n            align-items: flex-start;\n}\n.p-dialog-topleft {\n    -webkit-box-pack: start;\n        -ms-flex-pack: start;\n            justify-content: flex-start;\n    -webkit-box-align: start;\n        -ms-flex-align: start;\n            align-items: flex-start;\n}\n.p-dialog-topright {\n    -webkit-box-pack: end;\n        -ms-flex-pack: end;\n            justify-content: flex-end;\n    -webkit-box-align: start;\n        -ms-flex-align: start;\n            align-items: flex-start;\n}\n.p-dialog-bottom {\n    -webkit-box-align: end;\n        -ms-flex-align: end;\n            align-items: flex-end;\n}\n.p-dialog-bottomleft {\n    -webkit-box-pack: start;\n        -ms-flex-pack: start;\n            justify-content: flex-start;\n    -webkit-box-align: end;\n        -ms-flex-align: end;\n            align-items: flex-end;\n}\n.p-dialog-bottomright {\n    -webkit-box-pack: end;\n        -ms-flex-pack: end;\n            justify-content: flex-end;\n    -webkit-box-align: end;\n        -ms-flex-align: end;\n            align-items: flex-end;\n}\n.p-confirm-dialog .p-dialog-content {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n";
styleInject$q(css_248z$x);
script$1z.render = render$v;

const _subscriptions = {};
function subscribe(type, id, callback) {
  if (!_subscriptions[type]) {
    _subscriptions[type] = {};
  }

  _subscriptions[type][id] = callback;
}
function unsubscribe(type, id) {
  if (_subscriptions[type] && _subscriptions[type][id]) {
    delete _subscriptions[type][id];
  }
}
function trigger(type, ...args) {
  if (_subscriptions[type]) {
    for (const id in _subscriptions[type]) {
      _subscriptions[type][id](...args);
    }
  }
}

var script$1y = {
  setup(__props) {

const component = shallowRef(null);
const args = ref({});
const dialogswitch = ref(false);
const header = ref('');



subscribe("dialog_open", 1, (in_component, in_args, input_header) => {
    dialogswitch.value = true;
    header.value = input_header;
    component.value = in_component;
    args.value = in_args;
});

subscribe("dialog_close", 1, function() {
    dialogswitch.value = false;
    header.value = null;
    component.value = null;
    args.value = null;
});


onBeforeUnmount(() => {
    unsubscribe("dialog_close", 1);
    unsubscribe("dialog_open", 1);
});

return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$1z), {
    visible: dialogswitch.value,
    "onUpdate:visible": _cache[0] || (_cache[0] = $event => ((dialogswitch).value = $event)),
    header: header.value,
    modal: true,
    class: "p-fluid"
  }, {
    default: withCtx(() => [
      (openBlock(), createBlock(resolveDynamicComponent(unref(component)), normalizeProps(guardReactiveProps(args.value)), null, 16 /* FULL_PROPS */))
    ]),
    _: 1 /* STABLE */
  }, 8 /* PROPS */, ["visible", "header"]))
}
}

};

script$1y.__file = "presstojam/src/components/effects/dialog.vue";

var script$1x = {
  props: {
    value : [Number, String],
    field : Object
},
  setup(__props) {





return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("span", null, toDisplayString$1(__props.value), 1 /* TEXT */))
}
}

};

script$1x.__file = "presstojam/src/components/view/number.vue";

const _hoisted_1$O = {
  key: 0,
  class: "pi pi-check"
};
const _hoisted_2$F = { key: 1 };


var script$1w = {
  props: {
    value : [Number, Boolean],
    field : Object
},
  setup(__props) {

inject("client");



return (_ctx, _cache) => {
  return (__props.field.useIcons() && __props.value)
    ? (openBlock(), createElementBlock("i", _hoisted_1$O))
    : (openBlock(), createElementBlock("span", _hoisted_2$F, toDisplayString$1(__props.field.display(__props.value)), 1 /* TEXT */))
}
}

};

script$1w.__file = "presstojam/src/components/view/flag.vue";

class Model {
  constructor(name, debug = false) {
    this._name = name;
    this._fields = {};
    this._perms = [];
    this._import = false;
    this._export = false;
    this._max_cols = 8;
    this._no_filter = false;
    this._children = null;
    this._sort = null;
    this._limit = null;
    this._to = null;
    this._group = null;
    this._order = null;
    this._params = null;
    this._limited_fields = null;
    this._export_fields = null;
    this._distinguish = null;
    this._audit = false;
    this._actions = [];
    this._editable_fields = [];
    this._classes = null;
    this._group_classes = null;
    this._events = {};
    this._debug = debug;
    this._parent = null;
    const keys = Object.keys(this);
    keys.forEach(property => {
      if (property[0] == "_") {
        Object.defineProperty(this, property.substring(1), {
          get: function () {
            return this[property];
          },
          set: function (newValue) {
            this[property] = newValue;
          }
        });
      }
    });
    const entity = this.loadEntity();
    this.loadSettings();
    this.loadFields(entity);
    this.loadParentFields();
  }

  get children_models() {
    return this._fields["--id"].reference;
  }

  getSettings() {
    let settings = configs.get("models");

    if (settings[this._name]) {
      return settings[this._name];
    }
  }

  loadSettings() {
    const settings = this.getSettings();

    if (settings) {
      if (settings.to) this._to = settings.to;
      if (settings.perms) this._perms = settings.perms;
      if (settings.group) this._group = settings.group;
      if (settings.order) this._order = settings.order;
      if (settings.params) this._params = settings.params;
      if (settings.children) this._children = settings.children;
      if (settings.fields) this._limited_fields = settings.fields;
      if (settings.limit) this._limit = settings.limit;
      if (settings.export_fields) this._export_fields = settings.export_fields;
      if (settings.distinguish) this._distinguish = settings.distinguish;
      if (settings.actions) this._actions = settings.actions;
      if (settings.editable) this._editable_fields = settings.editable;
      if (settings.no_filter) this._no_filter = settings.no_filter;
      if (settings.max_cols) this._max_cols = settings.max_cols;
      if (settings.classes) this._classes = settings.classes;
      if (settings.group_classes) this._group_classes = settings.group_classes;
      if (settings.events) this._events = settings.events;
    }
  }

  loadEntity() {
    const entity = getEntity(this._name);

    if (!entity) {
      throw this._name;
    }

    if (entity.perms) this._perms = entity.perms;
    if (entity.sort) this._sort = entity.sort;
    if (entity.audit) this._audit = entity.audit;
    if (entity.import) this._import = entity.import;
    if (entity.export) this._export = entity.export;
    if (entity.parent) this._parent = entity.parent;
    return entity;
  }

  loadFields(entity, slug = "") {
    const fields = entity.cells;

    for (let i in fields) {
      if (!this._limited_fields || this._limited_fields.includes(slug + i)) {
        this._fields[slug + i] = Object.assign(Object.create(fields[i]), fields[i]);
        this._fields[slug + i].slug = slug + i;
        if (slug) this._fields[slug + i].summary = false; //set summary to false for anything that isn't the base

        if (fields[i].type == "id" && fields[i].reference_type == ReferenceTypes.REFERENCE) {
          const ref_entity = getEntity(fields[i].reference);
          if (ref_entity) this.loadFields(ref_entity, slug + i + "/");
        }
      }
    }
  }

  loadParentFields() {
    if (this._to) {
      let parent = this._parent;

      while (parent) {
        let entity = getEntity(parent);
        this.loadFields(entity, parent + "/");
        if (parent == this._to) break;
        parent = entity.parent;
      }
    }
  }

  loadCount(filters) {
    if (this._limit) {
      const client = getClient();
      return client.get("/count/" + this._name, this.buildParams(filters)).then(response => {
        return parseInt(response.count);
      });
    } else {
      return Promise.resolve(0);
    }
  }

  load(filters) {
    const client = getClient();
    return client.get("/data/" + this._name, this.buildParams(filters));
  }

  loadActive(filters) {
    const client = getClient();
    return client.get("/data/" + this._name + "/active", this.buildParams(filters));
  }

  reloadRow(id) {
    const client = getClient();
    return client.get("/data/" + this._name + "/active", {
      "--id": id
    });
  }

  loadFirst(filters) {
    const client = getClient();
    return client.get("/data/" + this._name + "/first", this.buildParams(filters));
  }

  loadReport(filters, field = null, aggregate = null) {
    let url = "/reports/" + this._name;
    if (field) url += "/" + field + "/" + aggregate;
    const client = getClient();
    return client.get(url, this.buildParams(filters));
  }

  saveOrder(rows) {
    const client = getClient();
    const vals = [];

    for (let i in rows) {
      vals.push({
        '--id': rows[i]['--id'],
        '--sort': i
      });
    }

    return client.put("/data/" + this._name + "/resort", {
      "_rows": vals
    });
  }

  buildParams(filters) {
    let params = {};
    if (this._to) params.__to = this._to;
    if (this._group) params.__group = this._group;

    if (this._limited_fields) {
      params.__fields = this._limited_fields;

      if (!params.__fields.includes("--id")) {
        params.__fields.push("--id");
      }
    }

    if (this._order) params.__order = this._order;

    if (this._limit) {
      params.__limit = this._limit;
    }

    for (let i in filters) {
      params[i] = filters[i];
    }

    return params;
  }

  trigger(key, data) {
    if (this._events[key]) {
      this._events[key](data);
    }
  }

  setTableCells(schema = null) {
    if (!schema) schema = this._fields;

    for (let i in schema) {
      schema[i].disabled = false;

      if (schema[i].background) {
        schema[i].disabled = true;
        continue;
      }

      if (schema[i].type == "id" && schema[i].reference_type == ReferenceTypes.PARENT) {
        schema[i].disabled = true;
        continue;
      }

      if (schema[i].slug != schema[i].name) {
        if (this._limited_fields) {
          if (!this._limited_fields.includes(i)) {
            schema[i].disabled = true;
            continue;
          } //don't continue if exists in limited fields

        } else {
          schema[i].disabled = true;
          continue;
        }
      }

      if (schema[i].type == "json") {
        this.setTableCells(schema[i].fields);
      }
    }
  }

  getEnabledCells() {
    let cells = {};

    for (let i in this._fields) {
      if (!this._fields[i].disabled) {
        cells[i] = this._fields[i];
      }
    }

    return cells;
  }

  getEnabledSummaryCells() {
    let cells = {};

    for (let i in this._fields) {
      if (!this._fields[i].disabled && this._fields[i].summary) {
        cells[i] = this._fields[i];
      }
    }

    return cells;
  }

}

const _hoisted_1$N = { key: 1 };


var script$1v = {
  props: {
    value : [Number, String ],
    field : Object,
    row : Object,
},
  setup(__props) {

const props = __props;




let show_route = false;
if (
    props.field.reference_type == ReferenceTypes.REFERENCE 
    && hasEntity(props.field.reference) 
    && props.value) {
        if (getEntity(props.field.reference).perms.includes("get"))
            show_route = true;
}


let display = computed(() => {
    if (props.field.reference_type == ReferenceTypes.REFERENCE) {
        const data = [];
    

        if (props.field.custom_fields.length) {
            for(const field of props.field.custom_fields) {
                data.push(props.row[props.field.name + "/" + field]);
            }
        } else {
            
            const ref_route = new Model(props.field.reference);
            
            for(const i in ref_route.fields) {
                if (ref_route.fields[i].summary) {
                    data.push(props.row[props.field.name + "/" + i]);
                }
            }
        }
        return data.join(" ");
    } else {
        return props.value; 
    }
});



return (_ctx, _cache) => {
  const _component_router_link = resolveComponent("router-link");

  return (unref(show_route))
    ? (openBlock(), createBlock(_component_router_link, {
        key: 0,
        to: { name : 'primary', params : {'model' : __props.field.reference, 'id' : __props.value }}
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString$1(unref(display)), 1 /* TEXT */)
        ]),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["to"]))
    : (openBlock(), createElementBlock("span", _hoisted_1$N, toDisplayString$1(unref(display)), 1 /* TEXT */))
}
}

};

script$1v.__file = "presstojam/src/components/view/id.vue";

var script$1u = {
  props: {
    value : [Number, String],
    field : Object
},
  setup(__props) {

const props = __props;




const val = computed(() => {
    var t = props.field.clean(props.value);
    return (!t) ? t : t.toLocaleDateString("en-UK");
});


return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("span", null, toDisplayString$1(unref(val)), 1 /* TEXT */))
}
}

};

script$1u.__file = "presstojam/src/components/view/time.vue";

const _hoisted_1$M = { key: 0 };
const _hoisted_2$E = {
  key: 1,
  class: "row"
};
const _hoisted_3$w = { key: 2 };


var script$1t = {
  props: {
    value : [String],
    field : Object
},
  setup(__props) {

const props = __props;



const tag = computed(() => {
 if (props.field.html || props.field.max > 300) {
    return "textarea";
 } else {
    return "input";
 }
});




return (_ctx, _cache) => {
  return (unref(tag)=='textarea')
    ? (openBlock(), createElementBlock("div", _hoisted_1$M, toDisplayString$1(__props.value), 1 /* TEXT */))
    : (props.field.isEnum())
      ? (openBlock(), createElementBlock("div", _hoisted_2$E, toDisplayString$1(props.field.clean(__props.value)), 1 /* TEXT */))
      : (openBlock(), createElementBlock("div", _hoisted_3$w, toDisplayString$1(props.field.clean(__props.value)), 1 /* TEXT */))
}
}

};

script$1t.__file = "presstojam/src/components/view/string.vue";

const _hoisted_1$L = /*#__PURE__*/createElementVNode("i", { class: "pi pi-download" }, null, -1 /* HOISTED */);
const _hoisted_2$D = [
  _hoisted_1$L
];


var script$1s = {
  props: {
    value : String,
    field : Object,
    id : Number
},
  setup(__props) {

const props = __props;

const client = inject("client");




function download() {
    client.getAsset("/asset/" + props.field.model + "/" + props.field.name + "/" + props.id)
    .then(blob => {

        const anchor = document.createElement("a");
        const url = URL.createObjectURL(blob);
        anchor.href = url;
        anchor.download = props.field.val;
        document.body.appendChild(anchor);
        anchor.click();
        document.body.removeChild(anchor);
        URL.revokeObjectURL(url);
    })
    .catch(e => {
        console.log(e);
    });
}

return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("span", null, [
    createTextVNode(toDisplayString$1(__props.value) + " ", 1 /* TEXT */),
    createElementVNode("a", {
      onClick: _cache[0] || (_cache[0] = $event => (download()))
    }, _hoisted_2$D)
  ]))
}
}

};

script$1s.__file = "presstojam/src/components/view/asset.vue";

const _hoisted_1$K = { key: 0 };
const _hoisted_2$C = { key: 1 };


var script$1r = {
  props: {
    value : [Object, String],
    field : Object
},
  setup(__props) {

const props = __props;




const jsonVal = props.field.clean(props.value);



return (_ctx, _cache) => {
  return (__props.field.fields.length > 0)
    ? (openBlock(), createElementBlock("div", _hoisted_1$K, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.field.fields, (field) => {
          return (openBlock(), createElementBlock("div", {
            key: field.name
          }, [
            createElementVNode("label", null, toDisplayString$1(_ctx.$t("models." + field.model + ".fields." + field.name + ".label")), 1 /* TEXT */),
            createVNode(script$1q, {
              field: field,
              value: unref(jsonVal)[field.name]
            }, null, 8 /* PROPS */, ["field", "value"])
          ]))
        }), 128 /* KEYED_FRAGMENT */))
      ]))
    : (openBlock(), createElementBlock("div", _hoisted_2$C, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(jsonVal), (value, field) => {
          return (openBlock(), createElementBlock("div", { key: field }, [
            createElementVNode("span", null, toDisplayString$1(field) + ": ", 1 /* TEXT */),
            createElementVNode("span", null, toDisplayString$1(value), 1 /* TEXT */)
          ]))
        }), 128 /* KEYED_FRAGMENT */))
      ]))
}
}

};

script$1r.__file = "presstojam/src/components/view/json.vue";

var script$1q = {
  props: {
    field : Object,
    row : [Array,Object],
},
  setup(__props) {

 

return (_ctx, _cache) => {
  return (__props.field.type=='number')
    ? (openBlock(), createBlock(script$1x, {
        key: 0,
        value: __props.row[__props.field.slug],
        field: __props.field
      }, null, 8 /* PROPS */, ["value", "field"]))
    : (__props.field.type=='flag')
      ? (openBlock(), createBlock(script$1w, {
          key: 1,
          value: __props.row[__props.field.slug],
          field: __props.field
        }, null, 8 /* PROPS */, ["value", "field"]))
      : (__props.field.type=='id')
        ? (openBlock(), createBlock(script$1v, {
            key: 2,
            value: __props.row[__props.field.slug],
            field: __props.field,
            row: __props.row
          }, null, 8 /* PROPS */, ["value", "field", "row"]))
        : (__props.field.type=='asset')
          ? (openBlock(), createBlock(script$1s, {
              key: 3,
              value: __props.row[__props.field.slug],
              field: __props.field,
              id: __props.row['--id']
            }, null, 8 /* PROPS */, ["value", "field", "id"]))
          : (__props.field.type=='time')
            ? (openBlock(), createBlock(script$1u, {
                key: 4,
                value: __props.row[__props.field.slug],
                field: __props.field
              }, null, 8 /* PROPS */, ["value", "field"]))
            : (__props.field.type=='json')
              ? (openBlock(), createBlock(script$1r, {
                  key: 5,
                  value: __props.row[__props.field.slug],
                  field: __props.field
                }, null, 8 /* PROPS */, ["value", "field"]))
              : (__props.field.type=='string')
                ? (openBlock(), createBlock(script$1t, {
                    key: 6,
                    value: __props.row[__props.field.slug],
                    field: __props.field
                  }, null, 8 /* PROPS */, ["value", "field"]))
                : createCommentVNode("v-if", true)
}
}

};

script$1q.__file = "presstojam/src/components/view/view-field.vue";

var viewField = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': script$1q
});

var script$1p = {
  props: {
        model : String,
        id : Number
    },
  setup(__props) {

    

return (_ctx, _cache) => {
  const _component_router_link = resolveComponent("router-link");

  return (openBlock(), createBlock(_component_router_link, {
    to: { name : 'primary', params : {'model' : __props.model, 'id' : __props.id }},
    style: {"text-decoration":"none"}
  }, {
    default: withCtx(({isActive, href, navigate}) => [
      createVNode(unref(script$1L), {
        icon: "pi pi-arrow-circle-right",
        class: "p-button-rounded p-button-success mr-2"
      })
    ]),
    _: 1 /* STABLE */
  }, 8 /* PROPS */, ["to"]))
}
}

};

script$1p.__file = "presstojam/src/components/actions/primary-action.vue";

const _hoisted_1$J = {
  class: "row",
  style: {"row-gap":"32px"}
};
const _hoisted_2$B = { class: "col-md-6 col-lg-4" };
const _hoisted_3$v = { class: "row" };
const _hoisted_4$q = { class: "col-6" };
const _hoisted_5$l = { class: "col-6" };


var script$1o = {
  props: {
    repo : Object
},
  setup(__props) {

const props = __props;




const store = props.repo.store;

store.setTableCells();
const cells = store.getEnabledCells();

const children = (store.fields['--id']) ? store.fields['--id'].reference : [];
const has_primary = (children.length) ? true : false;


return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("div", _hoisted_1$J, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(__props.repo.data.value, (irow) => {
      return (openBlock(), createElementBlock("div", _hoisted_2$B, [
        createVNode(unref(script$1N), null, {
          content: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(cells), (cell) => {
              return (openBlock(), createElementBlock("div", _hoisted_3$v, [
                createElementVNode("div", _hoisted_4$q, toDisplayString$1(_ctx.$t("models." + cell.model + ".fields." + cell.name + ".label")), 1 /* TEXT */),
                createElementVNode("div", _hoisted_5$l, [
                  createVNode(script$1q, {
                    field: cell,
                    row: irow
                  }, null, 8 /* PROPS */, ["field", "row"])
                ])
              ]))
            }), 256 /* UNKEYED_FRAGMENT */))
          ]),
          footer: withCtx(() => [
            (unref(has_primary))
              ? (openBlock(), createBlock(script$1p, {
                  key: 0,
                  model: unref(store).name,
                  id: irow['--id']
                }, null, 8 /* PROPS */, ["model", "id"]))
              : createCommentVNode("v-if", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(store).actions, (component) => {
              return (openBlock(), createBlock(resolveDynamicComponent(component.component), mergeProps({
                data: props.repo
              }, component.atts, { short: true }), null, 16 /* FULL_PROPS */, ["data"]))
            }), 256 /* UNKEYED_FRAGMENT */))
          ]),
          _: 2 /* DYNAMIC */
        }, 1024 /* DYNAMIC_SLOTS */)
      ]))
    }), 256 /* UNKEYED_FRAGMENT */))
  ]))
}
}

};

script$1o.__file = "presstojam/src/components/displays/data-display.vue";

var script$1n = {
  name: 'InputNumber',
  emits: ['update:modelValue', 'input', 'focus', 'blur'],
  props: {
    modelValue: {
      type: Number,
      default: null
    },
    format: {
      type: Boolean,
      default: true
    },
    showButtons: {
      type: Boolean,
      default: false
    },
    buttonLayout: {
      type: String,
      default: 'stacked'
    },
    incrementButtonClass: {
      type: String,
      default: null
    },
    decrementButtonClass: {
      type: String,
      default: null
    },
    incrementButtonIcon: {
      type: String,
      default: 'pi pi-angle-up'
    },
    decrementButtonIcon: {
      type: String,
      default: 'pi pi-angle-down'
    },
    locale: {
      type: String,
      default: undefined
    },
    localeMatcher: {
      type: String,
      default: undefined
    },
    mode: {
      type: String,
      default: 'decimal'
    },
    prefix: {
      type: String,
      default: null
    },
    suffix: {
      type: String,
      default: null
    },
    currency: {
      type: String,
      default: undefined
    },
    currencyDisplay: {
      type: String,
      default: undefined
    },
    useGrouping: {
      type: Boolean,
      default: true
    },
    minFractionDigits: {
      type: Number,
      default: undefined
    },
    maxFractionDigits: {
      type: Number,
      default: undefined
    },
    min: {
      type: Number,
      default: null
    },
    max: {
      type: Number,
      default: null
    },
    step: {
      type: Number,
      default: 1
    },
    allowEmpty: {
      type: Boolean,
      default: true
    },
    highlightOnFocus: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    placeholder: {
      type: String,
      default: null
    },
    inputId: {
      type: String,
      default: null
    },
    inputClass: {
      type: String,
      default: null
    },
    inputStyle: {
      type: null,
      default: null
    },
    inputProps: {
      type: null,
      default: null
    },
    incrementButtonProps: {
      type: null,
      default: null
    },
    decrementButtonProps: {
      type: null,
      default: null
    },
    'aria-labelledby': {
      type: String,
      default: null
    },
    'aria-label': {
      type: String,
      default: null
    }
  },
  numberFormat: null,
  _numeral: null,
  _decimal: null,
  _group: null,
  _minusSign: null,
  _currency: null,
  _suffix: null,
  _prefix: null,
  _index: null,
  groupChar: '',
  isSpecialChar: null,
  prefixChar: null,
  suffixChar: null,
  timer: null,

  data() {
    return {
      d_modelValue: this.modelValue,
      focused: false
    };
  },

  watch: {
    modelValue(newValue) {
      this.d_modelValue = newValue;
    },

    locale(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    },

    localeMatcher(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    },

    mode(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    },

    currency(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    },

    currencyDisplay(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    },

    useGrouping(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    },

    minFractionDigits(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    },

    maxFractionDigits(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    },

    suffix(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    },

    prefix(newValue, oldValue) {
      this.updateConstructParser(newValue, oldValue);
    }

  },

  created() {
    this.constructParser();
  },

  methods: {
    getOptions() {
      return {
        localeMatcher: this.localeMatcher,
        style: this.mode,
        currency: this.currency,
        currencyDisplay: this.currencyDisplay,
        useGrouping: this.useGrouping,
        minimumFractionDigits: this.minFractionDigits,
        maximumFractionDigits: this.maxFractionDigits
      };
    },

    constructParser() {
      this.numberFormat = new Intl.NumberFormat(this.locale, this.getOptions());
      const numerals = [...new Intl.NumberFormat(this.locale, {
        useGrouping: false
      }).format(9876543210)].reverse();
      const index = new Map(numerals.map((d, i) => [d, i]));
      this._numeral = new RegExp(`[${numerals.join('')}]`, 'g');
      this._group = this.getGroupingExpression();
      this._minusSign = this.getMinusSignExpression();
      this._currency = this.getCurrencyExpression();
      this._decimal = this.getDecimalExpression();
      this._suffix = this.getSuffixExpression();
      this._prefix = this.getPrefixExpression();

      this._index = d => index.get(d);
    },

    updateConstructParser(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.constructParser();
      }
    },

    escapeRegExp(text) {
      return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    },

    getDecimalExpression() {
      const formatter = new Intl.NumberFormat(this.locale, { ...this.getOptions(),
        useGrouping: false
      });
      return new RegExp(`[${formatter.format(1.1).replace(this._currency, '').trim().replace(this._numeral, '')}]`, 'g');
    },

    getGroupingExpression() {
      const formatter = new Intl.NumberFormat(this.locale, {
        useGrouping: true
      });
      this.groupChar = formatter.format(1000000).trim().replace(this._numeral, '').charAt(0);
      return new RegExp(`[${this.groupChar}]`, 'g');
    },

    getMinusSignExpression() {
      const formatter = new Intl.NumberFormat(this.locale, {
        useGrouping: false
      });
      return new RegExp(`[${formatter.format(-1).trim().replace(this._numeral, '')}]`, 'g');
    },

    getCurrencyExpression() {
      if (this.currency) {
        const formatter = new Intl.NumberFormat(this.locale, {
          style: 'currency',
          currency: this.currency,
          currencyDisplay: this.currencyDisplay,
          minimumFractionDigits: 0,
          maximumFractionDigits: 0
        });
        return new RegExp(`[${formatter.format(1).replace(/\s/g, '').replace(this._numeral, '').replace(this._group, '')}]`, 'g');
      }

      return new RegExp(`[]`, 'g');
    },

    getPrefixExpression() {
      if (this.prefix) {
        this.prefixChar = this.prefix;
      } else {
        const formatter = new Intl.NumberFormat(this.locale, {
          style: this.mode,
          currency: this.currency,
          currencyDisplay: this.currencyDisplay
        });
        this.prefixChar = formatter.format(1).split('1')[0];
      }

      return new RegExp(`${this.escapeRegExp(this.prefixChar || '')}`, 'g');
    },

    getSuffixExpression() {
      if (this.suffix) {
        this.suffixChar = this.suffix;
      } else {
        const formatter = new Intl.NumberFormat(this.locale, {
          style: this.mode,
          currency: this.currency,
          currencyDisplay: this.currencyDisplay,
          minimumFractionDigits: 0,
          maximumFractionDigits: 0
        });
        this.suffixChar = formatter.format(1).split('1')[1];
      }

      return new RegExp(`${this.escapeRegExp(this.suffixChar || '')}`, 'g');
    },

    formatValue(value) {
      if (value != null) {
        if (value === '-') {
          // Minus sign
          return value;
        }

        if (this.format) {
          let formatter = new Intl.NumberFormat(this.locale, this.getOptions());
          let formattedValue = formatter.format(value);

          if (this.prefix) {
            formattedValue = this.prefix + formattedValue;
          }

          if (this.suffix) {
            formattedValue = formattedValue + this.suffix;
          }

          return formattedValue;
        }

        return value.toString();
      }

      return '';
    },

    parseValue(text) {
      let filteredText = text.replace(this._suffix, '').replace(this._prefix, '').trim().replace(/\s/g, '').replace(this._currency, '').replace(this._group, '').replace(this._minusSign, '-').replace(this._decimal, '.').replace(this._numeral, this._index);

      if (filteredText) {
        if (filteredText === '-') // Minus sign
          return filteredText;
        let parsedValue = +filteredText;
        return isNaN(parsedValue) ? null : parsedValue;
      }

      return null;
    },

    repeat(event, interval, dir) {
      if (this.readonly) {
        return;
      }

      let i = interval || 500;
      this.clearTimer();
      this.timer = setTimeout(() => {
        this.repeat(event, 40, dir);
      }, i);
      this.spin(event, dir);
    },

    spin(event, dir) {
      if (this.$refs.input) {
        let step = this.step * dir;
        let currentValue = this.parseValue(this.$refs.input.$el.value) || 0;
        let newValue = this.validateValue(currentValue + step);
        this.updateInput(newValue, null, 'spin');
        this.updateModel(event, newValue);
        this.handleOnInput(event, currentValue, newValue);
      }
    },

    onUpButtonMouseDown(event) {
      if (!this.disabled) {
        this.$refs.input.$el.focus();
        this.repeat(event, null, 1);
        event.preventDefault();
      }
    },

    onUpButtonMouseUp() {
      if (!this.disabled) {
        this.clearTimer();
      }
    },

    onUpButtonMouseLeave() {
      if (!this.disabled) {
        this.clearTimer();
      }
    },

    onUpButtonKeyUp() {
      if (!this.disabled) {
        this.clearTimer();
      }
    },

    onUpButtonKeyDown(event) {
      if (event.keyCode === 32 || event.keyCode === 13) {
        this.repeat(event, null, 1);
      }
    },

    onDownButtonMouseDown(event) {
      if (!this.disabled) {
        this.$refs.input.$el.focus();
        this.repeat(event, null, -1);
        event.preventDefault();
      }
    },

    onDownButtonMouseUp() {
      if (!this.disabled) {
        this.clearTimer();
      }
    },

    onDownButtonMouseLeave() {
      if (!this.disabled) {
        this.clearTimer();
      }
    },

    onDownButtonKeyUp() {
      if (!this.disabled) {
        this.clearTimer();
      }
    },

    onDownButtonKeyDown(event) {
      if (event.keyCode === 32 || event.keyCode === 13) {
        this.repeat(event, null, -1);
      }
    },

    onUserInput() {
      if (this.isSpecialChar) {
        this.$refs.input.$el.value = this.lastValue;
      }

      this.isSpecialChar = false;
    },

    onInputKeyDown(event) {
      if (this.readonly) {
        return;
      }

      this.lastValue = event.target.value;

      if (event.shiftKey || event.altKey) {
        this.isSpecialChar = true;
        return;
      }

      let selectionStart = event.target.selectionStart;
      let selectionEnd = event.target.selectionEnd;
      let inputValue = event.target.value;
      let newValueStr = null;

      if (event.altKey) {
        event.preventDefault();
      }

      switch (event.which) {
        //up
        case 38:
          this.spin(event, 1);
          event.preventDefault();
          break;
        //down

        case 40:
          this.spin(event, -1);
          event.preventDefault();
          break;
        //left

        case 37:
          if (!this.isNumeralChar(inputValue.charAt(selectionStart - 1))) {
            event.preventDefault();
          }

          break;
        //right

        case 39:
          if (!this.isNumeralChar(inputValue.charAt(selectionStart))) {
            event.preventDefault();
          }

          break;
        //tab and enter

        case 9:
        case 13:
          newValueStr = this.validateValue(this.parseValue(inputValue));
          this.$refs.input.$el.value = this.formatValue(newValueStr);
          this.$refs.input.$el.setAttribute('aria-valuenow', newValueStr);
          this.updateModel(event, newValueStr);
          break;
        //backspace

        case 8:
          {
            event.preventDefault();

            if (selectionStart === selectionEnd) {
              const deleteChar = inputValue.charAt(selectionStart - 1);
              const {
                decimalCharIndex,
                decimalCharIndexWithoutPrefix
              } = this.getDecimalCharIndexes(inputValue);

              if (this.isNumeralChar(deleteChar)) {
                const decimalLength = this.getDecimalLength(inputValue);

                if (this._group.test(deleteChar)) {
                  this._group.lastIndex = 0;
                  newValueStr = inputValue.slice(0, selectionStart - 2) + inputValue.slice(selectionStart - 1);
                } else if (this._decimal.test(deleteChar)) {
                  this._decimal.lastIndex = 0;

                  if (decimalLength) {
                    this.$refs.input.$el.setSelectionRange(selectionStart - 1, selectionStart - 1);
                  } else {
                    newValueStr = inputValue.slice(0, selectionStart - 1) + inputValue.slice(selectionStart);
                  }
                } else if (decimalCharIndex > 0 && selectionStart > decimalCharIndex) {
                  const insertedText = this.isDecimalMode() && (this.minFractionDigits || 0) < decimalLength ? '' : '0';
                  newValueStr = inputValue.slice(0, selectionStart - 1) + insertedText + inputValue.slice(selectionStart);
                } else if (decimalCharIndexWithoutPrefix === 1) {
                  newValueStr = inputValue.slice(0, selectionStart - 1) + '0' + inputValue.slice(selectionStart);
                  newValueStr = this.parseValue(newValueStr) > 0 ? newValueStr : '';
                } else {
                  newValueStr = inputValue.slice(0, selectionStart - 1) + inputValue.slice(selectionStart);
                }
              }

              this.updateValue(event, newValueStr, null, 'delete-single');
            } else {
              newValueStr = this.deleteRange(inputValue, selectionStart, selectionEnd);
              this.updateValue(event, newValueStr, null, 'delete-range');
            }

            break;
          }
        // del

        case 46:
          event.preventDefault();

          if (selectionStart === selectionEnd) {
            const deleteChar = inputValue.charAt(selectionStart);
            const {
              decimalCharIndex,
              decimalCharIndexWithoutPrefix
            } = this.getDecimalCharIndexes(inputValue);

            if (this.isNumeralChar(deleteChar)) {
              const decimalLength = this.getDecimalLength(inputValue);

              if (this._group.test(deleteChar)) {
                this._group.lastIndex = 0;
                newValueStr = inputValue.slice(0, selectionStart) + inputValue.slice(selectionStart + 2);
              } else if (this._decimal.test(deleteChar)) {
                this._decimal.lastIndex = 0;

                if (decimalLength) {
                  this.$refs.input.$el.setSelectionRange(selectionStart + 1, selectionStart + 1);
                } else {
                  newValueStr = inputValue.slice(0, selectionStart) + inputValue.slice(selectionStart + 1);
                }
              } else if (decimalCharIndex > 0 && selectionStart > decimalCharIndex) {
                const insertedText = this.isDecimalMode() && (this.minFractionDigits || 0) < decimalLength ? '' : '0';
                newValueStr = inputValue.slice(0, selectionStart) + insertedText + inputValue.slice(selectionStart + 1);
              } else if (decimalCharIndexWithoutPrefix === 1) {
                newValueStr = inputValue.slice(0, selectionStart) + '0' + inputValue.slice(selectionStart + 1);
                newValueStr = this.parseValue(newValueStr) > 0 ? newValueStr : '';
              } else {
                newValueStr = inputValue.slice(0, selectionStart) + inputValue.slice(selectionStart + 1);
              }
            }

            this.updateValue(event, newValueStr, null, 'delete-back-single');
          } else {
            newValueStr = this.deleteRange(inputValue, selectionStart, selectionEnd);
            this.updateValue(event, newValueStr, null, 'delete-range');
          }

          break;
        //home

        case 36:
          if (this.min) {
            this.updateModel(event, this.min);
            event.preventDefault();
          }

          break;
        //end

        case 35:
          if (this.max) {
            this.updateModel(event, this.max);
            event.preventDefault();
          }

          break;
      }
    },

    onInputKeyPress(event) {
      if (this.readonly) {
        return;
      }

      event.preventDefault();
      let code = event.which || event.keyCode;
      let char = String.fromCharCode(code);
      const isDecimalSign = this.isDecimalSign(char);
      const isMinusSign = this.isMinusSign(char);

      if (48 <= code && code <= 57 || isMinusSign || isDecimalSign) {
        this.insert(event, char, {
          isDecimalSign,
          isMinusSign
        });
      }
    },

    onPaste(event) {
      event.preventDefault();
      let data = (event.clipboardData || window['clipboardData']).getData('Text');

      if (data) {
        let filteredData = this.parseValue(data);

        if (filteredData != null) {
          this.insert(event, filteredData.toString());
        }
      }
    },

    allowMinusSign() {
      return this.min === null || this.min < 0;
    },

    isMinusSign(char) {
      if (this._minusSign.test(char) || char === '-') {
        this._minusSign.lastIndex = 0;
        return true;
      }

      return false;
    },

    isDecimalSign(char) {
      if (this._decimal.test(char)) {
        this._decimal.lastIndex = 0;
        return true;
      }

      return false;
    },

    isDecimalMode() {
      return this.mode === 'decimal';
    },

    getDecimalCharIndexes(val) {
      let decimalCharIndex = val.search(this._decimal);
      this._decimal.lastIndex = 0;
      const filteredVal = val.replace(this._prefix, '').trim().replace(/\s/g, '').replace(this._currency, '');
      const decimalCharIndexWithoutPrefix = filteredVal.search(this._decimal);
      this._decimal.lastIndex = 0;
      return {
        decimalCharIndex,
        decimalCharIndexWithoutPrefix
      };
    },

    getCharIndexes(val) {
      const decimalCharIndex = val.search(this._decimal);
      this._decimal.lastIndex = 0;
      const minusCharIndex = val.search(this._minusSign);
      this._minusSign.lastIndex = 0;
      const suffixCharIndex = val.search(this._suffix);
      this._suffix.lastIndex = 0;
      const currencyCharIndex = val.search(this._currency);
      this._currency.lastIndex = 0;
      return {
        decimalCharIndex,
        minusCharIndex,
        suffixCharIndex,
        currencyCharIndex
      };
    },

    insert(event, text, sign = {
      isDecimalSign: false,
      isMinusSign: false
    }) {
      const minusCharIndexOnText = text.search(this._minusSign);
      this._minusSign.lastIndex = 0;

      if (!this.allowMinusSign() && minusCharIndexOnText !== -1) {
        return;
      }

      const selectionStart = this.$refs.input.$el.selectionStart;
      const selectionEnd = this.$refs.input.$el.selectionEnd;
      let inputValue = this.$refs.input.$el.value.trim();
      const {
        decimalCharIndex,
        minusCharIndex,
        suffixCharIndex,
        currencyCharIndex
      } = this.getCharIndexes(inputValue);
      let newValueStr;

      if (sign.isMinusSign) {
        if (selectionStart === 0) {
          newValueStr = inputValue;

          if (minusCharIndex === -1 || selectionEnd !== 0) {
            newValueStr = this.insertText(inputValue, text, 0, selectionEnd);
          }

          this.updateValue(event, newValueStr, text, 'insert');
        }
      } else if (sign.isDecimalSign) {
        if (decimalCharIndex > 0 && selectionStart === decimalCharIndex) {
          this.updateValue(event, inputValue, text, 'insert');
        } else if (decimalCharIndex > selectionStart && decimalCharIndex < selectionEnd) {
          newValueStr = this.insertText(inputValue, text, selectionStart, selectionEnd);
          this.updateValue(event, newValueStr, text, 'insert');
        } else if (decimalCharIndex === -1 && this.maxFractionDigits) {
          newValueStr = this.insertText(inputValue, text, selectionStart, selectionEnd);
          this.updateValue(event, newValueStr, text, 'insert');
        }
      } else {
        const maxFractionDigits = this.numberFormat.resolvedOptions().maximumFractionDigits;
        const operation = selectionStart !== selectionEnd ? 'range-insert' : 'insert';

        if (decimalCharIndex > 0 && selectionStart > decimalCharIndex) {
          if (selectionStart + text.length - (decimalCharIndex + 1) <= maxFractionDigits) {
            const charIndex = currencyCharIndex >= selectionStart ? currencyCharIndex - 1 : suffixCharIndex >= selectionStart ? suffixCharIndex : inputValue.length;
            newValueStr = inputValue.slice(0, selectionStart) + text + inputValue.slice(selectionStart + text.length, charIndex) + inputValue.slice(charIndex);
            this.updateValue(event, newValueStr, text, operation);
          }
        } else {
          newValueStr = this.insertText(inputValue, text, selectionStart, selectionEnd);
          this.updateValue(event, newValueStr, text, operation);
        }
      }
    },

    insertText(value, text, start, end) {
      let textSplit = text === '.' ? text : text.split('.');

      if (textSplit.length === 2) {
        const decimalCharIndex = value.slice(start, end).search(this._decimal);
        this._decimal.lastIndex = 0;
        return decimalCharIndex > 0 ? value.slice(0, start) + this.formatValue(text) + value.slice(end) : value || this.formatValue(text);
      } else if (end - start === value.length) {
        return this.formatValue(text);
      } else if (start === 0) {
        return text + value.slice(end);
      } else if (end === value.length) {
        return value.slice(0, start) + text;
      } else {
        return value.slice(0, start) + text + value.slice(end);
      }
    },

    deleteRange(value, start, end) {
      let newValueStr;
      if (end - start === value.length) newValueStr = '';else if (start === 0) newValueStr = value.slice(end);else if (end === value.length) newValueStr = value.slice(0, start);else newValueStr = value.slice(0, start) + value.slice(end);
      return newValueStr;
    },

    initCursor() {
      let selectionStart = this.$refs.input.$el.selectionStart;
      let inputValue = this.$refs.input.$el.value;
      let valueLength = inputValue.length;
      let index = null; // remove prefix

      let prefixLength = (this.prefixChar || '').length;
      inputValue = inputValue.replace(this._prefix, '');
      selectionStart = selectionStart - prefixLength;
      let char = inputValue.charAt(selectionStart);

      if (this.isNumeralChar(char)) {
        return selectionStart + prefixLength;
      } //left


      let i = selectionStart - 1;

      while (i >= 0) {
        char = inputValue.charAt(i);

        if (this.isNumeralChar(char)) {
          index = i + prefixLength;
          break;
        } else {
          i--;
        }
      }

      if (index !== null) {
        this.$refs.input.$el.setSelectionRange(index + 1, index + 1);
      } else {
        i = selectionStart;

        while (i < valueLength) {
          char = inputValue.charAt(i);

          if (this.isNumeralChar(char)) {
            index = i + prefixLength;
            break;
          } else {
            i++;
          }
        }

        if (index !== null) {
          this.$refs.input.$el.setSelectionRange(index, index);
        }
      }

      return index || 0;
    },

    onInputClick() {
      const currentValue = this.$refs.input.$el.value;

      if (!this.readonly && currentValue !== DomHandler.getSelection()) {
        this.initCursor();
      }
    },

    isNumeralChar(char) {
      if (char.length === 1 && (this._numeral.test(char) || this._decimal.test(char) || this._group.test(char) || this._minusSign.test(char))) {
        this.resetRegex();
        return true;
      }

      return false;
    },

    resetRegex() {
      this._numeral.lastIndex = 0;
      this._decimal.lastIndex = 0;
      this._group.lastIndex = 0;
      this._minusSign.lastIndex = 0;
    },

    updateValue(event, valueStr, insertedValueStr, operation) {
      let currentValue = this.$refs.input.$el.value;
      let newValue = null;

      if (valueStr != null) {
        newValue = this.parseValue(valueStr);
        newValue = !newValue && !this.allowEmpty ? 0 : newValue;
        this.updateInput(newValue, insertedValueStr, operation, valueStr);
        this.handleOnInput(event, currentValue, newValue);
      }
    },

    handleOnInput(event, currentValue, newValue) {
      if (this.isValueChanged(currentValue, newValue)) {
        this.$emit('input', {
          originalEvent: event,
          value: newValue,
          formattedValue: currentValue
        });
      }
    },

    isValueChanged(currentValue, newValue) {
      if (newValue === null && currentValue !== null) {
        return true;
      }

      if (newValue != null) {
        let parsedCurrentValue = typeof currentValue === 'string' ? this.parseValue(currentValue) : currentValue;
        return newValue !== parsedCurrentValue;
      }

      return false;
    },

    validateValue(value) {
      if (value === '-' || value == null) {
        return null;
      }

      if (this.min != null && value < this.min) {
        return this.min;
      }

      if (this.max != null && value > this.max) {
        return this.max;
      }

      return value;
    },

    updateInput(value, insertedValueStr, operation, valueStr) {
      insertedValueStr = insertedValueStr || '';
      let inputValue = this.$refs.input.$el.value;
      let newValue = this.formatValue(value);
      let currentLength = inputValue.length;

      if (newValue !== valueStr) {
        newValue = this.concatValues(newValue, valueStr);
      }

      if (currentLength === 0) {
        this.$refs.input.$el.value = newValue;
        this.$refs.input.$el.setSelectionRange(0, 0);
        const index = this.initCursor();
        const selectionEnd = index + insertedValueStr.length;
        this.$refs.input.$el.setSelectionRange(selectionEnd, selectionEnd);
      } else {
        let selectionStart = this.$refs.input.$el.selectionStart;
        let selectionEnd = this.$refs.input.$el.selectionEnd;
        this.$refs.input.$el.value = newValue;
        let newLength = newValue.length;

        if (operation === 'range-insert') {
          const startValue = this.parseValue((inputValue || '').slice(0, selectionStart));
          const startValueStr = startValue !== null ? startValue.toString() : '';
          const startExpr = startValueStr.split('').join(`(${this.groupChar})?`);
          const sRegex = new RegExp(startExpr, 'g');
          sRegex.test(newValue);
          const tExpr = insertedValueStr.split('').join(`(${this.groupChar})?`);
          const tRegex = new RegExp(tExpr, 'g');
          tRegex.test(newValue.slice(sRegex.lastIndex));
          selectionEnd = sRegex.lastIndex + tRegex.lastIndex;
          this.$refs.input.$el.setSelectionRange(selectionEnd, selectionEnd);
        } else if (newLength === currentLength) {
          if (operation === 'insert' || operation === 'delete-back-single') this.$refs.input.$el.setSelectionRange(selectionEnd + 1, selectionEnd + 1);else if (operation === 'delete-single') this.$refs.input.$el.setSelectionRange(selectionEnd - 1, selectionEnd - 1);else if (operation === 'delete-range' || operation === 'spin') this.$refs.input.$el.setSelectionRange(selectionEnd, selectionEnd);
        } else if (operation === 'delete-back-single') {
          let prevChar = inputValue.charAt(selectionEnd - 1);
          let nextChar = inputValue.charAt(selectionEnd);
          let diff = currentLength - newLength;

          let isGroupChar = this._group.test(nextChar);

          if (isGroupChar && diff === 1) {
            selectionEnd += 1;
          } else if (!isGroupChar && this.isNumeralChar(prevChar)) {
            selectionEnd += -1 * diff + 1;
          }

          this._group.lastIndex = 0;
          this.$refs.input.$el.setSelectionRange(selectionEnd, selectionEnd);
        } else if (inputValue === '-' && operation === 'insert') {
          this.$refs.input.$el.setSelectionRange(0, 0);
          const index = this.initCursor();
          const selectionEnd = index + insertedValueStr.length + 1;
          this.$refs.input.$el.setSelectionRange(selectionEnd, selectionEnd);
        } else {
          selectionEnd = selectionEnd + (newLength - currentLength);
          this.$refs.input.$el.setSelectionRange(selectionEnd, selectionEnd);
        }
      }

      this.$refs.input.$el.setAttribute('aria-valuenow', value);
    },

    concatValues(val1, val2) {
      if (val1 && val2) {
        let decimalCharIndex = val2.search(this._decimal);
        this._decimal.lastIndex = 0;

        if (this.suffixChar) {
          return val1.replace(this.suffixChar, '').split(this._decimal)[0] + val2.replace(this.suffixChar, '').slice(decimalCharIndex) + this.suffixChar;
        } else {
          return decimalCharIndex !== -1 ? val1.split(this._decimal)[0] + val2.slice(decimalCharIndex) : val1;
        }
      }

      return val1;
    },

    getDecimalLength(value) {
      if (value) {
        const valueSplit = value.split(this._decimal);

        if (valueSplit.length === 2) {
          return valueSplit[1].replace(this._suffix, '').trim().replace(/\s/g, '').replace(this._currency, '').length;
        }
      }

      return 0;
    },

    updateModel(event, value) {
      this.d_modelValue = value;
      this.$emit('update:modelValue', value);
    },

    onInputFocus(event) {
      this.focused = true;

      if (!this.disabled && !this.readonly && this.$refs.input.$el.value !== DomHandler.getSelection() && this.highlightOnFocus) {
        event.target.select();
      }

      this.$emit('focus', event);
    },

    onInputBlur(event) {
      this.focused = false;
      let input = event.target;
      let newValue = this.validateValue(this.parseValue(input.value));
      this.$emit('blur', {
        originalEvent: event,
        value: input.value
      });
      input.value = this.formatValue(newValue);
      input.setAttribute('aria-valuenow', newValue);
      this.updateModel(event, newValue);
    },

    clearTimer() {
      if (this.timer) {
        clearInterval(this.timer);
      }
    },

    maxBoundry() {
      return this.d_modelValue >= this.max;
    },

    minBoundry() {
      return this.d_modelValue <= this.min;
    }

  },
  computed: {
    containerClass() {
      return ['p-inputnumber p-component p-inputwrapper', {
        'p-inputwrapper-filled': this.filled,
        'p-inputwrapper-focus': this.focused,
        'p-inputnumber-buttons-stacked': this.showButtons && this.buttonLayout === 'stacked',
        'p-inputnumber-buttons-horizontal': this.showButtons && this.buttonLayout === 'horizontal',
        'p-inputnumber-buttons-vertical': this.showButtons && this.buttonLayout === 'vertical'
      }];
    },

    upButtonClass() {
      return ['p-inputnumber-button p-inputnumber-button-up', this.incrementButtonClass, {
        'p-disabled': this.showButtons && this.max !== null && this.maxBoundry()
      }];
    },

    downButtonClass() {
      return ['p-inputnumber-button p-inputnumber-button-down', this.decrementButtonClass, {
        'p-disabled': this.showButtons && this.min !== null && this.minBoundry()
      }];
    },

    filled() {
      return this.modelValue != null && this.modelValue.toString().length > 0;
    },

    upButtonListeners() {
      return {
        mousedown: event => this.onUpButtonMouseDown(event),
        mouseup: event => this.onUpButtonMouseUp(event),
        mouseleave: event => this.onUpButtonMouseLeave(event),
        keydown: event => this.onUpButtonKeyDown(event),
        keyup: event => this.onUpButtonKeyUp(event)
      };
    },

    downButtonListeners() {
      return {
        mousedown: event => this.onDownButtonMouseDown(event),
        mouseup: event => this.onDownButtonMouseUp(event),
        mouseleave: event => this.onDownButtonMouseLeave(event),
        keydown: event => this.onDownButtonKeyDown(event),
        keyup: event => this.onDownButtonKeyUp(event)
      };
    },

    formattedValue() {
      const val = !this.modelValue && !this.allowEmpty ? 0 : this.modelValue;
      return this.formatValue(val);
    },

    getFormatter() {
      return this.numberFormat;
    }

  },
  components: {
    INInputText: script$1M,
    INButton: script$1L
  }
};
const _hoisted_1$I = {
  key: 0,
  class: "p-inputnumber-button-group"
};

function render$u(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_INInputText = resolveComponent("INInputText");

  const _component_INButton = resolveComponent("INButton");

  return openBlock(), createElementBlock("span", {
    class: normalizeClass($options.containerClass)
  }, [createVNode(_component_INInputText, mergeProps({
    ref: "input",
    id: $props.inputId,
    class: ["p-inputnumber-input", $props.inputClass],
    role: "spinbutton",
    style: $props.inputStyle,
    value: $options.formattedValue,
    "aria-valuemin": $props.min,
    "aria-valuemax": $props.max,
    "aria-valuenow": $props.modelValue,
    disabled: $props.disabled,
    readonly: $props.readonly,
    placeholder: $props.placeholder,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    onInput: $options.onUserInput,
    onKeydown: $options.onInputKeyDown,
    onKeypress: $options.onInputKeyPress,
    onPaste: $options.onPaste,
    onClick: $options.onInputClick,
    onFocus: $options.onInputFocus,
    onBlur: $options.onInputBlur
  }, $props.inputProps), null, 16, ["id", "class", "style", "value", "aria-valuemin", "aria-valuemax", "aria-valuenow", "disabled", "readonly", "placeholder", "aria-labelledby", "aria-label", "onInput", "onKeydown", "onKeypress", "onPaste", "onClick", "onFocus", "onBlur"]), $props.showButtons && $props.buttonLayout === 'stacked' ? (openBlock(), createElementBlock("span", _hoisted_1$I, [createVNode(_component_INButton, mergeProps({
    class: $options.upButtonClass,
    icon: $props.incrementButtonIcon
  }, toHandlers($options.upButtonListeners), {
    disabled: $props.disabled,
    tabindex: -1,
    "aria-hidden": "true"
  }, $props.incrementButtonProps), null, 16, ["class", "icon", "disabled"]), createVNode(_component_INButton, mergeProps({
    class: $options.downButtonClass,
    icon: $props.decrementButtonIcon
  }, toHandlers($options.downButtonListeners), {
    disabled: $props.disabled,
    tabindex: -1,
    "aria-hidden": "true"
  }, $props.decrementButtonProps), null, 16, ["class", "icon", "disabled"])])) : createCommentVNode("", true), $props.showButtons && $props.buttonLayout !== 'stacked' ? (openBlock(), createBlock(_component_INButton, mergeProps({
    key: 1,
    class: $options.upButtonClass,
    icon: $props.incrementButtonIcon
  }, toHandlers($options.upButtonListeners), {
    disabled: $props.disabled,
    tabindex: -1,
    "aria-hidden": "true"
  }, $props.incrementButtonProps), null, 16, ["class", "icon", "disabled"])) : createCommentVNode("", true), $props.showButtons && $props.buttonLayout !== 'stacked' ? (openBlock(), createBlock(_component_INButton, mergeProps({
    key: 2,
    class: $options.downButtonClass,
    icon: $props.decrementButtonIcon
  }, toHandlers($options.downButtonListeners), {
    disabled: $props.disabled,
    tabindex: -1,
    "aria-hidden": "true"
  }, $props.decrementButtonProps), null, 16, ["class", "icon", "disabled"])) : createCommentVNode("", true)], 2);
}

function styleInject$p(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$w = "\n.p-inputnumber {\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n}\n.p-inputnumber-button {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    -webkit-box-flex: 0;\n        -ms-flex: 0 0 auto;\n            flex: 0 0 auto;\n}\n.p-inputnumber-buttons-stacked .p-button.p-inputnumber-button .p-button-label,\n.p-inputnumber-buttons-horizontal .p-button.p-inputnumber-button .p-button-label {\n    display: none;\n}\n.p-inputnumber-buttons-stacked .p-button.p-inputnumber-button-up {\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n    padding: 0;\n}\n.p-inputnumber-buttons-stacked .p-inputnumber-input {\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n}\n.p-inputnumber-buttons-stacked .p-button.p-inputnumber-button-down {\n    border-top-left-radius: 0;\n    border-top-right-radius: 0;\n    border-bottom-left-radius: 0;\n    padding: 0;\n}\n.p-inputnumber-buttons-stacked .p-inputnumber-button-group {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n        -ms-flex-direction: column;\n            flex-direction: column;\n}\n.p-inputnumber-buttons-stacked .p-inputnumber-button-group .p-button.p-inputnumber-button {\n    -webkit-box-flex: 1;\n        -ms-flex: 1 1 auto;\n            flex: 1 1 auto;\n}\n.p-inputnumber-buttons-horizontal .p-button.p-inputnumber-button-up {\n    -webkit-box-ordinal-group: 4;\n        -ms-flex-order: 3;\n            order: 3;\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0;\n}\n.p-inputnumber-buttons-horizontal .p-inputnumber-input {\n    -webkit-box-ordinal-group: 3;\n        -ms-flex-order: 2;\n            order: 2;\n    border-radius: 0;\n}\n.p-inputnumber-buttons-horizontal .p-button.p-inputnumber-button-down {\n    -webkit-box-ordinal-group: 2;\n        -ms-flex-order: 1;\n            order: 1;\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n}\n.p-inputnumber-buttons-vertical {\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n        -ms-flex-direction: column;\n            flex-direction: column;\n}\n.p-inputnumber-buttons-vertical .p-button.p-inputnumber-button-up {\n    -webkit-box-ordinal-group: 2;\n        -ms-flex-order: 1;\n            order: 1;\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n    width: 100%;\n}\n.p-inputnumber-buttons-vertical .p-inputnumber-input {\n    -webkit-box-ordinal-group: 3;\n        -ms-flex-order: 2;\n            order: 2;\n    border-radius: 0;\n    text-align: center;\n}\n.p-inputnumber-buttons-vertical .p-button.p-inputnumber-button-down {\n    -webkit-box-ordinal-group: 4;\n        -ms-flex-order: 3;\n            order: 3;\n    border-top-left-radius: 0;\n    border-top-right-radius: 0;\n    width: 100%;\n}\n.p-inputnumber-input {\n    -webkit-box-flex: 1;\n        -ms-flex: 1 1 auto;\n            flex: 1 1 auto;\n}\n.p-fluid .p-inputnumber {\n    width: 100%;\n}\n.p-fluid .p-inputnumber .p-inputnumber-input {\n    width: 1%;\n}\n.p-fluid .p-inputnumber-buttons-vertical .p-inputnumber-input {\n    width: 100%;\n}\n";
styleInject$p(css_248z$w);
script$1n.render = render$u;

var script$1m = {
  props: {
    bind : {
        type : Object,
        required : true
    }
},
  setup(__props) {

const props = __props;





const cvalue = ref(props.bind.value);

const value = computed({
    get() {
        return cvalue.value;
    },
    set(val) {
        props.bind.setValue(val);
        cvalue.value = val;
    }
});



const cell = props.bind.cell;
const atts = {};
if (cell.round) {
    let step = "0.";
    for(let i=0; i<cell.round - 1; ++i) {
        step += "0";
    }
    step += "1";
    atts["step"]  = parseInt(step);
}


return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$1n), mergeProps({
    class: ["focus:border-primary", __props.bind.classes],
    name: __props.bind.cell.name,
    modelValue: unref(value),
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (isRef(value) ? (value).value = $event : null))
  }, atts, {
    onBlur: _cache[1] || (_cache[1] = $event => (__props.bind.active_validation = true))
  }), null, 16 /* FULL_PROPS */, ["name", "class", "modelValue"]))
}
}

};

script$1m.__file = "presstojam/src/components/form/number-edit.vue";

var script$1l = {
  props: {
    bind : {
        type : Object,
        required : true
    }
},
  setup(__props) {

const props = __props;



const cvalue = ref(props.bind.value ? true : false);




const value = computed({
    get() {
        return cvalue.value;
    },
    set(val) {
        props.bind.value = (val) ? 1 : 0;
        cvalue.value = val;
    }
});


return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$1I), {
    modelValue: unref(value),
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (isRef(value) ? (value).value = $event : null)),
    class: normalizeClass(__props.bind.classes),
    inputId: __props.bind.cell.name,
    binary: true,
    onBlur: _cache[1] || (_cache[1] = $event => (__props.bind.setShowError(true)))
  }, null, 8 /* PROPS */, ["modelValue", "class", "inputId"]))
}
}

};

script$1l.__file = "presstojam/src/components/form/flag-edit.vue";

var script$1$5 = {
  name: 'TreeNode',
  emits: ['node-toggle', 'node-click', 'checkbox-change'],
  props: {
    node: {
      type: null,
      default: null
    },
    expandedKeys: {
      type: null,
      default: null
    },
    selectionKeys: {
      type: null,
      default: null
    },
    selectionMode: {
      type: String,
      default: null
    },
    templates: {
      type: null,
      default: null
    },
    level: {
      type: Number,
      default: null
    },
    index: {
      type: Number,
      default: null
    }
  },
  nodeTouched: false,
  methods: {
    toggle() {
      this.$emit('node-toggle', this.node);
    },

    label(node) {
      return typeof node.label === 'function' ? node.label() : node.label;
    },

    onChildNodeToggle(node) {
      this.$emit('node-toggle', node);
    },

    onClick(event) {
      if (DomHandler.hasClass(event.target, 'p-tree-toggler') || DomHandler.hasClass(event.target.parentElement, 'p-tree-toggler')) {
        return;
      }

      if (this.isCheckboxSelectionMode()) {
        this.toggleCheckbox();
      } else {
        this.$emit('node-click', {
          originalEvent: event,
          nodeTouched: this.nodeTouched,
          node: this.node
        });
      }

      this.nodeTouched = false;
    },

    onChildNodeClick(event) {
      this.$emit('node-click', event);
    },

    onTouchEnd() {
      this.nodeTouched = true;
    },

    onKeyDown(event) {
      const nodeElement = event.target.parentElement;

      switch (event.code) {
        case 'ArrowDown':
          var listElement = nodeElement.children[1];

          if (listElement) {
            this.focusNode(listElement.children[0]);
          } else {
            const nextNodeElement = nodeElement.nextElementSibling;

            if (nextNodeElement) {
              this.focusNode(nextNodeElement);
            } else {
              let nextSiblingAncestor = this.findNextSiblingOfAncestor(nodeElement);

              if (nextSiblingAncestor) {
                this.focusNode(nextSiblingAncestor);
              }
            }
          }

          break;

        case 'ArrowUp':
          if (nodeElement.previousElementSibling) {
            this.focusNode(this.findLastVisibleDescendant(nodeElement.previousElementSibling));
          } else {
            let parentNodeElement = this.getParentNodeElement(nodeElement);

            if (parentNodeElement) {
              this.focusNode(parentNodeElement);
            }
          }

          break;

        case 'ArrowRight':
        case 'ArrowLeft':
          this.$emit('node-toggle', this.node);
          break;

        case 'Enter':
        case 'Space':
          this.onClick(event);
          break;
      }

      event.preventDefault();
    },

    toggleCheckbox() {
      let _selectionKeys = this.selectionKeys ? { ...this.selectionKeys
      } : {};

      const _check = !this.checked;

      this.propagateDown(this.node, _check, _selectionKeys);
      this.$emit('checkbox-change', {
        node: this.node,
        check: _check,
        selectionKeys: _selectionKeys
      });
    },

    propagateDown(node, check, selectionKeys) {
      if (check) selectionKeys[node.key] = {
        checked: true,
        partialChecked: false
      };else delete selectionKeys[node.key];

      if (node.children && node.children.length) {
        for (let child of node.children) {
          this.propagateDown(child, check, selectionKeys);
        }
      }
    },

    propagateUp(event) {
      let check = event.check;
      let _selectionKeys = { ...event.selectionKeys
      };
      let checkedChildCount = 0;
      let childPartialSelected = false;

      for (let child of this.node.children) {
        if (_selectionKeys[child.key] && _selectionKeys[child.key].checked) checkedChildCount++;else if (_selectionKeys[child.key] && _selectionKeys[child.key].partialChecked) childPartialSelected = true;
      }

      if (check && checkedChildCount === this.node.children.length) {
        _selectionKeys[this.node.key] = {
          checked: true,
          partialChecked: false
        };
      } else {
        if (!check) {
          delete _selectionKeys[this.node.key];
        }

        if (childPartialSelected || checkedChildCount > 0 && checkedChildCount !== this.node.children.length) _selectionKeys[this.node.key] = {
          checked: false,
          partialChecked: true
        };else delete _selectionKeys[this.node.key];
      }

      this.$emit('checkbox-change', {
        node: event.node,
        check: event.check,
        selectionKeys: _selectionKeys
      });
    },

    onChildCheckboxChange(event) {
      this.$emit('checkbox-change', event);
    },

    findNextSiblingOfAncestor(nodeElement) {
      let parentNodeElement = this.getParentNodeElement(nodeElement);

      if (parentNodeElement) {
        if (parentNodeElement.nextElementSibling) return parentNodeElement.nextElementSibling;else return this.findNextSiblingOfAncestor(parentNodeElement);
      } else {
        return null;
      }
    },

    findLastVisibleDescendant(nodeElement) {
      const childrenListElement = nodeElement.children[1];

      if (childrenListElement) {
        const lastChildElement = childrenListElement.children[childrenListElement.children.length - 1];
        return this.findLastVisibleDescendant(lastChildElement);
      } else {
        return nodeElement;
      }
    },

    getParentNodeElement(nodeElement) {
      const parentNodeElement = nodeElement.parentElement.parentElement;
      return DomHandler.hasClass(parentNodeElement, 'p-treenode') ? parentNodeElement : null;
    },

    focusNode(element) {
      element.children[0].focus();
    },

    isCheckboxSelectionMode() {
      return this.selectionMode === 'checkbox';
    }

  },
  computed: {
    hasChildren() {
      return this.node.children && this.node.children.length > 0;
    },

    expanded() {
      return this.expandedKeys && this.expandedKeys[this.node.key] === true;
    },

    leaf() {
      return this.node.leaf === false ? false : !(this.node.children && this.node.children.length);
    },

    selectable() {
      return this.node.selectable === false ? false : this.selectionMode != null;
    },

    selected() {
      return this.selectionMode && this.selectionKeys ? this.selectionKeys[this.node.key] === true : false;
    },

    containerClass() {
      return ['p-treenode', {
        'p-treenode-leaf': this.leaf
      }];
    },

    contentClass() {
      return ['p-treenode-content', this.node.styleClass, {
        'p-treenode-selectable': this.selectable,
        'p-highlight': this.checkboxMode ? this.checked : this.selected
      }];
    },

    icon() {
      return ['p-treenode-icon', this.node.icon];
    },

    toggleIcon() {
      return ['p-tree-toggler-icon pi pi-fw', this.expanded ? this.node.expandedIcon || 'pi-chevron-down' : this.node.collapsedIcon || 'pi-chevron-right'];
    },

    checkboxClass() {
      return ['p-checkbox-box', {
        'p-highlight': this.checked,
        'p-indeterminate': this.partialChecked
      }];
    },

    checkboxIcon() {
      return ['p-checkbox-icon', {
        'pi pi-check': this.checked,
        'pi pi-minus': this.partialChecked
      }];
    },

    checkboxMode() {
      return this.selectionMode === 'checkbox' && this.node.selectable !== false;
    },

    checked() {
      return this.selectionKeys ? this.selectionKeys[this.node.key] && this.selectionKeys[this.node.key].checked : false;
    },

    partialChecked() {
      return this.selectionKeys ? this.selectionKeys[this.node.key] && this.selectionKeys[this.node.key].partialChecked : false;
    }

  },
  directives: {
    ripple: Ripple
  }
};
const _hoisted_1$1$5 = ["aria-label", "aria-selected", "aria-expanded", "aria-setsize", "aria-posinset", "aria-level"];
const _hoisted_2$1$5 = ["aria-expanded"];
const _hoisted_3$1$4 = {
  key: 0,
  class: "p-checkbox p-component"
};
const _hoisted_4$1$3 = ["aria-checked"];
const _hoisted_5$1$3 = {
  class: "p-treenode-label"
};
const _hoisted_6$i = {
  key: 0,
  class: "p-treenode-children",
  role: "group"
};

function render$1$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TreeNode = resolveComponent("TreeNode", true);

  const _directive_ripple = resolveDirective("ripple");

  return openBlock(), createElementBlock("li", {
    class: normalizeClass($options.containerClass),
    role: "treeitem",
    "aria-label": $options.label($props.node),
    "aria-selected": $options.selected,
    "aria-expanded": $options.expanded,
    "aria-setsize": $props.node.children ? $props.node.children.length : 0,
    "aria-posinset": $props.index + 1,
    "aria-level": $props.level
  }, [createElementVNode("div", {
    class: normalizeClass($options.contentClass),
    tabindex: "0",
    role: "treeitem",
    "aria-expanded": $options.expanded,
    onClick: _cache[1] || (_cache[1] = (...args) => $options.onClick && $options.onClick(...args)),
    onKeydown: _cache[2] || (_cache[2] = (...args) => $options.onKeyDown && $options.onKeyDown(...args)),
    onTouchend: _cache[3] || (_cache[3] = (...args) => $options.onTouchEnd && $options.onTouchEnd(...args)),
    style: normalizeStyle($props.node.style)
  }, [withDirectives((openBlock(), createElementBlock("button", {
    type: "button",
    class: "p-tree-toggler p-link",
    onClick: _cache[0] || (_cache[0] = (...args) => $options.toggle && $options.toggle(...args)),
    tabindex: "-1"
  }, [createElementVNode("span", {
    class: normalizeClass($options.toggleIcon)
  }, null, 2)])), [[_directive_ripple]]), $options.checkboxMode ? (openBlock(), createElementBlock("div", _hoisted_3$1$4, [createElementVNode("div", {
    class: normalizeClass($options.checkboxClass),
    role: "checkbox",
    "aria-checked": $options.checked
  }, [createElementVNode("span", {
    class: normalizeClass($options.checkboxIcon)
  }, null, 2)], 10, _hoisted_4$1$3)])) : createCommentVNode("", true), createElementVNode("span", {
    class: normalizeClass($options.icon)
  }, null, 2), createElementVNode("span", _hoisted_5$1$3, [$props.templates[$props.node.type] || $props.templates['default'] ? (openBlock(), createBlock(resolveDynamicComponent($props.templates[$props.node.type] || $props.templates['default']), {
    key: 0,
    node: $props.node
  }, null, 8, ["node"])) : (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [createTextVNode(toDisplayString$1($options.label($props.node)), 1)], 64))])], 46, _hoisted_2$1$5), $options.hasChildren && $options.expanded ? (openBlock(), createElementBlock("ul", _hoisted_6$i, [(openBlock(true), createElementBlock(Fragment, null, renderList($props.node.children, childNode => {
    return openBlock(), createBlock(_component_TreeNode, {
      key: childNode.key,
      node: childNode,
      templates: $props.templates,
      level: $props.level + 1,
      expandedKeys: $props.expandedKeys,
      onNodeToggle: $options.onChildNodeToggle,
      onNodeClick: $options.onChildNodeClick,
      selectionMode: $props.selectionMode,
      selectionKeys: $props.selectionKeys,
      onCheckboxChange: $options.propagateUp
    }, null, 8, ["node", "templates", "level", "expandedKeys", "onNodeToggle", "onNodeClick", "selectionMode", "selectionKeys", "onCheckboxChange"]);
  }), 128))])) : createCommentVNode("", true)], 10, _hoisted_1$1$5);
}

script$1$5.render = render$1$5;
var script$1k = {
  name: 'Tree',
  emits: ['node-expand', 'node-collapse', 'update:expandedKeys', 'update:selectionKeys', 'node-select', 'node-unselect'],
  props: {
    value: {
      type: null,
      default: null
    },
    expandedKeys: {
      type: null,
      default: null
    },
    selectionKeys: {
      type: null,
      default: null
    },
    selectionMode: {
      type: String,
      default: null
    },
    metaKeySelection: {
      type: Boolean,
      default: true
    },
    loading: {
      type: Boolean,
      default: false
    },
    loadingIcon: {
      type: String,
      default: 'pi pi-spinner'
    },
    filter: {
      type: Boolean,
      default: false
    },
    filterBy: {
      type: String,
      default: 'label'
    },
    filterMode: {
      type: String,
      default: 'lenient'
    },
    filterPlaceholder: {
      type: String,
      default: null
    },
    filterLocale: {
      type: String,
      default: undefined
    },
    scrollHeight: {
      type: String,
      default: null
    },
    level: {
      type: Number,
      default: 0
    }
  },

  data() {
    return {
      d_expandedKeys: this.expandedKeys || {},
      filterValue: null
    };
  },

  watch: {
    expandedKeys(newValue) {
      this.d_expandedKeys = newValue;
    }

  },
  methods: {
    onNodeToggle(node) {
      const key = node.key;

      if (this.d_expandedKeys[key]) {
        delete this.d_expandedKeys[key];
        this.$emit('node-collapse', node);
      } else {
        this.d_expandedKeys[key] = true;
        this.$emit('node-expand', node);
      }

      this.d_expandedKeys = { ...this.d_expandedKeys
      };
      this.$emit('update:expandedKeys', this.d_expandedKeys);
    },

    onNodeClick(event) {
      if (this.selectionMode != null && event.node.selectable !== false) {
        const metaSelection = event.nodeTouched ? false : this.metaKeySelection;

        const _selectionKeys = metaSelection ? this.handleSelectionWithMetaKey(event) : this.handleSelectionWithoutMetaKey(event);

        this.$emit('update:selectionKeys', _selectionKeys);
      }
    },

    onCheckboxChange(event) {
      this.$emit('update:selectionKeys', event.selectionKeys);
      if (event.check) this.$emit('node-select', event.node);else this.$emit('node-unselect', event.node);
    },

    handleSelectionWithMetaKey(event) {
      const originalEvent = event.originalEvent;
      const node = event.node;
      const metaKey = originalEvent.metaKey || originalEvent.ctrlKey;
      const selected = this.isNodeSelected(node);

      let _selectionKeys;

      if (selected && metaKey) {
        if (this.isSingleSelectionMode()) {
          _selectionKeys = {};
        } else {
          _selectionKeys = { ...this.selectionKeys
          };
          delete _selectionKeys[node.key];
        }

        this.$emit('node-unselect', node);
      } else {
        if (this.isSingleSelectionMode()) {
          _selectionKeys = {};
        } else if (this.isMultipleSelectionMode()) {
          _selectionKeys = !metaKey ? {} : this.selectionKeys ? { ...this.selectionKeys
          } : {};
        }

        _selectionKeys[node.key] = true;
        this.$emit('node-select', node);
      }

      return _selectionKeys;
    },

    handleSelectionWithoutMetaKey(event) {
      const node = event.node;
      const selected = this.isNodeSelected(node);

      let _selectionKeys;

      if (this.isSingleSelectionMode()) {
        if (selected) {
          _selectionKeys = {};
          this.$emit('node-unselect', node);
        } else {
          _selectionKeys = {};
          _selectionKeys[node.key] = true;
          this.$emit('node-select', node);
        }
      } else {
        if (selected) {
          _selectionKeys = { ...this.selectionKeys
          };
          delete _selectionKeys[node.key];
          this.$emit('node-unselect', node);
        } else {
          _selectionKeys = this.selectionKeys ? { ...this.selectionKeys
          } : {};
          _selectionKeys[node.key] = true;
          this.$emit('node-select', node);
        }
      }

      return _selectionKeys;
    },

    isSingleSelectionMode() {
      return this.selectionMode === 'single';
    },

    isMultipleSelectionMode() {
      return this.selectionMode === 'multiple';
    },

    isNodeSelected(node) {
      return this.selectionMode && this.selectionKeys ? this.selectionKeys[node.key] === true : false;
    },

    isChecked(node) {
      return this.selectionKeys ? this.selectionKeys[node.key] && this.selectionKeys[node.key].checked : false;
    },

    isNodeLeaf(node) {
      return node.leaf === false ? false : !(node.children && node.children.length);
    },

    onFilterKeydown(event) {
      if (event.which === 13) {
        event.preventDefault();
      }
    },

    findFilteredNodes(node, paramsWithoutNode) {
      if (node) {
        let matched = false;

        if (node.children) {
          let childNodes = [...node.children];
          node.children = [];

          for (let childNode of childNodes) {
            let copyChildNode = { ...childNode
            };

            if (this.isFilterMatched(copyChildNode, paramsWithoutNode)) {
              matched = true;
              node.children.push(copyChildNode);
            }
          }
        }

        if (matched) {
          return true;
        }
      }
    },

    isFilterMatched(node, {
      searchFields,
      filterText,
      strict
    }) {
      let matched = false;

      for (let field of searchFields) {
        let fieldValue = String(ObjectUtils.resolveFieldData(node, field)).toLocaleLowerCase(this.filterLocale);

        if (fieldValue.indexOf(filterText) > -1) {
          matched = true;
        }
      }

      if (!matched || strict && !this.isNodeLeaf(node)) {
        matched = this.findFilteredNodes(node, {
          searchFields,
          filterText,
          strict
        }) || matched;
      }

      return matched;
    }

  },
  computed: {
    containerClass() {
      return ['p-tree p-component', {
        'p-tree-selectable': this.selectionMode != null,
        'p-tree-loading': this.loading,
        'p-tree-flex-scrollable': this.scrollHeight === 'flex'
      }];
    },

    loadingIconClass() {
      return ['p-tree-loading-icon pi-spin', this.loadingIcon];
    },

    filteredValue() {
      let filteredNodes = [];
      const searchFields = this.filterBy.split(',');
      const filterText = this.filterValue.trim().toLocaleLowerCase(this.filterLocale);
      const strict = this.filterMode === 'strict';

      for (let node of this.value) {
        let _node = { ...node
        };
        let paramsWithoutNode = {
          searchFields,
          filterText,
          strict
        };

        if (strict && (this.findFilteredNodes(_node, paramsWithoutNode) || this.isFilterMatched(_node, paramsWithoutNode)) || !strict && (this.isFilterMatched(_node, paramsWithoutNode) || this.findFilteredNodes(_node, paramsWithoutNode))) {
          filteredNodes.push(_node);
        }
      }

      return filteredNodes;
    },

    valueToRender() {
      if (this.filterValue && this.filterValue.trim().length > 0) return this.filteredValue;else return this.value;
    }

  },
  components: {
    TreeNode: script$1$5
  }
};
const _hoisted_1$H = {
  key: 0,
  class: "p-tree-loading-overlay p-component-overlay"
};
const _hoisted_2$A = {
  key: 1,
  class: "p-tree-filter-container"
};
const _hoisted_3$u = ["placeholder"];

const _hoisted_4$p = /*#__PURE__*/createElementVNode("span", {
  class: "p-tree-filter-icon pi pi-search"
}, null, -1);

const _hoisted_5$k = {
  class: "p-tree-container",
  role: "tree"
};

function render$t(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TreeNode = resolveComponent("TreeNode");

  return openBlock(), createElementBlock("div", {
    class: normalizeClass($options.containerClass)
  }, [$props.loading ? (openBlock(), createElementBlock("div", _hoisted_1$H, [createElementVNode("i", {
    class: normalizeClass($options.loadingIconClass)
  }, null, 2)])) : createCommentVNode("", true), $props.filter ? (openBlock(), createElementBlock("div", _hoisted_2$A, [withDirectives(createElementVNode("input", {
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => $data.filterValue = $event),
    type: "text",
    autocomplete: "off",
    class: "p-tree-filter p-inputtext p-component",
    placeholder: $props.filterPlaceholder,
    onKeydown: _cache[1] || (_cache[1] = (...args) => $options.onFilterKeydown && $options.onFilterKeydown(...args))
  }, null, 40, _hoisted_3$u), [[vModelText, $data.filterValue]]), _hoisted_4$p])) : createCommentVNode("", true), createElementVNode("div", {
    class: "p-tree-wrapper",
    style: normalizeStyle({
      maxHeight: $props.scrollHeight
    })
  }, [createElementVNode("ul", _hoisted_5$k, [(openBlock(true), createElementBlock(Fragment, null, renderList($options.valueToRender, (node, index) => {
    return openBlock(), createBlock(_component_TreeNode, {
      key: node.key,
      node: node,
      templates: _ctx.$slots,
      level: $props.level + 1,
      index: index,
      expandedKeys: $data.d_expandedKeys,
      onNodeToggle: $options.onNodeToggle,
      onNodeClick: $options.onNodeClick,
      selectionMode: $props.selectionMode,
      selectionKeys: $props.selectionKeys,
      onCheckboxChange: $options.onCheckboxChange
    }, null, 8, ["node", "templates", "level", "index", "expandedKeys", "onNodeToggle", "onNodeClick", "selectionMode", "selectionKeys", "onCheckboxChange"]);
  }), 128))])], 4)], 2);
}

function styleInject$o(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$v = "\n.p-tree-container {\n    margin: 0;\n    padding: 0;\n    list-style-type: none;\n    overflow: auto;\n}\n.p-treenode-children {\n    margin: 0;\n    padding: 0;\n    list-style-type: none;\n}\n.p-tree-wrapper {\n    overflow: auto;\n}\n.p-treenode-selectable {\n    cursor: pointer;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n}\n.p-tree-toggler {\n    cursor: pointer;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    overflow: hidden;\n    position: relative;\n    -ms-flex-negative: 0;\n        flex-shrink: 0;\n}\n.p-treenode-leaf > .p-treenode-content .p-tree-toggler {\n    visibility: hidden;\n}\n.p-treenode-content {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n.p-tree-filter {\n    width: 100%;\n}\n.p-tree-filter-container {\n    position: relative;\n    display: block;\n    width: 100%;\n}\n.p-tree-filter-icon {\n    position: absolute;\n    top: 50%;\n    margin-top: -0.5rem;\n}\n.p-tree-loading {\n    position: relative;\n    min-height: 4rem;\n}\n.p-tree .p-tree-loading-overlay {\n    position: absolute;\n    z-index: 1;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n}\n.p-tree-flex-scrollable {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-flex: 1;\n        -ms-flex: 1;\n            flex: 1;\n    height: 100%;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n        -ms-flex-direction: column;\n            flex-direction: column;\n}\n.p-tree-flex-scrollable .p-tree-wrapper {\n    -webkit-box-flex: 1;\n        -ms-flex: 1;\n            flex: 1;\n}\n";
styleInject$o(css_248z$v);
script$1k.render = render$t;

var script$1j = {
  name: 'TreeSelect',
  emits: ['update:modelValue', 'before-show', 'before-hide', 'change', 'show', 'hide', 'node-select', 'node-unselect', 'node-expand', 'node-collapse', 'focus', 'blur'],
  props: {
    modelValue: null,
    options: Array,
    scrollHeight: {
      type: String,
      default: '400px'
    },
    placeholder: {
      type: String,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    tabindex: {
      type: Number,
      default: null
    },
    selectionMode: {
      type: String,
      default: 'single'
    },
    appendTo: {
      type: String,
      default: 'body'
    },
    emptyMessage: {
      type: String,
      default: null
    },
    display: {
      type: String,
      default: 'comma'
    },
    metaKeySelection: {
      type: Boolean,
      default: true
    },
    inputId: {
      type: String,
      default: null
    },
    inputClass: {
      type: String,
      default: null
    },
    inputStyle: {
      type: null,
      default: null
    },
    inputProps: {
      type: null,
      default: null
    },
    panelClass: {
      type: String,
      default: null
    },
    panelProps: {
      type: null,
      default: null
    },
    'aria-labelledby': {
      type: String,
      default: null
    },
    'aria-label': {
      type: String,
      default: null
    }
  },

  data() {
    return {
      focused: false,
      overlayVisible: false,
      expandedKeys: {}
    };
  },

  watch: {
    modelValue: {
      handler: function () {
        if (!this.selfChange) {
          this.updateTreeState();
        }

        this.selfChange = false;
      },
      immediate: true
    },

    options() {
      this.updateTreeState();
    }

  },
  outsideClickListener: null,
  resizeListener: null,
  scrollHandler: null,
  overlay: null,
  selfChange: false,

  beforeUnmount() {
    this.unbindOutsideClickListener();
    this.unbindResizeListener();

    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }

    if (this.overlay) {
      ZIndexUtils.clear(this.overlay);
      this.overlay = null;
    }
  },

  mounted() {
    this.updateTreeState();
  },

  methods: {
    show() {
      this.$emit('before-show');
      this.overlayVisible = true;
    },

    hide() {
      this.$emit('before-hide');
      this.overlayVisible = false;
      this.$refs.focusInput.focus();
    },

    onFocus(event) {
      this.focused = true;
      this.$emit('focus', event);
    },

    onBlur(event) {
      this.focused = false;
      this.$emit('blur', event);
    },

    onClick(event) {
      if (!this.disabled && (!this.overlay || !this.overlay.contains(event.target)) && !DomHandler.hasClass(event.target, 'p-treeselect-close')) {
        if (this.overlayVisible) this.hide();else this.show();
        this.$refs.focusInput.focus();
      }
    },

    onSelectionChange(keys) {
      this.selfChange = true;
      this.$emit('update:modelValue', keys);
      this.$emit('change', keys);
    },

    onNodeSelect(node) {
      this.$emit('node-select', node);

      if (this.selectionMode === 'single') {
        this.hide();
      }
    },

    onNodeUnselect(node) {
      this.$emit('node-unselect', node);
    },

    onNodeToggle(keys) {
      this.expandedKeys = keys;
    },

    onKeyDown(event) {
      switch (event.code) {
        case 'Down':
        case 'ArrowDown':
          if (this.overlayVisible) {
            if (DomHandler.findSingle(this.overlay, '.p-highlight')) {
              DomHandler.findSingle(this.overlay, '.p-highlight').focus();
            } else DomHandler.findSingle(this.overlay, '.p-treenode').children[0].focus();
          } else {
            this.show();
          }

          event.preventDefault();
          break;

        case 'Space':
        case 'Enter':
          if (this.overlayVisible) {
            this.hide();
          } else {
            this.show();
          }

          event.preventDefault();
          break;

        case 'Escape':
        case 'Tab':
          if (this.overlayVisible) {
            this.hide();
            event.preventDefault();
          }

          break;
      }
    },

    onOverlayEnter(el) {
      ZIndexUtils.set('overlay', el, this.$primevue.config.zIndex.overlay);
      this.alignOverlay();
      this.bindOutsideClickListener();
      this.bindScrollListener();
      this.bindResizeListener();
      this.scrollValueInView();
      this.$emit('show');
    },

    onOverlayLeave() {
      this.unbindOutsideClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
      this.$emit('hide');
      this.overlay = null;
    },

    onOverlayAfterLeave(el) {
      ZIndexUtils.clear(el);
    },

    alignOverlay() {
      if (this.appendTo === 'self') {
        DomHandler.relativePosition(this.overlay, this.$el);
      } else {
        this.overlay.style.minWidth = DomHandler.getOuterWidth(this.$el) + 'px';
        DomHandler.absolutePosition(this.overlay, this.$el);
      }
    },

    bindOutsideClickListener() {
      if (!this.outsideClickListener) {
        this.outsideClickListener = event => {
          if (this.overlayVisible && this.isOutsideClicked(event)) {
            this.hide();
          }
        };

        document.addEventListener('click', this.outsideClickListener);
      }
    },

    unbindOutsideClickListener() {
      if (this.outsideClickListener) {
        document.removeEventListener('click', this.outsideClickListener);
        this.outsideClickListener = null;
      }
    },

    bindScrollListener() {
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.$refs.container, () => {
          if (this.overlayVisible) {
            this.hide();
          }
        });
      }

      this.scrollHandler.bindScrollListener();
    },

    unbindScrollListener() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    },

    bindResizeListener() {
      if (!this.resizeListener) {
        this.resizeListener = () => {
          if (this.overlayVisible && !DomHandler.isTouchDevice()) {
            this.hide();
          }
        };

        window.addEventListener('resize', this.resizeListener);
      }
    },

    unbindResizeListener() {
      if (this.resizeListener) {
        window.removeEventListener('resize', this.resizeListener);
        this.resizeListener = null;
      }
    },

    isOutsideClicked(event) {
      return !(this.$el.isSameNode(event.target) || this.$el.contains(event.target) || this.overlay && this.overlay.contains(event.target));
    },

    overlayRef(el) {
      this.overlay = el;
    },

    onOverlayClick(event) {
      OverlayEventBus.emit('overlay-click', {
        originalEvent: event,
        target: this.$el
      });
    },

    findSelectedNodes(node, keys, selectedNodes) {
      if (node) {
        if (this.isSelected(node, keys)) {
          selectedNodes.push(node);
          delete keys[node.key];
        }

        if (Object.keys(keys).length && node.children) {
          for (let childNode of node.children) {
            this.findSelectedNodes(childNode, keys, selectedNodes);
          }
        }
      } else {
        for (let childNode of this.options) {
          this.findSelectedNodes(childNode, keys, selectedNodes);
        }
      }
    },

    isSelected(node, keys) {
      return this.selectionMode === 'checkbox' ? keys[node.key] && keys[node.key].checked : keys[node.key];
    },

    updateTreeState() {
      let keys = { ...this.modelValue
      };
      this.expandedKeys = {};

      if (keys && this.options) {
        this.updateTreeBranchState(null, null, keys);
      }
    },

    updateTreeBranchState(node, path, keys) {
      if (node) {
        if (this.isSelected(node, keys)) {
          this.expandPath(path);
          delete keys[node.key];
        }

        if (Object.keys(keys).length && node.children) {
          for (let childNode of node.children) {
            path.push(node.key);
            this.updateTreeBranchState(childNode, path, keys);
          }
        }
      } else {
        for (let childNode of this.options) {
          this.updateTreeBranchState(childNode, [], keys);
        }
      }
    },

    expandPath(path) {
      if (path.length > 0) {
        for (let key of path) {
          this.expandedKeys[key] = true;
        }
      }
    },

    scrollValueInView() {
      if (this.overlay) {
        let selectedItem = DomHandler.findSingle(this.overlay, 'li.p-highlight');

        if (selectedItem) {
          selectedItem.scrollIntoView({
            block: 'nearest',
            inline: 'start'
          });
        }
      }
    }

  },
  computed: {
    containerClass() {
      return ['p-treeselect p-component p-inputwrapper', {
        'p-treeselect-chip': this.display === 'chip',
        'p-disabled': this.disabled,
        'p-focus': this.focused,
        'p-inputwrapper-filled': !this.emptyValue,
        'p-inputwrapper-focus': this.focused || this.overlayVisible
      }];
    },

    labelClass() {
      return ['p-treeselect-label', {
        'p-placeholder': this.label === this.placeholder,
        'p-treeselect-label-empty': !this.placeholder && this.emptyValue
      }];
    },

    panelStyleClass() {
      return ['p-treeselect-panel p-component', this.panelClass, {
        'p-input-filled': this.$primevue.config.inputStyle === 'filled',
        'p-ripple-disabled': this.$primevue.config.ripple === false
      }];
    },

    selectedNodes() {
      let selectedNodes = [];

      if (this.modelValue && this.options) {
        let keys = { ...this.modelValue
        };
        this.findSelectedNodes(null, keys, selectedNodes);
      }

      return selectedNodes;
    },

    label() {
      let value = this.selectedNodes;
      return value.length ? value.map(node => node.label).join(', ') : this.placeholder;
    },

    emptyMessageText() {
      return this.emptyMessage || this.$primevue.config.locale.emptyMessage;
    },

    emptyValue() {
      return !this.modelValue || Object.keys(this.modelValue).length === 0;
    },

    emptyOptions() {
      return !this.options || this.options.length === 0;
    },

    listId() {
      return UniqueComponentId() + '_list';
    }

  },
  components: {
    TSTree: script$1k,
    Portal: script$1C
  },
  directives: {
    ripple: Ripple
  }
};
const _hoisted_1$G = {
  class: "p-hidden-accessible"
};
const _hoisted_2$z = ["id", "disabled", "tabindex", "aria-labelledby", "aria-label", "aria-expanded", "aria-controls"];
const _hoisted_3$t = {
  class: "p-treeselect-label-container"
};
const _hoisted_4$o = {
  class: "p-treeselect-token-label"
};
const _hoisted_5$j = ["aria-expanded"];

const _hoisted_6$h = /*#__PURE__*/createElementVNode("span", {
  class: "p-treeselect-trigger-icon pi pi-chevron-down"
}, null, -1);

const _hoisted_7$c = {
  key: 0,
  class: "p-treeselect-empty-message"
};

function render$s(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TSTree = resolveComponent("TSTree");

  const _component_Portal = resolveComponent("Portal");

  return openBlock(), createElementBlock("div", {
    ref: "container",
    class: normalizeClass($options.containerClass),
    onClick: _cache[6] || (_cache[6] = (...args) => $options.onClick && $options.onClick(...args))
  }, [createElementVNode("div", _hoisted_1$G, [createElementVNode("input", mergeProps({
    ref: "focusInput",
    id: $props.inputId,
    type: "text",
    role: "combobox",
    class: $props.inputClass,
    style: $props.inputStyle,
    readonly: "",
    disabled: $props.disabled,
    tabindex: !$props.disabled ? $props.tabindex : -1,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    "aria-haspopup": "tree",
    "aria-expanded": $data.overlayVisible,
    "aria-controls": $options.listId,
    onFocus: _cache[0] || (_cache[0] = $event => $options.onFocus($event)),
    onBlur: _cache[1] || (_cache[1] = $event => $options.onBlur($event)),
    onKeydown: _cache[2] || (_cache[2] = $event => $options.onKeyDown($event))
  }, $props.inputProps), null, 16, _hoisted_2$z)]), createElementVNode("div", _hoisted_3$t, [createElementVNode("div", {
    class: normalizeClass($options.labelClass)
  }, [renderSlot(_ctx.$slots, "value", {
    value: $options.selectedNodes,
    placeholder: $props.placeholder
  }, () => [$props.display === 'comma' ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [createTextVNode(toDisplayString$1($options.label || 'empty'), 1)], 64)) : $props.display === 'chip' ? (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [(openBlock(true), createElementBlock(Fragment, null, renderList($options.selectedNodes, node => {
    return openBlock(), createElementBlock("div", {
      key: node.key,
      class: "p-treeselect-token"
    }, [createElementVNode("span", _hoisted_4$o, toDisplayString$1(node.label), 1)]);
  }), 128)), $options.emptyValue ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [createTextVNode(toDisplayString$1($props.placeholder || 'empty'), 1)], 64)) : createCommentVNode("", true)], 64)) : createCommentVNode("", true)])], 2)]), createElementVNode("div", {
    class: "p-treeselect-trigger",
    role: "button",
    "aria-haspopup": "tree",
    "aria-expanded": $data.overlayVisible
  }, [renderSlot(_ctx.$slots, "indicator", {}, () => [_hoisted_6$h])], 8, _hoisted_5$j), createVNode(_component_Portal, {
    appendTo: $props.appendTo
  }, {
    default: withCtx(() => [createVNode(Transition, {
      name: "p-connected-overlay",
      onEnter: $options.onOverlayEnter,
      onLeave: $options.onOverlayLeave,
      onAfterLeave: $options.onOverlayAfterLeave
    }, {
      default: withCtx(() => [$data.overlayVisible ? (openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        ref: $options.overlayRef,
        onClick: _cache[5] || (_cache[5] = (...args) => $options.onOverlayClick && $options.onOverlayClick(...args)),
        class: $options.panelStyleClass
      }, $props.panelProps), [renderSlot(_ctx.$slots, "header", {
        value: $props.modelValue,
        options: $props.options
      }), createElementVNode("div", {
        class: "p-treeselect-items-wrapper",
        style: normalizeStyle({
          'max-height': $props.scrollHeight
        })
      }, [createVNode(_component_TSTree, {
        id: $options.listId,
        value: $props.options,
        selectionMode: $props.selectionMode,
        "onUpdate:selectionKeys": $options.onSelectionChange,
        selectionKeys: $props.modelValue,
        expandedKeys: $data.expandedKeys,
        "onUpdate:expandedKeys": $options.onNodeToggle,
        metaKeySelection: $props.metaKeySelection,
        onNodeExpand: _cache[3] || (_cache[3] = $event => _ctx.$emit('node-expand', $event)),
        onNodeCollapse: _cache[4] || (_cache[4] = $event => _ctx.$emit('node-collapse', $event)),
        onNodeSelect: $options.onNodeSelect,
        onNodeUnselect: $options.onNodeUnselect,
        level: 0
      }, null, 8, ["id", "value", "selectionMode", "onUpdate:selectionKeys", "selectionKeys", "expandedKeys", "onUpdate:expandedKeys", "metaKeySelection", "onNodeSelect", "onNodeUnselect"]), $options.emptyOptions ? (openBlock(), createElementBlock("div", _hoisted_7$c, [renderSlot(_ctx.$slots, "empty", {}, () => [createTextVNode(toDisplayString$1($options.emptyMessageText), 1)])])) : createCommentVNode("", true)], 4), renderSlot(_ctx.$slots, "footer", {
        value: $props.modelValue,
        options: $props.options
      })], 16)) : createCommentVNode("", true)]),
      _: 3
    }, 8, ["onEnter", "onLeave", "onAfterLeave"])]),
    _: 3
  }, 8, ["appendTo"])], 2);
}

function styleInject$n(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$u = "\n.p-treeselect {\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    cursor: pointer;\n    position: relative;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n}\n.p-treeselect-trigger {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    -ms-flex-negative: 0;\n        flex-shrink: 0;\n}\n.p-treeselect-label-container {\n    overflow: hidden;\n    -webkit-box-flex: 1;\n        -ms-flex: 1 1 auto;\n            flex: 1 1 auto;\n    cursor: pointer;\n}\n.p-treeselect-label {\n    display: block;\n    white-space: nowrap;\n    cursor: pointer;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n.p-treeselect-label-empty {\n    overflow: hidden;\n    visibility: hidden;\n}\n.p-treeselect-token {\n    cursor: default;\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-flex: 0;\n        -ms-flex: 0 0 auto;\n            flex: 0 0 auto;\n}\n.p-treeselect .p-treeselect-panel {\n    min-width: 100%;\n}\n.p-treeselect-panel {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.p-treeselect-items-wrapper {\n    overflow: auto;\n}\n.p-fluid .p-treeselect {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n}\n";
styleInject$n(css_248z$u);
script$1j.render = render$s;

var script$1i = {
  props: {
        name : String
     },
  setup(__props) {


 
return (_ctx, _cache) => {
  return (openBlock(), createBlock(script$X, {
    entity_name: __props.name,
    method: "post"
  }, null, 8 /* PROPS */, ["entity_name"]))
}
}

};

script$1i.__file = "presstojam/src/components/effects/reference-effect.vue";

var script$1h = {
  props: {
       name : String
    },
  setup(__props) {

const props = __props;

    
    
 
    const i18n = inject("i18n");
    const t = i18n.t;

 
    const header = "Create " + t("models." + props.name + ".title", 1);

   
    function createReference() {
      trigger("dialog_open",
        script$1i, 
        {
            name : props.name
        }, 
        header);
    }
 
return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("i", {
    class: "pi pi-plus",
    onClick: createReference,
    style: {"cursor":"pointer"}
  }))
}
}

};

script$1h.__file = "presstojam/src/components/actions/reference-action.vue";

var script$1g = {
  name: 'VirtualScroller',
  emits: ['update:numToleratedItems', 'scroll', 'scroll-index-change', 'lazy-load'],
  props: {
    id: {
      type: String,
      default: null
    },
    style: null,
    class: null,
    items: {
      type: Array,
      default: null
    },
    itemSize: {
      type: [Number, Array],
      default: 0
    },
    scrollHeight: null,
    scrollWidth: null,
    orientation: {
      type: String,
      default: 'vertical'
    },
    numToleratedItems: {
      type: Number,
      default: null
    },
    delay: {
      type: Number,
      default: 0
    },
    lazy: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    loaderDisabled: {
      type: Boolean,
      default: false
    },
    columns: {
      type: Array,
      default: null
    },
    loading: {
      type: Boolean,
      default: false
    },
    showSpacer: {
      type: Boolean,
      default: true
    },
    showLoader: {
      type: Boolean,
      default: false
    },
    tabindex: {
      type: Number,
      default: 0
    }
  },

  data() {
    return {
      first: this.isBoth() ? {
        rows: 0,
        cols: 0
      } : 0,
      last: this.isBoth() ? {
        rows: 0,
        cols: 0
      } : 0,
      numItemsInViewport: this.isBoth() ? {
        rows: 0,
        cols: 0
      } : 0,
      lastScrollPos: this.isBoth() ? {
        top: 0,
        left: 0
      } : 0,
      d_numToleratedItems: this.numToleratedItems,
      d_loading: this.loading,
      loaderArr: [],
      spacerStyle: {},
      contentStyle: {}
    };
  },

  element: null,
  content: null,
  lastScrollPos: null,
  scrollTimeout: null,
  watch: {
    numToleratedItems(newValue) {
      this.d_numToleratedItems = newValue;
    },

    loading(newValue) {
      this.d_loading = newValue;
    },

    items(newValue, oldValue) {
      if (!oldValue || oldValue.length !== (newValue || []).length) {
        this.init();
      }
    },

    orientation() {
      this.lastScrollPos = this.isBoth() ? {
        top: 0,
        left: 0
      } : 0;
    }

  },

  mounted() {
    this.init();
    this.lastScrollPos = this.isBoth() ? {
      top: 0,
      left: 0
    } : 0;
  },

  methods: {
    init() {
      this.setSize();
      this.calculateOptions();
      this.setSpacerSize();
    },

    isVertical() {
      return this.orientation === 'vertical';
    },

    isHorizontal() {
      return this.orientation === 'horizontal';
    },

    isBoth() {
      return this.orientation === 'both';
    },

    scrollTo(options) {
      this.element && this.element.scrollTo(options);
    },

    scrollToIndex(index, behavior = 'auto') {
      const both = this.isBoth();
      const horizontal = this.isHorizontal();
      const first = this.first;
      const {
        numToleratedItems
      } = this.calculateNumItems();
      const itemSize = this.itemSize;

      const calculateFirst = (_index = 0, _numT) => _index <= _numT ? 0 : _index;

      const calculateCoord = (_first, _size) => _first * _size;

      const scrollTo = (left = 0, top = 0) => this.scrollTo({
        left,
        top,
        behavior
      });

      if (both) {
        const newFirst = {
          rows: calculateFirst(index[0], numToleratedItems[0]),
          cols: calculateFirst(index[1], numToleratedItems[1])
        };

        if (newFirst.rows !== first.rows || newFirst.cols !== first.cols) {
          scrollTo(calculateCoord(newFirst.cols, itemSize[1]), calculateCoord(newFirst.rows, itemSize[0]));
        }
      } else {
        const newFirst = calculateFirst(index, numToleratedItems);

        if (newFirst !== first) {
          horizontal ? scrollTo(calculateCoord(newFirst, itemSize), 0) : scrollTo(0, calculateCoord(newFirst, itemSize));
        }
      }
    },

    scrollInView(index, to, behavior = 'auto') {
      if (to) {
        const both = this.isBoth();
        const horizontal = this.isHorizontal();
        const {
          first,
          viewport
        } = this.getRenderedRange();

        const scrollTo = (left = 0, top = 0) => this.scrollTo({
          left,
          top,
          behavior
        });

        const isToStart = to === 'to-start';
        const isToEnd = to === 'to-end';

        if (isToStart) {
          if (both) {
            if (viewport.first.rows - first.rows > index[0]) {
              scrollTo(viewport.first.cols * this.itemSize[1], (viewport.first.rows - 1) * this.itemSize[0]);
            } else if (viewport.first.cols - first.cols > index[1]) {
              scrollTo((viewport.first.cols - 1) * this.itemSize[1], viewport.first.rows * this.itemSize[0]);
            }
          } else {
            if (viewport.first - first > index) {
              const pos = (viewport.first - 1) * this.itemSize;
              horizontal ? scrollTo(pos, 0) : scrollTo(0, pos);
            }
          }
        } else if (isToEnd) {
          if (both) {
            if (viewport.last.rows - first.rows <= index[0] + 1) {
              scrollTo(viewport.first.cols * this.itemSize[1], (viewport.first.rows + 1) * this.itemSize[0]);
            } else if (viewport.last.cols - first.cols <= index[1] + 1) {
              scrollTo((viewport.first.cols + 1) * this.itemSize[1], viewport.first.rows * this.itemSize[0]);
            }
          } else {
            if (viewport.last - first <= index + 1) {
              const pos = (viewport.first + 1) * this.itemSize;
              horizontal ? scrollTo(pos, 0) : scrollTo(0, pos);
            }
          }
        }
      } else {
        this.scrollToIndex(index, behavior);
      }
    },

    getRenderedRange() {
      const calculateFirstInViewport = (_pos, _size) => Math.floor(_pos / (_size || _pos));

      let firstInViewport = this.first;
      let lastInViewport = 0;

      if (this.element) {
        const both = this.isBoth();
        const horizontal = this.isHorizontal();
        const scrollTop = this.element.scrollTop;
        const scrollLeft = this.element.scrollLeft;

        if (both) {
          firstInViewport = {
            rows: calculateFirstInViewport(scrollTop, this.itemSize[0]),
            cols: calculateFirstInViewport(scrollLeft, this.itemSize[1])
          };
          lastInViewport = {
            rows: firstInViewport.rows + this.numItemsInViewport.rows,
            cols: firstInViewport.cols + this.numItemsInViewport.cols
          };
        } else {
          const scrollPos = horizontal ? scrollLeft : scrollTop;
          firstInViewport = calculateFirstInViewport(scrollPos, this.itemSize);
          lastInViewport = firstInViewport + this.numItemsInViewport;
        }
      }

      return {
        first: this.first,
        last: this.last,
        viewport: {
          first: firstInViewport,
          last: lastInViewport
        }
      };
    },

    calculateNumItems() {
      const both = this.isBoth();
      const horizontal = this.isHorizontal();
      const itemSize = this.itemSize;
      const contentPos = this.getContentPosition();
      const contentWidth = this.element ? this.element.offsetWidth - contentPos.left : 0;
      const contentHeight = this.element ? this.element.offsetHeight - contentPos.top : 0;

      const calculateNumItemsInViewport = (_contentSize, _itemSize) => Math.ceil(_contentSize / (_itemSize || _contentSize));

      const calculateNumToleratedItems = _numItems => Math.ceil(_numItems / 2);

      const numItemsInViewport = both ? {
        rows: calculateNumItemsInViewport(contentHeight, itemSize[0]),
        cols: calculateNumItemsInViewport(contentWidth, itemSize[1])
      } : calculateNumItemsInViewport(horizontal ? contentWidth : contentHeight, itemSize);
      const numToleratedItems = this.d_numToleratedItems || (both ? [calculateNumToleratedItems(numItemsInViewport.rows), calculateNumToleratedItems(numItemsInViewport.cols)] : calculateNumToleratedItems(numItemsInViewport));
      return {
        numItemsInViewport,
        numToleratedItems
      };
    },

    calculateOptions() {
      const both = this.isBoth();
      const first = this.first;
      const {
        numItemsInViewport,
        numToleratedItems
      } = this.calculateNumItems();

      const calculateLast = (_first, _num, _numT, _isCols) => this.getLast(_first + _num + (_first < _numT ? 2 : 3) * _numT, _isCols);

      const last = both ? {
        rows: calculateLast(first.rows, numItemsInViewport.rows, numToleratedItems[0]),
        cols: calculateLast(first.cols, numItemsInViewport.cols, numToleratedItems[1], true)
      } : calculateLast(first, numItemsInViewport, numToleratedItems);
      this.last = last;
      this.numItemsInViewport = numItemsInViewport;
      this.d_numToleratedItems = numToleratedItems;
      this.$emit('update:numToleratedItems', this.d_numToleratedItems);

      if (this.showLoader) {
        this.loaderArr = both ? Array.from({
          length: numItemsInViewport.rows
        }).map(() => Array.from({
          length: numItemsInViewport.cols
        })) : Array.from({
          length: numItemsInViewport
        });
      }

      if (this.lazy) {
        this.$emit('lazy-load', {
          first,
          last
        });
      }
    },

    getLast(last = 0, isCols) {
      if (this.items) {
        return Math.min(isCols ? (this.columns || this.items[0]).length : this.items.length, last);
      }

      return 0;
    },

    getContentPosition() {
      if (this.content) {
        const style = getComputedStyle(this.content);
        const left = parseInt(style.paddingLeft, 10) + Math.max(parseInt(style.left, 10), 0);
        const right = parseInt(style.paddingRight, 10) + Math.max(parseInt(style.right, 10), 0);
        const top = parseInt(style.paddingTop, 10) + Math.max(parseInt(style.top, 10), 0);
        const bottom = parseInt(style.paddingBottom, 10) + Math.max(parseInt(style.bottom, 10), 0);
        return {
          left,
          right,
          top,
          bottom,
          x: left + right,
          y: top + bottom
        };
      }

      return {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        x: 0,
        y: 0
      };
    },

    setSize() {
      if (this.element) {
        const both = this.isBoth();
        const horizontal = this.isHorizontal();
        const parentElement = this.element.parentElement;
        const width = this.scrollWidth || `${this.element.offsetWidth || parentElement.offsetWidth}px`;
        const height = this.scrollHeight || `${this.element.offsetHeight || parentElement.offsetHeight}px`;

        const setProp = (_name, _value) => this.element.style[_name] = _value;

        if (both || horizontal) {
          setProp('height', height);
          setProp('width', width);
        } else {
          setProp('height', height);
        }
      }
    },

    setSpacerSize() {
      const items = this.items;

      if (items) {
        const both = this.isBoth();
        const horizontal = this.isHorizontal();
        const contentPos = this.getContentPosition();

        const setProp = (_name, _value, _size, _cpos = 0) => this.spacerStyle = { ...this.spacerStyle,
          ...{
            [`${_name}`]: (_value || []).length * _size + _cpos + 'px'
          }
        };

        if (both) {
          setProp('height', items, this.itemSize[0], contentPos.y);
          setProp('width', this.columns || items[1], this.itemSize[1], contentPos.x);
        } else {
          horizontal ? setProp('width', this.columns || items, this.itemSize, contentPos.x) : setProp('height', items, this.itemSize, contentPos.y);
        }
      }
    },

    setContentPosition(pos) {
      if (this.content) {
        const both = this.isBoth();
        const horizontal = this.isHorizontal();
        const first = pos ? pos.first : this.first;

        const calculateTranslateVal = (_first, _size) => _first * _size;

        const setTransform = (_x = 0, _y = 0) => {
          this.contentStyle = { ...this.contentStyle,
            ...{
              transform: `translate3d(${_x}px, ${_y}px, 0)`
            }
          };
        };

        if (both) {
          setTransform(calculateTranslateVal(first.cols, this.itemSize[1]), calculateTranslateVal(first.rows, this.itemSize[0]));
        } else {
          const translateVal = calculateTranslateVal(first, this.itemSize);
          horizontal ? setTransform(translateVal, 0) : setTransform(0, translateVal);
        }
      }
    },

    onScrollPositionChange(event) {
      const target = event.target;
      const both = this.isBoth();
      const horizontal = this.isHorizontal();
      const contentPos = this.getContentPosition();

      const calculateScrollPos = (_pos, _cpos) => _pos ? _pos > _cpos ? _pos - _cpos : _pos : 0;

      const calculateCurrentIndex = (_pos, _size) => Math.floor(_pos / (_size || _pos));

      const calculateTriggerIndex = (_currentIndex, _first, _last, _num, _numT, _isScrollDownOrRight) => {
        return _currentIndex <= _numT ? _numT : _isScrollDownOrRight ? _last - _num - _numT : _first + _numT - 1;
      };

      const calculateFirst = (_currentIndex, _triggerIndex, _first, _last, _num, _numT, _isScrollDownOrRight) => {
        if (_currentIndex <= _numT) return 0;else return Math.max(0, _isScrollDownOrRight ? _currentIndex < _triggerIndex ? _first : _currentIndex - _numT : _currentIndex > _triggerIndex ? _first : _currentIndex - 2 * _numT);
      };

      const calculateLast = (_currentIndex, _first, _last, _num, _numT, _isCols) => {
        let lastValue = _first + _num + 2 * _numT;

        if (_currentIndex >= _numT) {
          lastValue += _numT + 1;
        }

        return this.getLast(lastValue, _isCols);
      };

      const scrollTop = calculateScrollPos(target.scrollTop, contentPos.top);
      const scrollLeft = calculateScrollPos(target.scrollLeft, contentPos.left);
      let newFirst = both ? {
        rows: 0,
        cols: 0
      } : 0;
      let newLast = this.last;
      let isRangeChanged = false;
      let newScrollPos = this.lastScrollPos;

      if (both) {
        const isScrollDown = this.lastScrollPos.top <= scrollTop;
        const isScrollRight = this.lastScrollPos.left <= scrollLeft;
        const currentIndex = {
          rows: calculateCurrentIndex(scrollTop, this.itemSize[0]),
          cols: calculateCurrentIndex(scrollLeft, this.itemSize[1])
        };
        const triggerIndex = {
          rows: calculateTriggerIndex(currentIndex.rows, this.first.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0], isScrollDown),
          cols: calculateTriggerIndex(currentIndex.cols, this.first.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], isScrollRight)
        };
        newFirst = {
          rows: calculateFirst(currentIndex.rows, triggerIndex.rows, this.first.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0], isScrollDown),
          cols: calculateFirst(currentIndex.cols, triggerIndex.cols, this.first.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], isScrollRight)
        };
        newLast = {
          rows: calculateLast(currentIndex.rows, newFirst.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0]),
          cols: calculateLast(currentIndex.cols, newFirst.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], true)
        };
        isRangeChanged = newFirst.rows !== this.first.rows || newLast.rows !== this.last.rows || newFirst.cols !== this.first.cols || newLast.cols !== this.last.cols;
        newScrollPos = {
          top: scrollTop,
          left: scrollLeft
        };
      } else {
        const scrollPos = horizontal ? scrollLeft : scrollTop;
        const isScrollDownOrRight = this.lastScrollPos <= scrollPos;
        const currentIndex = calculateCurrentIndex(scrollPos, this.itemSize);
        const triggerIndex = calculateTriggerIndex(currentIndex, this.first, this.last, this.numItemsInViewport, this.d_numToleratedItems, isScrollDownOrRight);
        newFirst = calculateFirst(currentIndex, triggerIndex, this.first, this.last, this.numItemsInViewport, this.d_numToleratedItems, isScrollDownOrRight);
        newLast = calculateLast(currentIndex, newFirst, this.last, this.numItemsInViewport, this.d_numToleratedItems);
        isRangeChanged = newFirst !== this.first || newLast !== this.last;
        newScrollPos = scrollPos;
      }

      return {
        first: newFirst,
        last: newLast,
        isRangeChanged,
        scrollPos: newScrollPos
      };
    },

    onScrollChange(event) {
      const {
        first,
        last,
        isRangeChanged,
        scrollPos
      } = this.onScrollPositionChange(event);

      if (isRangeChanged) {
        const newState = {
          first,
          last
        };
        this.setContentPosition(newState);
        this.first = first;
        this.last = last;
        this.lastScrollPos = scrollPos;
        this.$emit('scroll-index-change', newState);

        if (this.lazy) {
          this.$emit('lazy-load', newState);
        }
      }
    },

    onScroll(event) {
      this.$emit('scroll', event);

      if (this.delay) {
        if (this.scrollTimeout) {
          clearTimeout(this.scrollTimeout);
        }

        if (!this.d_loading && this.showLoader) {
          const {
            isRangeChanged: changed
          } = this.onScrollPositionChange(event);
          changed && (this.d_loading = true);
        }

        this.scrollTimeout = setTimeout(() => {
          this.onScrollChange(event);

          if (this.d_loading && this.showLoader && !this.lazy) {
            this.d_loading = false;
          }
        }, this.delay);
      } else {
        this.onScrollChange(event);
      }
    },

    getOptions(renderedIndex) {
      const count = (this.items || []).length;
      const index = this.isBoth() ? this.first.rows + renderedIndex : this.first + renderedIndex;
      return {
        index,
        count,
        first: index === 0,
        last: index === count - 1,
        even: index % 2 === 0,
        odd: index % 2 !== 0
      };
    },

    getLoaderOptions(index, extOptions) {
      let count = this.loaderArr.length;
      return {
        index,
        count,
        first: index === 0,
        last: index === count - 1,
        even: index % 2 === 0,
        odd: index % 2 !== 0,
        ...extOptions
      };
    },

    elementRef(el) {
      this.element = el;
    },

    contentRef(el) {
      this.content = el;
    }

  },
  computed: {
    containerClass() {
      return ['p-virtualscroller', {
        'p-both-scroll': this.isBoth(),
        'p-horizontal-scroll': this.isHorizontal()
      }, this.class];
    },

    contentClass() {
      return ['p-virtualscroller-content', {
        'p-virtualscroller-loading': this.d_loading
      }];
    },

    loaderClass() {
      return ['p-virtualscroller-loader', {
        'p-component-overlay': !this.$slots.loader
      }];
    },

    loadedItems() {
      const items = this.items;

      if (items && !this.d_loading) {
        if (this.isBoth()) {
          return items.slice(this.first.rows, this.last.rows).map(item => this.columns ? item : item.slice(this.first.cols, this.last.cols));
        } else if (this.isHorizontal() && this.columns) return items;else return items.slice(this.first, this.last);
      }

      return [];
    },

    loadedRows() {
      return this.d_loading ? this.loaderDisabled ? this.loaderArr : [] : this.loadedItems;
    },

    loadedColumns() {
      if (this.columns) {
        const both = this.isBoth();
        const horizontal = this.isHorizontal();

        if (both || horizontal) {
          return this.d_loading && this.loaderDisabled ? both ? this.loaderArr[0] : this.loaderArr : this.columns.slice(both ? this.first.cols : this.first, both ? this.last.cols : this.last);
        }
      }

      return this.columns;
    }

  }
};
const _hoisted_1$F = ["tabindex"];
const _hoisted_2$y = {
  key: 1,
  class: "p-virtualscroller-loading-icon pi pi-spinner pi-spin"
};

function render$r(_ctx, _cache, $props, $setup, $data, $options) {
  return !$props.disabled ? (openBlock(), createElementBlock("div", {
    key: 0,
    ref: $options.elementRef,
    class: normalizeClass($options.containerClass),
    tabindex: $props.tabindex,
    style: normalizeStyle($props.style),
    onScroll: _cache[0] || (_cache[0] = (...args) => $options.onScroll && $options.onScroll(...args))
  }, [renderSlot(_ctx.$slots, "content", {
    styleClass: $options.contentClass,
    items: $options.loadedItems,
    getItemOptions: $options.getOptions,
    loading: $data.d_loading,
    getLoaderOptions: $options.getLoaderOptions,
    itemSize: $props.itemSize,
    rows: $options.loadedRows,
    columns: $options.loadedColumns,
    contentRef: $options.contentRef,
    spacerStyle: $data.spacerStyle,
    contentStyle: $data.contentStyle,
    vertical: $options.isVertical(),
    horizontal: $options.isHorizontal(),
    both: $options.isBoth()
  }, () => [createElementVNode("div", {
    ref: $options.contentRef,
    class: normalizeClass($options.contentClass),
    style: normalizeStyle($data.contentStyle)
  }, [(openBlock(true), createElementBlock(Fragment, null, renderList($options.loadedItems, (item, index) => {
    return renderSlot(_ctx.$slots, "item", {
      key: index,
      item: item,
      options: $options.getOptions(index)
    });
  }), 128))], 6)]), $props.showSpacer ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "p-virtualscroller-spacer",
    style: normalizeStyle($data.spacerStyle)
  }, null, 4)) : createCommentVNode("", true), !$props.loaderDisabled && $props.showLoader && $data.d_loading ? (openBlock(), createElementBlock("div", {
    key: 1,
    class: normalizeClass($options.loaderClass)
  }, [_ctx.$slots && _ctx.$slots.loader ? (openBlock(true), createElementBlock(Fragment, {
    key: 0
  }, renderList($data.loaderArr, (_, index) => {
    return renderSlot(_ctx.$slots, "loader", {
      key: index,
      options: $options.getLoaderOptions(index, $options.isBoth() && {
        numCols: _ctx.d_numItemsInViewport.cols
      })
    });
  }), 128)) : (openBlock(), createElementBlock("i", _hoisted_2$y))], 2)) : createCommentVNode("", true)], 46, _hoisted_1$F)) : (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [renderSlot(_ctx.$slots, "default"), renderSlot(_ctx.$slots, "content", {
    items: $props.items,
    rows: $props.items,
    columns: $options.loadedColumns
  })], 64));
}

function styleInject$m(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$t = "\n.p-virtualscroller {\n    position: relative;\n    overflow: auto;\n    contain: strict;\n    -webkit-transform: translateZ(0);\n            transform: translateZ(0);\n    will-change: scroll-position;\n    outline: 0 none;\n}\n.p-virtualscroller-content {\n    position: absolute;\n    top: 0;\n    left: 0;\n    contain: content;\n    min-height: 100%;\n    min-width: 100%;\n    will-change: transform;\n}\n.p-virtualscroller-spacer {\n    position: absolute;\n    top: 0;\n    left: 0;\n    height: 1px;\n    width: 1px;\n    -webkit-transform-origin: 0 0;\n            transform-origin: 0 0;\n    pointer-events: none;\n}\n.p-virtualscroller .p-virtualscroller-loader {\n    position: sticky;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n.p-virtualscroller-loader.p-component-overlay {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n}\n";
styleInject$m(css_248z$t);
script$1g.render = render$r;

var script$1f = {
  name: 'AutoComplete',
  emits: ['update:modelValue', 'change', 'focus', 'blur', 'item-select', 'item-unselect', 'dropdown-click', 'clear', 'complete', 'before-show', 'before-hide', 'show', 'hide'],
  props: {
    modelValue: null,
    suggestions: {
      type: Array,
      default: null
    },
    field: {
      // TODO: Deprecated since v3.16.0
      type: [String, Function],
      default: null
    },
    optionLabel: null,
    optionDisabled: null,
    optionGroupLabel: null,
    optionGroupChildren: null,
    scrollHeight: {
      type: String,
      default: '200px'
    },
    dropdown: {
      type: Boolean,
      default: false
    },
    dropdownMode: {
      type: String,
      default: 'blank'
    },
    autoHighlight: {
      // TODO: Deprecated since v3.16.0. Use selectOnFocus property instead.
      type: Boolean,
      default: false
    },
    multiple: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    placeholder: {
      type: String,
      default: null
    },
    dataKey: {
      type: String,
      default: null
    },
    minLength: {
      type: Number,
      default: 1
    },
    delay: {
      type: Number,
      default: 300
    },
    appendTo: {
      type: String,
      default: 'body'
    },
    forceSelection: {
      type: Boolean,
      default: false
    },
    completeOnFocus: {
      type: Boolean,
      default: false
    },
    inputId: {
      type: String,
      default: null
    },
    inputStyle: {
      type: null,
      default: null
    },
    inputClass: {
      type: String,
      default: null
    },
    inputProps: {
      type: null,
      default: null
    },
    panelStyle: {
      type: null,
      default: null
    },
    panelClass: {
      type: String,
      default: null
    },
    panelProps: {
      type: null,
      default: null
    },
    dropdownIcon: {
      type: String,
      default: 'pi pi-chevron-down'
    },
    loadingIcon: {
      type: String,
      default: 'pi pi-spinner'
    },
    removeTokenIcon: {
      type: String,
      default: 'pi pi-times-circle'
    },
    virtualScrollerOptions: {
      type: Object,
      default: null
    },
    autoOptionFocus: {
      type: Boolean,
      default: true
    },
    selectOnFocus: {
      type: Boolean,
      default: false
    },
    searchLocale: {
      type: String,
      default: undefined
    },
    searchMessage: {
      type: String,
      default: null
    },
    selectionMessage: {
      type: String,
      default: null
    },
    emptySelectionMessage: {
      type: String,
      default: null
    },
    emptySearchMessage: {
      type: String,
      default: null
    },
    tabindex: {
      type: Number,
      default: 0
    },
    'aria-label': {
      type: String,
      default: null
    },
    'aria-labelledby': {
      type: String,
      default: null
    }
  },
  outsideClickListener: null,
  resizeListener: null,
  scrollHandler: null,
  overlay: null,
  virtualScroller: null,
  searchTimeout: null,
  focusOnHover: false,
  dirty: false,

  data() {
    return {
      focused: false,
      focusedOptionIndex: -1,
      focusedMultipleOptionIndex: -1,
      overlayVisible: false,
      searching: false
    };
  },

  watch: {
    suggestions() {
      if (this.searching) {
        ObjectUtils.isNotEmpty(this.suggestions) ? this.show() : this.hide();
        this.focusedOptionIndex = this.overlayVisible && this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : -1;
        this.searching = false;
      }

      this.autoUpdateModel();
    }

  },

  mounted() {
    this.autoUpdateModel();
  },

  updated() {
    if (this.overlayVisible) {
      this.alignOverlay();
    }
  },

  beforeUnmount() {
    this.unbindOutsideClickListener();
    this.unbindResizeListener();

    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }

    if (this.overlay) {
      ZIndexUtils.clear(this.overlay);
      this.overlay = null;
    }
  },

  methods: {
    getOptionIndex(index, fn) {
      return this.virtualScrollerDisabled ? index : fn && fn(index)['index'];
    },

    getOptionLabel(option) {
      return this.field || this.optionLabel ? ObjectUtils.resolveFieldData(option, this.field || this.optionLabel) : option;
    },

    getOptionValue(option) {
      return option; // TODO: The 'optionValue' properties can be added.
    },

    getOptionRenderKey(option, index) {
      return (this.dataKey ? ObjectUtils.resolveFieldData(option, this.dataKey) : this.getOptionLabel(option)) + '_' + index;
    },

    isOptionDisabled(option) {
      return this.optionDisabled ? ObjectUtils.resolveFieldData(option, this.optionDisabled) : false;
    },

    isOptionGroup(option) {
      return this.optionGroupLabel && option.optionGroup && option.group;
    },

    getOptionGroupLabel(optionGroup) {
      return ObjectUtils.resolveFieldData(optionGroup, this.optionGroupLabel);
    },

    getOptionGroupChildren(optionGroup) {
      return ObjectUtils.resolveFieldData(optionGroup, this.optionGroupChildren);
    },

    getAriaPosInset(index) {
      return (this.optionGroupLabel ? index - this.visibleOptions.slice(0, index).filter(option => this.isOptionGroup(option)).length : index) + 1;
    },

    show(isFocus) {
      this.$emit('before-show');
      this.dirty = true;
      this.overlayVisible = true;
      this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : -1;
      isFocus && DomHandler.focus(this.$refs.focusInput);
    },

    hide(isFocus) {
      const _hide = () => {
        this.$emit('before-hide');
        this.dirty = isFocus;
        this.overlayVisible = false;
        this.focusedOptionIndex = -1;
        isFocus && DomHandler.focus(this.$refs.focusInput);
      };

      setTimeout(() => {
        _hide();
      }, 0); // For ScreenReaders
    },

    onFocus(event) {
      if (!this.dirty && this.completeOnFocus) {
        this.search(event, event.target.value, 'focus');
      }

      this.dirty = true;
      this.focused = true;
      this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.overlayVisible && this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : -1;
      this.overlayVisible && this.scrollInView(this.focusedOptionIndex);
      this.$emit('focus', event);
    },

    onBlur(event) {
      this.dirty = false;
      this.focused = false;
      this.focusedOptionIndex = -1;
      this.$emit('blur', event);
    },

    onKeyDown(event) {
      switch (event.code) {
        case 'ArrowDown':
          this.onArrowDownKey(event);
          break;

        case 'ArrowUp':
          this.onArrowUpKey(event);
          break;

        case 'ArrowLeft':
          this.onArrowLeftKey(event);
          break;

        case 'ArrowRight':
          this.onArrowRightKey(event);
          break;

        case 'Home':
          this.onHomeKey(event);
          break;

        case 'End':
          this.onEndKey(event);
          break;

        case 'PageDown':
          this.onPageDownKey(event);
          break;

        case 'PageUp':
          this.onPageUpKey(event);
          break;

        case 'Enter':
          this.onEnterKey(event);
          break;

        case 'Escape':
          this.onEscapeKey(event);
          break;

        case 'Tab':
          this.onTabKey(event);
          break;

        case 'Backspace':
          this.onBackspaceKey(event);
          break;
      }
    },

    onInput(event) {
      if (this.searchTimeout) {
        clearTimeout(this.searchTimeout);
      }

      let query = event.target.value;

      if (!this.multiple) {
        this.updateModel(event, query);
      }

      if (query.length === 0) {
        this.hide();
        this.$emit('clear');
      } else {
        if (query.length >= this.minLength) {
          this.focusedOptionIndex = -1;
          this.searchTimeout = setTimeout(() => {
            this.search(event, query, 'input');
          }, this.delay);
        } else {
          this.hide();
        }
      }
    },

    onChange(event) {
      if (this.forceSelection) {
        let valid = false;

        if (this.visibleOptions) {
          const matchedValue = this.visibleOptions.find(option => this.isOptionMatched(option, event.target.value));

          if (matchedValue !== undefined) {
            valid = true;
            !this.isSelected(matchedValue) && this.onOptionSelect(event, matchedValue);
          }
        }

        if (!valid) {
          this.$refs.focusInput.value = '';
          this.$emit('clear');
          !this.multiple && this.updateModel(event, null);
        }
      }
    },

    onMultipleContainerFocus() {
      this.focused = true;
    },

    onMultipleContainerBlur() {
      this.focusedMultipleOptionIndex = -1;
      this.focused = false;
    },

    onMultipleContainerKeyDown(event) {
      switch (event.code) {
        case 'ArrowLeft':
          this.onArrowLeftKeyOnMultiple(event);
          break;

        case 'ArrowRight':
          this.onArrowRightKeyOnMultiple(event);
          break;

        case 'Backspace':
          this.onBackspaceKeyOnMultiple(event);
          break;
      }
    },

    onContainerClick(event) {
      if (this.disabled || this.searching || this.isInputClicked(event) || this.isDropdownClicked(event)) {
        return;
      }

      if (!this.overlay || !this.overlay.contains(event.target)) {
        DomHandler.focus(this.$refs.focusInput);
      }
    },

    onDropdownClick(event) {
      let query = undefined;

      if (this.overlayVisible) {
        this.hide(true);
      } else {
        DomHandler.focus(this.$refs.focusInput);
        query = this.$refs.focusInput.value;
        if (this.dropdownMode === 'blank') this.search(event, '', 'dropdown');else if (this.dropdownMode === 'current') this.search(event, query, 'dropdown');
      }

      this.$emit('dropdown-click', {
        originalEvent: event,
        query
      });
    },

    onOptionSelect(event, option, isHide = true) {
      const value = this.getOptionValue(option);

      if (this.multiple) {
        this.$refs.focusInput.value = '';

        if (!this.isSelected(option)) {
          this.updateModel(event, [...(this.modelValue || []), value]);
        }
      } else {
        this.updateModel(event, value);
      }

      this.$emit('item-select', {
        originalEvent: event,
        value: option
      });
      isHide && this.hide(true);
    },

    onOptionMouseMove(event, index) {
      if (this.focusOnHover) {
        this.changeFocusedOptionIndex(event, index);
      }
    },

    onOverlayClick(event) {
      OverlayEventBus.emit('overlay-click', {
        originalEvent: event,
        target: this.$el
      });
    },

    onOverlayKeyDown(event) {
      switch (event.code) {
        case 'Escape':
          this.onEscapeKey(event);
          break;
      }
    },

    onArrowDownKey(event) {
      if (!this.overlayVisible) {
        return;
      }

      const optionIndex = this.focusedOptionIndex !== -1 ? this.findNextOptionIndex(this.focusedOptionIndex) : this.findFirstFocusedOptionIndex();
      this.changeFocusedOptionIndex(event, optionIndex);
      event.preventDefault();
    },

    onArrowUpKey(event) {
      if (!this.overlayVisible) {
        return;
      }

      if (event.altKey) {
        if (this.focusedOptionIndex !== -1) {
          this.onOptionSelect(event, this.visibleOptions[this.focusedOptionIndex]);
        }

        this.overlayVisible && this.hide();
        event.preventDefault();
      } else {
        const optionIndex = this.focusedOptionIndex !== -1 ? this.findPrevOptionIndex(this.focusedOptionIndex) : this.findLastFocusedOptionIndex();
        this.changeFocusedOptionIndex(event, optionIndex);
        event.preventDefault();
      }
    },

    onArrowLeftKey(event) {
      const target = event.currentTarget;
      this.focusedOptionIndex = -1;

      if (this.multiple) {
        if (ObjectUtils.isEmpty(target.value) && this.hasSelectedOption) {
          DomHandler.focus(this.$refs.multiContainer);
          this.focusedMultipleOptionIndex = this.modelValue.length;
        } else {
          event.stopPropagation(); // To prevent onArrowLeftKeyOnMultiple method
        }
      }
    },

    onArrowRightKey(event) {
      this.focusedOptionIndex = -1;
      this.multiple && event.stopPropagation(); // To prevent onArrowRightKeyOnMultiple method
    },

    onHomeKey(event) {
      const target = event.currentTarget;
      const len = target.value.length;

      if (event.shiftKey) {
        event.currentTarget.setSelectionRange(0, len);
      } else {
        event.currentTarget.setSelectionRange(0, 0);
      }

      this.focusedOptionIndex = -1;
      event.preventDefault();
    },

    onEndKey(event) {
      const target = event.currentTarget;
      const len = target.value.length;

      if (event.shiftKey) {
        event.currentTarget.setSelectionRange(0, len);
      } else {
        target.setSelectionRange(len, len);
      }

      this.focusedOptionIndex = -1;
      event.preventDefault();
    },

    onPageUpKey(event) {
      this.scrollInView(0);
      event.preventDefault();
    },

    onPageDownKey(event) {
      this.scrollInView(this.visibleOptions.length - 1);
      event.preventDefault();
    },

    onEnterKey(event) {
      if (!this.overlayVisible) {
        this.onArrowDownKey(event);
      } else {
        if (this.focusedOptionIndex !== -1) {
          this.onOptionSelect(event, this.visibleOptions[this.focusedOptionIndex]);
        }

        this.hide();
      }

      event.preventDefault();
    },

    onEscapeKey(event) {
      this.overlayVisible && this.hide(true);
      event.preventDefault();
    },

    onTabKey(event) {
      if (this.focusedOptionIndex !== -1) {
        this.onOptionSelect(event, this.visibleOptions[this.focusedOptionIndex]);
      }

      this.overlayVisible && this.hide();
    },

    onBackspaceKey(event) {
      if (this.multiple) {
        if (ObjectUtils.isNotEmpty(this.modelValue) && !this.$refs.focusInput.value) {
          const removedValue = this.modelValue[this.modelValue.length - 1];
          const newValue = this.modelValue.slice(0, -1);
          this.$emit('update:modelValue', newValue);
          this.$emit('item-unselect', {
            originalEvent: event,
            value: removedValue
          });
        }

        event.stopPropagation(); // To prevent onBackspaceKeyOnMultiple method
      }
    },

    onArrowLeftKeyOnMultiple() {
      this.focusedMultipleOptionIndex = this.focusedMultipleOptionIndex < 1 ? 0 : this.focusedMultipleOptionIndex - 1;
    },

    onArrowRightKeyOnMultiple() {
      this.focusedMultipleOptionIndex++;

      if (this.focusedMultipleOptionIndex > this.modelValue.length - 1) {
        this.focusedMultipleOptionIndex = -1;
        DomHandler.focus(this.$refs.focusInput);
      }
    },

    onBackspaceKeyOnMultiple(event) {
      if (this.focusedMultipleOptionIndex !== -1) {
        this.removeOption(event, this.focusedMultipleOptionIndex);
      }
    },

    onOverlayEnter(el) {
      ZIndexUtils.set('overlay', el, this.$primevue.config.zIndex.overlay);
      this.alignOverlay();
    },

    onOverlayAfterEnter() {
      this.bindOutsideClickListener();
      this.bindScrollListener();
      this.bindResizeListener();
      this.$emit('show');
    },

    onOverlayLeave() {
      this.unbindOutsideClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
      this.$emit('hide');
      this.overlay = null;
    },

    onOverlayAfterLeave(el) {
      ZIndexUtils.clear(el);
    },

    alignOverlay() {
      let target = this.multiple ? this.$refs.multiContainer : this.$refs.focusInput;

      if (this.appendTo === 'self') {
        DomHandler.relativePosition(this.overlay, target);
      } else {
        this.overlay.style.minWidth = DomHandler.getOuterWidth(target) + 'px';
        DomHandler.absolutePosition(this.overlay, target);
      }
    },

    bindOutsideClickListener() {
      if (!this.outsideClickListener) {
        this.outsideClickListener = event => {
          if (this.overlayVisible && this.overlay && this.isOutsideClicked(event)) {
            this.hide();
          }
        };

        document.addEventListener('click', this.outsideClickListener);
      }
    },

    unbindOutsideClickListener() {
      if (this.outsideClickListener) {
        document.removeEventListener('click', this.outsideClickListener);
        this.outsideClickListener = null;
      }
    },

    bindScrollListener() {
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.$refs.container, () => {
          if (this.overlayVisible) {
            this.hide();
          }
        });
      }

      this.scrollHandler.bindScrollListener();
    },

    unbindScrollListener() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    },

    bindResizeListener() {
      if (!this.resizeListener) {
        this.resizeListener = () => {
          if (this.overlayVisible && !DomHandler.isTouchDevice()) {
            this.hide();
          }
        };

        window.addEventListener('resize', this.resizeListener);
      }
    },

    unbindResizeListener() {
      if (this.resizeListener) {
        window.removeEventListener('resize', this.resizeListener);
        this.resizeListener = null;
      }
    },

    isOutsideClicked(event) {
      return !this.overlay.contains(event.target) && !this.isInputClicked(event) && !this.isDropdownClicked(event);
    },

    isInputClicked(event) {
      if (this.multiple) return event.target === this.$refs.multiContainer || this.$refs.multiContainer.contains(event.target);else return event.target === this.$refs.focusInput;
    },

    isDropdownClicked(event) {
      return this.$refs.dropdownButton ? event.target === this.$refs.dropdownButton || this.$refs.dropdownButton.$el.contains(event.target) : false;
    },

    isOptionMatched(option, value) {
      return this.isValidOption(option) && this.getOptionLabel(option).toLocaleLowerCase(this.searchLocale) === value.toLocaleLowerCase(this.searchLocale);
    },

    isValidOption(option) {
      return option && !(this.isOptionDisabled(option) || this.isOptionGroup(option));
    },

    isValidSelectedOption(option) {
      return this.isValidOption(option) && this.isSelected(option);
    },

    isSelected(option) {
      return ObjectUtils.equals(this.modelValue, this.getOptionValue(option), this.equalityKey);
    },

    findFirstOptionIndex() {
      return this.visibleOptions.findIndex(option => this.isValidOption(option));
    },

    findLastOptionIndex() {
      return ObjectUtils.findLastIndex(this.visibleOptions, option => this.isValidOption(option));
    },

    findNextOptionIndex(index) {
      const matchedOptionIndex = index < this.visibleOptions.length - 1 ? this.visibleOptions.slice(index + 1).findIndex(option => this.isValidOption(option)) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex + index + 1 : index;
    },

    findPrevOptionIndex(index) {
      const matchedOptionIndex = index > 0 ? ObjectUtils.findLastIndex(this.visibleOptions.slice(0, index), option => this.isValidOption(option)) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex : index;
    },

    findSelectedOptionIndex() {
      return this.hasSelectedOption ? this.visibleOptions.findIndex(option => this.isValidSelectedOption(option)) : -1;
    },

    findFirstFocusedOptionIndex() {
      const selectedIndex = this.findSelectedOptionIndex();
      return selectedIndex < 0 ? this.findFirstOptionIndex() : selectedIndex;
    },

    findLastFocusedOptionIndex() {
      const selectedIndex = this.findSelectedOptionIndex();
      return selectedIndex < 0 ? this.findLastOptionIndex() : selectedIndex;
    },

    search(event, query, source) {
      //allow empty string but not undefined or null
      if (query === undefined || query === null) {
        return;
      } //do not search blank values on input change


      if (source === 'input' && query.trim().length === 0) {
        return;
      }

      this.searching = true;
      this.$emit('complete', {
        originalEvent: event,
        query
      });
    },

    removeOption(event, index) {
      const removedOption = this.modelValue[index];
      const value = this.modelValue.filter((_, i) => i !== index).map(option => this.getOptionValue(option));
      this.updateModel(event, value);
      this.$emit('item-unselect', {
        originalEvent: event,
        value: removedOption
      });
      this.dirty = true;
      DomHandler.focus(this.$refs.focusInput);
    },

    changeFocusedOptionIndex(event, index) {
      if (this.focusedOptionIndex !== index) {
        this.focusedOptionIndex = index;
        this.scrollInView();

        if (this.selectOnFocus || this.autoHighlight) {
          this.onOptionSelect(event, this.visibleOptions[index], false);
        }
      }
    },

    scrollInView(index = -1) {
      const id = index !== -1 ? `${this.id}_${index}` : this.focusedOptionId;
      const element = DomHandler.findSingle(this.list, `li[id="${id}"]`);

      if (element) {
        element.scrollIntoView && element.scrollIntoView({
          block: 'nearest',
          inline: 'start'
        });
      } else if (!this.virtualScrollerDisabled) {
        setTimeout(() => {
          this.virtualScroller && this.virtualScroller.scrollToIndex(index !== -1 ? index : this.focusedOptionIndex);
        }, 0);
      }
    },

    autoUpdateModel() {
      if ((this.selectOnFocus || this.autoHighlight) && this.autoOptionFocus && !this.hasSelectedOption) {
        this.focusedOptionIndex = this.findFirstFocusedOptionIndex();
        this.onOptionSelect(null, this.visibleOptions[this.focusedOptionIndex], false);
      }
    },

    updateModel(event, value) {
      this.$emit('update:modelValue', value);
      this.$emit('change', {
        originalEvent: event,
        value
      });
    },

    flatOptions(options) {
      return (options || []).reduce((result, option, index) => {
        result.push({
          optionGroup: option,
          group: true,
          index
        });
        const optionGroupChildren = this.getOptionGroupChildren(option);
        optionGroupChildren && optionGroupChildren.forEach(o => result.push(o));
        return result;
      }, []);
    },

    overlayRef(el) {
      this.overlay = el;
    },

    listRef(el, contentRef) {
      this.list = el;
      contentRef && contentRef(el); // For VirtualScroller
    },

    virtualScrollerRef(el) {
      this.virtualScroller = el;
    }

  },
  computed: {
    containerClass() {
      return ['p-autocomplete p-component p-inputwrapper', {
        'p-disabled': this.disabled,
        'p-focus': this.focused,
        'p-autocomplete-dd': this.dropdown,
        'p-autocomplete-multiple': this.multiple,
        'p-inputwrapper-filled': this.modelValue || ObjectUtils.isNotEmpty(this.inputValue),
        'p-inputwrapper-focus': this.focused,
        'p-overlay-open': this.overlayVisible
      }];
    },

    inputStyleClass() {
      return ['p-autocomplete-input p-inputtext p-component', this.inputClass, {
        'p-autocomplete-dd-input': this.dropdown
      }];
    },

    multiContainerClass() {
      return ['p-autocomplete-multiple-container p-component p-inputtext'];
    },

    panelStyleClass() {
      return ['p-autocomplete-panel p-component', this.panelClass, {
        'p-input-filled': this.$primevue.config.inputStyle === 'filled',
        'p-ripple-disabled': this.$primevue.config.ripple === false
      }];
    },

    loadingIconClass() {
      return ['p-autocomplete-loader pi-spin', this.loadingIcon];
    },

    visibleOptions() {
      return this.optionGroupLabel ? this.flatOptions(this.suggestions) : this.suggestions || [];
    },

    inputValue() {
      if (this.modelValue) {
        if (typeof this.modelValue === 'object') {
          const label = this.getOptionLabel(this.modelValue);
          return label != null ? label : this.modelValue;
        } else {
          return this.modelValue;
        }
      } else {
        return '';
      }
    },

    hasSelectedOption() {
      return ObjectUtils.isNotEmpty(this.modelValue);
    },

    equalityKey() {
      return this.dataKey; // TODO: The 'optionValue' properties can be added.
    },

    searchResultMessageText() {
      return ObjectUtils.isNotEmpty(this.visibleOptions) && this.overlayVisible ? this.searchMessageText.replaceAll('{0}', this.visibleOptions.length) : this.emptySearchMessageText;
    },

    searchMessageText() {
      return this.searchMessage || this.$primevue.config.locale.searchMessage || '';
    },

    emptySearchMessageText() {
      return this.emptySearchMessage || this.$primevue.config.locale.emptySearchMessage || '';
    },

    selectionMessageText() {
      return this.selectionMessage || this.$primevue.config.locale.selectionMessage || '';
    },

    emptySelectionMessageText() {
      return this.emptySelectionMessage || this.$primevue.config.locale.emptySelectionMessage || '';
    },

    selectedMessageText() {
      return this.hasSelectedOption ? this.selectionMessageText.replaceAll('{0}', this.multiple ? this.modelValue.length : '1') : this.emptySelectionMessageText;
    },

    id() {
      return this.$attrs.id || UniqueComponentId();
    },

    focusedOptionId() {
      return this.focusedOptionIndex !== -1 ? `${this.id}_${this.focusedOptionIndex}` : null;
    },

    focusedMultipleOptionId() {
      return this.focusedMultipleOptionIndex !== -1 ? `${this.id}_multiple_option_${this.focusedMultipleOptionIndex}` : null;
    },

    ariaSetSize() {
      return this.visibleOptions.filter(option => !this.isOptionGroup(option)).length;
    },

    virtualScrollerDisabled() {
      return !this.virtualScrollerOptions;
    }

  },
  components: {
    Button: script$1L,
    VirtualScroller: script$1g,
    Portal: script$1C
  },
  directives: {
    ripple: Ripple
  }
};
const _hoisted_1$E = ["id", "value", "placeholder", "tabindex", "disabled", "aria-label", "aria-labelledby", "aria-expanded", "aria-controls", "aria-activedescendant"];
const _hoisted_2$x = ["aria-activedescendant"];
const _hoisted_3$s = ["id", "aria-label", "aria-setsize", "aria-posinset"];
const _hoisted_4$n = {
  class: "p-autocomplete-token-label"
};
const _hoisted_5$i = ["onClick"];
const _hoisted_6$g = {
  class: "p-autocomplete-input-token",
  role: "option"
};
const _hoisted_7$b = ["id", "placeholder", "tabindex", "disabled", "aria-label", "aria-labelledby", "aria-expanded", "aria-controls", "aria-activedescendant"];
const _hoisted_8$a = {
  role: "status",
  "aria-live": "polite",
  class: "p-hidden-accessible"
};
const _hoisted_9$5 = ["id"];
const _hoisted_10$5 = ["id"];
const _hoisted_11$5 = ["id", "aria-label", "aria-selected", "aria-disabled", "aria-setsize", "aria-posinset", "onClick", "onMousemove"];
const _hoisted_12$5 = {
  role: "status",
  "aria-live": "polite",
  class: "p-hidden-accessible"
};

function render$q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Button = resolveComponent("Button");

  const _component_VirtualScroller = resolveComponent("VirtualScroller");

  const _component_Portal = resolveComponent("Portal");

  const _directive_ripple = resolveDirective("ripple");

  return openBlock(), createElementBlock("div", {
    ref: "container",
    class: normalizeClass($options.containerClass),
    onClick: _cache[15] || (_cache[15] = (...args) => $options.onContainerClick && $options.onContainerClick(...args))
  }, [!$props.multiple ? (openBlock(), createElementBlock("input", mergeProps({
    key: 0,
    ref: "focusInput",
    id: $props.inputId,
    type: "text",
    style: $props.inputStyle,
    class: $options.inputStyleClass,
    value: $options.inputValue,
    placeholder: $props.placeholder,
    tabindex: !$props.disabled ? $props.tabindex : -1,
    disabled: $props.disabled,
    autocomplete: "off",
    role: "combobox",
    "aria-label": _ctx.ariaLabel,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-haspopup": "listbox",
    "aria-autocomplete": "list",
    "aria-expanded": $data.overlayVisible,
    "aria-controls": $options.id + '_list',
    "aria-activedescendant": $data.focused ? $options.focusedOptionId : undefined,
    onFocus: _cache[0] || (_cache[0] = (...args) => $options.onFocus && $options.onFocus(...args)),
    onBlur: _cache[1] || (_cache[1] = (...args) => $options.onBlur && $options.onBlur(...args)),
    onKeydown: _cache[2] || (_cache[2] = (...args) => $options.onKeyDown && $options.onKeyDown(...args)),
    onInput: _cache[3] || (_cache[3] = (...args) => $options.onInput && $options.onInput(...args)),
    onChange: _cache[4] || (_cache[4] = (...args) => $options.onChange && $options.onChange(...args))
  }, $props.inputProps), null, 16, _hoisted_1$E)) : createCommentVNode("", true), $props.multiple ? (openBlock(), createElementBlock("ul", {
    key: 1,
    ref: "multiContainer",
    class: normalizeClass($options.multiContainerClass),
    tabindex: "-1",
    role: "listbox",
    "aria-orientation": "horizontal",
    "aria-activedescendant": $data.focused ? $options.focusedMultipleOptionId : undefined,
    onFocus: _cache[10] || (_cache[10] = (...args) => $options.onMultipleContainerFocus && $options.onMultipleContainerFocus(...args)),
    onBlur: _cache[11] || (_cache[11] = (...args) => $options.onMultipleContainerBlur && $options.onMultipleContainerBlur(...args)),
    onKeydown: _cache[12] || (_cache[12] = (...args) => $options.onMultipleContainerKeyDown && $options.onMultipleContainerKeyDown(...args))
  }, [(openBlock(true), createElementBlock(Fragment, null, renderList($props.modelValue, (option, i) => {
    return openBlock(), createElementBlock("li", {
      key: i,
      id: $options.id + '_multiple_option_' + i,
      class: normalizeClass(['p-autocomplete-token', {
        'p-focus': $data.focusedMultipleOptionIndex === i
      }]),
      role: "option",
      "aria-label": $options.getOptionLabel(option),
      "aria-selected": true,
      "aria-setsize": $props.modelValue.length,
      "aria-posinset": i + 1
    }, [renderSlot(_ctx.$slots, "chip", {
      value: option
    }, () => [createElementVNode("span", _hoisted_4$n, toDisplayString$1($options.getOptionLabel(option)), 1)]), createElementVNode("span", {
      class: normalizeClass(['p-autocomplete-token-icon', $props.removeTokenIcon]),
      onClick: $event => $options.removeOption($event, i),
      "aria-hidden": "true"
    }, null, 10, _hoisted_5$i)], 10, _hoisted_3$s);
  }), 128)), createElementVNode("li", _hoisted_6$g, [createElementVNode("input", mergeProps({
    ref: "focusInput",
    id: $props.inputId,
    type: "text",
    style: $props.inputStyle,
    class: $props.inputClass,
    placeholder: $props.placeholder,
    tabindex: !$props.disabled ? $props.tabindex : -1,
    disabled: $props.disabled,
    autocomplete: "off",
    role: "combobox",
    "aria-label": _ctx.ariaLabel,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-haspopup": "listbox",
    "aria-autocomplete": "list",
    "aria-expanded": $data.overlayVisible,
    "aria-controls": $options.id + '_list',
    "aria-activedescendant": $data.focused ? $options.focusedOptionId : undefined,
    onFocus: _cache[5] || (_cache[5] = (...args) => $options.onFocus && $options.onFocus(...args)),
    onBlur: _cache[6] || (_cache[6] = (...args) => $options.onBlur && $options.onBlur(...args)),
    onKeydown: _cache[7] || (_cache[7] = (...args) => $options.onKeyDown && $options.onKeyDown(...args)),
    onInput: _cache[8] || (_cache[8] = (...args) => $options.onInput && $options.onInput(...args)),
    onChange: _cache[9] || (_cache[9] = (...args) => $options.onChange && $options.onChange(...args))
  }, $props.inputProps), null, 16, _hoisted_7$b)])], 42, _hoisted_2$x)) : createCommentVNode("", true), $data.searching ? (openBlock(), createElementBlock("i", {
    key: 2,
    class: normalizeClass($options.loadingIconClass),
    "aria-hidden": "true"
  }, null, 2)) : createCommentVNode("", true), $props.dropdown ? (openBlock(), createBlock(_component_Button, {
    key: 3,
    ref: "dropdownButton",
    type: "button",
    icon: $props.dropdownIcon,
    class: "p-autocomplete-dropdown",
    tabindex: "-1",
    disabled: $props.disabled,
    "aria-hidden": "true",
    onClick: $options.onDropdownClick
  }, null, 8, ["icon", "disabled", "onClick"])) : createCommentVNode("", true), createElementVNode("span", _hoisted_8$a, toDisplayString$1($options.searchResultMessageText), 1), createVNode(_component_Portal, {
    appendTo: $props.appendTo
  }, {
    default: withCtx(() => [createVNode(Transition, {
      name: "p-connected-overlay",
      onEnter: $options.onOverlayEnter,
      onAfterEnter: $options.onOverlayAfterEnter,
      onLeave: $options.onOverlayLeave,
      onAfterLeave: $options.onOverlayAfterLeave
    }, {
      default: withCtx(() => [$data.overlayVisible ? (openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        ref: $options.overlayRef,
        class: $options.panelStyleClass,
        style: { ...$props.panelStyle,
          'max-height': $options.virtualScrollerDisabled ? $props.scrollHeight : ''
        },
        onClick: _cache[13] || (_cache[13] = (...args) => $options.onOverlayClick && $options.onOverlayClick(...args)),
        onKeydown: _cache[14] || (_cache[14] = (...args) => $options.onOverlayKeyDown && $options.onOverlayKeyDown(...args))
      }, $props.panelProps), [renderSlot(_ctx.$slots, "header", {
        value: $props.modelValue,
        suggestions: $options.visibleOptions
      }), createVNode(_component_VirtualScroller, mergeProps({
        ref: $options.virtualScrollerRef
      }, $props.virtualScrollerOptions, {
        style: {
          height: $props.scrollHeight
        },
        items: $options.visibleOptions,
        tabindex: -1,
        disabled: $options.virtualScrollerDisabled
      }), createSlots({
        content: withCtx(({
          styleClass,
          contentRef,
          items,
          getItemOptions,
          contentStyle,
          itemSize
        }) => [createElementVNode("ul", {
          ref: el => $options.listRef(el, contentRef),
          id: $options.id + '_list',
          class: normalizeClass(['p-autocomplete-items', styleClass]),
          style: normalizeStyle(contentStyle),
          role: "listbox"
        }, [(openBlock(true), createElementBlock(Fragment, null, renderList(items, (option, i) => {
          return openBlock(), createElementBlock(Fragment, {
            key: $options.getOptionRenderKey(option, $options.getOptionIndex(i, getItemOptions))
          }, [$options.isOptionGroup(option) ? (openBlock(), createElementBlock("li", {
            key: 0,
            id: $options.id + '_' + $options.getOptionIndex(i, getItemOptions),
            style: normalizeStyle({
              height: itemSize ? itemSize + 'px' : undefined
            }),
            class: "p-autocomplete-item-group",
            role: "option"
          }, [renderSlot(_ctx.$slots, "optiongroup", {
            option: option.optionGroup,
            item: option.optionGroup,
            index: $options.getOptionIndex(i, getItemOptions)
          }, () => [createTextVNode(toDisplayString$1($options.getOptionGroupLabel(option.optionGroup)), 1)])], 12, _hoisted_10$5)) : withDirectives((openBlock(), createElementBlock("li", {
            key: 1,
            id: $options.id + '_' + $options.getOptionIndex(i, getItemOptions),
            style: normalizeStyle({
              height: itemSize ? itemSize + 'px' : undefined
            }),
            class: normalizeClass(['p-autocomplete-item', {
              'p-highlight': $options.isSelected(option),
              'p-focus': $data.focusedOptionIndex === $options.getOptionIndex(i, getItemOptions),
              'p-disabled': $options.isOptionDisabled(option)
            }]),
            role: "option",
            "aria-label": $options.getOptionLabel(option),
            "aria-selected": $options.isSelected(option),
            "aria-disabled": $options.isOptionDisabled(option),
            "aria-setsize": $options.ariaSetSize,
            "aria-posinset": $options.getAriaPosInset($options.getOptionIndex(i, getItemOptions)),
            onClick: $event => $options.onOptionSelect($event, option),
            onMousemove: $event => $options.onOptionMouseMove($event, $options.getOptionIndex(i, getItemOptions))
          }, [_ctx.$slots.option ? renderSlot(_ctx.$slots, "option", {
            key: 0,
            option: option,
            index: $options.getOptionIndex(i, getItemOptions)
          }, () => [createTextVNode(toDisplayString$1($options.getOptionLabel(option)), 1)]) : renderSlot(_ctx.$slots, "item", {
            key: 1,
            item: option,
            index: $options.getOptionIndex(i, getItemOptions)
          }, () => [createTextVNode(toDisplayString$1($options.getOptionLabel(option)), 1)])], 46, _hoisted_11$5)), [[_directive_ripple]])], 64);
        }), 128))], 14, _hoisted_9$5), createElementVNode("span", _hoisted_12$5, toDisplayString$1($options.selectedMessageText), 1)]),
        _: 2
      }, [_ctx.$slots.loader ? {
        name: "loader",
        fn: withCtx(({
          options
        }) => [renderSlot(_ctx.$slots, "loader", {
          options: options
        })]),
        key: "0"
      } : undefined]), 1040, ["style", "items", "disabled"]), renderSlot(_ctx.$slots, "footer", {
        value: $props.modelValue,
        suggestions: $options.visibleOptions
      })], 16)) : createCommentVNode("", true)]),
      _: 3
    }, 8, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])]),
    _: 3
  }, 8, ["appendTo"])], 2);
}

function styleInject$l(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$s = "\n.p-autocomplete {\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    position: relative;\n}\n.p-autocomplete-loader {\n    position: absolute;\n    top: 50%;\n    margin-top: -0.5rem;\n}\n.p-autocomplete-dd .p-autocomplete-input {\n    -webkit-box-flex: 1;\n        -ms-flex: 1 1 auto;\n            flex: 1 1 auto;\n    width: 1%;\n}\n.p-autocomplete-dd .p-autocomplete-input,\n.p-autocomplete-dd .p-autocomplete-multiple-container {\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n}\n.p-autocomplete-dd .p-autocomplete-dropdown {\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0px;\n}\n.p-autocomplete .p-autocomplete-panel {\n    min-width: 100%;\n}\n.p-autocomplete-panel {\n    position: absolute;\n    overflow: auto;\n    top: 0;\n    left: 0;\n}\n.p-autocomplete-items {\n    margin: 0;\n    padding: 0;\n    list-style-type: none;\n}\n.p-autocomplete-item {\n    cursor: pointer;\n    white-space: nowrap;\n    position: relative;\n    overflow: hidden;\n}\n.p-autocomplete-multiple-container {\n    margin: 0;\n    padding: 0;\n    list-style-type: none;\n    cursor: text;\n    overflow: hidden;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -ms-flex-wrap: wrap;\n        flex-wrap: wrap;\n}\n.p-autocomplete-token {\n    cursor: default;\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-flex: 0;\n        -ms-flex: 0 0 auto;\n            flex: 0 0 auto;\n}\n.p-autocomplete-token-icon {\n    cursor: pointer;\n}\n.p-autocomplete-input-token {\n    -webkit-box-flex: 1;\n        -ms-flex: 1 1 auto;\n            flex: 1 1 auto;\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n}\n.p-autocomplete-input-token input {\n    border: 0 none;\n    outline: 0 none;\n    background-color: transparent;\n    margin: 0;\n    padding: 0;\n    -webkit-box-shadow: none;\n            box-shadow: none;\n    border-radius: 0;\n    width: 100%;\n}\n.p-fluid .p-autocomplete {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n}\n.p-fluid .p-autocomplete-dd .p-autocomplete-input {\n    width: 1%;\n}\n";
styleInject$l(css_248z$s);
script$1f.render = render$q;

var script$1e = {
  props: {
    bind : Object,
    options : Array
},
  setup(__props) {

const props = __props;



const is_multiple = (props.bind.cell.multiple) ? true : false;

const filtered_options = ref([]);

const cvalue = ref();
if(is_multiple) {
    cvalue.value = [];
    for(let i in props.bind.value) {
        cvalue.value.push({ value : i, label : ''});
    }
} else {
    cvalue.value = { value : props.bind.value, label : ''};
}


const def = props.options.filter(opt => opt.value == props.bind.value);

if (def.length > 0) {
    cvalue.value = def[0];
}


const value = computed({
    get() {
        return cvalue.value;
    },
    set(val) {
        cvalue.value = val;
        if (is_multiple) {
            let arr = [];
            for(const i in val) {
                arr.push(val[i].value);
            }
            props.bind.setValue(arr);
        } else {
            props.bind.setValue(val.value);
        }
    }
});

function searchOptions(e) {
    const active = (is_multiple) 
    ? props.options.filter(opt => cvalue.value.includes(opt.value))
    : props.options.filter(opt => opt.value == cvalue.value.value);
    if (active.length > 0) cvalue.value = active[0];
    let vl = (!e || !e.query) ? "" : e.query.trim().toLowerCase();
    filtered_options.value = props.options.filter((opt) => {
        return opt.label.toLowerCase().startsWith(vl);
    });
}


watch(() => props.options, () => {
    searchOptions();
});


return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$1f), {
    modelValue: unref(value),
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (isRef(value) ? (value).value = $event : null)),
    name: __props.bind.cell.name,
    optionLabel: "label",
    forceSelection: "",
    dropdown: true,
    suggestions: filtered_options.value,
    placeholder: "Please Select",
    class: normalizeClass(["focus:border-primary", __props.bind.classes]),
    multiple: unref(is_multiple),
    onComplete: _cache[1] || (_cache[1] = $event => (searchOptions($event))),
    onBlur: _cache[2] || (_cache[2] = $event => (__props.bind.setShowError(true)))
  }, null, 8 /* PROPS */, ["modelValue", "name", "suggestions", "class", "multiple"]))
}
}

};

script$1e.__file = "presstojam/src/components/form/autocomplete-select.vue";

const _hoisted_1$D = {
  key: 0,
  class: "p-inputgroup"
};
const _hoisted_2$w = {
  key: 0,
  class: "p-inputgroup-addon"
};



var script$1d = {
  props: {
    bind : {
        type : Object,
        required : true
    },
    data : Object
},
  setup(__props) {

const props = __props;



const store = inject("model");

const options = ref([]);


let obj = {};

if (props.bind.cell.multiple) {
    for(const i in props.bind.value) {
        obj[i] = true;
    }
} else {
    obj[props.bind.value] = true;
}
let cvalue = ref(obj);
let value;



const parent_id =(props.data['--parent']) ? props.data["--parent"] : 0;

const cell = props.bind.cell;


if (cell.isReferenceType()) {
        store.getOptions(cell.name, parent_id)
        .then(response => {
            let arr = [...response];
            arr.unshift({value:0,label:"None"});
            options.value = arr;
        })
        .catch(e => console.log(e));
    

    value = computed({
        get() {
            return cvalue.value;
        },
        set(val) {
            props.bind.setValue(val);
            cvalue.value = val;
        }
    });

} else if (cell.recursive) {
      store.getRecursiveOptions(cell.name, parent_id)
       .then(response => {
        let arr = [...response];
        arr.unshift({key : "0", label : 'None' , "--recursive" : 0});
        options.value =arr;
       })
       .catch(e => console.log(e));

    value = computed({
        get() {
            return cvalue.value;
        },
        set(val) {
            const keys = Object.keys(val);
            props.bind.setValue(keys[0]);
            cvalue.value= val;
        }
    });
} 



return (_ctx, _cache) => {
  return (__props.bind.cell.isReferenceType())
    ? (openBlock(), createElementBlock("div", _hoisted_1$D, [
        createVNode(script$1e, {
          bind: __props.bind,
          options: options.value
        }, null, 8 /* PROPS */, ["bind", "options"]),
        (unref(store).perms.includes('post'))
          ? (openBlock(), createElementBlock("span", _hoisted_2$w, [
              createVNode(script$1h, {
                name: __props.bind.cell.reference,
                model: unref(store)
              }, null, 8 /* PROPS */, ["name", "model"])
            ]))
          : createCommentVNode("v-if", true)
      ]))
    : (__props.bind.cell.recursive)
      ? (openBlock(), createBlock(unref(script$1j), {
          key: 1,
          modelValue: unref(value),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (isRef(value) ? (value).value = $event : value = $event)),
          options: options.value,
          placeholder: "Select Item",
          onBlur: _cache[1] || (_cache[1] = $event => (__props.bind.setShowError(true)))
        }, null, 8 /* PROPS */, ["modelValue", "options"]))
      : (openBlock(), createBlock(unref(script$1n), {
          key: 2,
          name: __props.bind.cell.name,
          modelValue: unref(value),
          "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => (isRef(value) ? (value).value = $event : value = $event)),
          disabled: true,
          onBlur: _cache[3] || (_cache[3] = $event => (__props.bind.setShowError(true)))
        }, null, 8 /* PROPS */, ["name", "modelValue"]))
}
}

};

script$1d.__file = "presstojam/src/components/form/id-edit.vue";

var script$1c = {
  name: 'Calendar',
  emits: ['show', 'hide', 'input', 'month-change', 'year-change', 'date-select', 'update:modelValue', 'today-click', 'clear-click', 'focus', 'blur', 'keydown'],
  props: {
    modelValue: null,
    selectionMode: {
      type: String,
      default: 'single'
    },
    dateFormat: {
      type: String,
      default: null
    },
    inline: {
      type: Boolean,
      default: false
    },
    showOtherMonths: {
      type: Boolean,
      default: true
    },
    selectOtherMonths: {
      type: Boolean,
      default: false
    },
    showIcon: {
      type: Boolean,
      default: false
    },
    icon: {
      type: String,
      default: 'pi pi-calendar'
    },
    previousIcon: {
      type: String,
      default: 'pi pi-chevron-left'
    },
    nextIcon: {
      type: String,
      default: 'pi pi-chevron-right'
    },
    incrementIcon: {
      type: String,
      default: 'pi pi-chevron-up'
    },
    decrementIcon: {
      type: String,
      default: 'pi pi-chevron-down'
    },
    numberOfMonths: {
      type: Number,
      default: 1
    },
    responsiveOptions: Array,
    view: {
      type: String,
      default: 'date'
    },
    touchUI: {
      type: Boolean,
      default: false
    },
    monthNavigator: {
      type: Boolean,
      default: false
    },
    yearNavigator: {
      type: Boolean,
      default: false
    },
    yearRange: {
      type: String,
      default: null
    },
    minDate: {
      type: Date,
      value: null
    },
    maxDate: {
      type: Date,
      value: null
    },
    disabledDates: {
      type: Array,
      value: null
    },
    disabledDays: {
      type: Array,
      value: null
    },
    maxDateCount: {
      type: Number,
      value: null
    },
    showOnFocus: {
      type: Boolean,
      default: true
    },
    autoZIndex: {
      type: Boolean,
      default: true
    },
    baseZIndex: {
      type: Number,
      default: 0
    },
    showButtonBar: {
      type: Boolean,
      default: false
    },
    shortYearCutoff: {
      type: String,
      default: '+10'
    },
    showTime: {
      type: Boolean,
      default: false
    },
    timeOnly: {
      type: Boolean,
      default: false
    },
    hourFormat: {
      type: String,
      default: '24'
    },
    stepHour: {
      type: Number,
      default: 1
    },
    stepMinute: {
      type: Number,
      default: 1
    },
    stepSecond: {
      type: Number,
      default: 1
    },
    showSeconds: {
      type: Boolean,
      default: false
    },
    hideOnDateTimeSelect: {
      type: Boolean,
      default: false
    },
    hideOnRangeSelection: {
      type: Boolean,
      default: false
    },
    timeSeparator: {
      type: String,
      default: ':'
    },
    showWeek: {
      type: Boolean,
      default: false
    },
    manualInput: {
      type: Boolean,
      default: true
    },
    appendTo: {
      type: String,
      default: 'body'
    },
    disabled: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    placeholder: {
      type: String,
      default: null
    },
    id: {
      type: String,
      default: null
    },
    inputId: {
      type: String,
      default: null
    },
    inputClass: {
      type: String,
      default: null
    },
    inputStyle: {
      type: null,
      default: null
    },
    inputProps: {
      type: null,
      default: null
    },
    panelClass: {
      type: String,
      default: null
    },
    panelStyle: {
      type: null,
      default: null
    },
    panelProps: {
      type: null,
      default: null
    },
    'aria-labelledby': {
      type: String,
      default: null
    },
    'aria-label': {
      type: String,
      default: null
    }
  },
  navigationState: null,
  timePickerChange: false,
  scrollHandler: null,
  outsideClickListener: null,
  maskClickListener: null,
  resizeListener: null,
  overlay: null,
  input: null,
  mask: null,
  timePickerTimer: null,
  preventFocus: false,
  typeUpdate: false,

  data() {
    return {
      currentMonth: null,
      currentYear: null,
      currentHour: null,
      currentMinute: null,
      currentSecond: null,
      pm: null,
      focused: false,
      overlayVisible: false,
      currentView: this.view
    };
  },

  watch: {
    modelValue(newValue) {
      this.updateCurrentMetaData();

      if (!this.typeUpdate && !this.inline && this.input) {
        this.input.value = this.formatValue(newValue);
      }

      this.typeUpdate = false;
    },

    showTime() {
      this.updateCurrentMetaData();
    },

    months() {
      if (this.overlay) {
        if (!this.focused) {
          if (this.inline) {
            this.preventFocus = true;
          }

          setTimeout(this.updateFocus, 0);
        }
      }
    },

    numberOfMonths() {
      this.destroyResponsiveStyleElement();
      this.createResponsiveStyle();
    },

    responsiveOptions() {
      this.destroyResponsiveStyleElement();
      this.createResponsiveStyle();
    },

    currentView() {
      Promise.resolve(null).then(() => this.alignOverlay());
    }

  },

  created() {
    this.updateCurrentMetaData();
  },

  mounted() {
    this.createResponsiveStyle();

    if (this.inline) {
      this.overlay && this.overlay.setAttribute(this.attributeSelector, '');

      if (!this.disabled) {
        this.preventFocus = true;
        this.initFocusableCell();

        if (this.numberOfMonths === 1) {
          this.overlay.style.width = DomHandler.getOuterWidth(this.$el) + 'px';
        }
      }
    } else {
      this.input.value = this.formatValue(this.modelValue);
    }
  },

  updated() {
    if (this.overlay) {
      this.preventFocus = true;
      this.updateFocus();
    }

    if (this.input && this.selectionStart != null && this.selectionEnd != null) {
      this.input.selectionStart = this.selectionStart;
      this.input.selectionEnd = this.selectionEnd;
      this.selectionStart = null;
      this.selectionEnd = null;
    }
  },

  beforeUnmount() {
    if (this.timePickerTimer) {
      clearTimeout(this.timePickerTimer);
    }

    if (this.mask) {
      this.destroyMask();
    }

    this.destroyResponsiveStyleElement();
    this.unbindOutsideClickListener();
    this.unbindResizeListener();

    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }

    if (this.overlay && this.autoZIndex) {
      ZIndexUtils.clear(this.overlay);
    }

    this.overlay = null;
  },

  methods: {
    isComparable() {
      return this.modelValue != null && typeof this.modelValue !== 'string';
    },

    isSelected(dateMeta) {
      if (!this.isComparable()) {
        return false;
      }

      if (this.modelValue) {
        if (this.isSingleSelection()) {
          return this.isDateEquals(this.modelValue, dateMeta);
        } else if (this.isMultipleSelection()) {
          let selected = false;

          for (let date of this.modelValue) {
            selected = this.isDateEquals(date, dateMeta);

            if (selected) {
              break;
            }
          }

          return selected;
        } else if (this.isRangeSelection()) {
          if (this.modelValue[1]) return this.isDateEquals(this.modelValue[0], dateMeta) || this.isDateEquals(this.modelValue[1], dateMeta) || this.isDateBetween(this.modelValue[0], this.modelValue[1], dateMeta);else {
            return this.isDateEquals(this.modelValue[0], dateMeta);
          }
        }
      }

      return false;
    },

    isMonthSelected(month) {
      if (this.isComparable()) {
        let value = this.isRangeSelection() ? this.modelValue[0] : this.modelValue;
        return !this.isMultipleSelection() ? value.getMonth() === month && value.getFullYear() === this.currentYear : false;
      }

      return false;
    },

    isYearSelected(year) {
      if (this.isComparable()) {
        let value = this.isRangeSelection() ? this.modelValue[0] : this.modelValue;
        return !this.isMultipleSelection() && this.isComparable() ? value.getFullYear() === year : false;
      }

      return false;
    },

    isDateEquals(value, dateMeta) {
      if (value) return value.getDate() === dateMeta.day && value.getMonth() === dateMeta.month && value.getFullYear() === dateMeta.year;else return false;
    },

    isDateBetween(start, end, dateMeta) {
      let between = false;

      if (start && end) {
        let date = new Date(dateMeta.year, dateMeta.month, dateMeta.day);
        return start.getTime() <= date.getTime() && end.getTime() >= date.getTime();
      }

      return between;
    },

    getFirstDayOfMonthIndex(month, year) {
      let day = new Date();
      day.setDate(1);
      day.setMonth(month);
      day.setFullYear(year);
      let dayIndex = day.getDay() + this.sundayIndex;
      return dayIndex >= 7 ? dayIndex - 7 : dayIndex;
    },

    getDaysCountInMonth(month, year) {
      return 32 - this.daylightSavingAdjust(new Date(year, month, 32)).getDate();
    },

    getDaysCountInPrevMonth(month, year) {
      let prev = this.getPreviousMonthAndYear(month, year);
      return this.getDaysCountInMonth(prev.month, prev.year);
    },

    getPreviousMonthAndYear(month, year) {
      let m, y;

      if (month === 0) {
        m = 11;
        y = year - 1;
      } else {
        m = month - 1;
        y = year;
      }

      return {
        month: m,
        year: y
      };
    },

    getNextMonthAndYear(month, year) {
      let m, y;

      if (month === 11) {
        m = 0;
        y = year + 1;
      } else {
        m = month + 1;
        y = year;
      }

      return {
        month: m,
        year: y
      };
    },

    daylightSavingAdjust(date) {
      if (!date) {
        return null;
      }

      date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
      return date;
    },

    isToday(today, day, month, year) {
      return today.getDate() === day && today.getMonth() === month && today.getFullYear() === year;
    },

    isSelectable(day, month, year, otherMonth) {
      let validMin = true;
      let validMax = true;
      let validDate = true;
      let validDay = true;

      if (otherMonth && !this.selectOtherMonths) {
        return false;
      }

      if (this.minDate) {
        if (this.minDate.getFullYear() > year) {
          validMin = false;
        } else if (this.minDate.getFullYear() === year) {
          if (this.minDate.getMonth() > month) {
            validMin = false;
          } else if (this.minDate.getMonth() === month) {
            if (this.minDate.getDate() > day) {
              validMin = false;
            }
          }
        }
      }

      if (this.maxDate) {
        if (this.maxDate.getFullYear() < year) {
          validMax = false;
        } else if (this.maxDate.getFullYear() === year) {
          if (this.maxDate.getMonth() < month) {
            validMax = false;
          } else if (this.maxDate.getMonth() === month) {
            if (this.maxDate.getDate() < day) {
              validMax = false;
            }
          }
        }
      }

      if (this.disabledDates) {
        validDate = !this.isDateDisabled(day, month, year);
      }

      if (this.disabledDays) {
        validDay = !this.isDayDisabled(day, month, year);
      }

      return validMin && validMax && validDate && validDay;
    },

    onOverlayEnter(el) {
      el.setAttribute(this.attributeSelector, '');

      if (this.autoZIndex) {
        if (this.touchUI) ZIndexUtils.set('modal', el, this.baseZIndex || this.$primevue.config.zIndex.modal);else ZIndexUtils.set('overlay', el, this.baseZIndex || this.$primevue.config.zIndex.overlay);
      }

      this.alignOverlay();
      this.$emit('show');
    },

    onOverlayEnterComplete() {
      this.bindOutsideClickListener();
      this.bindScrollListener();
      this.bindResizeListener();
    },

    onOverlayAfterLeave(el) {
      if (this.autoZIndex) {
        ZIndexUtils.clear(el);
      }
    },

    onOverlayLeave() {
      this.currentView = this.view;
      this.unbindOutsideClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
      this.$emit('hide');

      if (this.mask) {
        this.disableModality();
      }

      this.overlay = null;
    },

    onPrevButtonClick(event) {
      if (this.showOtherMonths) {
        this.navigationState = {
          backward: true,
          button: true
        };
        this.navBackward(event);
      }
    },

    onNextButtonClick(event) {
      if (this.showOtherMonths) {
        this.navigationState = {
          backward: false,
          button: true
        };
        this.navForward(event);
      }
    },

    navBackward(event) {
      event.preventDefault();

      if (!this.isEnabled()) {
        return;
      }

      if (this.currentView === 'month') {
        this.decrementYear();
      } else if (this.currentView === 'year') {
        this.decrementDecade();
      } else {
        if (event.shiftKey) {
          this.decrementYear();
        } else {
          if (this.currentMonth === 0) {
            this.currentMonth = 11;
            this.decrementYear();
          } else {
            this.currentMonth--;
          }

          this.$emit('month-change', {
            month: this.currentMonth + 1,
            year: this.currentYear
          });
        }
      }
    },

    navForward(event) {
      event.preventDefault();

      if (!this.isEnabled()) {
        return;
      }

      if (this.currentView === 'month') {
        this.incrementYear();
      } else if (this.currentView === 'year') {
        this.incrementDecade();
      } else {
        if (event.shiftKey) {
          this.incrementYear();
        } else {
          if (this.currentMonth === 11) {
            this.currentMonth = 0;
            this.incrementYear();
          } else {
            this.currentMonth++;
          }

          this.$emit('month-change', {
            month: this.currentMonth + 1,
            year: this.currentYear
          });
        }
      }
    },

    decrementYear() {
      this.currentYear--;
    },

    decrementDecade() {
      this.currentYear = this.currentYear - 10;
    },

    incrementYear() {
      this.currentYear++;
    },

    incrementDecade() {
      this.currentYear = this.currentYear + 10;
    },

    switchToMonthView(event) {
      this.currentView = 'month';
      setTimeout(this.updateFocus, 0);
      event.preventDefault();
    },

    switchToYearView(event) {
      this.currentView = 'year';
      setTimeout(this.updateFocus, 0);
      event.preventDefault();
    },

    isEnabled() {
      return !this.disabled && !this.readonly;
    },

    updateCurrentTimeMeta(date) {
      let currentHour = date.getHours();

      if (this.hourFormat === '12') {
        this.pm = currentHour > 11;
        if (currentHour >= 12) currentHour = currentHour == 12 ? 12 : currentHour - 12;else currentHour = currentHour == 0 ? 12 : currentHour;
      }

      this.currentHour = Math.floor(currentHour / this.stepHour) * this.stepHour;
      this.currentMinute = Math.floor(date.getMinutes() / this.stepMinute) * this.stepMinute;
      this.currentSecond = Math.floor(date.getSeconds() / this.stepSecond) * this.stepSecond;
    },

    bindOutsideClickListener() {
      if (!this.outsideClickListener) {
        this.outsideClickListener = event => {
          if (this.overlayVisible && this.isOutsideClicked(event)) {
            this.overlayVisible = false;
          }
        };

        document.addEventListener('mousedown', this.outsideClickListener);
      }
    },

    unbindOutsideClickListener() {
      if (this.outsideClickListener) {
        document.removeEventListener('mousedown', this.outsideClickListener);
        this.outsideClickListener = null;
      }
    },

    bindScrollListener() {
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.$refs.container, () => {
          if (this.overlayVisible) {
            this.overlayVisible = false;
          }
        });
      }

      this.scrollHandler.bindScrollListener();
    },

    unbindScrollListener() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    },

    bindResizeListener() {
      if (!this.resizeListener) {
        this.resizeListener = () => {
          if (this.overlayVisible && !DomHandler.isTouchDevice()) {
            this.overlayVisible = false;
          }
        };

        window.addEventListener('resize', this.resizeListener);
      }
    },

    unbindResizeListener() {
      if (this.resizeListener) {
        window.removeEventListener('resize', this.resizeListener);
        this.resizeListener = null;
      }
    },

    isOutsideClicked(event) {
      return !(this.$el.isSameNode(event.target) || this.isNavIconClicked(event) || this.$el.contains(event.target) || this.overlay && this.overlay.contains(event.target));
    },

    isNavIconClicked(event) {
      return DomHandler.hasClass(event.target, 'p-datepicker-prev') || DomHandler.hasClass(event.target, 'p-datepicker-prev-icon') || DomHandler.hasClass(event.target, 'p-datepicker-next') || DomHandler.hasClass(event.target, 'p-datepicker-next-icon');
    },

    alignOverlay() {
      if (this.touchUI) {
        this.enableModality();
      } else if (this.overlay) {
        if (this.appendTo === 'self' || this.inline) {
          DomHandler.relativePosition(this.overlay, this.$el);
        } else {
          if (this.view === 'date') {
            this.overlay.style.width = DomHandler.getOuterWidth(this.overlay) + 'px';
            this.overlay.style.minWidth = DomHandler.getOuterWidth(this.$el) + 'px';
          } else {
            this.overlay.style.width = DomHandler.getOuterWidth(this.$el) + 'px';
          }

          DomHandler.absolutePosition(this.overlay, this.$el);
        }
      }
    },

    onButtonClick() {
      if (this.isEnabled()) {
        if (!this.overlayVisible) {
          this.input.focus();
          this.overlayVisible = true;
        } else {
          this.overlayVisible = false;
        }
      }
    },

    isDateDisabled(day, month, year) {
      if (this.disabledDates) {
        for (let disabledDate of this.disabledDates) {
          if (disabledDate.getFullYear() === year && disabledDate.getMonth() === month && disabledDate.getDate() === day) {
            return true;
          }
        }
      }

      return false;
    },

    isDayDisabled(day, month, year) {
      if (this.disabledDays) {
        let weekday = new Date(year, month, day);
        let weekdayNumber = weekday.getDay();
        return this.disabledDays.indexOf(weekdayNumber) !== -1;
      }

      return false;
    },

    onMonthDropdownChange(value) {
      this.currentMonth = parseInt(value);
      this.$emit('month-change', {
        month: this.currentMonth + 1,
        year: this.currentYear
      });
    },

    onYearDropdownChange(value) {
      this.currentYear = parseInt(value);
      this.$emit('year-change', {
        month: this.currentMonth + 1,
        year: this.currentYear
      });
    },

    onDateSelect(event, dateMeta) {
      if (this.disabled || !dateMeta.selectable) {
        return;
      }

      DomHandler.find(this.overlay, '.p-datepicker-calendar td span:not(.p-disabled)').forEach(cell => cell.tabIndex = -1);

      if (event) {
        event.currentTarget.focus();
      }

      if (this.isMultipleSelection() && this.isSelected(dateMeta)) {
        let newValue = this.modelValue.filter(date => !this.isDateEquals(date, dateMeta));
        this.updateModel(newValue);
      } else {
        if (this.shouldSelectDate(dateMeta)) {
          if (dateMeta.otherMonth) {
            this.currentMonth = dateMeta.month;
            this.currentYear = dateMeta.year;
            this.selectDate(dateMeta);
          } else {
            this.selectDate(dateMeta);
          }
        }
      }

      if (this.isSingleSelection() && (!this.showTime || this.hideOnDateTimeSelect)) {
        setTimeout(() => {
          if (this.input) {
            this.input.focus();
          }

          this.overlayVisible = false;
        }, 150);
      }
    },

    selectDate(dateMeta) {
      let date = new Date(dateMeta.year, dateMeta.month, dateMeta.day);

      if (this.showTime) {
        if (this.hourFormat === '12' && this.pm && this.currentHour != 12) date.setHours(this.currentHour + 12);else date.setHours(this.currentHour);
        date.setMinutes(this.currentMinute);
        date.setSeconds(this.currentSecond);
      }

      if (this.minDate && this.minDate > date) {
        date = this.minDate;
        this.currentHour = date.getHours();
        this.currentMinute = date.getMinutes();
        this.currentSecond = date.getSeconds();
      }

      if (this.maxDate && this.maxDate < date) {
        date = this.maxDate;
        this.currentHour = date.getHours();
        this.currentMinute = date.getMinutes();
        this.currentSecond = date.getSeconds();
      }

      let modelVal = null;

      if (this.isSingleSelection()) {
        modelVal = date;
      } else if (this.isMultipleSelection()) {
        modelVal = this.modelValue ? [...this.modelValue, date] : [date];
      } else if (this.isRangeSelection()) {
        if (this.modelValue && this.modelValue.length) {
          let startDate = this.modelValue[0];
          let endDate = this.modelValue[1];

          if (!endDate && date.getTime() >= startDate.getTime()) {
            endDate = date;
          } else {
            startDate = date;
            endDate = null;
          }

          modelVal = [startDate, endDate];
        } else {
          modelVal = [date, null];
        }
      }

      if (modelVal !== null) {
        this.updateModel(modelVal);
      }

      if (this.isRangeSelection() && this.hideOnRangeSelection && modelVal[1] !== null) {
        setTimeout(() => {
          this.overlayVisible = false;
        }, 150);
      }

      this.$emit('date-select', date);
    },

    updateModel(value) {
      this.$emit('update:modelValue', value);
    },

    shouldSelectDate() {
      if (this.isMultipleSelection()) return this.maxDateCount != null ? this.maxDateCount > (this.modelValue ? this.modelValue.length : 0) : true;else return true;
    },

    isSingleSelection() {
      return this.selectionMode === 'single';
    },

    isRangeSelection() {
      return this.selectionMode === 'range';
    },

    isMultipleSelection() {
      return this.selectionMode === 'multiple';
    },

    formatValue(value) {
      if (typeof value === 'string') {
        return value;
      }

      let formattedValue = '';

      if (value) {
        try {
          if (this.isSingleSelection()) {
            formattedValue = this.formatDateTime(value);
          } else if (this.isMultipleSelection()) {
            for (let i = 0; i < value.length; i++) {
              let dateAsString = this.formatDateTime(value[i]);
              formattedValue += dateAsString;

              if (i !== value.length - 1) {
                formattedValue += ', ';
              }
            }
          } else if (this.isRangeSelection()) {
            if (value && value.length) {
              let startDate = value[0];
              let endDate = value[1];
              formattedValue = this.formatDateTime(startDate);

              if (endDate) {
                formattedValue += ' - ' + this.formatDateTime(endDate);
              }
            }
          }
        } catch (err) {
          formattedValue = value;
        }
      }

      return formattedValue;
    },

    formatDateTime(date) {
      let formattedValue = null;

      if (date) {
        if (this.timeOnly) {
          formattedValue = this.formatTime(date);
        } else {
          formattedValue = this.formatDate(date, this.datePattern);

          if (this.showTime) {
            formattedValue += ' ' + this.formatTime(date);
          }
        }
      }

      return formattedValue;
    },

    formatDate(date, format) {
      if (!date) {
        return '';
      }

      let iFormat;

      const lookAhead = match => {
        const matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;

        if (matches) {
          iFormat++;
        }

        return matches;
      },
            formatNumber = (match, value, len) => {
        let num = '' + value;

        if (lookAhead(match)) {
          while (num.length < len) {
            num = '0' + num;
          }
        }

        return num;
      },
            formatName = (match, value, shortNames, longNames) => {
        return lookAhead(match) ? longNames[value] : shortNames[value];
      };

      let output = '';
      let literal = false;

      if (date) {
        for (iFormat = 0; iFormat < format.length; iFormat++) {
          if (literal) {
            if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
              literal = false;
            } else {
              output += format.charAt(iFormat);
            }
          } else {
            switch (format.charAt(iFormat)) {
              case 'd':
                output += formatNumber('d', date.getDate(), 2);
                break;

              case 'D':
                output += formatName('D', date.getDay(), this.$primevue.config.locale.dayNamesShort, this.$primevue.config.locale.dayNames);
                break;

              case 'o':
                output += formatNumber('o', Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
                break;

              case 'm':
                output += formatNumber('m', date.getMonth() + 1, 2);
                break;

              case 'M':
                output += formatName('M', date.getMonth(), this.$primevue.config.locale.monthNamesShort, this.$primevue.config.locale.monthNames);
                break;

              case 'y':
                output += lookAhead('y') ? date.getFullYear() : (date.getFullYear() % 100 < 10 ? '0' : '') + date.getFullYear() % 100;
                break;

              case '@':
                output += date.getTime();
                break;

              case '!':
                output += date.getTime() * 10000 + this.ticksTo1970;
                break;

              case "'":
                if (lookAhead("'")) {
                  output += "'";
                } else {
                  literal = true;
                }

                break;

              default:
                output += format.charAt(iFormat);
            }
          }
        }
      }

      return output;
    },

    formatTime(date) {
      if (!date) {
        return '';
      }

      let output = '';
      let hours = date.getHours();
      let minutes = date.getMinutes();
      let seconds = date.getSeconds();

      if (this.hourFormat === '12' && hours > 11 && hours !== 12) {
        hours -= 12;
      }

      if (this.hourFormat === '12') {
        output += hours === 0 ? 12 : hours < 10 ? '0' + hours : hours;
      } else {
        output += hours < 10 ? '0' + hours : hours;
      }

      output += ':';
      output += minutes < 10 ? '0' + minutes : minutes;

      if (this.showSeconds) {
        output += ':';
        output += seconds < 10 ? '0' + seconds : seconds;
      }

      if (this.hourFormat === '12') {
        output += date.getHours() > 11 ? ` ${this.$primevue.config.locale.pm}` : ` ${this.$primevue.config.locale.am}`;
      }

      return output;
    },

    onTodayButtonClick(event) {
      let date = new Date();
      let dateMeta = {
        day: date.getDate(),
        month: date.getMonth(),
        year: date.getFullYear(),
        otherMonth: date.getMonth() !== this.currentMonth || date.getFullYear() !== this.currentYear,
        today: true,
        selectable: true
      };
      this.onDateSelect(null, dateMeta);
      this.$emit('today-click', date);
      event.preventDefault();
    },

    onClearButtonClick(event) {
      this.updateModel(null);
      this.overlayVisible = false;
      this.$emit('clear-click', event);
      event.preventDefault();
    },

    onTimePickerElementMouseDown(event, type, direction) {
      if (this.isEnabled()) {
        this.repeat(event, null, type, direction);
        event.preventDefault();
      }
    },

    onTimePickerElementMouseUp(event) {
      if (this.isEnabled()) {
        this.clearTimePickerTimer();
        this.updateModelTime();
        event.preventDefault();
      }
    },

    onTimePickerElementMouseLeave() {
      this.clearTimePickerTimer();
    },

    repeat(event, interval, type, direction) {
      let i = interval || 500;
      this.clearTimePickerTimer();
      this.timePickerTimer = setTimeout(() => {
        this.repeat(event, 100, type, direction);
      }, i);

      switch (type) {
        case 0:
          if (direction === 1) this.incrementHour(event);else this.decrementHour(event);
          break;

        case 1:
          if (direction === 1) this.incrementMinute(event);else this.decrementMinute(event);
          break;

        case 2:
          if (direction === 1) this.incrementSecond(event);else this.decrementSecond(event);
          break;
      }
    },

    convertTo24Hour(hours, pm) {
      if (this.hourFormat == '12') {
        if (hours === 12) {
          return pm ? 12 : 0;
        } else {
          return pm ? hours + 12 : hours;
        }
      }

      return hours;
    },

    validateTime(hour, minute, second, pm) {
      let value = this.isComparable() ? this.modelValue : this.viewDate;
      const convertedHour = this.convertTo24Hour(hour, pm);

      if (this.isRangeSelection()) {
        value = this.modelValue[1] || this.modelValue[0];
      }

      if (this.isMultipleSelection()) {
        value = this.modelValue[this.modelValue.length - 1];
      }

      const valueDateString = value ? value.toDateString() : null;

      if (this.minDate && valueDateString && this.minDate.toDateString() === valueDateString) {
        if (this.minDate.getHours() > convertedHour) {
          return false;
        }

        if (this.minDate.getHours() === convertedHour) {
          if (this.minDate.getMinutes() > minute) {
            return false;
          }

          if (this.minDate.getMinutes() === minute) {
            if (this.minDate.getSeconds() > second) {
              return false;
            }
          }
        }
      }

      if (this.maxDate && valueDateString && this.maxDate.toDateString() === valueDateString) {
        if (this.maxDate.getHours() < convertedHour) {
          return false;
        }

        if (this.maxDate.getHours() === convertedHour) {
          if (this.maxDate.getMinutes() < minute) {
            return false;
          }

          if (this.maxDate.getMinutes() === minute) {
            if (this.maxDate.getSeconds() < second) {
              return false;
            }
          }
        }
      }

      return true;
    },

    incrementHour(event) {
      let prevHour = this.currentHour;
      let newHour = this.currentHour + this.stepHour;
      let newPM = this.pm;
      if (this.hourFormat == '24') newHour = newHour >= 24 ? newHour - 24 : newHour;else if (this.hourFormat == '12') {
        // Before the AM/PM break, now after
        if (prevHour < 12 && newHour > 11) {
          newPM = !this.pm;
        }

        newHour = newHour >= 13 ? newHour - 12 : newHour;
      }

      if (this.validateTime(newHour, this.currentMinute, this.currentSecond, newPM)) {
        this.currentHour = newHour;
        this.pm = newPM;
      }

      event.preventDefault();
    },

    decrementHour(event) {
      let newHour = this.currentHour - this.stepHour;
      let newPM = this.pm;
      if (this.hourFormat == '24') newHour = newHour < 0 ? 24 + newHour : newHour;else if (this.hourFormat == '12') {
        // If we were at noon/midnight, then switch
        if (this.currentHour === 12) {
          newPM = !this.pm;
        }

        newHour = newHour <= 0 ? 12 + newHour : newHour;
      }

      if (this.validateTime(newHour, this.currentMinute, this.currentSecond, newPM)) {
        this.currentHour = newHour;
        this.pm = newPM;
      }

      event.preventDefault();
    },

    incrementMinute(event) {
      let newMinute = this.currentMinute + this.stepMinute;

      if (this.validateTime(this.currentHour, newMinute, this.currentSecond, true)) {
        this.currentMinute = newMinute > 59 ? newMinute - 60 : newMinute;
      }

      event.preventDefault();
    },

    decrementMinute(event) {
      let newMinute = this.currentMinute - this.stepMinute;
      newMinute = newMinute < 0 ? 60 + newMinute : newMinute;

      if (this.validateTime(this.currentHour, newMinute, this.currentSecond, true)) {
        this.currentMinute = newMinute;
      }

      event.preventDefault();
    },

    incrementSecond(event) {
      let newSecond = this.currentSecond + this.stepSecond;

      if (this.validateTime(this.currentHour, this.currentMinute, newSecond, true)) {
        this.currentSecond = newSecond > 59 ? newSecond - 60 : newSecond;
      }

      event.preventDefault();
    },

    decrementSecond(event) {
      let newSecond = this.currentSecond - this.stepSecond;
      newSecond = newSecond < 0 ? 60 + newSecond : newSecond;

      if (this.validateTime(this.currentHour, this.currentMinute, newSecond, true)) {
        this.currentSecond = newSecond;
      }

      event.preventDefault();
    },

    updateModelTime() {
      this.timePickerChange = true;
      let value = this.isComparable() ? this.modelValue : this.viewDate;

      if (this.isRangeSelection()) {
        value = this.modelValue[1] || this.modelValue[0];
      }

      if (this.isMultipleSelection()) {
        value = this.modelValue[this.modelValue.length - 1];
      }

      value = value ? new Date(value.getTime()) : new Date();

      if (this.hourFormat == '12') {
        if (this.currentHour === 12) value.setHours(this.pm ? 12 : 0);else value.setHours(this.pm ? this.currentHour + 12 : this.currentHour);
      } else {
        value.setHours(this.currentHour);
      }

      value.setMinutes(this.currentMinute);
      value.setSeconds(this.currentSecond);

      if (this.isRangeSelection()) {
        if (this.modelValue[1]) value = [this.modelValue[0], value];else value = [value, null];
      }

      if (this.isMultipleSelection()) {
        value = [...this.modelValue.slice(0, -1), value];
      }

      this.updateModel(value);
      this.$emit('date-select', value);
      setTimeout(() => this.timePickerChange = false, 0);
    },

    toggleAMPM(event) {
      this.pm = !this.pm;
      this.updateModelTime();
      event.preventDefault();
    },

    clearTimePickerTimer() {
      if (this.timePickerTimer) {
        clearInterval(this.timePickerTimer);
      }
    },

    onMonthSelect(event, index) {
      if (this.view === 'month') {
        this.onDateSelect(event, {
          year: this.currentYear,
          month: index,
          day: 1,
          selectable: true
        });
      } else {
        this.currentMonth = index;
        this.currentView = 'date';
        this.$emit('month-change', {
          month: this.currentMonth + 1,
          year: this.currentYear
        });
      }

      setTimeout(this.updateFocus, 0);
    },

    onYearSelect(event, year) {
      if (this.view === 'year') {
        this.onDateSelect(event, {
          year: year,
          month: 0,
          day: 1,
          selectable: true
        });
      } else {
        this.currentYear = year;
        this.currentView = 'month';
        this.$emit('year-change', {
          month: this.currentMonth + 1,
          year: this.currentYear
        });
      }

      setTimeout(this.updateFocus, 0);
    },

    enableModality() {
      if (!this.mask) {
        this.mask = document.createElement('div');
        this.mask.style.zIndex = String(parseInt(this.overlay.style.zIndex, 10) - 1);
        DomHandler.addMultipleClasses(this.mask, 'p-datepicker-mask p-datepicker-mask-scrollblocker p-component-overlay p-component-overlay-enter');

        this.maskClickListener = () => {
          this.overlayVisible = false;
        };

        this.mask.addEventListener('click', this.maskClickListener);
        document.body.appendChild(this.mask);
        DomHandler.addClass(document.body, 'p-overflow-hidden');
      }
    },

    disableModality() {
      if (this.mask) {
        DomHandler.addClass(this.mask, 'p-component-overlay-leave');
        this.mask.addEventListener('animationend', () => {
          this.destroyMask();
        });
      }
    },

    destroyMask() {
      this.mask.removeEventListener('click', this.maskClickListener);
      this.maskClickListener = null;
      document.body.removeChild(this.mask);
      this.mask = null;
      let bodyChildren = document.body.children;
      let hasBlockerMasks;

      for (let i = 0; i < bodyChildren.length; i++) {
        let bodyChild = bodyChildren[i];

        if (DomHandler.hasClass(bodyChild, 'p-datepicker-mask-scrollblocker')) {
          hasBlockerMasks = true;
          break;
        }
      }

      if (!hasBlockerMasks) {
        DomHandler.removeClass(document.body, 'p-overflow-hidden');
      }
    },

    updateCurrentMetaData() {
      const viewDate = this.viewDate;
      this.currentMonth = viewDate.getMonth();
      this.currentYear = viewDate.getFullYear();

      if (this.showTime || this.timeOnly) {
        this.updateCurrentTimeMeta(viewDate);
      }
    },

    isValidSelection(value) {
      if (value == null) {
        return true;
      }

      let isValid = true;

      if (this.isSingleSelection()) {
        if (!this.isSelectable(value.getDate(), value.getMonth(), value.getFullYear(), false)) {
          isValid = false;
        }
      } else if (value.every(v => this.isSelectable(v.getDate(), v.getMonth(), v.getFullYear(), false))) {
        if (this.isRangeSelection()) {
          isValid = value.length > 1 && value[1] > value[0] ? true : false;
        }
      }

      return isValid;
    },

    parseValue(text) {
      if (!text || text.trim().length === 0) {
        return null;
      }

      let value;

      if (this.isSingleSelection()) {
        value = this.parseDateTime(text);
      } else if (this.isMultipleSelection()) {
        let tokens = text.split(',');
        value = [];

        for (let token of tokens) {
          value.push(this.parseDateTime(token.trim()));
        }
      } else if (this.isRangeSelection()) {
        let tokens = text.split(' - ');
        value = [];

        for (let i = 0; i < tokens.length; i++) {
          value[i] = this.parseDateTime(tokens[i].trim());
        }
      }

      return value;
    },

    parseDateTime(text) {
      let date;
      let parts = text.split(' ');

      if (this.timeOnly) {
        date = new Date();
        this.populateTime(date, parts[0], parts[1]);
      } else {
        const dateFormat = this.datePattern;

        if (this.showTime) {
          date = this.parseDate(parts[0], dateFormat);
          this.populateTime(date, parts[1], parts[2]);
        } else {
          date = this.parseDate(text, dateFormat);
        }
      }

      return date;
    },

    populateTime(value, timeString, ampm) {
      if (this.hourFormat == '12' && !ampm) {
        throw 'Invalid Time';
      }

      this.pm = ampm === this.$primevue.config.locale.am || ampm === this.$primevue.config.locale.am.toLowerCase();
      let time = this.parseTime(timeString);
      value.setHours(time.hour);
      value.setMinutes(time.minute);
      value.setSeconds(time.second);
    },

    parseTime(value) {
      let tokens = value.split(':');
      let validTokenLength = this.showSeconds ? 3 : 2;
      let regex = /^[0-9][0-9]$/;

      if (tokens.length !== validTokenLength || !tokens[0].match(regex) || !tokens[1].match(regex) || this.showSeconds && !tokens[2].match(regex)) {
        throw 'Invalid time';
      }

      let h = parseInt(tokens[0]);
      let m = parseInt(tokens[1]);
      let s = this.showSeconds ? parseInt(tokens[2]) : null;

      if (isNaN(h) || isNaN(m) || h > 23 || m > 59 || this.hourFormat == '12' && h > 12 || this.showSeconds && (isNaN(s) || s > 59)) {
        throw 'Invalid time';
      } else {
        if (this.hourFormat == '12' && h !== 12 && this.pm) {
          h += 12;
        }

        return {
          hour: h,
          minute: m,
          second: s
        };
      }
    },

    parseDate(value, format) {
      if (format == null || value == null) {
        throw 'Invalid arguments';
      }

      value = typeof value === 'object' ? value.toString() : value + '';

      if (value === '') {
        return null;
      }

      let iFormat,
          dim,
          extra,
          iValue = 0,
          shortYearCutoff = typeof this.shortYearCutoff !== 'string' ? this.shortYearCutoff : new Date().getFullYear() % 100 + parseInt(this.shortYearCutoff, 10),
          year = -1,
          month = -1,
          day = -1,
          doy = -1,
          literal = false,
          date,
          lookAhead = match => {
        let matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;

        if (matches) {
          iFormat++;
        }

        return matches;
      },
          getNumber = match => {
        let isDoubled = lookAhead(match),
            size = match === '@' ? 14 : match === '!' ? 20 : match === 'y' && isDoubled ? 4 : match === 'o' ? 3 : 2,
            minSize = match === 'y' ? size : 1,
            digits = new RegExp('^\\d{' + minSize + ',' + size + '}'),
            num = value.substring(iValue).match(digits);

        if (!num) {
          throw 'Missing number at position ' + iValue;
        }

        iValue += num[0].length;
        return parseInt(num[0], 10);
      },
          getName = (match, shortNames, longNames) => {
        let index = -1;
        let arr = lookAhead(match) ? longNames : shortNames;
        let names = [];

        for (let i = 0; i < arr.length; i++) {
          names.push([i, arr[i]]);
        }

        names.sort((a, b) => {
          return -(a[1].length - b[1].length);
        });

        for (let i = 0; i < names.length; i++) {
          let name = names[i][1];

          if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
            index = names[i][0];
            iValue += name.length;
            break;
          }
        }

        if (index !== -1) {
          return index + 1;
        } else {
          throw 'Unknown name at position ' + iValue;
        }
      },
          checkLiteral = () => {
        if (value.charAt(iValue) !== format.charAt(iFormat)) {
          throw 'Unexpected literal at position ' + iValue;
        }

        iValue++;
      };

      if (this.currentView === 'month') {
        day = 1;
      }

      for (iFormat = 0; iFormat < format.length; iFormat++) {
        if (literal) {
          if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
            literal = false;
          } else {
            checkLiteral();
          }
        } else {
          switch (format.charAt(iFormat)) {
            case 'd':
              day = getNumber('d');
              break;

            case 'D':
              getName('D', this.$primevue.config.locale.dayNamesShort, this.$primevue.config.locale.dayNames);
              break;

            case 'o':
              doy = getNumber('o');
              break;

            case 'm':
              month = getNumber('m');
              break;

            case 'M':
              month = getName('M', this.$primevue.config.locale.monthNamesShort, this.$primevue.config.locale.monthNames);
              break;

            case 'y':
              year = getNumber('y');
              break;

            case '@':
              date = new Date(getNumber('@'));
              year = date.getFullYear();
              month = date.getMonth() + 1;
              day = date.getDate();
              break;

            case '!':
              date = new Date((getNumber('!') - this.ticksTo1970) / 10000);
              year = date.getFullYear();
              month = date.getMonth() + 1;
              day = date.getDate();
              break;

            case "'":
              if (lookAhead("'")) {
                checkLiteral();
              } else {
                literal = true;
              }

              break;

            default:
              checkLiteral();
          }
        }
      }

      if (iValue < value.length) {
        extra = value.substr(iValue);

        if (!/^\s+/.test(extra)) {
          throw 'Extra/unparsed characters found in date: ' + extra;
        }
      }

      if (year === -1) {
        year = new Date().getFullYear();
      } else if (year < 100) {
        year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100);
      }

      if (doy > -1) {
        month = 1;
        day = doy;

        do {
          dim = this.getDaysCountInMonth(year, month - 1);

          if (day <= dim) {
            break;
          }

          month++;
          day -= dim; // eslint-disable-next-line
        } while (true);
      }

      date = this.daylightSavingAdjust(new Date(year, month - 1, day));

      if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
        throw 'Invalid date'; // E.g. 31/02/00
      }

      return date;
    },

    getWeekNumber(date) {
      let checkDate = new Date(date.getTime());
      checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
      let time = checkDate.getTime();
      checkDate.setMonth(0);
      checkDate.setDate(1);
      return Math.floor(Math.round((time - checkDate.getTime()) / 86400000) / 7) + 1;
    },

    onDateCellKeydown(event, date, groupIndex) {
      const cellContent = event.currentTarget;
      const cell = cellContent.parentElement;
      const cellIndex = DomHandler.index(cell);

      switch (event.code) {
        case 'ArrowDown':
          {
            cellContent.tabIndex = '-1';
            let nextRow = cell.parentElement.nextElementSibling;

            if (nextRow) {
              let tableRowIndex = DomHandler.index(cell.parentElement);
              const tableRows = Array.from(cell.parentElement.parentElement.children);
              const nextTableRows = tableRows.slice(tableRowIndex + 1);
              let hasNextFocusableDate = nextTableRows.find(el => {
                let focusCell = el.children[cellIndex].children[0];
                return !DomHandler.hasClass(focusCell, 'p-disabled');
              });

              if (hasNextFocusableDate) {
                let focusCell = hasNextFocusableDate.children[cellIndex].children[0];
                focusCell.tabIndex = '0';
                focusCell.focus();
              } else {
                this.navigationState = {
                  backward: false
                };
                this.navForward(event);
              }
            } else {
              this.navigationState = {
                backward: false
              };
              this.navForward(event);
            }

            event.preventDefault();
            break;
          }

        case 'ArrowUp':
          {
            cellContent.tabIndex = '-1';
            let prevRow = cell.parentElement.previousElementSibling;

            if (prevRow) {
              let tableRowIndex = DomHandler.index(cell.parentElement);
              const tableRows = Array.from(cell.parentElement.parentElement.children);
              const prevTableRows = tableRows.slice(0, tableRowIndex).reverse();
              let hasNextFocusableDate = prevTableRows.find(el => {
                let focusCell = el.children[cellIndex].children[0];
                return !DomHandler.hasClass(focusCell, 'p-disabled');
              });

              if (hasNextFocusableDate) {
                let focusCell = hasNextFocusableDate.children[cellIndex].children[0];
                focusCell.tabIndex = '0';
                focusCell.focus();
              } else {
                this.navigationState = {
                  backward: true
                };
                this.navBackward(event);
              }
            } else {
              this.navigationState = {
                backward: true
              };
              this.navBackward(event);
            }

            event.preventDefault();
            break;
          }

        case 'ArrowLeft':
          {
            cellContent.tabIndex = '-1';
            let prevCell = cell.previousElementSibling;

            if (prevCell) {
              const cells = Array.from(cell.parentElement.children);
              const prevCells = cells.slice(0, cellIndex).reverse();
              let hasNextFocusableDate = prevCells.find(el => {
                let focusCell = el.children[0];
                return !DomHandler.hasClass(focusCell, 'p-disabled');
              });

              if (hasNextFocusableDate) {
                let focusCell = hasNextFocusableDate.children[0];
                focusCell.tabIndex = '0';
                focusCell.focus();
              } else {
                this.navigateToMonth(event, true, groupIndex);
              }
            } else {
              this.navigateToMonth(event, true, groupIndex);
            }

            event.preventDefault();
            break;
          }

        case 'ArrowRight':
          {
            cellContent.tabIndex = '-1';
            let nextCell = cell.nextElementSibling;

            if (nextCell) {
              const cells = Array.from(cell.parentElement.children);
              const nextCells = cells.slice(cellIndex + 1);
              let hasNextFocusableDate = nextCells.find(el => {
                let focusCell = el.children[0];
                return !DomHandler.hasClass(focusCell, 'p-disabled');
              });

              if (hasNextFocusableDate) {
                let focusCell = hasNextFocusableDate.children[0];
                focusCell.tabIndex = '0';
                focusCell.focus();
              } else {
                this.navigateToMonth(event, false, groupIndex);
              }
            } else {
              this.navigateToMonth(event, false, groupIndex);
            }

            event.preventDefault();
            break;
          }

        case 'Enter':
        case 'Space':
          {
            this.onDateSelect(event, date);
            event.preventDefault();
            break;
          }

        case 'Escape':
          {
            this.overlayVisible = false;
            event.preventDefault();
            break;
          }

        case 'Tab':
          {
            if (!this.inline) {
              this.trapFocus(event);
            }

            break;
          }

        case 'Home':
          {
            cellContent.tabIndex = '-1';
            let currentRow = cell.parentElement;
            let focusCell = currentRow.children[0].children[0];

            if (DomHandler.hasClass(focusCell, 'p-disabled')) {
              this.navigateToMonth(event, true, groupIndex);
            } else {
              focusCell.tabIndex = '0';
              focusCell.focus();
            }

            event.preventDefault();
            break;
          }

        case 'End':
          {
            cellContent.tabIndex = '-1';
            let currentRow = cell.parentElement;
            let focusCell = currentRow.children[currentRow.children.length - 1].children[0];

            if (DomHandler.hasClass(focusCell, 'p-disabled')) {
              this.navigateToMonth(event, false, groupIndex);
            } else {
              focusCell.tabIndex = '0';
              focusCell.focus();
            }

            event.preventDefault();
            break;
          }

        case 'PageUp':
          {
            cellContent.tabIndex = '-1';

            if (event.shiftKey) {
              this.navigationState = {
                backward: true
              };
              this.navBackward(event);
            } else this.navigateToMonth(event, true, groupIndex);

            event.preventDefault();
            break;
          }

        case 'PageDown':
          {
            cellContent.tabIndex = '-1';

            if (event.shiftKey) {
              this.navigationState = {
                backward: false
              };
              this.navForward(event);
            } else this.navigateToMonth(event, false, groupIndex);

            event.preventDefault();
            break;
          }
      }
    },

    navigateToMonth(event, prev, groupIndex) {
      if (prev) {
        if (this.numberOfMonths === 1 || groupIndex === 0) {
          this.navigationState = {
            backward: true
          };
          this.navBackward(event);
        } else {
          let prevMonthContainer = this.overlay.children[groupIndex - 1];
          let cells = DomHandler.find(prevMonthContainer, '.p-datepicker-calendar td span:not(.p-disabled):not(.p-ink)');
          let focusCell = cells[cells.length - 1];
          focusCell.tabIndex = '0';
          focusCell.focus();
        }
      } else {
        if (this.numberOfMonths === 1 || groupIndex === this.numberOfMonths - 1) {
          this.navigationState = {
            backward: false
          };
          this.navForward(event);
        } else {
          let nextMonthContainer = this.overlay.children[groupIndex + 1];
          let focusCell = DomHandler.findSingle(nextMonthContainer, '.p-datepicker-calendar td span:not(.p-disabled):not(.p-ink)');
          focusCell.tabIndex = '0';
          focusCell.focus();
        }
      }
    },

    onMonthCellKeydown(event, index) {
      const cell = event.currentTarget;

      switch (event.code) {
        case 'ArrowUp':
        case 'ArrowDown':
          {
            cell.tabIndex = '-1';
            var cells = cell.parentElement.children;
            var cellIndex = DomHandler.index(cell);
            let nextCell = cells[event.code === 'ArrowDown' ? cellIndex + 3 : cellIndex - 3];

            if (nextCell) {
              nextCell.tabIndex = '0';
              nextCell.focus();
            }

            event.preventDefault();
            break;
          }

        case 'ArrowLeft':
          {
            cell.tabIndex = '-1';
            let prevCell = cell.previousElementSibling;

            if (prevCell) {
              prevCell.tabIndex = '0';
              prevCell.focus();
            } else {
              this.navigationState = {
                backward: true
              };
              this.navBackward(event);
            }

            event.preventDefault();
            break;
          }

        case 'ArrowRight':
          {
            cell.tabIndex = '-1';
            let nextCell = cell.nextElementSibling;

            if (nextCell) {
              nextCell.tabIndex = '0';
              nextCell.focus();
            } else {
              this.navigationState = {
                backward: false
              };
              this.navForward(event);
            }

            event.preventDefault();
            break;
          }

        case 'PageUp':
          {
            if (event.shiftKey) return;
            this.navigationState = {
              backward: true
            };
            this.navBackward(event);
            break;
          }

        case 'PageDown':
          {
            if (event.shiftKey) return;
            this.navigationState = {
              backward: false
            };
            this.navForward(event);
            break;
          }

        case 'Enter':
        case 'Space':
          {
            this.onMonthSelect(event, index);
            event.preventDefault();
            break;
          }

        case 'Escape':
          {
            this.overlayVisible = false;
            event.preventDefault();
            break;
          }

        case 'Tab':
          {
            this.trapFocus(event);
            break;
          }
      }
    },

    onYearCellKeydown(event, index) {
      const cell = event.currentTarget;

      switch (event.code) {
        case 'ArrowUp':
        case 'ArrowDown':
          {
            cell.tabIndex = '-1';
            var cells = cell.parentElement.children;
            var cellIndex = DomHandler.index(cell);
            let nextCell = cells[event.code === 'ArrowDown' ? cellIndex + 2 : cellIndex - 2];

            if (nextCell) {
              nextCell.tabIndex = '0';
              nextCell.focus();
            }

            event.preventDefault();
            break;
          }

        case 'ArrowLeft':
          {
            cell.tabIndex = '-1';
            let prevCell = cell.previousElementSibling;

            if (prevCell) {
              prevCell.tabIndex = '0';
              prevCell.focus();
            } else {
              this.navigationState = {
                backward: true
              };
              this.navBackward(event);
            }

            event.preventDefault();
            break;
          }

        case 'ArrowRight':
          {
            cell.tabIndex = '-1';
            let nextCell = cell.nextElementSibling;

            if (nextCell) {
              nextCell.tabIndex = '0';
              nextCell.focus();
            } else {
              this.navigationState = {
                backward: false
              };
              this.navForward(event);
            }

            event.preventDefault();
            break;
          }

        case 'PageUp':
          {
            if (event.shiftKey) return;
            this.navigationState = {
              backward: true
            };
            this.navBackward(event);
            break;
          }

        case 'PageDown':
          {
            if (event.shiftKey) return;
            this.navigationState = {
              backward: false
            };
            this.navForward(event);
            break;
          }

        case 'Enter':
        case 'Space':
          {
            this.onYearSelect(event, index);
            event.preventDefault();
            break;
          }

        case 'Escape':
          {
            this.overlayVisible = false;
            event.preventDefault();
            break;
          }

        case 'Tab':
          {
            this.trapFocus(event);
            break;
          }
      }
    },

    updateFocus() {
      let cell;

      if (this.navigationState) {
        if (this.navigationState.button) {
          this.initFocusableCell();
          if (this.navigationState.backward) DomHandler.findSingle(this.overlay, '.p-datepicker-prev').focus();else DomHandler.findSingle(this.overlay, '.p-datepicker-next').focus();
        } else {
          if (this.navigationState.backward) {
            let cells;

            if (this.currentView === 'month') {
              cells = DomHandler.find(this.overlay, '.p-monthpicker .p-monthpicker-month:not(.p-disabled)');
            } else if (this.currentView === 'year') {
              cells = DomHandler.find(this.overlay, '.p-yearpicker .p-yearpicker-year:not(.p-disabled)');
            } else {
              cells = DomHandler.find(this.overlay, '.p-datepicker-calendar td span:not(.p-disabled):not(.p-ink)');
            }

            if (cells && cells.length > 0) {
              cell = cells[cells.length - 1];
            }
          } else {
            if (this.currentView === 'month') {
              cell = DomHandler.findSingle(this.overlay, '.p-monthpicker .p-monthpicker-month:not(.p-disabled)');
            } else if (this.currentView === 'year') {
              cell = DomHandler.findSingle(this.overlay, '.p-yearpicker .p-yearpicker-year:not(.p-disabled)');
            } else {
              cell = DomHandler.findSingle(this.overlay, '.p-datepicker-calendar td span:not(.p-disabled):not(.p-ink)');
            }
          }

          if (cell) {
            cell.tabIndex = '0';
            cell.focus();
          }
        }

        this.navigationState = null;
      } else {
        this.initFocusableCell();
      }
    },

    initFocusableCell() {
      let cell;

      if (this.currentView === 'month') {
        let cells = DomHandler.find(this.overlay, '.p-monthpicker .p-monthpicker-month');
        let selectedCell = DomHandler.findSingle(this.overlay, '.p-monthpicker .p-monthpicker-month.p-highlight');
        cells.forEach(cell => cell.tabIndex = -1);
        cell = selectedCell || cells[0];
      } else if (this.currentView === 'year') {
        let cells = DomHandler.find(this.overlay, '.p-yearpicker .p-yearpicker-year');
        let selectedCell = DomHandler.findSingle(this.overlay, '.p-yearpicker .p-yearpicker-year.p-highlight');
        cells.forEach(cell => cell.tabIndex = -1);
        cell = selectedCell || cells[0];
      } else {
        cell = DomHandler.findSingle(this.overlay, 'span.p-highlight');

        if (!cell) {
          let todayCell = DomHandler.findSingle(this.overlay, 'td.p-datepicker-today span:not(.p-disabled):not(.p-ink');
          if (todayCell) cell = todayCell;else cell = DomHandler.findSingle(this.overlay, '.p-datepicker-calendar td span:not(.p-disabled):not(.p-ink');
        }
      }

      if (cell) {
        cell.tabIndex = '0';

        if (!this.preventFocus && (!this.navigationState || !this.navigationState.button) && !this.timePickerChange) {
          cell.focus();
        }

        this.preventFocus = false;
      }
    },

    trapFocus(event) {
      event.preventDefault();
      let focusableElements = DomHandler.getFocusableElements(this.overlay);

      if (focusableElements && focusableElements.length > 0) {
        if (!document.activeElement) {
          focusableElements[0].focus();
        } else {
          let focusedIndex = focusableElements.indexOf(document.activeElement);

          if (event.shiftKey) {
            if (focusedIndex === -1 || focusedIndex === 0) focusableElements[focusableElements.length - 1].focus();else focusableElements[focusedIndex - 1].focus();
          } else {
            if (focusedIndex === -1) {
              if (this.timeOnly) {
                focusableElements[0].focus();
              } else {
                let spanIndex = null;

                for (let i = 0; i < focusableElements.length; i++) {
                  if (focusableElements[i].tagName === 'SPAN') spanIndex = i;
                }

                focusableElements[spanIndex].focus();
              }
            } else if (focusedIndex === focusableElements.length - 1) focusableElements[0].focus();else focusableElements[focusedIndex + 1].focus();
          }
        }
      }
    },

    onContainerButtonKeydown(event) {
      switch (event.code) {
        case 'Tab':
          this.trapFocus(event);
          break;

        case 'Escape':
          this.overlayVisible = false;
          event.preventDefault();
          break;
      }

      this.$emit('keydown', event);
    },

    onInput(event) {
      try {
        this.selectionStart = this.input.selectionStart;
        this.selectionEnd = this.input.selectionEnd;
        let value = this.parseValue(event.target.value);

        if (this.isValidSelection(value)) {
          this.typeUpdate = true;
          this.updateModel(value);
        }
      } catch (err) {
        /* NoOp */
      }

      this.$emit('input', event);
    },

    onInputClick() {
      if (this.showOnFocus && this.isEnabled() && !this.overlayVisible) {
        this.overlayVisible = true;
      }
    },

    onFocus(event) {
      if (this.showOnFocus && this.isEnabled()) {
        this.overlayVisible = true;
      }

      this.focused = true;
      this.$emit('focus', event);
    },

    onBlur(event) {
      this.$emit('blur', {
        originalEvent: event,
        value: event.target.value
      });
      this.focused = false;
      event.target.value = this.formatValue(this.modelValue);
    },

    onKeyDown(event) {
      if (event.code === 'ArrowDown' && this.overlay) {
        this.trapFocus(event);
      } else if (event.code === 'ArrowDown' && !this.overlay) {
        this.overlayVisible = true;
      } else if (event.code === 'Escape') {
        if (this.overlayVisible) {
          this.overlayVisible = false;
          event.preventDefault();
        }
      } else if (event.code === 'Tab') {
        if (this.overlay) {
          DomHandler.getFocusableElements(this.overlay).forEach(el => el.tabIndex = '-1');
        }

        if (this.overlayVisible) {
          this.overlayVisible = false;
        }
      }
    },

    overlayRef(el) {
      this.overlay = el;
    },

    inputRef(el) {
      this.input = el;
    },

    getMonthName(index) {
      return this.$primevue.config.locale.monthNames[index];
    },

    getYear(month) {
      return this.currentView === 'month' ? this.currentYear : month.year;
    },

    onOverlayClick(event) {
      if (!this.inline) {
        OverlayEventBus.emit('overlay-click', {
          originalEvent: event,
          target: this.$el
        });
      }
    },

    onOverlayKeyDown(event) {
      switch (event.code) {
        case 'Escape':
          this.input.focus();
          this.overlayVisible = false;
          break;
      }
    },

    onOverlayMouseUp(event) {
      this.onOverlayClick(event);
    },

    createResponsiveStyle() {
      if (this.numberOfMonths > 1 && this.responsiveOptions) {
        if (!this.responsiveStyleElement) {
          this.responsiveStyleElement = document.createElement('style');
          this.responsiveStyleElement.type = 'text/css';
          document.body.appendChild(this.responsiveStyleElement);
        }

        let innerHTML = '';

        if (this.responsiveOptions) {
          let responsiveOptions = [...this.responsiveOptions].filter(o => !!(o.breakpoint && o.numMonths)).sort((o1, o2) => -1 * o1.breakpoint.localeCompare(o2.breakpoint, undefined, {
            numeric: true
          }));

          for (let i = 0; i < responsiveOptions.length; i++) {
            let {
              breakpoint,
              numMonths
            } = responsiveOptions[i];
            let styles = `
                            .p-datepicker[${this.attributeSelector}] .p-datepicker-group:nth-child(${numMonths}) .p-datepicker-next {
                                display: inline-flex !important;
                            }
                        `;

            for (let j = numMonths; j < this.numberOfMonths; j++) {
              styles += `
                                .p-datepicker[${this.attributeSelector}] .p-datepicker-group:nth-child(${j + 1}) {
                                    display: none !important;
                                }
                            `;
            }

            innerHTML += `
                            @media screen and (max-width: ${breakpoint}) {
                                ${styles}
                            }
                        `;
          }
        }

        this.responsiveStyleElement.innerHTML = innerHTML;
      }
    },

    destroyResponsiveStyleElement() {
      if (this.responsiveStyleElement) {
        this.responsiveStyleElement.remove();
        this.responsiveStyleElement = null;
      }
    }

  },
  computed: {
    viewDate() {
      let propValue = this.modelValue;

      if (propValue && Array.isArray(propValue)) {
        if (this.isRangeSelection()) {
          propValue = this.inline ? propValue[0] : propValue[1] || propValue[0];
        } else if (this.isMultipleSelection()) {
          propValue = propValue[propValue.length - 1];
        }
      }

      if (propValue && typeof propValue !== 'string') {
        return propValue;
      } else {
        let today = new Date();

        if (this.maxDate && this.maxDate < today) {
          return this.maxDate;
        }

        if (this.minDate && this.minDate > today) {
          return this.minDate;
        }

        return today;
      }
    },

    inputFieldValue() {
      return this.formatValue(this.modelValue);
    },

    containerClass() {
      return ['p-calendar p-component p-inputwrapper', {
        'p-calendar-w-btn': this.showIcon,
        'p-calendar-timeonly': this.timeOnly,
        'p-calendar-disabled': this.disabled,
        'p-inputwrapper-filled': this.modelValue,
        'p-inputwrapper-focus': this.focused
      }];
    },

    panelStyleClass() {
      return ['p-datepicker p-component', this.panelClass, {
        'p-datepicker-inline': this.inline,
        'p-disabled': this.disabled,
        'p-datepicker-timeonly': this.timeOnly,
        'p-datepicker-multiple-month': this.numberOfMonths > 1,
        'p-datepicker-monthpicker': this.currentView === 'month',
        'p-datepicker-yearpicker': this.currentView === 'year',
        'p-datepicker-touch-ui': this.touchUI,
        'p-input-filled': this.$primevue.config.inputStyle === 'filled',
        'p-ripple-disabled': this.$primevue.config.ripple === false
      }];
    },

    months() {
      let months = [];

      for (let i = 0; i < this.numberOfMonths; i++) {
        let month = this.currentMonth + i;
        let year = this.currentYear;

        if (month > 11) {
          month = month % 11 - 1;
          year = year + 1;
        }

        let dates = [];
        let firstDay = this.getFirstDayOfMonthIndex(month, year);
        let daysLength = this.getDaysCountInMonth(month, year);
        let prevMonthDaysLength = this.getDaysCountInPrevMonth(month, year);
        let dayNo = 1;
        let today = new Date();
        let weekNumbers = [];
        let monthRows = Math.ceil((daysLength + firstDay) / 7);

        for (let i = 0; i < monthRows; i++) {
          let week = [];

          if (i == 0) {
            for (let j = prevMonthDaysLength - firstDay + 1; j <= prevMonthDaysLength; j++) {
              let prev = this.getPreviousMonthAndYear(month, year);
              week.push({
                day: j,
                month: prev.month,
                year: prev.year,
                otherMonth: true,
                today: this.isToday(today, j, prev.month, prev.year),
                selectable: this.isSelectable(j, prev.month, prev.year, true)
              });
            }

            let remainingDaysLength = 7 - week.length;

            for (let j = 0; j < remainingDaysLength; j++) {
              week.push({
                day: dayNo,
                month: month,
                year: year,
                today: this.isToday(today, dayNo, month, year),
                selectable: this.isSelectable(dayNo, month, year, false)
              });
              dayNo++;
            }
          } else {
            for (let j = 0; j < 7; j++) {
              if (dayNo > daysLength) {
                let next = this.getNextMonthAndYear(month, year);
                week.push({
                  day: dayNo - daysLength,
                  month: next.month,
                  year: next.year,
                  otherMonth: true,
                  today: this.isToday(today, dayNo - daysLength, next.month, next.year),
                  selectable: this.isSelectable(dayNo - daysLength, next.month, next.year, true)
                });
              } else {
                week.push({
                  day: dayNo,
                  month: month,
                  year: year,
                  today: this.isToday(today, dayNo, month, year),
                  selectable: this.isSelectable(dayNo, month, year, false)
                });
              }

              dayNo++;
            }
          }

          if (this.showWeek) {
            weekNumbers.push(this.getWeekNumber(new Date(week[0].year, week[0].month, week[0].day)));
          }

          dates.push(week);
        }

        months.push({
          month: month,
          year: year,
          dates: dates,
          weekNumbers: weekNumbers
        });
      }

      return months;
    },

    weekDays() {
      let weekDays = [];
      let dayIndex = this.$primevue.config.locale.firstDayOfWeek;

      for (let i = 0; i < 7; i++) {
        weekDays.push(this.$primevue.config.locale.dayNamesMin[dayIndex]);
        dayIndex = dayIndex == 6 ? 0 : ++dayIndex;
      }

      return weekDays;
    },

    ticksTo1970() {
      return ((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000;
    },

    sundayIndex() {
      return this.$primevue.config.locale.firstDayOfWeek > 0 ? 7 - this.$primevue.config.locale.firstDayOfWeek : 0;
    },

    datePattern() {
      return this.dateFormat || this.$primevue.config.locale.dateFormat;
    },

    yearOptions() {
      if (this.yearRange) {
        let $vm = this;
        const years = this.yearRange.split(':');
        let yearStart = parseInt(years[0]);
        let yearEnd = parseInt(years[1]);
        let yearOptions = [];

        if (this.currentYear < yearStart) {
          $vm.currentYear = yearEnd;
        } else if (this.currentYear > yearEnd) {
          $vm.currentYear = yearStart;
        }

        for (let i = yearStart; i <= yearEnd; i++) {
          yearOptions.push(i);
        }

        return yearOptions;
      } else {
        return null;
      }
    },

    monthPickerValues() {
      let monthPickerValues = [];

      for (let i = 0; i <= 11; i++) {
        monthPickerValues.push(this.$primevue.config.locale.monthNamesShort[i]);
      }

      return monthPickerValues;
    },

    yearPickerValues() {
      let yearPickerValues = [];
      let base = this.currentYear - this.currentYear % 10;

      for (let i = 0; i < 10; i++) {
        yearPickerValues.push(base + i);
      }

      return yearPickerValues;
    },

    formattedCurrentHour() {
      return this.currentHour < 10 ? '0' + this.currentHour : this.currentHour;
    },

    formattedCurrentMinute() {
      return this.currentMinute < 10 ? '0' + this.currentMinute : this.currentMinute;
    },

    formattedCurrentSecond() {
      return this.currentSecond < 10 ? '0' + this.currentSecond : this.currentSecond;
    },

    todayLabel() {
      return this.$primevue.config.locale.today;
    },

    clearLabel() {
      return this.$primevue.config.locale.clear;
    },

    weekHeaderLabel() {
      return this.$primevue.config.locale.weekHeader;
    },

    monthNames() {
      return this.$primevue.config.locale.monthNames;
    },

    attributeSelector() {
      return UniqueComponentId();
    },

    switchViewButtonDisabled() {
      return this.numberOfMonths > 1 || this.disabled;
    },

    panelId() {
      return UniqueComponentId() + '_panel';
    }

  },
  components: {
    CalendarButton: script$1L,
    Portal: script$1C
  },
  directives: {
    ripple: Ripple
  }
};
const _hoisted_1$C = ["id"];
const _hoisted_2$v = ["id", "placeholder", "aria-expanded", "aria-controls", "aria-labelledby", "aria-label", "disabled", "readonly"];
const _hoisted_3$r = ["id", "role", "aria-modal", "aria-label"];
const _hoisted_4$m = {
  class: "p-datepicker-group-container"
};
const _hoisted_5$h = {
  class: "p-datepicker-header"
};
const _hoisted_6$f = ["disabled", "aria-label"];
const _hoisted_7$a = {
  class: "p-datepicker-title"
};
const _hoisted_8$9 = ["disabled", "aria-label"];
const _hoisted_9$4 = ["disabled", "aria-label"];
const _hoisted_10$4 = {
  key: 2,
  class: "p-datepicker-decade"
};
const _hoisted_11$4 = ["disabled", "aria-label"];
const _hoisted_12$4 = {
  key: 0,
  class: "p-datepicker-calendar-container"
};
const _hoisted_13$4 = {
  class: "p-datepicker-calendar",
  role: "grid"
};
const _hoisted_14$3 = {
  key: 0,
  scope: "col",
  class: "p-datepicker-weekheader p-disabled"
};
const _hoisted_15$2 = ["abbr"];
const _hoisted_16$1 = {
  key: 0,
  class: "p-datepicker-weeknumber"
};
const _hoisted_17$1 = {
  class: "p-disabled"
};
const _hoisted_18$1 = {
  key: 0,
  style: {
    "visibility": "hidden"
  }
};
const _hoisted_19$1 = ["aria-label"];
const _hoisted_20$1 = ["onClick", "onKeydown", "aria-selected"];
const _hoisted_21$1 = {
  key: 0,
  class: "p-hidden-accessible",
  "aria-live": "polite"
};
const _hoisted_22 = {
  key: 0,
  class: "p-monthpicker"
};
const _hoisted_23 = ["onClick", "onKeydown"];
const _hoisted_24 = {
  key: 0,
  class: "p-hidden-accessible",
  "aria-live": "polite"
};
const _hoisted_25 = {
  key: 1,
  class: "p-yearpicker"
};
const _hoisted_26 = ["onClick", "onKeydown"];
const _hoisted_27 = {
  key: 0,
  class: "p-hidden-accessible",
  "aria-live": "polite"
};
const _hoisted_28 = {
  key: 1,
  class: "p-timepicker"
};
const _hoisted_29 = {
  class: "p-hour-picker"
};
const _hoisted_30 = ["aria-label"];
const _hoisted_31 = ["aria-label"];
const _hoisted_32 = {
  class: "p-separator"
};
const _hoisted_33 = {
  class: "p-minute-picker"
};
const _hoisted_34 = ["aria-label", "disabled"];
const _hoisted_35 = ["aria-label", "disabled"];
const _hoisted_36 = {
  key: 0,
  class: "p-separator"
};
const _hoisted_37 = {
  key: 1,
  class: "p-second-picker"
};
const _hoisted_38 = ["aria-label", "disabled"];
const _hoisted_39 = ["aria-label", "disabled"];
const _hoisted_40 = {
  key: 2,
  class: "p-separator"
};
const _hoisted_41 = {
  key: 3,
  class: "p-ampm-picker"
};
const _hoisted_42 = ["aria-label", "disabled"];
const _hoisted_43 = ["aria-label", "disabled"];
const _hoisted_44 = {
  key: 2,
  class: "p-datepicker-buttonbar"
};

function render$p(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CalendarButton = resolveComponent("CalendarButton");

  const _component_Portal = resolveComponent("Portal");

  const _directive_ripple = resolveDirective("ripple");

  return openBlock(), createElementBlock("span", {
    ref: "container",
    id: $props.id,
    class: normalizeClass($options.containerClass)
  }, [!$props.inline ? (openBlock(), createElementBlock("input", mergeProps({
    key: 0,
    ref: $options.inputRef,
    id: $props.inputId,
    type: "text",
    role: "combobox",
    class: ['p-inputtext p-component', $props.inputClass],
    style: $props.inputStyle,
    placeholder: $props.placeholder,
    "aria-autocomplete": "none",
    "aria-haspopup": "dialog",
    "aria-expanded": $data.overlayVisible,
    "aria-controls": $options.panelId,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    inputmode: "none",
    disabled: $props.disabled,
    readonly: !$props.manualInput || $props.readonly,
    tabindex: 0,
    onInput: _cache[0] || (_cache[0] = (...args) => $options.onInput && $options.onInput(...args)),
    onClick: _cache[1] || (_cache[1] = (...args) => $options.onInputClick && $options.onInputClick(...args)),
    onFocus: _cache[2] || (_cache[2] = (...args) => $options.onFocus && $options.onFocus(...args)),
    onBlur: _cache[3] || (_cache[3] = (...args) => $options.onBlur && $options.onBlur(...args)),
    onKeydown: _cache[4] || (_cache[4] = (...args) => $options.onKeyDown && $options.onKeyDown(...args))
  }, $props.inputProps), null, 16, _hoisted_2$v)) : createCommentVNode("", true), $props.showIcon ? (openBlock(), createBlock(_component_CalendarButton, {
    key: 1,
    icon: $props.icon,
    class: "p-datepicker-trigger",
    disabled: $props.disabled,
    onClick: $options.onButtonClick,
    type: "button",
    "aria-label": _ctx.$primevue.config.locale.chooseDate,
    "aria-haspopup": "dialog",
    "aria-expanded": $data.overlayVisible,
    "aria-controls": $options.panelId
  }, null, 8, ["icon", "disabled", "onClick", "aria-label", "aria-expanded", "aria-controls"])) : createCommentVNode("", true), createVNode(_component_Portal, {
    appendTo: $props.appendTo,
    disabled: $props.inline
  }, {
    default: withCtx(() => [createVNode(Transition, {
      name: "p-connected-overlay",
      onEnter: _cache[68] || (_cache[68] = $event => $options.onOverlayEnter($event)),
      onAfterEnter: $options.onOverlayEnterComplete,
      onAfterLeave: $options.onOverlayAfterLeave,
      onLeave: $options.onOverlayLeave
    }, {
      default: withCtx(() => [$props.inline || $data.overlayVisible ? (openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        ref: $options.overlayRef,
        id: $options.panelId,
        class: $options.panelStyleClass,
        style: $props.panelStyle,
        role: $props.inline ? null : 'dialog',
        "aria-modal": $props.inline ? null : 'true',
        "aria-label": _ctx.$primevue.config.locale.chooseDate,
        onClick: _cache[65] || (_cache[65] = (...args) => $options.onOverlayClick && $options.onOverlayClick(...args)),
        onKeydown: _cache[66] || (_cache[66] = (...args) => $options.onOverlayKeyDown && $options.onOverlayKeyDown(...args)),
        onMouseup: _cache[67] || (_cache[67] = (...args) => $options.onOverlayMouseUp && $options.onOverlayMouseUp(...args))
      }, $props.panelProps), [!$props.timeOnly ? (openBlock(), createElementBlock(Fragment, {
        key: 0
      }, [createElementVNode("div", _hoisted_4$m, [(openBlock(true), createElementBlock(Fragment, null, renderList($options.months, (month, groupIndex) => {
        return openBlock(), createElementBlock("div", {
          key: month.month + month.year,
          class: "p-datepicker-group"
        }, [createElementVNode("div", _hoisted_5$h, [renderSlot(_ctx.$slots, "header"), withDirectives((openBlock(), createElementBlock("button", {
          class: "p-datepicker-prev p-link",
          onClick: _cache[5] || (_cache[5] = (...args) => $options.onPrevButtonClick && $options.onPrevButtonClick(...args)),
          type: "button",
          onKeydown: _cache[6] || (_cache[6] = (...args) => $options.onContainerButtonKeydown && $options.onContainerButtonKeydown(...args)),
          disabled: $props.disabled,
          "aria-label": $data.currentView === 'year' ? _ctx.$primevue.config.locale.prevDecade : $data.currentView === 'month' ? _ctx.$primevue.config.locale.prevYear : _ctx.$primevue.config.locale.prevMonth
        }, [createElementVNode("span", {
          class: normalizeClass(['p-datepicker-prev-icon', $props.previousIcon])
        }, null, 2)], 40, _hoisted_6$f)), [[vShow, $props.showOtherMonths ? groupIndex === 0 : false], [_directive_ripple]]), createElementVNode("div", _hoisted_7$a, [$data.currentView === 'date' ? (openBlock(), createElementBlock("button", {
          key: 0,
          type: "button",
          onClick: _cache[7] || (_cache[7] = (...args) => $options.switchToMonthView && $options.switchToMonthView(...args)),
          onKeydown: _cache[8] || (_cache[8] = (...args) => $options.onContainerButtonKeydown && $options.onContainerButtonKeydown(...args)),
          class: "p-datepicker-month p-link",
          disabled: $options.switchViewButtonDisabled,
          "aria-label": _ctx.$primevue.config.locale.chooseMonth
        }, toDisplayString$1($options.getMonthName(month.month)), 41, _hoisted_8$9)) : createCommentVNode("", true), $data.currentView !== 'year' ? (openBlock(), createElementBlock("button", {
          key: 1,
          type: "button",
          onClick: _cache[9] || (_cache[9] = (...args) => $options.switchToYearView && $options.switchToYearView(...args)),
          onKeydown: _cache[10] || (_cache[10] = (...args) => $options.onContainerButtonKeydown && $options.onContainerButtonKeydown(...args)),
          class: "p-datepicker-year p-link",
          disabled: $options.switchViewButtonDisabled,
          "aria-label": _ctx.$primevue.config.locale.chooseYear
        }, toDisplayString$1($options.getYear(month)), 41, _hoisted_9$4)) : createCommentVNode("", true), $data.currentView === 'year' ? (openBlock(), createElementBlock("span", _hoisted_10$4, [renderSlot(_ctx.$slots, "decade", {
          years: $options.yearPickerValues
        }, () => [createTextVNode(toDisplayString$1($options.yearPickerValues[0]) + " - " + toDisplayString$1($options.yearPickerValues[$options.yearPickerValues.length - 1]), 1)])])) : createCommentVNode("", true)]), withDirectives((openBlock(), createElementBlock("button", {
          class: "p-datepicker-next p-link",
          onClick: _cache[11] || (_cache[11] = (...args) => $options.onNextButtonClick && $options.onNextButtonClick(...args)),
          type: "button",
          onKeydown: _cache[12] || (_cache[12] = (...args) => $options.onContainerButtonKeydown && $options.onContainerButtonKeydown(...args)),
          disabled: $props.disabled,
          "aria-label": $data.currentView === 'year' ? _ctx.$primevue.config.locale.nextDecade : $data.currentView === 'month' ? _ctx.$primevue.config.locale.nextYear : _ctx.$primevue.config.locale.nextMonth
        }, [createElementVNode("span", {
          class: normalizeClass(['p-datepicker-next-icon', $props.nextIcon])
        }, null, 2)], 40, _hoisted_11$4)), [[vShow, $props.showOtherMonths ? $props.numberOfMonths === 1 ? true : groupIndex === $props.numberOfMonths - 1 : false], [_directive_ripple]])]), $data.currentView === 'date' ? (openBlock(), createElementBlock("div", _hoisted_12$4, [createElementVNode("table", _hoisted_13$4, [createElementVNode("thead", null, [createElementVNode("tr", null, [$props.showWeek ? (openBlock(), createElementBlock("th", _hoisted_14$3, [createElementVNode("span", null, toDisplayString$1($options.weekHeaderLabel), 1)])) : createCommentVNode("", true), (openBlock(true), createElementBlock(Fragment, null, renderList($options.weekDays, weekDay => {
          return openBlock(), createElementBlock("th", {
            key: weekDay,
            scope: "col",
            abbr: weekDay
          }, [createElementVNode("span", null, toDisplayString$1(weekDay), 1)], 8, _hoisted_15$2);
        }), 128))])]), createElementVNode("tbody", null, [(openBlock(true), createElementBlock(Fragment, null, renderList(month.dates, (week, i) => {
          return openBlock(), createElementBlock("tr", {
            key: week[0].day + '' + week[0].month
          }, [$props.showWeek ? (openBlock(), createElementBlock("td", _hoisted_16$1, [createElementVNode("span", _hoisted_17$1, [month.weekNumbers[i] < 10 ? (openBlock(), createElementBlock("span", _hoisted_18$1, "0")) : createCommentVNode("", true), createTextVNode(" " + toDisplayString$1(month.weekNumbers[i]), 1)])])) : createCommentVNode("", true), (openBlock(true), createElementBlock(Fragment, null, renderList(week, date => {
            return openBlock(), createElementBlock("td", {
              key: date.day + '' + date.month,
              "aria-label": date.day,
              class: normalizeClass({
                'p-datepicker-other-month': date.otherMonth,
                'p-datepicker-today': date.today
              })
            }, [withDirectives((openBlock(), createElementBlock("span", {
              class: normalizeClass({
                'p-highlight': $options.isSelected(date),
                'p-disabled': !date.selectable
              }),
              onClick: $event => $options.onDateSelect($event, date),
              draggable: "false",
              onKeydown: $event => $options.onDateCellKeydown($event, date, groupIndex),
              "aria-selected": $options.isSelected(date)
            }, [renderSlot(_ctx.$slots, "date", {
              date: date
            }, () => [createTextVNode(toDisplayString$1(date.day), 1)])], 42, _hoisted_20$1)), [[_directive_ripple]]), $options.isSelected(date) ? (openBlock(), createElementBlock("div", _hoisted_21$1, toDisplayString$1(date.day), 1)) : createCommentVNode("", true)], 10, _hoisted_19$1);
          }), 128))]);
        }), 128))])])])) : createCommentVNode("", true)]);
      }), 128))]), $data.currentView === 'month' ? (openBlock(), createElementBlock("div", _hoisted_22, [(openBlock(true), createElementBlock(Fragment, null, renderList($options.monthPickerValues, (m, i) => {
        return withDirectives((openBlock(), createElementBlock("span", {
          key: m,
          onClick: $event => $options.onMonthSelect($event, i),
          onKeydown: $event => $options.onMonthCellKeydown($event, i),
          class: normalizeClass(["p-monthpicker-month", {
            'p-highlight': $options.isMonthSelected(i)
          }])
        }, [createTextVNode(toDisplayString$1(m) + " ", 1), $options.isMonthSelected(i) ? (openBlock(), createElementBlock("div", _hoisted_24, toDisplayString$1(m), 1)) : createCommentVNode("", true)], 42, _hoisted_23)), [[_directive_ripple]]);
      }), 128))])) : createCommentVNode("", true), $data.currentView === 'year' ? (openBlock(), createElementBlock("div", _hoisted_25, [(openBlock(true), createElementBlock(Fragment, null, renderList($options.yearPickerValues, y => {
        return withDirectives((openBlock(), createElementBlock("span", {
          key: y,
          onClick: $event => $options.onYearSelect($event, y),
          onKeydown: $event => $options.onYearCellKeydown($event, y),
          class: normalizeClass(["p-yearpicker-year", {
            'p-highlight': $options.isYearSelected(y)
          }])
        }, [createTextVNode(toDisplayString$1(y) + " ", 1), $options.isYearSelected(y) ? (openBlock(), createElementBlock("div", _hoisted_27, toDisplayString$1(y), 1)) : createCommentVNode("", true)], 42, _hoisted_26)), [[_directive_ripple]]);
      }), 128))])) : createCommentVNode("", true)], 64)) : createCommentVNode("", true), ($props.showTime || $props.timeOnly) && $data.currentView === 'date' ? (openBlock(), createElementBlock("div", _hoisted_28, [createElementVNode("div", _hoisted_29, [withDirectives((openBlock(), createElementBlock("button", {
        class: "p-link",
        "aria-label": _ctx.$primevue.config.locale.nextHour,
        onMousedown: _cache[13] || (_cache[13] = $event => $options.onTimePickerElementMouseDown($event, 0, 1)),
        onMouseup: _cache[14] || (_cache[14] = $event => $options.onTimePickerElementMouseUp($event)),
        onKeydown: [_cache[15] || (_cache[15] = (...args) => $options.onContainerButtonKeydown && $options.onContainerButtonKeydown(...args)), _cache[17] || (_cache[17] = withKeys($event => $options.onTimePickerElementMouseDown($event, 0, 1), ["enter"])), _cache[18] || (_cache[18] = withKeys($event => $options.onTimePickerElementMouseDown($event, 0, 1), ["space"]))],
        onMouseleave: _cache[16] || (_cache[16] = $event => $options.onTimePickerElementMouseLeave()),
        onKeyup: [_cache[19] || (_cache[19] = withKeys($event => $options.onTimePickerElementMouseUp($event), ["enter"])), _cache[20] || (_cache[20] = withKeys($event => $options.onTimePickerElementMouseUp($event), ["space"]))],
        type: "button"
      }, [createElementVNode("span", {
        class: normalizeClass($props.incrementIcon)
      }, null, 2)], 40, _hoisted_30)), [[_directive_ripple]]), createElementVNode("span", null, toDisplayString$1($options.formattedCurrentHour), 1), withDirectives((openBlock(), createElementBlock("button", {
        class: "p-link",
        "aria-label": _ctx.$primevue.config.locale.prevHour,
        onMousedown: _cache[21] || (_cache[21] = $event => $options.onTimePickerElementMouseDown($event, 0, -1)),
        onMouseup: _cache[22] || (_cache[22] = $event => $options.onTimePickerElementMouseUp($event)),
        onKeydown: [_cache[23] || (_cache[23] = (...args) => $options.onContainerButtonKeydown && $options.onContainerButtonKeydown(...args)), _cache[25] || (_cache[25] = withKeys($event => $options.onTimePickerElementMouseDown($event, 0, -1), ["enter"])), _cache[26] || (_cache[26] = withKeys($event => $options.onTimePickerElementMouseDown($event, 0, -1), ["space"]))],
        onMouseleave: _cache[24] || (_cache[24] = $event => $options.onTimePickerElementMouseLeave()),
        onKeyup: [_cache[27] || (_cache[27] = withKeys($event => $options.onTimePickerElementMouseUp($event), ["enter"])), _cache[28] || (_cache[28] = withKeys($event => $options.onTimePickerElementMouseUp($event), ["space"]))],
        type: "button"
      }, [createElementVNode("span", {
        class: normalizeClass($props.decrementIcon)
      }, null, 2)], 40, _hoisted_31)), [[_directive_ripple]])]), createElementVNode("div", _hoisted_32, [createElementVNode("span", null, toDisplayString$1($props.timeSeparator), 1)]), createElementVNode("div", _hoisted_33, [withDirectives((openBlock(), createElementBlock("button", {
        class: "p-link",
        "aria-label": _ctx.$primevue.config.locale.nextMinute,
        onMousedown: _cache[29] || (_cache[29] = $event => $options.onTimePickerElementMouseDown($event, 1, 1)),
        onMouseup: _cache[30] || (_cache[30] = $event => $options.onTimePickerElementMouseUp($event)),
        onKeydown: [_cache[31] || (_cache[31] = (...args) => $options.onContainerButtonKeydown && $options.onContainerButtonKeydown(...args)), _cache[33] || (_cache[33] = withKeys($event => $options.onTimePickerElementMouseDown($event, 1, 1), ["enter"])), _cache[34] || (_cache[34] = withKeys($event => $options.onTimePickerElementMouseDown($event, 1, 1), ["space"]))],
        disabled: $props.disabled,
        onMouseleave: _cache[32] || (_cache[32] = $event => $options.onTimePickerElementMouseLeave()),
        onKeyup: [_cache[35] || (_cache[35] = withKeys($event => $options.onTimePickerElementMouseUp($event), ["enter"])), _cache[36] || (_cache[36] = withKeys($event => $options.onTimePickerElementMouseUp($event), ["space"]))],
        type: "button"
      }, [createElementVNode("span", {
        class: normalizeClass($props.incrementIcon)
      }, null, 2)], 40, _hoisted_34)), [[_directive_ripple]]), createElementVNode("span", null, toDisplayString$1($options.formattedCurrentMinute), 1), withDirectives((openBlock(), createElementBlock("button", {
        class: "p-link",
        "aria-label": _ctx.$primevue.config.locale.prevMinute,
        onMousedown: _cache[37] || (_cache[37] = $event => $options.onTimePickerElementMouseDown($event, 1, -1)),
        onMouseup: _cache[38] || (_cache[38] = $event => $options.onTimePickerElementMouseUp($event)),
        onKeydown: [_cache[39] || (_cache[39] = (...args) => $options.onContainerButtonKeydown && $options.onContainerButtonKeydown(...args)), _cache[41] || (_cache[41] = withKeys($event => $options.onTimePickerElementMouseDown($event, 1, -1), ["enter"])), _cache[42] || (_cache[42] = withKeys($event => $options.onTimePickerElementMouseDown($event, 1, -1), ["space"]))],
        disabled: $props.disabled,
        onMouseleave: _cache[40] || (_cache[40] = $event => $options.onTimePickerElementMouseLeave()),
        onKeyup: [_cache[43] || (_cache[43] = withKeys($event => $options.onTimePickerElementMouseUp($event), ["enter"])), _cache[44] || (_cache[44] = withKeys($event => $options.onTimePickerElementMouseUp($event), ["space"]))],
        type: "button"
      }, [createElementVNode("span", {
        class: normalizeClass($props.decrementIcon)
      }, null, 2)], 40, _hoisted_35)), [[_directive_ripple]])]), $props.showSeconds ? (openBlock(), createElementBlock("div", _hoisted_36, [createElementVNode("span", null, toDisplayString$1($props.timeSeparator), 1)])) : createCommentVNode("", true), $props.showSeconds ? (openBlock(), createElementBlock("div", _hoisted_37, [withDirectives((openBlock(), createElementBlock("button", {
        class: "p-link",
        "aria-label": _ctx.$primevue.config.locale.nextSecond,
        onMousedown: _cache[45] || (_cache[45] = $event => $options.onTimePickerElementMouseDown($event, 2, 1)),
        onMouseup: _cache[46] || (_cache[46] = $event => $options.onTimePickerElementMouseUp($event)),
        onKeydown: [_cache[47] || (_cache[47] = (...args) => $options.onContainerButtonKeydown && $options.onContainerButtonKeydown(...args)), _cache[49] || (_cache[49] = withKeys($event => $options.onTimePickerElementMouseDown($event, 2, 1), ["enter"])), _cache[50] || (_cache[50] = withKeys($event => $options.onTimePickerElementMouseDown($event, 2, 1), ["space"]))],
        disabled: $props.disabled,
        onMouseleave: _cache[48] || (_cache[48] = $event => $options.onTimePickerElementMouseLeave()),
        onKeyup: [_cache[51] || (_cache[51] = withKeys($event => $options.onTimePickerElementMouseUp($event), ["enter"])), _cache[52] || (_cache[52] = withKeys($event => $options.onTimePickerElementMouseUp($event), ["space"]))],
        type: "button"
      }, [createElementVNode("span", {
        class: normalizeClass($props.incrementIcon)
      }, null, 2)], 40, _hoisted_38)), [[_directive_ripple]]), createElementVNode("span", null, toDisplayString$1($options.formattedCurrentSecond), 1), withDirectives((openBlock(), createElementBlock("button", {
        class: "p-link",
        "aria-label": _ctx.$primevue.config.locale.prevSecond,
        onMousedown: _cache[53] || (_cache[53] = $event => $options.onTimePickerElementMouseDown($event, 2, -1)),
        onMouseup: _cache[54] || (_cache[54] = $event => $options.onTimePickerElementMouseUp($event)),
        onKeydown: [_cache[55] || (_cache[55] = (...args) => $options.onContainerButtonKeydown && $options.onContainerButtonKeydown(...args)), _cache[57] || (_cache[57] = withKeys($event => $options.onTimePickerElementMouseDown($event, 2, -1), ["enter"])), _cache[58] || (_cache[58] = withKeys($event => $options.onTimePickerElementMouseDown($event, 2, -1), ["space"]))],
        disabled: $props.disabled,
        onMouseleave: _cache[56] || (_cache[56] = $event => $options.onTimePickerElementMouseLeave()),
        onKeyup: [_cache[59] || (_cache[59] = withKeys($event => $options.onTimePickerElementMouseUp($event), ["enter"])), _cache[60] || (_cache[60] = withKeys($event => $options.onTimePickerElementMouseUp($event), ["space"]))],
        type: "button"
      }, [createElementVNode("span", {
        class: normalizeClass($props.decrementIcon)
      }, null, 2)], 40, _hoisted_39)), [[_directive_ripple]])])) : createCommentVNode("", true), $props.hourFormat == '12' ? (openBlock(), createElementBlock("div", _hoisted_40, [createElementVNode("span", null, toDisplayString$1($props.timeSeparator), 1)])) : createCommentVNode("", true), $props.hourFormat == '12' ? (openBlock(), createElementBlock("div", _hoisted_41, [withDirectives((openBlock(), createElementBlock("button", {
        class: "p-link",
        "aria-label": _ctx.$primevue.config.locale.am,
        onClick: _cache[61] || (_cache[61] = $event => $options.toggleAMPM($event)),
        type: "button",
        disabled: $props.disabled
      }, [createElementVNode("span", {
        class: normalizeClass($props.incrementIcon)
      }, null, 2)], 8, _hoisted_42)), [[_directive_ripple]]), createElementVNode("span", null, toDisplayString$1($data.pm ? _ctx.$primevue.config.locale.pm : _ctx.$primevue.config.locale.am), 1), withDirectives((openBlock(), createElementBlock("button", {
        class: "p-link",
        "aria-label": _ctx.$primevue.config.locale.pm,
        onClick: _cache[62] || (_cache[62] = $event => $options.toggleAMPM($event)),
        type: "button",
        disabled: $props.disabled
      }, [createElementVNode("span", {
        class: normalizeClass($props.decrementIcon)
      }, null, 2)], 8, _hoisted_43)), [[_directive_ripple]])])) : createCommentVNode("", true)])) : createCommentVNode("", true), $props.showButtonBar ? (openBlock(), createElementBlock("div", _hoisted_44, [createVNode(_component_CalendarButton, {
        type: "button",
        label: $options.todayLabel,
        onClick: _cache[63] || (_cache[63] = $event => $options.onTodayButtonClick($event)),
        class: "p-button-text",
        onKeydown: $options.onContainerButtonKeydown
      }, null, 8, ["label", "onKeydown"]), createVNode(_component_CalendarButton, {
        type: "button",
        label: $options.clearLabel,
        onClick: _cache[64] || (_cache[64] = $event => $options.onClearButtonClick($event)),
        class: "p-button-text",
        onKeydown: $options.onContainerButtonKeydown
      }, null, 8, ["label", "onKeydown"])])) : createCommentVNode("", true), renderSlot(_ctx.$slots, "footer")], 16, _hoisted_3$r)) : createCommentVNode("", true)]),
      _: 3
    }, 8, ["onAfterEnter", "onAfterLeave", "onLeave"])]),
    _: 3
  }, 8, ["appendTo", "disabled"])], 10, _hoisted_1$C);
}

function styleInject$k(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$r = "\n.p-calendar {\n    position: relative;\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    max-width: 100%;\n}\n.p-calendar .p-inputtext {\n    -webkit-box-flex: 1;\n        -ms-flex: 1 1 auto;\n            flex: 1 1 auto;\n    width: 1%;\n}\n.p-calendar-w-btn .p-inputtext {\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n}\n.p-calendar-w-btn .p-datepicker-trigger {\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0;\n}\n\n/* Fluid */\n.p-fluid .p-calendar {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n}\n.p-fluid .p-calendar .p-inputtext {\n    width: 1%;\n}\n\n/* Datepicker */\n.p-calendar .p-datepicker {\n    min-width: 100%;\n}\n.p-datepicker {\n    width: auto;\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.p-datepicker-inline {\n    display: inline-block;\n    position: static;\n    overflow-x: auto;\n}\n\n/* Header */\n.p-datepicker-header {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: justify;\n        -ms-flex-pack: justify;\n            justify-content: space-between;\n}\n.p-datepicker-header .p-datepicker-title {\n    margin: 0 auto;\n}\n.p-datepicker-prev,\n.p-datepicker-next {\n    cursor: pointer;\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    overflow: hidden;\n    position: relative;\n}\n\n/* Multiple Month DatePicker */\n.p-datepicker-multiple-month .p-datepicker-group-container {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n}\n.p-datepicker-multiple-month .p-datepicker-group-container .p-datepicker-group {\n    -webkit-box-flex: 1;\n        -ms-flex: 1 1 auto;\n            flex: 1 1 auto;\n}\n\n/* DatePicker Table */\n.p-datepicker table {\n    width: 100%;\n    border-collapse: collapse;\n}\n.p-datepicker td > span {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    cursor: pointer;\n    margin: 0 auto;\n    overflow: hidden;\n    position: relative;\n}\n\n/* Month Picker */\n.p-monthpicker-month {\n    width: 33.3%;\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    cursor: pointer;\n    overflow: hidden;\n    position: relative;\n}\n\n/* Year Picker */\n.p-yearpicker-year {\n    width: 50%;\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    cursor: pointer;\n    overflow: hidden;\n    position: relative;\n}\n\n/*  Button Bar */\n.p-datepicker-buttonbar {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-pack: justify;\n        -ms-flex-pack: justify;\n            justify-content: space-between;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n\n/* Time Picker */\n.p-timepicker {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n.p-timepicker button {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    cursor: pointer;\n    overflow: hidden;\n    position: relative;\n}\n.p-timepicker > div {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n        -ms-flex-direction: column;\n            flex-direction: column;\n}\n\n/* Touch UI */\n.p-datepicker-touch-ui,\n.p-calendar .p-datepicker-touch-ui {\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    min-width: 80vw;\n    -webkit-transform: translate(-50%, -50%);\n            transform: translate(-50%, -50%);\n}\n";
styleInject$k(css_248z$r);
script$1c.render = render$p;

const _hoisted_1$B = { key: 1 };


var script$1b = {
  props: {
    bind : {
        type : Object,
        required : true
    }
},
  setup(__props) {

const props = __props;



let cvalue = ref(props.bind.value);

const value = computed({
    get() {
        return cvalue.value;
    },
    set(val) {
        props.bind.setValue(val);
        cvalue.value = props.bind.value;
    }
});

const disabled = (props.bind.cell.system) ? true : false;


return (_ctx, _cache) => {
  return (unref(disabled)==false)
    ? (openBlock(), createBlock(unref(script$1c), {
        key: 0,
        id: "range",
        modelValue: unref(value),
        "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (isRef(value) ? (value).value = $event : null)),
        disabledDates: __props.bind.cell.invalid_dates,
        manualInput: false,
        class: normalizeClass([__props.bind.classes, "focus:border-primary"]),
        dateFormat: "dd/mm/yy",
        onBlur: _cache[1] || (_cache[1] = $event => (__props.bind.setShowError(true)))
      }, null, 8 /* PROPS */, ["modelValue", "disabledDates", "class"]))
    : (openBlock(), createElementBlock("span", _hoisted_1$B, toDisplayString$1(unref(value)), 1 /* TEXT */))
}
}

};

script$1b.__file = "presstojam/src/components/form/time-edit.vue";

var script$1a = {
  name: 'Password',
  emits: ['update:modelValue', 'change', 'focus', 'blur', 'invalid'],
  props: {
    modelValue: String,
    promptLabel: {
      type: String,
      default: null
    },
    mediumRegex: {
      type: String,
      default: '^(((?=.*[a-z])(?=.*[A-Z]))|((?=.*[a-z])(?=.*[0-9]))|((?=.*[A-Z])(?=.*[0-9])))(?=.{6,})' // eslint-disable-line

    },
    strongRegex: {
      type: String,
      default: '^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.{8,})' // eslint-disable-line

    },
    weakLabel: {
      type: String,
      default: null
    },
    mediumLabel: {
      type: String,
      default: null
    },
    strongLabel: {
      type: String,
      default: null
    },
    feedback: {
      type: Boolean,
      default: true
    },
    appendTo: {
      type: String,
      default: 'body'
    },
    toggleMask: {
      type: Boolean,
      default: false
    },
    hideIcon: {
      type: String,
      default: 'pi pi-eye-slash'
    },
    showIcon: {
      type: String,
      default: 'pi pi-eye'
    },
    disabled: {
      type: Boolean,
      default: false
    },
    placeholder: {
      type: String,
      default: null
    },
    required: {
      type: Boolean,
      default: false
    },
    inputId: {
      type: String,
      default: null
    },
    inputClass: {
      type: String,
      default: null
    },
    inputStyle: {
      type: null,
      default: null
    },
    inputProps: {
      type: null,
      default: null
    },
    panelId: {
      type: String,
      default: null
    },
    panelClass: {
      type: String,
      default: null
    },
    panelStyle: {
      type: null,
      default: null
    },
    panelProps: {
      type: null,
      default: null
    },
    'aria-labelledby': {
      type: String,
      default: null
    },
    'aria-label': {
      type: String,
      default: null
    }
  },

  data() {
    return {
      overlayVisible: false,
      meter: null,
      infoText: null,
      focused: false,
      unmasked: false
    };
  },

  mediumCheckRegExp: null,
  strongCheckRegExp: null,
  resizeListener: null,
  scrollHandler: null,
  overlay: null,

  mounted() {
    this.infoText = this.promptText;
    this.mediumCheckRegExp = new RegExp(this.mediumRegex);
    this.strongCheckRegExp = new RegExp(this.strongRegex);
  },

  beforeUnmount() {
    this.unbindResizeListener();

    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }

    if (this.overlay) {
      ZIndexUtils.clear(this.overlay);
      this.overlay = null;
    }
  },

  methods: {
    onOverlayEnter(el) {
      ZIndexUtils.set('overlay', el, this.$primevue.config.zIndex.overlay);
      this.alignOverlay();
      this.bindScrollListener();
      this.bindResizeListener();
    },

    onOverlayLeave() {
      this.unbindScrollListener();
      this.unbindResizeListener();
      this.overlay = null;
    },

    onOverlayAfterLeave(el) {
      ZIndexUtils.clear(el);
    },

    alignOverlay() {
      if (this.appendTo === 'self') {
        DomHandler.relativePosition(this.overlay, this.$refs.input.$el);
      } else {
        this.overlay.style.minWidth = DomHandler.getOuterWidth(this.$refs.input.$el) + 'px';
        DomHandler.absolutePosition(this.overlay, this.$refs.input.$el);
      }
    },

    testStrength(str) {
      let level = 0;
      if (this.strongCheckRegExp.test(str)) level = 3;else if (this.mediumCheckRegExp.test(str)) level = 2;else if (str.length) level = 1;
      return level;
    },

    onInput(event) {
      this.$emit('update:modelValue', event.target.value);
    },

    onFocus(event) {
      this.focused = true;

      if (this.feedback) {
        this.setPasswordMeter(this.modelValue);
        this.overlayVisible = true;
      }

      this.$emit('focus', event);
    },

    onBlur(event) {
      this.focused = false;

      if (this.feedback) {
        this.overlayVisible = false;
      }

      this.$emit('blur', event);
    },

    onKeyUp(event) {
      if (this.feedback) {
        const value = event.target.value;
        const {
          meter,
          label
        } = this.checkPasswordStrength(value);
        this.meter = meter;
        this.infoText = label;

        if (event.code === 'Escape') {
          this.overlayVisible && (this.overlayVisible = false);
          return;
        }

        if (!this.overlayVisible) {
          this.overlayVisible = true;
        }
      }
    },

    setPasswordMeter() {
      if (!this.modelValue) return;
      const {
        meter,
        label
      } = this.checkPasswordStrength(this.modelValue);
      this.meter = meter;
      this.infoText = label;

      if (!this.overlayVisible) {
        this.overlayVisible = true;
      }
    },

    checkPasswordStrength(value) {
      let label = null;
      let meter = null;

      switch (this.testStrength(value)) {
        case 1:
          label = this.weakText;
          meter = {
            strength: 'weak',
            width: '33.33%'
          };
          break;

        case 2:
          label = this.mediumText;
          meter = {
            strength: 'medium',
            width: '66.66%'
          };
          break;

        case 3:
          label = this.strongText;
          meter = {
            strength: 'strong',
            width: '100%'
          };
          break;

        default:
          label = this.promptText;
          meter = null;
          break;
      }

      return {
        label,
        meter
      };
    },

    onInvalid(event) {
      this.$emit('invalid', event);
    },

    bindScrollListener() {
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.$refs.input.$el, () => {
          if (this.overlayVisible) {
            this.overlayVisible = false;
          }
        });
      }

      this.scrollHandler.bindScrollListener();
    },

    unbindScrollListener() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    },

    bindResizeListener() {
      if (!this.resizeListener) {
        this.resizeListener = () => {
          if (this.overlayVisible && !DomHandler.isTouchDevice()) {
            this.overlayVisible = false;
          }
        };

        window.addEventListener('resize', this.resizeListener);
      }
    },

    unbindResizeListener() {
      if (this.resizeListener) {
        window.removeEventListener('resize', this.resizeListener);
        this.resizeListener = null;
      }
    },

    overlayRef(el) {
      this.overlay = el;
    },

    onMaskToggle() {
      this.unmasked = !this.unmasked;
    },

    onOverlayClick(event) {
      OverlayEventBus.emit('overlay-click', {
        originalEvent: event,
        target: this.$el
      });
    }

  },
  computed: {
    containerClass() {
      return ['p-password p-component p-inputwrapper', {
        'p-inputwrapper-filled': this.filled,
        'p-inputwrapper-focus': this.focused,
        'p-input-icon-right': this.toggleMask
      }];
    },

    inputFieldClass() {
      return ['p-password-input', this.inputClass, {
        'p-disabled': this.disabled
      }];
    },

    panelStyleClass() {
      return ['p-password-panel p-component', this.panelClass, {
        'p-input-filled': this.$primevue.config.inputStyle === 'filled',
        'p-ripple-disabled': this.$primevue.config.ripple === false
      }];
    },

    toggleIconClass() {
      return this.unmasked ? this.hideIcon : this.showIcon;
    },

    strengthClass() {
      return `p-password-strength ${this.meter ? this.meter.strength : ''}`;
    },

    inputType() {
      return this.unmasked ? 'text' : 'password';
    },

    filled() {
      return this.modelValue != null && this.modelValue.toString().length > 0;
    },

    weakText() {
      return this.weakLabel || this.$primevue.config.locale.weak;
    },

    mediumText() {
      return this.mediumLabel || this.$primevue.config.locale.medium;
    },

    strongText() {
      return this.strongLabel || this.$primevue.config.locale.strong;
    },

    promptText() {
      return this.promptLabel || this.$primevue.config.locale.passwordPrompt;
    },

    panelUniqueId() {
      return UniqueComponentId() + '_panel';
    }

  },
  components: {
    PInputText: script$1M,
    Portal: script$1C
  }
};
const _hoisted_1$A = {
  class: "p-hidden-accessible",
  "aria-live": "polite"
};
const _hoisted_2$u = ["id"];
const _hoisted_3$q = {
  class: "p-password-meter"
};
const _hoisted_4$l = {
  class: "p-password-info"
};

function render$o(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PInputText = resolveComponent("PInputText");

  const _component_Portal = resolveComponent("Portal");

  return openBlock(), createElementBlock("div", {
    class: normalizeClass($options.containerClass)
  }, [createVNode(_component_PInputText, mergeProps({
    ref: "input",
    id: $props.inputId,
    type: $options.inputType,
    class: $options.inputFieldClass,
    style: $props.inputStyle,
    value: $props.modelValue,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    "aria-controls": $props.panelProps && $props.panelProps.id || $props.panelId || $options.panelUniqueId,
    "aria-expanded": $data.overlayVisible,
    "aria-haspopup": true,
    placeholder: $props.placeholder,
    required: $props.required,
    onInput: $options.onInput,
    onFocus: $options.onFocus,
    onBlur: $options.onBlur,
    onKeyup: $options.onKeyUp,
    onInvalid: $options.onInvalid
  }, $props.inputProps), null, 16, ["id", "type", "class", "style", "value", "aria-labelledby", "aria-label", "aria-controls", "aria-expanded", "placeholder", "required", "onInput", "onFocus", "onBlur", "onKeyup", "onInvalid"]), $props.toggleMask ? (openBlock(), createElementBlock("i", {
    key: 0,
    class: normalizeClass($options.toggleIconClass),
    onClick: _cache[0] || (_cache[0] = (...args) => $options.onMaskToggle && $options.onMaskToggle(...args))
  }, null, 2)) : createCommentVNode("", true), createElementVNode("span", _hoisted_1$A, toDisplayString$1($data.infoText), 1), createVNode(_component_Portal, {
    appendTo: $props.appendTo
  }, {
    default: withCtx(() => [createVNode(Transition, {
      name: "p-connected-overlay",
      onEnter: $options.onOverlayEnter,
      onLeave: $options.onOverlayLeave,
      onAfterLeave: $options.onOverlayAfterLeave
    }, {
      default: withCtx(() => [$data.overlayVisible ? (openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        ref: $options.overlayRef,
        id: $props.panelId || $options.panelUniqueId,
        class: $options.panelStyleClass,
        style: $props.panelStyle,
        onClick: _cache[1] || (_cache[1] = (...args) => $options.onOverlayClick && $options.onOverlayClick(...args))
      }, $props.panelProps), [renderSlot(_ctx.$slots, "header"), renderSlot(_ctx.$slots, "content", {}, () => [createElementVNode("div", _hoisted_3$q, [createElementVNode("div", {
        class: normalizeClass($options.strengthClass),
        style: normalizeStyle({
          width: $data.meter ? $data.meter.width : ''
        })
      }, null, 6)]), createElementVNode("div", _hoisted_4$l, toDisplayString$1($data.infoText), 1)]), renderSlot(_ctx.$slots, "footer")], 16, _hoisted_2$u)) : createCommentVNode("", true)]),
      _: 3
    }, 8, ["onEnter", "onLeave", "onAfterLeave"])]),
    _: 3
  }, 8, ["appendTo"])], 2);
}

function styleInject$j(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$q = "\n.p-password {\n    position: relative;\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n}\n.p-password-panel {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.p-password .p-password-panel {\n    min-width: 100%;\n}\n.p-password-meter {\n    height: 10px;\n}\n.p-password-strength {\n    height: 100%;\n    width: 0;\n    -webkit-transition: width 1s ease-in-out;\n    transition: width 1s ease-in-out;\n}\n.p-fluid .p-password {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n}\n";
styleInject$j(css_248z$q);
script$1a.render = render$o;

var script$19 = {
  name: 'Textarea',
  emits: ['update:modelValue'],
  props: {
    modelValue: null,
    autoResize: Boolean
  },

  mounted() {
    if (this.$el.offsetParent && this.autoResize) {
      this.resize();
    }
  },

  updated() {
    if (this.$el.offsetParent && this.autoResize) {
      this.resize();
    }
  },

  methods: {
    resize() {
      const style = window.getComputedStyle(this.$el);
      this.$el.style.height = 'auto';
      this.$el.style.height = `calc(${style.borderTopWidth} + ${style.borderBottomWidth} + ${this.$el.scrollHeight}px)`;

      if (parseFloat(this.$el.style.height) >= parseFloat(this.$el.style.maxHeight)) {
        this.$el.style.overflowY = 'scroll';
        this.$el.style.height = this.$el.style.maxHeight;
      } else {
        this.$el.style.overflow = 'hidden';
      }
    },

    onInput(event) {
      if (this.autoResize) {
        this.resize();
      }

      this.$emit('update:modelValue', event.target.value);
    }

  },
  computed: {
    filled() {
      return this.modelValue != null && this.modelValue.toString().length > 0;
    }

  }
};
const _hoisted_1$z = ["value"];

function render$n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("textarea", {
    class: normalizeClass(['p-inputtextarea p-inputtext p-component', {
      'p-filled': $options.filled,
      'p-inputtextarea-resizable ': $props.autoResize
    }]),
    value: $props.modelValue,
    onInput: _cache[0] || (_cache[0] = (...args) => $options.onInput && $options.onInput(...args))
  }, null, 42, _hoisted_1$z);
}

function styleInject$i(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$p = "\n.p-inputtextarea-resizable {\n    overflow: hidden;\n    resize: none;\n}\n.p-fluid .p-inputtextarea {\n    width: 100%;\n}\n";
styleInject$i(css_248z$p);
script$19.render = render$n;

var script$18 = {
  props: {
    bind : {
        type : Object,
        required : true
    }
},
  setup(__props) {

const props = __props;



const value = computed({
    get() {
        return props.bind.value;
    },
    set(val) {
        props.bind.setValue(val);
    }
});


const cell = props.bind.cell;
const { te, t } = useI18n$1();
let options = [];


let tag;
if (cell.isEnum()) {
    options = cell.getOptions();
    tag = "select";
} else if (cell.encrypted) {
    tag = "input";
} else if (cell.html || cell.max > 300) {
    tag = "textarea";
} else {
    tag = "input";
}



const atts = {};
if (cell.encrypted) {
    atts.type = "password";
}

if (cell.immutable) {
    atts.readonly = true;
}


let pholder = te("models." + cell.model + ".fields." + cell.name + ".placeholder");
if (pholder) {
    atts.placeholder = t("models." + cell.model + ".fields." + cell.name + ".placeholder");
}

if (cell.contains.includes("html")) {
    atts["data-html"] = 1;
}



return (_ctx, _cache) => {
  return (__props.bind.cell.encrypted)
    ? (openBlock(), createBlock(unref(script$1a), {
        key: 0,
        modelValue: unref(value),
        "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (isRef(value) ? (value).value = $event : null)),
        class: normalizeClass(["focus:border-primary", __props.bind.classes]),
        onBlur: _cache[1] || (_cache[1] = $event => (__props.bind.setShowError(true)))
      }, null, 8 /* PROPS */, ["modelValue", "class"]))
    : (unref(tag)=='textarea')
      ? (openBlock(), createBlock(unref(script$19), {
          key: 1,
          modelValue: unref(value),
          "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => (isRef(value) ? (value).value = $event : null)),
          rows: "5",
          class: normalizeClass(__props.bind.classes),
          onBlur: _cache[3] || (_cache[3] = $event => (__props.bind.setShowError(true)))
        }, null, 8 /* PROPS */, ["modelValue", "class"]))
      : (unref(tag)=='select')
        ? (openBlock(), createBlock(script$1e, {
            key: 2,
            bind: __props.bind,
            options: unref(options),
            class: normalizeClass(__props.bind.classes),
            onBlur: _cache[4] || (_cache[4] = $event => (__props.bind.setShowError(true)))
          }, null, 8 /* PROPS */, ["bind", "options", "class"]))
        : (openBlock(), createBlock(unref(script$1M), mergeProps({ key: 3 }, atts, {
            name: __props.bind.cell.name,
            class: ["focus:border-primary form-control", __props.bind.classes],
            modelValue: unref(value),
            "onUpdate:modelValue": _cache[5] || (_cache[5] = $event => (isRef(value) ? (value).value = $event : null)),
            onBlur: _cache[6] || (_cache[6] = $event => (__props.bind.setShowError(true)))
          }), null, 16 /* FULL_PROPS */, ["name", "modelValue", "class"]))
}
}

};

script$18.__file = "presstojam/src/components/form/string-edit.vue";

var script$17 = {
  name: 'ProgressBar',
  props: {
    value: {
      type: Number,
      default: null
    },
    mode: {
      type: String,
      default: 'determinate'
    },
    showValue: {
      type: Boolean,
      default: true
    }
  },
  computed: {
    containerClass() {
      return ['p-progressbar p-component', {
        'p-progressbar-determinate': this.determinate,
        'p-progressbar-indeterminate': this.indeterminate
      }];
    },

    progressStyle() {
      return {
        width: this.value + '%',
        display: 'flex'
      };
    },

    indeterminate() {
      return this.mode === 'indeterminate';
    },

    determinate() {
      return this.mode === 'determinate';
    }

  }
};
const _hoisted_1$y = ["aria-valuenow"];
const _hoisted_2$t = {
  key: 0,
  class: "p-progressbar-label"
};
const _hoisted_3$p = {
  key: 1,
  class: "p-progressbar-indeterminate-container"
};

const _hoisted_4$k = /*#__PURE__*/createElementVNode("div", {
  class: "p-progressbar-value p-progressbar-value-animate"
}, null, -1);

const _hoisted_5$g = [_hoisted_4$k];

function render$m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    role: "progressbar",
    class: normalizeClass($options.containerClass),
    "aria-valuemin": "0",
    "aria-valuenow": $props.value,
    "aria-valuemax": "100"
  }, [$options.determinate ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "p-progressbar-value p-progressbar-value-animate",
    style: normalizeStyle($options.progressStyle)
  }, [$props.value != null && $props.value !== 0 && $props.showValue ? (openBlock(), createElementBlock("div", _hoisted_2$t, [renderSlot(_ctx.$slots, "default", {}, () => [createTextVNode(toDisplayString$1($props.value + '%'), 1)])])) : createCommentVNode("", true)], 4)) : createCommentVNode("", true), $options.indeterminate ? (openBlock(), createElementBlock("div", _hoisted_3$p, _hoisted_5$g)) : createCommentVNode("", true)], 10, _hoisted_1$y);
}

function styleInject$h(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$o = "\n.p-progressbar {\n    position: relative;\n    overflow: hidden;\n}\n.p-progressbar-determinate .p-progressbar-value {\n    height: 100%;\n    width: 0%;\n    position: absolute;\n    display: none;\n    border: 0 none;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    overflow: hidden;\n}\n.p-progressbar-determinate .p-progressbar-label {\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n}\n.p-progressbar-determinate .p-progressbar-value-animate {\n    -webkit-transition: width 1s ease-in-out;\n    transition: width 1s ease-in-out;\n}\n.p-progressbar-indeterminate .p-progressbar-value::before {\n    content: '';\n    position: absolute;\n    background-color: inherit;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    will-change: left, right;\n    -webkit-animation: p-progressbar-indeterminate-anim 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;\n    animation: p-progressbar-indeterminate-anim 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;\n}\n.p-progressbar-indeterminate .p-progressbar-value::after {\n    content: '';\n    position: absolute;\n    background-color: inherit;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    will-change: left, right;\n    -webkit-animation: p-progressbar-indeterminate-anim-short 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) infinite;\n    animation: p-progressbar-indeterminate-anim-short 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) infinite;\n    -webkit-animation-delay: 1.15s;\n    animation-delay: 1.15s;\n}\n@-webkit-keyframes p-progressbar-indeterminate-anim {\n0% {\n        left: -35%;\n        right: 100%;\n}\n60% {\n        left: 100%;\n        right: -90%;\n}\n100% {\n        left: 100%;\n        right: -90%;\n}\n}\n@keyframes p-progressbar-indeterminate-anim {\n0% {\n        left: -35%;\n        right: 100%;\n}\n60% {\n        left: 100%;\n        right: -90%;\n}\n100% {\n        left: 100%;\n        right: -90%;\n}\n}\n@-webkit-keyframes p-progressbar-indeterminate-anim-short {\n0% {\n        left: -200%;\n        right: 100%;\n}\n60% {\n        left: 107%;\n        right: -8%;\n}\n100% {\n        left: 107%;\n        right: -8%;\n}\n}\n@keyframes p-progressbar-indeterminate-anim-short {\n0% {\n        left: -200%;\n        right: 100%;\n}\n60% {\n        left: 107%;\n        right: -8%;\n}\n100% {\n        left: 107%;\n        right: -8%;\n}\n}\n";
styleInject$h(css_248z$o);
script$17.render = render$m;

var script$16 = {
  name: 'Badge',
  props: {
    value: null,
    severity: null,
    size: null
  },
  computed: {
    containerClass() {
      return this.$slots.default ? 'p-overlay-badge' : this.badgeClass;
    },

    badgeClass() {
      return ['p-badge p-component', {
        'p-badge-no-gutter': this.value && String(this.value).length === 1,
        'p-badge-dot': !this.value && !this.$slots.default,
        'p-badge-lg': this.size === 'large',
        'p-badge-xl': this.size === 'xlarge',
        'p-badge-info': this.severity === 'info',
        'p-badge-success': this.severity === 'success',
        'p-badge-warning': this.severity === 'warning',
        'p-badge-danger': this.severity === 'danger'
      }];
    }

  }
};

function render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", {
    class: normalizeClass($options.badgeClass)
  }, [renderSlot(_ctx.$slots, "default", {}, () => [createTextVNode(toDisplayString$1($props.value), 1)])], 2);
}

script$16.render = render$l;

var script$1$4 = {
  emits: ['remove'],
  props: {
    files: {
      type: Array,
      default: () => []
    },
    badgeSeverity: {
      type: String,
      default: 'warning'
    },
    badgeValue: {
      type: String,
      default: null
    },
    previewWidth: {
      type: Number,
      default: 50
    }
  },
  methods: {
    formatSize(bytes) {
      if (bytes === 0) {
        return '0 B';
      }

      let k = 1000,
          dm = 3,
          sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
          i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

  },
  components: {
    FileUploadButton: script$1L,
    FileUploadBadge: script$16
  }
};
const _hoisted_1$1$4 = ["alt", "src", "width"];
const _hoisted_2$1$4 = {
  class: "p-fileupload-file-details"
};
const _hoisted_3$1$3 = {
  class: "p-fileupload-file-name"
};
const _hoisted_4$1$2 = {
  class: "p-fileupload-file-size"
};
const _hoisted_5$1$2 = {
  class: "p-fileupload-file-actions"
};

function render$1$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_FileUploadBadge = resolveComponent("FileUploadBadge");

  const _component_FileUploadButton = resolveComponent("FileUploadButton");

  return openBlock(true), createElementBlock(Fragment, null, renderList($props.files, (file, index) => {
    return openBlock(), createElementBlock("div", {
      key: file.name + file.type + file.size,
      class: "p-fileupload-file"
    }, [createElementVNode("img", {
      role: "presentation",
      class: "p-fileupload-file-thumbnail",
      alt: file.name,
      src: file.objectURL,
      width: $props.previewWidth
    }, null, 8, _hoisted_1$1$4), createElementVNode("div", _hoisted_2$1$4, [createElementVNode("div", _hoisted_3$1$3, toDisplayString$1(file.name), 1), createElementVNode("span", _hoisted_4$1$2, toDisplayString$1($options.formatSize(file.size)), 1), createVNode(_component_FileUploadBadge, {
      value: $props.badgeValue,
      class: "p-fileupload-file-badge",
      severity: $props.badgeSeverity
    }, null, 8, ["value", "severity"])]), createElementVNode("div", _hoisted_5$1$2, [createVNode(_component_FileUploadButton, {
      icon: "pi pi-times",
      onClick: $event => _ctx.$emit('remove', index),
      class: "p-fileupload-file-remove p-button-text p-button-danger p-button-rounded"
    }, null, 8, ["onClick"])])]);
  }), 128);
}

script$1$4.render = render$1$4;
var script$15 = {
  name: 'FileUpload',
  emits: ['select', 'uploader', 'before-upload', 'progress', 'upload', 'error', 'before-send', 'clear', 'remove', 'removeUploadedFile'],
  props: {
    name: {
      type: String,
      default: null
    },
    url: {
      type: String,
      default: null
    },
    mode: {
      type: String,
      default: 'advanced'
    },
    multiple: {
      type: Boolean,
      default: false
    },
    accept: {
      type: String,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    auto: {
      type: Boolean,
      default: false
    },
    maxFileSize: {
      type: Number,
      default: null
    },
    invalidFileSizeMessage: {
      type: String,
      default: '{0}: Invalid file size, file size should be smaller than {1}.'
    },
    invalidFileTypeMessage: {
      type: String,
      default: '{0}: Invalid file type, allowed file types: {1}.'
    },
    fileLimit: {
      type: Number,
      default: null
    },
    invalidFileLimitMessage: {
      type: String,
      default: 'Maximum number of files exceeded, limit is {0} at most.'
    },
    withCredentials: {
      type: Boolean,
      default: false
    },
    previewWidth: {
      type: Number,
      default: 50
    },
    chooseLabel: {
      type: String,
      default: null
    },
    uploadLabel: {
      type: String,
      default: null
    },
    cancelLabel: {
      type: String,
      default: null
    },
    customUpload: {
      type: Boolean,
      default: false
    },
    showUploadButton: {
      type: Boolean,
      default: true
    },
    showCancelButton: {
      type: Boolean,
      default: true
    },
    chooseIcon: {
      type: String,
      default: 'pi pi-plus'
    },
    uploadIcon: {
      type: String,
      default: 'pi pi-upload'
    },
    cancelIcon: {
      type: String,
      default: 'pi pi-times'
    },
    style: null,
    class: null
  },
  duplicateIEEvent: false,

  data() {
    return {
      uploadedFileCount: 0,
      files: [],
      messages: [],
      focused: false,
      progress: null,
      uploadedFiles: []
    };
  },

  methods: {
    onFileSelect(event) {
      if (event.type !== 'drop' && this.isIE11() && this.duplicateIEEvent) {
        this.duplicateIEEvent = false;
        return;
      }

      this.messages = [];
      this.files = this.files || [];
      let files = event.dataTransfer ? event.dataTransfer.files : event.target.files;

      for (let file of files) {
        if (!this.isFileSelected(file)) {
          if (this.validate(file)) {
            if (this.isImage(file)) {
              file.objectURL = window.URL.createObjectURL(file);
            }

            this.files.push(file);
          }
        }
      }

      this.$emit('select', {
        originalEvent: event,
        files: this.files
      });

      if (this.fileLimit) {
        this.checkFileLimit();
      }

      if (this.auto && this.hasFiles && !this.isFileLimitExceeded()) {
        this.upload();
      }

      if (event.type !== 'drop' && this.isIE11()) {
        this.clearIEInput();
      } else {
        this.clearInputElement();
      }
    },

    choose() {
      this.$refs.fileInput.click();
    },

    upload() {
      if (this.customUpload) {
        if (this.fileLimit) {
          this.uploadedFileCount += this.files.length;
        }

        this.$emit('uploader', {
          files: this.files
        });
        this.clear();
      } else {
        let xhr = new XMLHttpRequest();
        let formData = new FormData();
        this.$emit('before-upload', {
          xhr: xhr,
          formData: formData
        });

        for (let file of this.files) {
          formData.append(this.name, file, file.name);
        }

        xhr.upload.addEventListener('progress', event => {
          if (event.lengthComputable) {
            this.progress = Math.round(event.loaded * 100 / event.total);
          }

          this.$emit('progress', {
            originalEvent: event,
            progress: this.progress
          });
        });

        xhr.onreadystatechange = () => {
          if (xhr.readyState === 4) {
            this.progress = 0;

            if (xhr.status >= 200 && xhr.status < 300) {
              if (this.fileLimit) {
                this.uploadedFileCount += this.files.length;
              }

              this.$emit('upload', {
                xhr: xhr,
                files: this.files
              });
            } else {
              this.$emit('error', {
                xhr: xhr,
                files: this.files
              });
            }

            this.uploadedFiles.push(...this.files);
            this.clear();
          }
        };

        xhr.open('POST', this.url, true);
        this.$emit('before-send', {
          xhr: xhr,
          formData: formData
        });
        xhr.withCredentials = this.withCredentials;
        xhr.send(formData);
      }
    },

    clear() {
      this.files = [];
      this.messages = null;
      this.$emit('clear');

      if (this.isAdvanced) {
        this.clearInputElement();
      }
    },

    onFocus() {
      this.focused = true;
    },

    onBlur() {
      this.focused = false;
    },

    isFileSelected(file) {
      if (this.files && this.files.length) {
        for (let sFile of this.files) {
          if (sFile.name + sFile.type + sFile.size === file.name + file.type + file.size) return true;
        }
      }

      return false;
    },

    isIE11() {
      return !!window['MSInputMethodContext'] && !!document['documentMode'];
    },

    validate(file) {
      if (this.accept && !this.isFileTypeValid(file)) {
        this.messages.push(this.invalidFileTypeMessage.replace('{0}', file.name).replace('{1}', this.accept));
        return false;
      }

      if (this.maxFileSize && file.size > this.maxFileSize) {
        this.messages.push(this.invalidFileSizeMessage.replace('{0}', file.name).replace('{1}', this.formatSize(this.maxFileSize)));
        return false;
      }

      return true;
    },

    isFileTypeValid(file) {
      let acceptableTypes = this.accept.split(',').map(type => type.trim());

      for (let type of acceptableTypes) {
        let acceptable = this.isWildcard(type) ? this.getTypeClass(file.type) === this.getTypeClass(type) : file.type == type || this.getFileExtension(file).toLowerCase() === type.toLowerCase();

        if (acceptable) {
          return true;
        }
      }

      return false;
    },

    getTypeClass(fileType) {
      return fileType.substring(0, fileType.indexOf('/'));
    },

    isWildcard(fileType) {
      return fileType.indexOf('*') !== -1;
    },

    getFileExtension(file) {
      return '.' + file.name.split('.').pop();
    },

    isImage(file) {
      return /^image\//.test(file.type);
    },

    onDragEnter(event) {
      if (!this.disabled) {
        event.stopPropagation();
        event.preventDefault();
      }
    },

    onDragOver(event) {
      if (!this.disabled) {
        DomHandler.addClass(this.$refs.content, 'p-fileupload-highlight');
        event.stopPropagation();
        event.preventDefault();
      }
    },

    onDragLeave() {
      if (!this.disabled) {
        DomHandler.removeClass(this.$refs.content, 'p-fileupload-highlight');
      }
    },

    onDrop(event) {
      if (!this.disabled) {
        DomHandler.removeClass(this.$refs.content, 'p-fileupload-highlight');
        event.stopPropagation();
        event.preventDefault();
        const files = event.dataTransfer ? event.dataTransfer.files : event.target.files;
        const allowDrop = this.multiple || files && files.length === 1;

        if (allowDrop) {
          this.onFileSelect(event);
        }
      }
    },

    onBasicUploaderClick() {
      if (this.hasFiles) this.upload();else this.$refs.fileInput.click();
    },

    remove(index) {
      this.clearInputElement();
      let removedFile = this.files.splice(index, 1)[0];
      this.files = [...this.files];
      this.$emit('remove', {
        file: removedFile,
        files: this.files
      });
    },

    removeUploadedFile(index) {
      let removedFile = this.uploadedFiles.splice(index, 1)[0];
      this.uploadedFiles = [...this.uploadedFiles];
      this.$emit('removeUploadedFile', {
        file: removedFile,
        files: this.uploadedFiles
      });
    },

    clearInputElement() {
      this.$refs.fileInput.value = '';
    },

    clearIEInput() {
      if (this.$refs.fileInput) {
        this.duplicateIEEvent = true; //IE11 fix to prevent onFileChange trigger again

        this.$refs.fileInput.value = '';
      }
    },

    formatSize(bytes) {
      if (bytes === 0) {
        return '0 B';
      }

      let k = 1000,
          dm = 3,
          sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
          i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    },

    isFileLimitExceeded() {
      if (this.fileLimit && this.fileLimit <= this.files.length + this.uploadedFileCount && this.focused) {
        this.focused = false;
      }

      return this.fileLimit && this.fileLimit < this.files.length + this.uploadedFileCount;
    },

    checkFileLimit() {
      if (this.isFileLimitExceeded()) {
        this.messages.push(this.invalidFileLimitMessage.replace('{0}', this.fileLimit.toString()));
      }
    },

    onMessageClose() {
      this.messages = null;
    }

  },
  computed: {
    isAdvanced() {
      return this.mode === 'advanced';
    },

    isBasic() {
      return this.mode === 'basic';
    },

    advancedChooseButtonClass() {
      return ['p-button p-component p-fileupload-choose', this.class, {
        'p-disabled': this.disabled,
        'p-focus': this.focused
      }];
    },

    basicChooseButtonClass() {
      return ['p-button p-component p-fileupload-choose', this.class, {
        'p-fileupload-choose-selected': this.hasFiles,
        'p-disabled': this.disabled,
        'p-focus': this.focused
      }];
    },

    advancedChooseIconClass() {
      return ['p-button-icon p-button-icon-left pi-fw', this.chooseIcon];
    },

    basicChooseButtonIconClass() {
      return ['p-button-icon p-button-icon-left', !this.hasFiles || this.auto ? this.uploadIcon : this.chooseIcon];
    },

    basicChooseButtonLabel() {
      return this.auto ? this.chooseButtonLabel : this.hasFiles ? this.files.map(f => f.name).join(', ') : this.chooseButtonLabel;
    },

    hasFiles() {
      return this.files && this.files.length > 0;
    },

    hasUploadedFiles() {
      return this.uploadedFiles && this.uploadedFiles.length > 0;
    },

    chooseDisabled() {
      return this.disabled || this.fileLimit && this.fileLimit <= this.files.length + this.uploadedFileCount;
    },

    uploadDisabled() {
      return this.disabled || !this.hasFiles || this.fileLimit && this.fileLimit < this.files.length;
    },

    cancelDisabled() {
      return this.disabled || !this.hasFiles;
    },

    chooseButtonLabel() {
      return this.chooseLabel || this.$primevue.config.locale.choose;
    },

    uploadButtonLabel() {
      return this.uploadLabel || this.$primevue.config.locale.upload;
    },

    cancelButtonLabel() {
      return this.cancelLabel || this.$primevue.config.locale.cancel;
    },

    completedLabel() {
      return this.$primevue.config.locale.completed;
    },

    pendingLabel() {
      return this.$primevue.config.locale.pending;
    }

  },
  components: {
    FileUploadButton: script$1L,
    FileUploadProgressBar: script$17,
    FileUploadMessage: script$1K,
    FileContent: script$1$4
  },
  directives: {
    ripple: Ripple
  }
};
const _hoisted_1$x = {
  key: 0,
  class: "p-fileupload p-fileupload-advanced p-component"
};
const _hoisted_2$s = ["multiple", "accept", "disabled"];
const _hoisted_3$o = {
  class: "p-fileupload-buttonbar"
};
const _hoisted_4$j = {
  class: "p-button-label"
};
const _hoisted_5$f = {
  key: 0,
  class: "p-fileupload-empty"
};
const _hoisted_6$e = {
  key: 1,
  class: "p-fileupload p-fileupload-basic p-component"
};
const _hoisted_7$9 = {
  class: "p-button-label"
};
const _hoisted_8$8 = ["accept", "disabled", "multiple"];

function render$k(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_FileUploadButton = resolveComponent("FileUploadButton");

  const _component_FileUploadProgressBar = resolveComponent("FileUploadProgressBar");

  const _component_FileUploadMessage = resolveComponent("FileUploadMessage");

  const _component_FileContent = resolveComponent("FileContent");

  const _directive_ripple = resolveDirective("ripple");

  return $options.isAdvanced ? (openBlock(), createElementBlock("div", _hoisted_1$x, [createElementVNode("input", {
    ref: "fileInput",
    type: "file",
    onChange: _cache[0] || (_cache[0] = (...args) => $options.onFileSelect && $options.onFileSelect(...args)),
    multiple: $props.multiple,
    accept: $props.accept,
    disabled: $options.chooseDisabled
  }, null, 40, _hoisted_2$s), createElementVNode("div", _hoisted_3$o, [renderSlot(_ctx.$slots, "header", {
    files: $data.files,
    uploadedFiles: $data.uploadedFiles,
    chooseCallback: $options.choose,
    uploadCallback: $options.upload,
    clearCallback: $options.clear
  }, () => [withDirectives((openBlock(), createElementBlock("span", {
    class: normalizeClass($options.advancedChooseButtonClass),
    style: normalizeStyle($props.style),
    onClick: _cache[1] || (_cache[1] = (...args) => $options.choose && $options.choose(...args)),
    onKeydown: _cache[2] || (_cache[2] = withKeys((...args) => $options.choose && $options.choose(...args), ["enter"])),
    onFocus: _cache[3] || (_cache[3] = (...args) => $options.onFocus && $options.onFocus(...args)),
    onBlur: _cache[4] || (_cache[4] = (...args) => $options.onBlur && $options.onBlur(...args)),
    tabindex: "0"
  }, [createElementVNode("span", {
    class: normalizeClass($options.advancedChooseIconClass)
  }, null, 2), createElementVNode("span", _hoisted_4$j, toDisplayString$1($options.chooseButtonLabel), 1)], 38)), [[_directive_ripple]]), $props.showUploadButton ? (openBlock(), createBlock(_component_FileUploadButton, {
    key: 0,
    label: $options.uploadButtonLabel,
    icon: $props.uploadIcon,
    onClick: $options.upload,
    disabled: $options.uploadDisabled
  }, null, 8, ["label", "icon", "onClick", "disabled"])) : createCommentVNode("", true), $props.showCancelButton ? (openBlock(), createBlock(_component_FileUploadButton, {
    key: 1,
    label: $options.cancelButtonLabel,
    icon: $props.cancelIcon,
    onClick: $options.clear,
    disabled: $options.cancelDisabled
  }, null, 8, ["label", "icon", "onClick", "disabled"])) : createCommentVNode("", true)])]), createElementVNode("div", {
    ref: "content",
    class: "p-fileupload-content",
    onDragenter: _cache[5] || (_cache[5] = (...args) => $options.onDragEnter && $options.onDragEnter(...args)),
    onDragover: _cache[6] || (_cache[6] = (...args) => $options.onDragOver && $options.onDragOver(...args)),
    onDragleave: _cache[7] || (_cache[7] = (...args) => $options.onDragLeave && $options.onDragLeave(...args)),
    onDrop: _cache[8] || (_cache[8] = (...args) => $options.onDrop && $options.onDrop(...args))
  }, [renderSlot(_ctx.$slots, "content", {
    files: $data.files,
    uploadedFiles: $data.uploadedFiles,
    removeUploadedFileCallback: $options.removeUploadedFile,
    removeFileCallback: $options.remove,
    progress: $data.progress,
    messages: $data.messages
  }, () => [$options.hasFiles ? (openBlock(), createBlock(_component_FileUploadProgressBar, {
    key: 0,
    value: $data.progress,
    showValue: false
  }, null, 8, ["value"])) : createCommentVNode("", true), (openBlock(true), createElementBlock(Fragment, null, renderList($data.messages, msg => {
    return openBlock(), createBlock(_component_FileUploadMessage, {
      key: msg,
      severity: "error",
      onClose: $options.onMessageClose
    }, {
      default: withCtx(() => [createTextVNode(toDisplayString$1(msg), 1)]),
      _: 2
    }, 1032, ["onClose"]);
  }), 128)), $options.hasFiles ? (openBlock(), createBlock(_component_FileContent, {
    key: 1,
    files: $data.files,
    onRemove: $options.remove,
    badgeValue: $options.pendingLabel,
    previewWidth: $props.previewWidth
  }, null, 8, ["files", "onRemove", "badgeValue", "previewWidth"])) : createCommentVNode("", true), createVNode(_component_FileContent, {
    files: $data.uploadedFiles,
    onRemove: $options.removeUploadedFile,
    badgeValue: $options.completedLabel,
    badgeSeverity: "success",
    previewWidth: $props.previewWidth
  }, null, 8, ["files", "onRemove", "badgeValue", "previewWidth"])]), _ctx.$slots.empty && !$options.hasFiles && !$options.hasUploadedFiles ? (openBlock(), createElementBlock("div", _hoisted_5$f, [renderSlot(_ctx.$slots, "empty")])) : createCommentVNode("", true)], 544)])) : $options.isBasic ? (openBlock(), createElementBlock("div", _hoisted_6$e, [(openBlock(true), createElementBlock(Fragment, null, renderList($data.messages, msg => {
    return openBlock(), createBlock(_component_FileUploadMessage, {
      key: msg,
      severity: "error",
      onClose: $options.onMessageClose
    }, {
      default: withCtx(() => [createTextVNode(toDisplayString$1(msg), 1)]),
      _: 2
    }, 1032, ["onClose"]);
  }), 128)), withDirectives((openBlock(), createElementBlock("span", {
    class: normalizeClass($options.basicChooseButtonClass),
    style: normalizeStyle($props.style),
    onMouseup: _cache[12] || (_cache[12] = (...args) => $options.onBasicUploaderClick && $options.onBasicUploaderClick(...args)),
    onKeydown: _cache[13] || (_cache[13] = withKeys((...args) => $options.choose && $options.choose(...args), ["enter"])),
    onFocus: _cache[14] || (_cache[14] = (...args) => $options.onFocus && $options.onFocus(...args)),
    onBlur: _cache[15] || (_cache[15] = (...args) => $options.onBlur && $options.onBlur(...args)),
    tabindex: "0"
  }, [createElementVNode("span", {
    class: normalizeClass($options.basicChooseButtonIconClass)
  }, null, 2), createElementVNode("span", _hoisted_7$9, toDisplayString$1($options.basicChooseButtonLabel), 1), !$options.hasFiles ? (openBlock(), createElementBlock("input", {
    key: 0,
    ref: "fileInput",
    type: "file",
    accept: $props.accept,
    disabled: $props.disabled,
    multiple: $props.multiple,
    onChange: _cache[9] || (_cache[9] = (...args) => $options.onFileSelect && $options.onFileSelect(...args)),
    onFocus: _cache[10] || (_cache[10] = (...args) => $options.onFocus && $options.onFocus(...args)),
    onBlur: _cache[11] || (_cache[11] = (...args) => $options.onBlur && $options.onBlur(...args))
  }, null, 40, _hoisted_8$8)) : createCommentVNode("", true)], 38)), [[_directive_ripple]])])) : createCommentVNode("", true);
}

function styleInject$g(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$n = "\n.p-fileupload-content {\n    position: relative;\n}\n.p-fileupload-content .p-progressbar {\n    width: 100%;\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.p-button.p-fileupload-choose {\n    position: relative;\n    overflow: hidden;\n}\n.p-fileupload-buttonbar {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-wrap: wrap;\n        flex-wrap: wrap;\n}\n.p-fileupload > input[type='file'],\n.p-fileupload-basic input[type='file'] {\n    display: none;\n}\n.p-fluid .p-fileupload .p-button {\n    width: auto;\n}\n.p-fileupload-file {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-wrap: wrap;\n        flex-wrap: wrap;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n.p-fileupload-file-thumbnail {\n    -ms-flex-negative: 0;\n        flex-shrink: 0;\n}\n.p-fileupload-file-actions {\n    margin-left: auto;\n}\n";
styleInject$g(css_248z$n);
script$15.render = render$k;

// accept="image/*" 



var script$14 = {
  props: {
    bind : {
        type : Object,
        required : true
    },
    id : Number
},
  setup(__props) {

const props = __props;





function onUpload(e) {
    if (e.files.length == 0) {
        props.bind.value = null;
    } else {
        console.log("Value is", e.files[0]);
        props.bind.setValue(e.files[0]);
    }
}


return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$15), {
    mode: "basic",
    name: __props.bind.cell.name,
    customUpload: true,
    maxFileSize: 1000000,
    onSelect: onUpload
  }, null, 8 /* PROPS */, ["name"]))
}
}

};

script$14.__file = "presstojam/src/components/form/asset-edit.vue";

var script$13 = {
  name: 'Fieldset',
  emits: ['update:collapsed', 'toggle'],
  props: {
    legend: String,
    toggleable: Boolean,
    collapsed: Boolean,
    toggleButtonProps: String
  },

  data() {
    return {
      d_collapsed: this.collapsed
    };
  },

  watch: {
    collapsed(newValue) {
      this.d_collapsed = newValue;
    }

  },
  methods: {
    toggle(event) {
      this.d_collapsed = !this.d_collapsed;
      this.$emit('update:collapsed', this.d_collapsed);
      this.$emit('toggle', {
        originalEvent: event,
        value: this.d_collapsed
      });
    },

    onKeyDown(event) {
      if (event.code === 'Enter' || event.code === 'Space') {
        this.toggle(event);
        event.preventDefault();
      }
    }

  },
  computed: {
    iconClass() {
      return ['p-fieldset-toggler pi ', {
        'pi-minus': !this.d_collapsed,
        'pi-plus': this.d_collapsed
      }];
    },

    ariaId() {
      return UniqueComponentId();
    }

  },
  directives: {
    ripple: Ripple
  }
};
const _hoisted_1$w = {
  class: "p-fieldset-legend"
};
const _hoisted_2$r = ["id"];
const _hoisted_3$n = ["id", "aria-controls", "aria-expanded", "aria-label"];
const _hoisted_4$i = {
  class: "p-fieldset-legend-text"
};
const _hoisted_5$e = ["id", "aria-labelledby"];
const _hoisted_6$d = {
  class: "p-fieldset-content"
};

function render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_ripple = resolveDirective("ripple");

  return openBlock(), createElementBlock("fieldset", {
    class: normalizeClass(['p-fieldset p-component', {
      'p-fieldset-toggleable': $props.toggleable
    }])
  }, [createElementVNode("legend", _hoisted_1$w, [!$props.toggleable ? renderSlot(_ctx.$slots, "legend", {
    key: 0
  }, () => [createElementVNode("span", {
    id: $options.ariaId + '_header',
    class: "p-fieldset-legend-text"
  }, toDisplayString$1($props.legend), 9, _hoisted_2$r)]) : createCommentVNode("", true), $props.toggleable ? withDirectives((openBlock(), createElementBlock("a", {
    key: 1,
    id: $options.ariaId + '_header',
    tabindex: "0",
    role: "button",
    "aria-controls": $options.ariaId + '_content',
    "aria-expanded": !$data.d_collapsed,
    "aria-label": $props.toggleButtonProps || $props.legend,
    onClick: _cache[0] || (_cache[0] = (...args) => $options.toggle && $options.toggle(...args)),
    onKeydown: _cache[1] || (_cache[1] = (...args) => $options.onKeyDown && $options.onKeyDown(...args))
  }, [createElementVNode("span", {
    class: normalizeClass($options.iconClass)
  }, null, 2), renderSlot(_ctx.$slots, "legend", {}, () => [createElementVNode("span", _hoisted_4$i, toDisplayString$1($props.legend), 1)])], 40, _hoisted_3$n)), [[_directive_ripple]]) : createCommentVNode("", true)]), createVNode(Transition, {
    name: "p-toggleable-content"
  }, {
    default: withCtx(() => [withDirectives(createElementVNode("div", {
      id: $options.ariaId + '_content',
      class: "p-toggleable-content",
      role: "region",
      "aria-labelledby": $options.ariaId + '_header'
    }, [createElementVNode("div", _hoisted_6$d, [renderSlot(_ctx.$slots, "default")])], 8, _hoisted_5$e), [[vShow, !$data.d_collapsed]])]),
    _: 3
  })], 2);
}

function styleInject$f(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$m = "\n.p-fieldset-legend > a,\n.p-fieldset-legend > span {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n}\n.p-fieldset-toggleable .p-fieldset-legend a {\n    cursor: pointer;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n    overflow: hidden;\n    position: relative;\n    text-decoration: none;\n}\n.p-fieldset-legend-text {\n    line-height: 1;\n}\n";
styleInject$f(css_248z$m);
script$13.render = render$j;

var script$12 = {
  props: {
    bind : {
        type : Object,
        required : true
    },
    active_validation : Boolean,
    data : Object
},
  setup(__props) {

const props = __props;



let group = props.bind.getGroup();



const binds = computed(() => {
    const arr = [];
    for(let i in props.bind.cell.fields) {
        const gbind = group.getBind(props.bind.cell.name + "-" + i);
        if (gbind.active.value) {
            arr.push(gbind);
        } 
    }
    return arr;
});


return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$13), {
    legend: _ctx.$t('models.' + __props.bind.cell.model + '.fields.' + __props.bind.cell.name + '.label')
  }, {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(binds), (jbind) => {
        return (openBlock(), createElementBlock("div", {
          class: "field form-group",
          key: jbind.cell.name
        }, [
          createVNode(script$$, {
            bind: jbind,
            active_validation: __props.active_validation,
            data: __props.bind.cell.clean(__props.data)
          }, null, 8 /* PROPS */, ["bind", "active_validation", "data"])
        ]))
      }), 128 /* KEYED_FRAGMENT */))
    ]),
    _: 1 /* STABLE */
  }, 8 /* PROPS */, ["legend"]))
}
}

};

script$12.__file = "presstojam/src/components/form/json-edit.vue";

var script$11 = {
  props: {
    bind : {
        type : Object,
        required : true
    },
    active_validation : Boolean,
    data : Object
},
  setup(__props) {

const props = __props;



let group = props.bind.getGroup();



const binds = computed(() => {
    const arr = [];
    for(let i in props.bind.cell.fields) {
        const gbind = group.getBind(props.bind.cell.name + "-" + i);
        if (gbind.active.value) {
            arr.push(gbind);
        } 
    }
    return arr;
});


return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$13), {
    legend: _ctx.$t('models.' + __props.bind.cell.model + '.fields.' + __props.bind.cell.name + '.label')
  }, {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(binds), (jbind) => {
        return (openBlock(), createElementBlock("div", {
          class: "field form-group",
          key: jbind.cell.name
        }, [
          createVNode(script$$, {
            bind: jbind,
            active_validation: __props.active_validation,
            data: __props.bind.cell.clean(__props.data)
          }, null, 8 /* PROPS */, ["bind", "active_validation", "data"])
        ]))
      }), 128 /* KEYED_FRAGMENT */))
    ]),
    _: 1 /* STABLE */
  }, 8 /* PROPS */, ["legend"]))
}
}

};

script$11.__file = "presstojam/src/components/form/logic-edit.vue";

const _hoisted_1$v = { class: "invalid-feedback" };


var script$10 = {
  props: {
  bind :Object
},
  setup(__props) {

const props = __props;


const { t } = useI18n$1();



/*
  const OK = 0;
    const OutOfRangeMin = 1;
    const OutOfRangeMax = 2;
    const Characters = 3;
    const CharactersNegative = 4;
    const Unique = 5;
    const NullViolation = 6;
*/

const err_message = computed(() => {
  if (props.bind.error.value == 1) return t("errors.min",  { min : props.bind.cell.min });
  else if (props.bind.error.value == 2) return t("errors.max", { max : props.bind.cell.max });
  else if (props.bind.error.value == 3) return t("errors.contains", { char : props.bind.cell.contains });
  else if (props.bind.error.value == 4) return t("errors.notcontains",  { char : props.bind.cell.notcontains });
  else if (props.bind.error.value == 5) return t("errors.unique");
  else return "";
});


return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("div", _hoisted_1$v, toDisplayString$1(unref(err_message)), 1 /* TEXT */))
}
}

};

script$10.__file = "presstojam/src/components/form/error.vue";

const _hoisted_1$u = {
  key: 0,
  class: "form-check mt-3"
};
const _hoisted_2$q = { class: "offset-3 col-md-9" };
const _hoisted_3$m = ["for"];
const _hoisted_4$h = {
  key: 1,
  class: "json-group"
};
const _hoisted_5$d = {
  key: 2,
  class: "logic-group"
};
const _hoisted_6$c = {
  key: 3,
  class: "row"
};
const _hoisted_7$8 = ["for"];
const _hoisted_8$7 = { class: "col-md-9" };



var script$$ = {
  props: {
    bind : Object,
    active_validation : Boolean,
    data : Object
},
  setup(__props) {

const props = __props;

 



computed(() => {
    if (props.bind.show_error) return props.error;
    else return 0;
});



return (_ctx, _cache) => {
  return (__props.bind.cell.type=='flag')
    ? (openBlock(), createElementBlock("div", _hoisted_1$u, [
        createElementVNode("div", _hoisted_2$q, [
          createVNode(script$1l, { bind: __props.bind }, null, 8 /* PROPS */, ["bind"]),
          createElementVNode("label", {
            class: "form-check-label",
            for: __props.bind.cell.name
          }, toDisplayString$1(_ctx.$t("models." + __props.bind.cell.model + ".fields." + __props.bind.cell.name + ".label")), 9 /* TEXT, PROPS */, _hoisted_3$m),
          (__props.bind.show_error)
            ? (openBlock(), createBlock(script$10, {
                key: 0,
                bind: __props.bind
              }, null, 8 /* PROPS */, ["bind"]))
            : createCommentVNode("v-if", true)
        ])
      ]))
    : (__props.bind.cell.type=='json')
      ? (openBlock(), createElementBlock("div", _hoisted_4$h, [
          createVNode(script$12, {
            bind: __props.bind,
            active_validation: __props.active_validation,
            data: __props.data
          }, null, 8 /* PROPS */, ["bind", "active_validation", "data"])
        ]))
      : (__props.bind.cell.type=='logic')
        ? (openBlock(), createElementBlock("div", _hoisted_5$d, [
            createVNode(script$11, {
              bind: __props.bind,
              active_validation: __props.active_validation
            }, null, 8 /* PROPS */, ["bind", "active_validation"])
          ]))
        : (openBlock(), createElementBlock("div", _hoisted_6$c, [
            createElementVNode("label", {
              for: __props.bind.cell.name,
              class: "control-label col-md-3"
            }, toDisplayString$1(_ctx.$t("models." + __props.bind.cell.model + ".fields." + __props.bind.cell.name + ".label")), 9 /* TEXT, PROPS */, _hoisted_7$8),
            createElementVNode("div", _hoisted_8$7, [
              (__props.bind.cell.type=='number')
                ? (openBlock(), createBlock(script$1m, {
                    key: 0,
                    bind: __props.bind,
                    class: "col"
                  }, null, 8 /* PROPS */, ["bind"]))
                : (__props.bind.cell.type=='id')
                  ? (openBlock(), createBlock(script$1d, {
                      key: 1,
                      bind: __props.bind,
                      class: "col",
                      data: __props.data
                    }, null, 8 /* PROPS */, ["bind", "data"]))
                  : (__props.bind.cell.type=='asset')
                    ? (openBlock(), createBlock(script$14, {
                        key: 2,
                        bind: __props.bind,
                        class: "col"
                      }, null, 8 /* PROPS */, ["bind"]))
                    : (__props.bind.cell.type=='time')
                      ? (openBlock(), createBlock(script$1b, {
                          key: 3,
                          bind: __props.bind,
                          class: "col"
                        }, null, 8 /* PROPS */, ["bind"]))
                      : (__props.bind.cell.type=='json')
                        ? (openBlock(), createBlock(script$12, {
                            key: 4,
                            bind: __props.bind,
                            active_validation: __props.active_validation,
                            class: "col"
                          }, null, 8 /* PROPS */, ["bind", "active_validation"]))
                        : (openBlock(), createBlock(script$18, {
                            key: 5,
                            bind: __props.bind,
                            class: "col"
                          }, null, 8 /* PROPS */, ["bind"])),
              (__props.bind.show_error)
                ? (openBlock(), createBlock(script$10, {
                    key: 6,
                    bind: __props.bind,
                    class: "col"
                  }, null, 8 /* PROPS */, ["bind"]))
                : createCommentVNode("v-if", true)
            ])
          ]))
}
}

};

script$$.__file = "presstojam/src/components/form/edit-field.vue";

class Data {
  constructor(model_name) {
    this._model = new Model(model_name);
    this._is_loading = ref(false);
    this._load_promise = null;
    this._key = new Date().getTime();
    this._active = ref({});
    this._selected = ref([]);
    this._data = ref(null);
  }

  get selected() {
    return this._selected;
  }

  get store() {
    return this._model;
  }

  get model() {
    return this._model;
  }

  get active() {
    return this._active;
  }

  get fields() {
    return this._model.fields;
  }

  get is_loading() {
    return this._is_loading;
  }

  get data() {
    return this._data;
  }

  trigger(key) {
    this._model.trigger(key, this);
  }

}

class RepoData extends Data {
  constructor(model) {
    super(model);
    this._pagination = {
      rows_per_page: this._model.limit,
      count: ref(0),
      page: 0
    };
    this._parent_id = null;
    this._order = {};
    this._filters = {};
    this._count_promise = null;
    this._data.value = [];
  }

  get pagination() {
    return this._pagination;
  }

  get filters() {
    return this._filters;
  }

  get type() {
    return "repo";
  }

  get parent_id() {
    return this._parent_id;
  }

  set parent_id(id) {
    this._parent_id = id;
  }

  buildParams(all = false) {
    let filters = { ...this._filters
    };
    if (this._parent_id) filters["--parent"] = this._parent_id;

    if (this._pagination.rows_per_page && !all) {
      filters.__offset = this._pagination.page * this._pagination.rows_per_page;
    }

    return filters;
  }

  setPagination(page) {
    this._pagination.page = page;
    return this.reload();
  }

  hasPagination() {
    return this._pagination.rows_per_page ? true : false;
  }

  count() {
    if (!this._count_promise) {
      this._count_promise = this._model.loadCount(this.buildParams()).then(count => {
        this._pagination.count.value = count;
      });
    }

    return this._count_promise;
  }

  load() {
    if (!this._load_promise) {
      this._is_loading.value = true;
      this._load_promise = this.count().then(() => {
        return this._model.load(this.buildParams(), this._pagination.offset);
      });
    }

    this._load_promise.then(response => {
      this._data.value = response;
      this._is_loading.value = false;
    }).catch(e => {
      console.log(e);
      this.is_loading.value = false;
      throw e;
    });

    return this._load_promise;
  }

  loadAll() {
    let ocount = this._model.limit;
    this._model.limit = 0;

    const promise = this._model.load(this.buildParams(true));

    this._model.limit = ocount; //reset original limit

    return promise;
  }

  reload(params) {
    this._load_promise = null;
    return this.load(params);
  }

  addRow(iobj) {
    return this._model.reloadRow(iobj['--id']).then(response => {
      this._data.value.push(response);
    });
  }

  editRow(id) {
    return this._model.reloadRow(id).then(response => {
      for (const i in this._data.value) {
        if (this._data.value[i]['--id'] == response['--id']) {
          this._data.value[i] = response;
        }
      }
    });
  }

  remove(ids) {
    this._data.value.filter(function (item) {
      return !ids.include(item['--id']);
    });
  }

}

var script$_ = {
  props: {
    data : Object,
    common_id : Number,
    common_parent : String
},
  setup(__props) {

const props = __props;



inject("client");
const options = ref([]);

const repo = new RepoData(props.data.model.name);
repo.to = props.common_parent;

const params = {};
params[props.data.common_parent + "/--id"] = props.data.common_id; 
repo.filters = params;
repo.load()
.then(() => {
    options.value = repo.data.value;
});



let value;



return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$1j), {
    modelValue: unref(value),
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (isRef(value) ? (value).value = $event : value = $event)),
    options: options.value,
    placeholder: "Select Item"
  }, null, 8 /* PROPS */, ["modelValue", "options"]))
}
}

};

script$_.__file = "presstojam/src/components/form/parent-select.vue";

class BindGroup {
  constructor() {
    this._binds = {};
  }

  showValidation(val) {
    for (const i in this._binds) {
      this._binds[i].setShowError(val);
    }
  }

  regBind(i, bind) {
    this._binds[i] = bind;
    bind.setGroup(this);
  }

  getBind(i) {
    return this._binds[i];
  }

  trigger(field, value) {
    for (let i in this._binds) {
      const cell = this._binds[i].cell; //only need to change active value if there is a where clause

      if (cell.where && cell.where.on == field) {
        this._binds[i].active = cell.where.is == value;
      }
    }
  }

  setInitActive() {
    for (let i in this._binds) {
      this.trigger(this._binds[i].cell.name, this._binds[i].value);
    }
  }

  hasErrors() {
    for (let i in this._binds) {
      if (this._binds[i].error.value) return true;
    }
  }

}

class Bind {
  constructor(cell, value = null) {
    this._cell = cell;
    this._value = this._cell.clean(value);
    this._error = ref(0);
    this._is_dirty = false;
    this._bind_group;
    this._active = ref(true);
    this._show_error = ref(false);
  }

  get cell() {
    return this._cell;
  }

  get value() {
    return this._value;
  }

  get is_dirty() {
    if (this._cell.type == "json") {
      for (let i in this._cell.fields) {
        if (this._bind_group.getBind(this._cell.name + "-" + i).is_dirty) return true;
      }

      return false;
    } else {
      return this._is_dirty;
    }
  }

  get error() {
    return this._error;
  }

  set error(err) {
    this._error.value = err;
  }

  set active(active) {
    this._active.value = active;
  }

  get active() {
    return this._active;
  }

  get show_error() {
    return this._show_error;
  }

  set value(val) {
    this.setValue(val);
  }

  get classes() {
    if (!this._show_error.value) return "";

    if (this._error.value) {
      return "is-invalid";
    } else {
      return "is-valid";
    }
  }

  setShowError(val) {
    if (this._cell.type == "json") return;
    this._show_error.value = val;
  }

  setValue(val) {
    if (this._cell.multiple) {
      for (let i in val) {
        val[i] = this._cell.clean(val);
        if (!this._error.value) this._cell.validate(val[i]);
      }
    } else {
      val = this._cell.clean(val);
      this._error.value = this._cell.validate(val);
    }

    this._value = val;
    this.setDirty(true);

    this._bind_group.trigger(this._cell.name, this._value);
  }

  setDirty(dirty) {
    if (dirty) {
      this._is_dirty = dirty;
    }
  }

  setGroup(group) {
    this._bind_group = group;
  }

  getGroup() {
    return this._bind_group;
  }

}

var script$Z = {
  name: 'Panel',
  emits: ['update:collapsed', 'toggle'],
  props: {
    header: String,
    toggleable: Boolean,
    collapsed: Boolean,
    toggleButtonProps: String
  },

  data() {
    return {
      d_collapsed: this.collapsed
    };
  },

  watch: {
    collapsed(newValue) {
      this.d_collapsed = newValue;
    }

  },
  methods: {
    toggle(event) {
      this.d_collapsed = !this.d_collapsed;
      this.$emit('update:collapsed', this.d_collapsed);
      this.$emit('toggle', {
        originalEvent: event,
        value: this.d_collapsed
      });
    },

    onKeyDown(event) {
      if (event.code === 'Enter' || event.code === 'Space') {
        this.toggle(event);
        event.preventDefault();
      }
    }

  },
  computed: {
    ariaId() {
      return UniqueComponentId();
    },

    containerClass() {
      return ['p-panel p-component', {
        'p-panel-toggleable': this.toggleable
      }];
    }

  },
  directives: {
    ripple: Ripple
  }
};
const _hoisted_1$t = {
  class: "p-panel-header"
};
const _hoisted_2$p = ["id"];
const _hoisted_3$l = {
  class: "p-panel-icons"
};
const _hoisted_4$g = ["id", "aria-label", "aria-controls", "aria-expanded"];
const _hoisted_5$c = ["id", "aria-labelledby"];
const _hoisted_6$b = {
  class: "p-panel-content"
};

function render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_ripple = resolveDirective("ripple");

  return openBlock(), createElementBlock("div", {
    class: normalizeClass($options.containerClass)
  }, [createElementVNode("div", _hoisted_1$t, [renderSlot(_ctx.$slots, "header", {}, () => [$props.header ? (openBlock(), createElementBlock("span", {
    key: 0,
    id: $options.ariaId + '_header',
    class: "p-panel-title"
  }, toDisplayString$1($props.header), 9, _hoisted_2$p)) : createCommentVNode("", true)]), createElementVNode("div", _hoisted_3$l, [renderSlot(_ctx.$slots, "icons"), $props.toggleable ? withDirectives((openBlock(), createElementBlock("button", {
    key: 0,
    id: $options.ariaId + '_header',
    type: "button",
    role: "button",
    class: "p-panel-header-icon p-panel-toggler p-link",
    "aria-label": $props.toggleButtonProps || $props.header,
    "aria-controls": $options.ariaId + '_content',
    "aria-expanded": !$data.d_collapsed,
    onClick: _cache[0] || (_cache[0] = (...args) => $options.toggle && $options.toggle(...args)),
    onKeydown: _cache[1] || (_cache[1] = (...args) => $options.onKeyDown && $options.onKeyDown(...args))
  }, [createElementVNode("span", {
    class: normalizeClass({
      'pi pi-minus': !$data.d_collapsed,
      'pi pi-plus': $data.d_collapsed
    })
  }, null, 2)], 40, _hoisted_4$g)), [[_directive_ripple]]) : createCommentVNode("", true)])]), createVNode(Transition, {
    name: "p-toggleable-content"
  }, {
    default: withCtx(() => [withDirectives(createElementVNode("div", {
      id: $options.ariaId + '_content',
      class: "p-toggleable-content",
      role: "region",
      "aria-labelledby": $options.ariaId + '_header'
    }, [createElementVNode("div", _hoisted_6$b, [renderSlot(_ctx.$slots, "default")])], 8, _hoisted_5$c), [[vShow, !$data.d_collapsed]])]),
    _: 3
  })], 2);
}

function styleInject$e(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$l = "\n.p-panel-header {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-pack: justify;\n        -ms-flex-pack: justify;\n            justify-content: space-between;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n.p-panel-title {\n    line-height: 1;\n}\n.p-panel-header-icon {\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    cursor: pointer;\n    text-decoration: none;\n    overflow: hidden;\n    position: relative;\n}\n";
styleInject$e(css_248z$l);
script$Z.render = render$i;

var script$Y = {
  name: 'ProgressSpinner',
  props: {
    strokeWidth: {
      type: String,
      default: '2'
    },
    fill: {
      type: String,
      default: 'none'
    },
    animationDuration: {
      type: String,
      default: '2s'
    }
  },
  computed: {
    svgStyle() {
      return {
        'animation-duration': this.animationDuration
      };
    }

  }
};
const _hoisted_1$s = {
  class: "p-progress-spinner",
  role: "alert",
  "aria-busy": "true"
};
const _hoisted_2$o = ["fill", "stroke-width"];

function render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$s, [(openBlock(), createElementBlock("svg", {
    class: "p-progress-spinner-svg",
    viewBox: "25 25 50 50",
    style: normalizeStyle($options.svgStyle)
  }, [createElementVNode("circle", {
    class: "p-progress-spinner-circle",
    cx: "50",
    cy: "50",
    r: "20",
    fill: $props.fill,
    "stroke-width": $props.strokeWidth,
    strokeMiterlimit: "10"
  }, null, 8, _hoisted_2$o)], 4))]);
}

function styleInject$d(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$k = "\n.p-progress-spinner {\n    position: relative;\n    margin: 0 auto;\n    width: 100px;\n    height: 100px;\n    display: inline-block;\n}\n.p-progress-spinner::before {\n    content: '';\n    display: block;\n    padding-top: 100%;\n}\n.p-progress-spinner-svg {\n    -webkit-animation: p-progress-spinner-rotate 2s linear infinite;\n            animation: p-progress-spinner-rotate 2s linear infinite;\n    height: 100%;\n    -webkit-transform-origin: center center;\n            transform-origin: center center;\n    width: 100%;\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    margin: auto;\n}\n.p-progress-spinner-circle {\n    stroke-dasharray: 89, 200;\n    stroke-dashoffset: 0;\n    stroke: #d62d20;\n    -webkit-animation: p-progress-spinner-dash 1.5s ease-in-out infinite, p-progress-spinner-color 6s ease-in-out infinite;\n            animation: p-progress-spinner-dash 1.5s ease-in-out infinite, p-progress-spinner-color 6s ease-in-out infinite;\n    stroke-linecap: round;\n}\n@-webkit-keyframes p-progress-spinner-rotate {\n100% {\n        -webkit-transform: rotate(360deg);\n                transform: rotate(360deg);\n}\n}\n@keyframes p-progress-spinner-rotate {\n100% {\n        -webkit-transform: rotate(360deg);\n                transform: rotate(360deg);\n}\n}\n@-webkit-keyframes p-progress-spinner-dash {\n0% {\n        stroke-dasharray: 1, 200;\n        stroke-dashoffset: 0;\n}\n50% {\n        stroke-dasharray: 89, 200;\n        stroke-dashoffset: -35px;\n}\n100% {\n        stroke-dasharray: 89, 200;\n        stroke-dashoffset: -124px;\n}\n}\n@keyframes p-progress-spinner-dash {\n0% {\n        stroke-dasharray: 1, 200;\n        stroke-dashoffset: 0;\n}\n50% {\n        stroke-dasharray: 89, 200;\n        stroke-dashoffset: -35px;\n}\n100% {\n        stroke-dasharray: 89, 200;\n        stroke-dashoffset: -124px;\n}\n}\n@-webkit-keyframes p-progress-spinner-color {\n100%,\n    0% {\n        stroke: #d62d20;\n}\n40% {\n        stroke: #0057e7;\n}\n66% {\n        stroke: #008744;\n}\n80%,\n    90% {\n        stroke: #ffa700;\n}\n}\n@keyframes p-progress-spinner-color {\n100%,\n    0% {\n        stroke: #d62d20;\n}\n40% {\n        stroke: #0057e7;\n}\n66% {\n        stroke: #008744;\n}\n80%,\n    90% {\n        stroke: #ffa700;\n}\n}\n";
styleInject$d(css_248z$k);
script$Y.render = render$h;

function toTree(arr, schema, parent_id = 0) {
  const nodes = [];
  const items = arr.filter(obj => obj['--recursive'] == parent_id);

  for (const item of items) {
    let label = getLabel(schema, item);
    const obj = {
      key: item['--id'],
      "label": label,
      data: item
    };
    obj.children = toTree(arr, schema, obj.key);
    nodes.push(obj);
  }

  return nodes;
}
function toReferenceTree(arr, schema, parent_id = 0) {
  const nodes = [];
  const items = arr.filter(obj => obj['--recursive'] == parent_id);

  for (const item of items) {
    const obj = {
      key: item.value,
      "label": item.label,
      data: item
    };
    obj.children = toReferenceTree(arr, schema, obj.key);
    nodes.push(obj);
  }

  return nodes;
}
function getLabel(schema, data) {
  let label = [];

  for (let i in schema) {
    if (schema[i].summary) {
      label.push(data[i]);
    }
  }

  return label.join(" ");
}
function sortByDictionary(a, b) {
  if (a.value < b.value) {
    return -1;
  } else if (a.value > b.value) {
    return 1;
  } else {
    return 0;
  }
}
function rowToTree(obj, parent) {
  function walkObjTreeBuild(obj, links) {
    for (let i = 0; i < links.length; ++i) {
      if (!obj[links[i]]) obj[links[i]] = {};
      obj = obj[links[i]];
    }

    return obj;
  }

  let nobj = {};
  nobj[parent] = {};

  for (let i in obj) {
    if (i.indexOf("/") > -1) {
      const pts = i.split("/");
      const name = pts.pop();
      const cobj = walkObjTreeBuild(nobj, pts);
      cobj[name] = obj[i];
    } else {
      nobj[parent][i] = obj[i];
    }
  }

  return nobj;
}

class FormModel {
  constructor(name, id) {
    this._name = name;
    this._fields = {};
    this._id = id;
    this._editable_fields = [];
    this._parent = null;
    this._events;
    this._perms = [];
    const keys = Object.keys(this);
    keys.forEach(property => {
      if (property[0] == "_") {
        Object.defineProperty(this, property.substring(1), {
          get: function () {
            return this[property];
          },
          set: function (newValue) {
            this[property] = newValue;
          }
        });
      }
    });
    const entity = this.loadEntity();
    this.loadSettings();
    this.loadFields(entity);
  }

  get children_models() {
    return this._fields["--id"].reference;
  }

  getSettings() {
    let settings = configs.get("models");

    if (settings[this._name]) {
      return settings[this._name];
    }
  }

  loadSettings() {
    const settings = this.getSettings();

    if (settings) {
      if (settings.editable) this._editable_fields = settings.editable;
    }
  }

  loadEntity() {
    const entity = getEntity(this._name);

    if (!entity) {
      throw this._name;
    }

    if (entity.perms) this._perms = entity.perms;
    return entity;
  }

  loadFields(entity) {
    const fields = entity.cells;

    for (let i in fields) {
      if (!this._limited_fields || this._limited_fields.includes(slug + i)) {
        this._fields[i] = Object.assign(Object.create(fields[i]), fields[i]);
        this._fields[i].slug = i;
      }
    }
  }

  load() {
    const client = getClient();
    return client.get("/data/" + this._name + "/active", {
      "--id": this._id
    });
  }

  trigger(key, data) {
    if (this._events[key]) {
      this._events[key](data);
    }
  }

  setEditableCells(schema = null) {
    if (!schema) schema = this._fields;

    for (let i in schema) {
      schema[i].disabled = false;

      if (schema[i].slug != schema[i].name) {
        schema[i].disabled = true; //continue - don't use includes or parents

        continue;
      }

      if (schema[i].system || schema[i].immutable) {
        schema[i].disabled = true; //continue - don't use includes or parents

        continue;
      } //check if limited


      if (this._editable_fields.length && !this._editable_fields.includes(i)) {
        schema[i].disabled = true;
        continue;
      }

      if (schema[i].type == "json") {
        this.setEditableCells(schema[i].fields);
      }
    }
  }

  setCreateCells(schema = null) {
    if (!schema) schema = this._fields;

    for (let i in schema) {
      schema[i].disabled = false;

      if (schema[i].slug != schema[i].name) {
        schema[i].disabled = true; //continue - don't use includes or parents

        continue;
      }

      if (schema[i].system) {
        schema[i].disabled = true; //continue - don't use includes or parents

        continue;
      }

      if (schema[i].type == "json") {
        this.setCreateCells(schema[i].fields);
      }
    }
  }

  getEnabledCells() {
    let cells = {};

    for (let i in this._fields) {
      if (!this._fields[i].disabled) {
        cells[i] = this._fields[i];
      }
    }

    return cells;
  }

  getOptions(name, id) {
    const client = getClient();
    let url = "/reference/" + this._name + "/" + name;
    if (id) url += "/" + id;
    return client.get(url).then(response => {
      response.sort(sortByDictionary);
      return response;
    });
  }

  getRecursiveOptions(name, id) {
    const client = getClient();
    let url = "/reference/" + this._name + "/" + name;
    if (id) url += "/" + id;
    return client.get(url).then(response => {
      return toReferenceTree(response, this._fields);
    });
  }

}

const _hoisted_1$r = ["onSubmit"];
const _hoisted_2$n = {
  key: 0,
  class: "row mt-3"
};
const _hoisted_3$k = { class: "control-label col-md-3" };
const _hoisted_4$f = { class: "col-md-9" };
const _hoisted_5$b = { class: "row" };
const _hoisted_6$a = { class: "offset-3 col-9" };
const _hoisted_7$7 = /*#__PURE__*/createElementVNode("p", null, "Please do not refresh or close the browser until complete", -1 /* HOISTED */);
const _hoisted_8$6 = { style: {"text-align":"center"} };



var script$X = {
  props: {
    id : Number,
    entity_name : String,
    method : {
        type : String,
        default : 'post'
    }
},
  async setup(__props) {

let __temp, __restore;

const props = __props;


const Client = inject("client");






const global_error = ref("");
const processing = ref(false);
const status = ref(0);


const model = new FormModel(props.entity_name, props.id);
provide("model", model);


if (props.method == 'put') model.setEditableCells();
else model.setCreateCells();

const cells = model.getEnabledCells();

const bindGroup = new BindGroup();

let data = {};
if (props.method == "put") {
    data = (
  ([__temp,__restore] = withAsyncContext(() => model.load())),
  __temp = await __temp,
  __restore(),
  __temp
);
} else if (props.id) {
    data['--parent'] = props.id;
}

//if (model.parent) {
  //  bindGroup.addBind("--parent", new Bind(model.fields["--parent"], props.id));
//}


for(const field in cells) {
    const bind = new Bind(cells[field], data[field]);
    bindGroup.regBind(field, bind);
    if (cells[field].type == "json") {

        for(let ocell in cells[field].fields) {
            bindGroup.regBind(field + "-" + ocell, new Bind(cells[field].fields[ocell], (bind.value) ? bind.value[ocell] : null));
        }
    } 
}


bindGroup.setInitActive();



function setErrors(err) {
    if (typeof err === 'string' || err instanceof String) {
        err = JSON.parse(err);
    }
    for(let i in err) {
        const bind = bindGroup.getBind(i);
        bind.error = err[i][0];
    }
}

function serializeData() {
    const formData = new FormData();
    for(const i in cells) {
        const bind = bindGroup.getBind(i);
        if (bind.is_dirty ) {
            const field = bind.cell;
            if (field.type == "time") formData.append(i, bind.cell.buildString(bind.value));
            else if (field.type == "json") formData.append(i, JSON.stringify(bind.cell.buildJSON(bind)));
            else if (field.type != "asset" || props.method == 'post') {
                formData.append(i, bind.value);
            }
        }
    } 
    return formData;
}


function submitFiles() {
    const promises = [];
    for(const i in cells) {
        const bind = bindGroup.getBind(i);
        if (bind.is_dirty && bind.cell.type == "asset") {
            const formData = new FormData();
            formData.append(i, bind.value);
            promises.push(Client.post("/asset/" + model.name + "/" + bind.cell.name + "/" + props.id, formData));
        }
    }
    return promises; 
}



function submit() {

    
    bindGroup.showValidation(true);
    if (bindGroup.hasErrors()) {
        global_error.value = "Some fields have errors, please correct and resubmit";
        return;
    }
    processing.value = true;
 
    const data = serializeData();

    if (props.method == "put") {
        data.append("--id", props.id);
    } else if (props.method == "post" && props.id) {
        data.append("--parent", props.id);
    }         

    //return;
    let promise;
    console.log("Total is", Array.from(data.keys()).length);
    if (props.method == "put" && Array.from(data.keys()).length == 1) {
        promise = Promise.resolve(true);
    } else {
        promise = Client[props.method]("/data/" + model.name, data);
    }
    return promise
    .then(response => {
        if (props.method == "put" && response.data) {
            response.data["--id"] = props.id;
        }
        return response;
    })
    .then(response => {
        if (props.method == "put") {
            Promise.resolve(submitFiles())
            .then(() => {
                return response;
            });
        } else {
            return response;
        }
    })
    .then(response => {
        if (response && response['--dispatchid']) {
            runDispatch(response['--dispatchid'], response);
        } else {
            trigger("form_saved", response, props.method, model);
            processing.value = false;
        }
        return response;
    })
    .catch(err => {
        console.log(err);
        processing.value = false;
        if (err.status == 422) {
            global_error.value = "Some fields have errors, please correct and resubmit";
            setErrors(err.response.error);
        } else global_error.value = err.response.error;
    });
}


function runDispatch(id, oresponse) {
    const delay = 1000;
   
    function chkProgress() {
        Client.get("/dispatch/status/" + id)
        .then(response => {
            if (response.progress == "FAILED") {
                trigger("dispatch_failed", oresponse, props.method, model, response);
            } else if (response.progress == "PROCESSED" || !response.progress) {
                trigger("form_saved", oresponse, props.method, model, response);
            } else {
                status.value = response.progress;
                setTimeout(chkProgress, delay);
            }
        });
    }
    chkProgress();
}



return (_ctx, _cache) => {
  return (openBlock(), createElementBlock(Fragment, null, [
    withDirectives(createElementVNode("form", {
      onSubmit: withModifiers(submit, ["prevent"]),
      novalidate: ""
    }, [
      withDirectives(createVNode(unref(script$1K), { severity: "error" }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString$1(global_error.value), 1 /* TEXT */)
        ]),
        _: 1 /* STABLE */
      }, 512 /* NEED_PATCH */), [
        [vShow, global_error.value]
      ]),
      (unref(model).parent)
        ? (openBlock(), createElementBlock("div", _hoisted_2$n, [
            createElementVNode("label", _hoisted_3$k, toDisplayString$1(_ctx.$t("models." + _ctx.store.parent + ".title")), 1 /* TEXT */),
            createElementVNode("div", _hoisted_4$f, [
              createVNode(script$_, {
                modelValue: _ctx.proxy_values['--parent'],
                "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((_ctx.proxy_values['--parent']) = $event)),
                model: _ctx.store.parent,
                common_parent: _ctx.common_parent,
                common_parent_id: _ctx.common_parent_id
              }, null, 8 /* PROPS */, ["modelValue", "model", "common_parent", "common_parent_id"])
            ])
          ]))
        : createCommentVNode("v-if", true),
      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(cells), (cell) => {
        return (openBlock(), createBlock(script$$, {
          bind: unref(bindGroup).getBind(cell.name),
          key: cell.name,
          data: unref(data)
        }, null, 8 /* PROPS */, ["bind", "data"]))
      }), 128 /* KEYED_FRAGMENT */)),
      createElementVNode("div", _hoisted_5$b, [
        createElementVNode("div", _hoisted_6$a, [
          createVNode(unref(script$1L), {
            label: _ctx.$t('btns.save'),
            onClick: submit
          }, null, 8 /* PROPS */, ["label"])
        ])
      ])
    ], 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_1$r), [
      [vShow, processing.value == false]
    ]),
    withDirectives(createVNode(unref(script$Z), {
      Panel: "",
      header: "Processing"
    }, {
      default: withCtx(() => [
        _hoisted_7$7,
        createElementVNode("p", null, "Status: " + toDisplayString$1(status.value), 1 /* TEXT */),
        createElementVNode("p", _hoisted_8$6, [
          createVNode(unref(script$Y))
        ])
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */), [
      [vShow, processing.value]
    ])
  ], 64 /* STABLE_FRAGMENT */))
}
}

};

script$X.__file = "presstojam/src/components/form/form.vue";

var form = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': script$X
});

var script$W = {
  props: {
    model : String,
    parent_id : Number
},
  setup(__props) {

const props = __props;



const i18n = inject("i18n");
const t = i18n.t;


const client = getClient();

const current_model = ref(null);
const current_num = ref(0);
const repo = ref(null);

computed(() => {
    const cdata = {};
    if (props.parent_id) cdata["--parent"] = props.parent_id;
    return cdata; 
});

const header = computed(() => {
    return (current_model.value.parent)
        ? "Add " + t("models." + current_model.value + ".title", 1) + " to " + t("models." + current_model.value.parent + ".title", 1)
        : "Create " + t("models." + current_model.value + ".title", 1);
});

function checkData() {
    let url = "/check";
    if (props.model) url += "/" + props.model + "/" + props.parent_id;
    client.get(url)
    .then(checks => {
        for(const i in checks) {
            const entity = getEntity(i);
            if (entity.perms.includes("post") && entity.min_rows && entity.min_rows > checks[i]) {
                current_model.value = i;
                current_num.value = checks[i];
                if (current_num.value) {
                    repo.value = new RepoData(i);
                    repo.parent_id = props.parent_id;
                } else {
                    repo.value = null;
                }
                return;
            }
        }
        //if we get here, then no checks
        trigger("integrity_min_data", props.model, true);
    });
}


subscribe("form_saved", "integrity_min_data", () => {
    current_num.value = 0;
    current_model.value = '';
    checkData();
});

onBeforeUnmount(() => {
    unsubscribe("form_saved", "integrity_min_data");
});

checkData();


return (_ctx, _cache) => {
  return (openBlock(), createElementBlock(Fragment, null, [
    (current_num.value.value)
      ? (openBlock(), createBlock(script$1o, {
          key: 0,
          repo: repo.value
        }, null, 8 /* PROPS */, ["repo"]))
      : createCommentVNode("v-if", true),
    (current_model.value)
      ? (openBlock(), createBlock(unref(script$1N), { key: 1 }, {
          header: withCtx(() => [
            createElementVNode("h2", null, toDisplayString$1(unref(header)), 1 /* TEXT */)
          ]),
          content: withCtx(() => [
            createVNode(script$X, { entity_name: current_model.value }, null, 8 /* PROPS */, ["entity_name"])
          ]),
          _: 1 /* STABLE */
        }))
      : createCommentVNode("v-if", true)
  ], 64 /* STABLE_FRAGMENT */))
}
}

};

script$W.__file = "presstojam/src/components/dataintegrity/mindata.vue";

const _hoisted_1$q = { key: 2 };



var script$V = {
  async setup(__props) {

let __temp, __restore;


const _profile = configs.get("profile");

const name = ref("");


const client = inject("client");
const i18n = inject("i18n");
const router = inject("router");

const require_login = ref(false);
const integrity_check = ref(false);

const no_nav = configs.get("no_nav", false);


function loadRoutes() {
    const base = configs.get("base");

    return client.get("/user/site-map")
    .then(response => {
        return loadSiteMap(response);
    })
    .then(routes => {
        let def = false;

        for(const i in routes) {
            if (!def && !routes[i].parent) def = { path : base + "/" , name : 'home', redirect : base + "/data/" + i};
        }

        if (def) {
            router.addRoute(def);
        }
    })
    .then(() => {
       
    })
}


function loadDictionary() {
    return client.get("/user/dictionary")
    .then(response => {
        for(let i in response) {
            i18n.setLocaleMessage(i, response[i]);
        }
    });
}

function loadUser() {
    return client.get("/user/details")
    .then(response => {
        name.value = (response.name) ? response.name : response.email;
    });  
}
(
  ([__temp,__restore] = withAsyncContext(() => client.get("/user/check-user")
.then(response => {
    if (response.name != _profile) {
        require_login.value = true;
        return loadDictionary();
    } else {
        let promises = [];
        promises.push(loadUser());
        promises.push(loadDictionary());
        promises.push(loadRoutes());
        return Promise.all(promises);
    }    
}))),
  await __temp,
  __restore()
);


subscribe("integrity_min_data", "user", (model, check) => {
    if (!model) integrity_check.value = check;
});



return (_ctx, _cache) => {
  return (require_login.value)
    ? (openBlock(), createBlock(script$1F, { key: 0 }))
    : (integrity_check.value == false)
      ? (openBlock(), createBlock(script$W, { key: 1 }))
      : (openBlock(), createElementBlock("div", _hoisted_1$q, [
          (unref(no_nav) == false)
            ? (openBlock(), createBlock(script$1A, {
                key: 0,
                name: name.value
              }, null, 8 /* PROPS */, ["name"]))
            : createCommentVNode("v-if", true),
          createVNode(script$1E),
          createVNode(script$1y)
        ]))
}
}

};

script$V.__file = "presstojam/src/components/user.vue";

var script$U = {
  setup(__props) {


return (_ctx, _cache) => {
  return (openBlock(), createBlock(Suspense, null, {
    default: withCtx(() => [
      createVNode(script$V)
    ]),
    _: 1 /* STABLE */
  }))
}
}

};

script$U.__file = "presstojam/src/components/controller.vue";

/*!
  * vue-router v4.1.6
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */
const isBrowser = typeof window !== 'undefined';

function isESModule(obj) {
  return obj.__esModule || obj[Symbol.toStringTag] === 'Module';
}

const assign = Object.assign;

function applyToParams(fn, params) {
  const newParams = {};

  for (const key in params) {
    const value = params[key];
    newParams[key] = isArray$1(value) ? value.map(fn) : fn(value);
  }

  return newParams;
}

const noop$1 = () => {};
/**
 * Typesafe alternative to Array.isArray
 * https://github.com/microsoft/TypeScript/pull/48228
 */


const isArray$1 = Array.isArray;

function warn(msg) {
  // avoid using ...args as it breaks in older Edge builds
  const args = Array.from(arguments).slice(1);
  console.warn.apply(console, ['[Vue Router warn]: ' + msg].concat(args));
}

const TRAILING_SLASH_RE = /\/$/;

const removeTrailingSlash = path => path.replace(TRAILING_SLASH_RE, '');
/**
 * Transforms a URI into a normalized history location
 *
 * @param parseQuery
 * @param location - URI to normalize
 * @param currentLocation - current absolute location. Allows resolving relative
 * paths. Must start with `/`. Defaults to `/`
 * @returns a normalized history location
 */


function parseURL(parseQuery, location, currentLocation = '/') {
  let path,
      query = {},
      searchString = '',
      hash = ''; // Could use URL and URLSearchParams but IE 11 doesn't support it
  // TODO: move to new URL()

  const hashPos = location.indexOf('#');
  let searchPos = location.indexOf('?'); // the hash appears before the search, so it's not part of the search string

  if (hashPos < searchPos && hashPos >= 0) {
    searchPos = -1;
  }

  if (searchPos > -1) {
    path = location.slice(0, searchPos);
    searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);
    query = parseQuery(searchString);
  }

  if (hashPos > -1) {
    path = path || location.slice(0, hashPos); // keep the # character

    hash = location.slice(hashPos, location.length);
  } // no search and no query


  path = resolveRelativePath(path != null ? path : location, currentLocation); // empty path means a relative query or hash `?foo=f`, `#thing`

  return {
    fullPath: path + (searchString && '?') + searchString + hash,
    path,
    query,
    hash
  };
}
/**
 * Stringifies a URL object
 *
 * @param stringifyQuery
 * @param location
 */


function stringifyURL(stringifyQuery, location) {
  const query = location.query ? stringifyQuery(location.query) : '';
  return location.path + (query && '?') + query + (location.hash || '');
}
/**
 * Strips off the base from the beginning of a location.pathname in a non-case-sensitive way.
 *
 * @param pathname - location.pathname
 * @param base - base to strip off
 */


function stripBase(pathname, base) {
  // no base or base is not found at the beginning
  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase())) return pathname;
  return pathname.slice(base.length) || '/';
}
/**
 * Checks if two RouteLocation are equal. This means that both locations are
 * pointing towards the same {@link RouteRecord} and that all `params`, `query`
 * parameters and `hash` are the same
 *
 * @param a - first {@link RouteLocation}
 * @param b - second {@link RouteLocation}
 */


function isSameRouteLocation(stringifyQuery, a, b) {
  const aLastIndex = a.matched.length - 1;
  const bLastIndex = b.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery(a.query) === stringifyQuery(b.query) && a.hash === b.hash;
}
/**
 * Check if two `RouteRecords` are equal. Takes into account aliases: they are
 * considered equal to the `RouteRecord` they are aliasing.
 *
 * @param a - first {@link RouteRecord}
 * @param b - second {@link RouteRecord}
 */


function isSameRouteRecord(a, b) {
  // since the original record has an undefined value for aliasOf
  // but all aliases point to the original record, this will always compare
  // the original record
  return (a.aliasOf || a) === (b.aliasOf || b);
}

function isSameRouteLocationParams(a, b) {
  if (Object.keys(a).length !== Object.keys(b).length) return false;

  for (const key in a) {
    if (!isSameRouteLocationParamsValue(a[key], b[key])) return false;
  }

  return true;
}

function isSameRouteLocationParamsValue(a, b) {
  return isArray$1(a) ? isEquivalentArray(a, b) : isArray$1(b) ? isEquivalentArray(b, a) : a === b;
}
/**
 * Check if two arrays are the same or if an array with one single entry is the
 * same as another primitive value. Used to check query and parameters
 *
 * @param a - array of values
 * @param b - array of values or a single value
 */


function isEquivalentArray(a, b) {
  return isArray$1(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;
}
/**
 * Resolves a relative path that starts with `.`.
 *
 * @param to - path location we are resolving
 * @param from - currentLocation.path, should start with `/`
 */


function resolveRelativePath(to, from) {
  if (to.startsWith('/')) return to;

  if (process.env.NODE_ENV !== 'production' && !from.startsWith('/')) {
    warn(`Cannot resolve a relative location without an absolute path. Trying to resolve "${to}" from "${from}". It should look like "/${from}".`);
    return to;
  }

  if (!to) return from;
  const fromSegments = from.split('/');
  const toSegments = to.split('/');
  let position = fromSegments.length - 1;
  let toPosition;
  let segment;

  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition]; // we stay on the same position

    if (segment === '.') continue; // go up in the from array

    if (segment === '..') {
      // we can't go below zero, but we still need to increment toPosition
      if (position > 1) position--; // continue
    } // we reached a non-relative path, we stop here
    else break;
  }

  return fromSegments.slice(0, position).join('/') + '/' + toSegments // ensure we use at least the last element in the toSegments
  .slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join('/');
}

var NavigationType;

(function (NavigationType) {
  NavigationType["pop"] = "pop";
  NavigationType["push"] = "push";
})(NavigationType || (NavigationType = {}));

var NavigationDirection;

(function (NavigationDirection) {
  NavigationDirection["back"] = "back";
  NavigationDirection["forward"] = "forward";
  NavigationDirection["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));

/**
 * Normalizes a base by removing any trailing slash and reading the base tag if
 * present.
 *
 * @param base - base to normalize
 */

function normalizeBase(base) {
  if (!base) {
    if (isBrowser) {
      // respect <base> tag
      const baseEl = document.querySelector('base');
      base = baseEl && baseEl.getAttribute('href') || '/'; // strip full URL origin

      base = base.replace(/^\w+:\/\/[^\/]+/, '');
    } else {
      base = '/';
    }
  } // ensure leading slash when it was removed by the regex above avoid leading
  // slash with hash because the file could be read from the disk like file://
  // and the leading slash would cause problems


  if (base[0] !== '/' && base[0] !== '#') base = '/' + base; // remove the trailing slash so all other method can just do `base + fullPath`
  // to build an href

  return removeTrailingSlash(base);
} // remove any character before the hash


const BEFORE_HASH_RE = /^[^#]+#/;

function createHref(base, location) {
  return base.replace(BEFORE_HASH_RE, '#') + location;
}

function getElementPosition(el, offset) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset.behavior,
    left: elRect.left - docRect.left - (offset.left || 0),
    top: elRect.top - docRect.top - (offset.top || 0)
  };
}

const computeScrollPosition = () => ({
  left: window.pageXOffset,
  top: window.pageYOffset
});

function scrollToPosition(position) {
  let scrollToOptions;

  if ('el' in position) {
    const positionEl = position.el;
    const isIdSelector = typeof positionEl === 'string' && positionEl.startsWith('#');
    /**
     * `id`s can accept pretty much any characters, including CSS combinators
     * like `>` or `~`. It's still possible to retrieve elements using
     * `document.getElementById('~')` but it needs to be escaped when using
     * `document.querySelector('#\\~')` for it to be valid. The only
     * requirements for `id`s are them to be unique on the page and to not be
     * empty (`id=""`). Because of that, when passing an id selector, it should
     * be properly escaped for it to work with `querySelector`. We could check
     * for the id selector to be simple (no CSS combinators `+ >~`) but that
     * would make things inconsistent since they are valid characters for an
     * `id` but would need to be escaped when using `querySelector`, breaking
     * their usage and ending up in no selector returned. Selectors need to be
     * escaped:
     *
     * - `#1-thing` becomes `#\31 -thing`
     * - `#with~symbols` becomes `#with\\~symbols`
     *
     * - More information about  the topic can be found at
     *   https://mathiasbynens.be/notes/html5-id-class.
     * - Practical example: https://mathiasbynens.be/demo/html5-id
     */

    if (process.env.NODE_ENV !== 'production' && typeof position.el === 'string') {
      if (!isIdSelector || !document.getElementById(position.el.slice(1))) {
        try {
          const foundEl = document.querySelector(position.el);

          if (isIdSelector && foundEl) {
            warn(`The selector "${position.el}" should be passed as "el: document.querySelector('${position.el}')" because it starts with "#".`); // return to avoid other warnings

            return;
          }
        } catch (err) {
          warn(`The selector "${position.el}" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`); // return to avoid other warnings

          return;
        }
      }
    }

    const el = typeof positionEl === 'string' ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;

    if (!el) {
      process.env.NODE_ENV !== 'production' && warn(`Couldn't find element using selector "${position.el}" returned by scrollBehavior.`);
      return;
    }

    scrollToOptions = getElementPosition(el, position);
  } else {
    scrollToOptions = position;
  }

  if ('scrollBehavior' in document.documentElement.style) window.scrollTo(scrollToOptions);else {
    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
  }
}

function getScrollKey(path, delta) {
  const position = history.state ? history.state.position - delta : -1;
  return position + path;
}

const scrollPositions = new Map();

function saveScrollPosition(key, scrollPosition) {
  scrollPositions.set(key, scrollPosition);
}

function getSavedScrollPosition(key) {
  const scroll = scrollPositions.get(key); // consume it so it's not used again

  scrollPositions.delete(key);
  return scroll;
} // TODO: RFC about how to save scroll position

/**
 * ScrollBehavior instance used by the router to compute and restore the scroll
 * position when navigating.
 */
// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {
//   // returns a scroll position that can be saved in history
//   compute(): ScrollPositionEntry
//   // can take an extended ScrollPositionEntry
//   scroll(position: ScrollPosition): void
// }
// export const scrollHandler: ScrollHandler<ScrollPosition> = {
//   compute: computeScroll,
//   scroll: scrollToPosition,
// }


let createBaseLocation = () => location.protocol + '//' + location.host;
/**
 * Creates a normalized history location from a window.location object
 * @param location -
 */


function createCurrentLocation(base, location) {
  const {
    pathname,
    search,
    hash
  } = location; // allows hash bases like #, /#, #/, #!, #!/, /#!/, or even /folder#end

  const hashPos = base.indexOf('#');

  if (hashPos > -1) {
    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
    let pathFromHash = hash.slice(slicePos); // prepend the starting slash to hash so the url starts with /#

    if (pathFromHash[0] !== '/') pathFromHash = '/' + pathFromHash;
    return stripBase(pathFromHash, '');
  }

  const path = stripBase(pathname, base);
  return path + search + hash;
}

function useHistoryListeners(base, historyState, currentLocation, replace) {
  let listeners = [];
  let teardowns = []; // TODO: should it be a stack? a Dict. Check if the popstate listener
  // can trigger twice

  let pauseState = null;

  const popStateHandler = ({
    state
  }) => {
    const to = createCurrentLocation(base, location);
    const from = currentLocation.value;
    const fromState = historyState.value;
    let delta = 0;

    if (state) {
      currentLocation.value = to;
      historyState.value = state; // ignore the popstate and reset the pauseState

      if (pauseState && pauseState === from) {
        pauseState = null;
        return;
      }

      delta = fromState ? state.position - fromState.position : 0;
    } else {
      replace(to);
    } // console.log({ deltaFromCurrent })
    // Here we could also revert the navigation by calling history.go(-delta)
    // this listener will have to be adapted to not trigger again and to wait for the url
    // to be updated before triggering the listeners. Some kind of validation function would also
    // need to be passed to the listeners so the navigation can be accepted
    // call all listeners


    listeners.forEach(listener => {
      listener(currentLocation.value, from, {
        delta,
        type: NavigationType.pop,
        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
      });
    });
  };

  function pauseListeners() {
    pauseState = currentLocation.value;
  }

  function listen(callback) {
    // set up the listener and prepare teardown callbacks
    listeners.push(callback);

    const teardown = () => {
      const index = listeners.indexOf(callback);
      if (index > -1) listeners.splice(index, 1);
    };

    teardowns.push(teardown);
    return teardown;
  }

  function beforeUnloadListener() {
    const {
      history
    } = window;
    if (!history.state) return;
    history.replaceState(assign({}, history.state, {
      scroll: computeScrollPosition()
    }), '');
  }

  function destroy() {
    for (const teardown of teardowns) teardown();

    teardowns = [];
    window.removeEventListener('popstate', popStateHandler);
    window.removeEventListener('beforeunload', beforeUnloadListener);
  } // set up the listeners and prepare teardown callbacks


  window.addEventListener('popstate', popStateHandler);
  window.addEventListener('beforeunload', beforeUnloadListener);
  return {
    pauseListeners,
    listen,
    destroy
  };
}
/**
 * Creates a state object
 */


function buildState(back, current, forward, replaced = false, computeScroll = false) {
  return {
    back,
    current,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null
  };
}

function useHistoryStateNavigation(base) {
  const {
    history,
    location
  } = window; // private variables

  const currentLocation = {
    value: createCurrentLocation(base, location)
  };
  const historyState = {
    value: history.state
  }; // build current history entry as this is a fresh navigation

  if (!historyState.value) {
    changeLocation(currentLocation.value, {
      back: null,
      current: currentLocation.value,
      forward: null,
      // the length is off by one, we need to decrease it
      position: history.length - 1,
      replaced: true,
      // don't add a scroll as the user may have an anchor, and we want
      // scrollBehavior to be triggered without a saved position
      scroll: null
    }, true);
  }

  function changeLocation(to, state, replace) {
    /**
     * if a base tag is provided, and we are on a normal domain, we have to
     * respect the provided `base` attribute because pushState() will use it and
     * potentially erase anything before the `#` like at
     * https://github.com/vuejs/router/issues/685 where a base of
     * `/folder/#` but a base of `/` would erase the `/folder/` section. If
     * there is no host, the `<base>` tag makes no sense and if there isn't a
     * base tag we can just use everything after the `#`.
     */
    const hashIndex = base.indexOf('#');
    const url = hashIndex > -1 ? (location.host && document.querySelector('base') ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;

    try {
      // BROWSER QUIRK
      // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds
      history[replace ? 'replaceState' : 'pushState'](state, '', url);
      historyState.value = state;
    } catch (err) {
      if (process.env.NODE_ENV !== 'production') {
        warn('Error with push/replace State', err);
      } else {
        console.error(err);
      } // Force the navigation, this also resets the call count


      location[replace ? 'replace' : 'assign'](url);
    }
  }

  function replace(to, data) {
    const state = assign({}, history.state, buildState(historyState.value.back, // keep back and forward entries but override current position
    to, historyState.value.forward, true), data, {
      position: historyState.value.position
    });
    changeLocation(to, state, true);
    currentLocation.value = to;
  }

  function push(to, data) {
    // Add to current entry the information of where we are going
    // as well as saving the current position
    const currentState = assign({}, // use current history state to gracefully handle a wrong call to
    // history.replaceState
    // https://github.com/vuejs/router/issues/366
    historyState.value, history.state, {
      forward: to,
      scroll: computeScrollPosition()
    });

    if (process.env.NODE_ENV !== 'production' && !history.state) {
      warn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\n\n` + `history.replaceState(history.state, '', url)\n\n` + `You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);
    }

    changeLocation(currentState.current, currentState, true);
    const state = assign({}, buildState(currentLocation.value, to, null), {
      position: currentState.position + 1
    }, data);
    changeLocation(to, state, false);
    currentLocation.value = to;
  }

  return {
    location: currentLocation,
    state: historyState,
    push,
    replace
  };
}
/**
 * Creates an HTML5 history. Most common history for single page applications.
 *
 * @param base -
 */


function createWebHistory(base) {
  base = normalizeBase(base);
  const historyNavigation = useHistoryStateNavigation(base);
  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);

  function go(delta, triggerListeners = true) {
    if (!triggerListeners) historyListeners.pauseListeners();
    history.go(delta);
  }

  const routerHistory = assign({
    // it's overridden right after
    location: '',
    base,
    go,
    createHref: createHref.bind(null, base)
  }, historyNavigation, historyListeners);
  Object.defineProperty(routerHistory, 'location', {
    enumerable: true,
    get: () => historyNavigation.location.value
  });
  Object.defineProperty(routerHistory, 'state', {
    enumerable: true,
    get: () => historyNavigation.state.value
  });
  return routerHistory;
}

function isRouteLocation(route) {
  return typeof route === 'string' || route && typeof route === 'object';
}

function isRouteName(name) {
  return typeof name === 'string' || typeof name === 'symbol';
}
/**
 * Initial route location where the router is. Can be used in navigation guards
 * to differentiate the initial navigation.
 *
 * @example
 * ```js
 * import { START_LOCATION } from 'vue-router'
 *
 * router.beforeEach((to, from) => {
 *   if (from === START_LOCATION) {
 *     // initial navigation
 *   }
 * })
 * ```
 */


const START_LOCATION_NORMALIZED = {
  path: '/',
  name: undefined,
  params: {},
  query: {},
  hash: '',
  fullPath: '/',
  matched: [],
  meta: {},
  redirectedFrom: undefined
};
const NavigationFailureSymbol = Symbol(process.env.NODE_ENV !== 'production' ? 'navigation failure' : '');
/**
 * Enumeration with all possible types for navigation failures. Can be passed to
 * {@link isNavigationFailure} to check for specific failures.
 */

var NavigationFailureType;

(function (NavigationFailureType) {
  /**
   * An aborted navigation is a navigation that failed because a navigation
   * guard returned `false` or called `next(false)`
   */
  NavigationFailureType[NavigationFailureType["aborted"] = 4] = "aborted";
  /**
   * A cancelled navigation is a navigation that failed because a more recent
   * navigation finished started (not necessarily finished).
   */

  NavigationFailureType[NavigationFailureType["cancelled"] = 8] = "cancelled";
  /**
   * A duplicated navigation is a navigation that failed because it was
   * initiated while already being at the exact same location.
   */

  NavigationFailureType[NavigationFailureType["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {})); // DEV only debug messages


const ErrorTypeMessages = {
  [1
  /* ErrorTypes.MATCHER_NOT_FOUND */
  ]({
    location,
    currentLocation
  }) {
    return `No match for\n ${JSON.stringify(location)}${currentLocation ? '\nwhile being at\n' + JSON.stringify(currentLocation) : ''}`;
  },

  [2
  /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
  ]({
    from,
    to
  }) {
    return `Redirected from "${from.fullPath}" to "${stringifyRoute(to)}" via a navigation guard.`;
  },

  [4
  /* ErrorTypes.NAVIGATION_ABORTED */
  ]({
    from,
    to
  }) {
    return `Navigation aborted from "${from.fullPath}" to "${to.fullPath}" via a navigation guard.`;
  },

  [8
  /* ErrorTypes.NAVIGATION_CANCELLED */
  ]({
    from,
    to
  }) {
    return `Navigation cancelled from "${from.fullPath}" to "${to.fullPath}" with a new navigation.`;
  },

  [16
  /* ErrorTypes.NAVIGATION_DUPLICATED */
  ]({
    from,
    to
  }) {
    return `Avoided redundant navigation to current location: "${from.fullPath}".`;
  }

};

function createRouterError(type, params) {
  // keep full error messages in cjs versions
  if (process.env.NODE_ENV !== 'production' || !true) {
    return assign(new Error(ErrorTypeMessages[type](params)), {
      type,
      [NavigationFailureSymbol]: true
    }, params);
  } else {
    return assign(new Error(), {
      type,
      [NavigationFailureSymbol]: true
    }, params);
  }
}

function isNavigationFailure(error, type) {
  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
}

const propertiesToLog = ['params', 'query', 'hash'];

function stringifyRoute(to) {
  if (typeof to === 'string') return to;
  if ('path' in to) return to.path;
  const location = {};

  for (const key of propertiesToLog) {
    if (key in to) location[key] = to[key];
  }

  return JSON.stringify(location, null, 2);
} // default pattern for a param: non-greedy everything but /


const BASE_PARAM_PATTERN = '[^/]+?';
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
}; // Special Regex characters that must be escaped in static tokens

const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
/**
 * Creates a path parser from an array of Segments (a segment is an array of Tokens)
 *
 * @param segments - array of segments returned by tokenizePath
 * @param extraOptions - optional options for the regexp
 * @returns a PathParser
 */

function tokensToParser(segments, extraOptions) {
  const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions); // the amount of scores is the same as the length of segments except for the root segment "/"

  const score = []; // the regexp as a string

  let pattern = options.start ? '^' : ''; // extracted keys

  const keys = [];

  for (const segment of segments) {
    // the root segment needs special treatment
    const segmentScores = segment.length ? [] : [90
    /* PathScore.Root */
    ]; // allow trailing slash

    if (options.strict && !segment.length) pattern += '/';

    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token = segment[tokenIndex]; // resets the score if we are inside a sub-segment /:a-other-:b

      let subSegmentScore = 40
      /* PathScore.Segment */
      + (options.sensitive ? 0.25
      /* PathScore.BonusCaseSensitive */
      : 0);

      if (token.type === 0
      /* TokenType.Static */
      ) {
        // prepend the slash if we are starting a new segment
        if (!tokenIndex) pattern += '/';
        pattern += token.value.replace(REGEX_CHARS_RE, '\\$&');
        subSegmentScore += 40
        /* PathScore.Static */
        ;
      } else if (token.type === 1
      /* TokenType.Param */
      ) {
        const {
          value,
          repeatable,
          optional,
          regexp
        } = token;
        keys.push({
          name: value,
          repeatable,
          optional
        });
        const re = regexp ? regexp : BASE_PARAM_PATTERN; // the user provided a custom regexp /:id(\\d+)

        if (re !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10
          /* PathScore.BonusCustomRegExp */
          ; // make sure the regexp is valid before using it

          try {
            new RegExp(`(${re})`);
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value}" (${re}): ` + err.message);
          }
        } // when we repeat we must take care of the repeating leading slash


        let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`; // prepend the slash if we are starting a new segment

        if (!tokenIndex) subPattern = // avoid an optional / if there are more segments e.g. /:p?-static
        // or /:p?-:p2
        optional && segment.length < 2 ? `(?:/${subPattern})` : '/' + subPattern;
        if (optional) subPattern += '?';
        pattern += subPattern;
        subSegmentScore += 20
        /* PathScore.Dynamic */
        ;
        if (optional) subSegmentScore += -8
        /* PathScore.BonusOptional */
        ;
        if (repeatable) subSegmentScore += -20
        /* PathScore.BonusRepeatable */
        ;
        if (re === '.*') subSegmentScore += -50
        /* PathScore.BonusWildcard */
        ;
      }

      segmentScores.push(subSegmentScore);
    } // an empty array like /home/ -> [[{home}], []]
    // if (!segment.length) pattern += '/'


    score.push(segmentScores);
  } // only apply the strict bonus to the last score


  if (options.strict && options.end) {
    const i = score.length - 1;
    score[i][score[i].length - 1] += 0.7000000000000001
    /* PathScore.BonusStrict */
    ;
  } // TODO: dev only warn double trailing slash


  if (!options.strict) pattern += '/?';
  if (options.end) pattern += '$'; // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else
  else if (options.strict) pattern += '(?:/|$)';
  const re = new RegExp(pattern, options.sensitive ? '' : 'i');

  function parse(path) {
    const match = path.match(re);
    const params = {};
    if (!match) return null;

    for (let i = 1; i < match.length; i++) {
      const value = match[i] || '';
      const key = keys[i - 1];
      params[key.name] = value && key.repeatable ? value.split('/') : value;
    }

    return params;
  }

  function stringify(params) {
    let path = ''; // for optional parameters to allow to be empty

    let avoidDuplicatedSlash = false;

    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path.endsWith('/')) path += '/';
      avoidDuplicatedSlash = false;

      for (const token of segment) {
        if (token.type === 0
        /* TokenType.Static */
        ) {
          path += token.value;
        } else if (token.type === 1
        /* TokenType.Param */
        ) {
          const {
            value,
            repeatable,
            optional
          } = token;
          const param = value in params ? params[value] : '';

          if (isArray$1(param) && !repeatable) {
            throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
          }

          const text = isArray$1(param) ? param.join('/') : param;

          if (!text) {
            if (optional) {
              // if we have more than one optional param like /:a?-static we don't need to care about the optional param
              if (segment.length < 2) {
                // remove the last slash as we could be at the end
                if (path.endsWith('/')) path = path.slice(0, -1); // do not append a slash on the next iteration
                else avoidDuplicatedSlash = true;
              }
            } else throw new Error(`Missing required param "${value}"`);
          }

          path += text;
        }
      }
    } // avoid empty path when we have multiple optional params


    return path || '/';
  }

  return {
    re,
    score,
    keys,
    parse,
    stringify
  };
}
/**
 * Compares an array of numbers as used in PathParser.score and returns a
 * number. This function can be used to `sort` an array
 *
 * @param a - first array of numbers
 * @param b - second array of numbers
 * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b
 * should be sorted first
 */


function compareScoreArray(a, b) {
  let i = 0;

  while (i < a.length && i < b.length) {
    const diff = b[i] - a[i]; // only keep going if diff === 0

    if (diff) return diff;
    i++;
  } // if the last subsegment was Static, the shorter segments should be sorted first
  // otherwise sort the longest segment first


  if (a.length < b.length) {
    return a.length === 1 && a[0] === 40
    /* PathScore.Static */
    + 40
    /* PathScore.Segment */
    ? -1 : 1;
  } else if (a.length > b.length) {
    return b.length === 1 && b[0] === 40
    /* PathScore.Static */
    + 40
    /* PathScore.Segment */
    ? 1 : -1;
  }

  return 0;
}
/**
 * Compare function that can be used with `sort` to sort an array of PathParser
 *
 * @param a - first PathParser
 * @param b - second PathParser
 * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b
 */


function comparePathParserScore(a, b) {
  let i = 0;
  const aScore = a.score;
  const bScore = b.score;

  while (i < aScore.length && i < bScore.length) {
    const comp = compareScoreArray(aScore[i], bScore[i]); // do not return if both are equal

    if (comp) return comp;
    i++;
  }

  if (Math.abs(bScore.length - aScore.length) === 1) {
    if (isLastScoreNegative(aScore)) return 1;
    if (isLastScoreNegative(bScore)) return -1;
  } // if a and b share the same score entries but b has more, sort b first


  return bScore.length - aScore.length; // this is the ternary version
  // return aScore.length < bScore.length
  //   ? 1
  //   : aScore.length > bScore.length
  //   ? -1
  //   : 0
}
/**
 * This allows detecting splats at the end of a path: /home/:id(.*)*
 *
 * @param score - score to check
 * @returns true if the last entry is negative
 */


function isLastScoreNegative(score) {
  const last = score[score.length - 1];
  return score.length > 0 && last[last.length - 1] < 0;
}

const ROOT_TOKEN = {
  type: 0
  /* TokenType.Static */
  ,
  value: ''
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/; // After some profiling, the cache seems to be unnecessary because tokenizePath
// (the slowest part of adding a route) is very fast
// const tokenCache = new Map<string, Token[][]>()

function tokenizePath(path) {
  if (!path) return [[]];
  if (path === '/') return [[ROOT_TOKEN]];

  if (!path.startsWith('/')) {
    throw new Error(process.env.NODE_ENV !== 'production' ? `Route paths should start with a "/": "${path}" should be "/${path}".` : `Invalid path "${path}"`);
  } // if (tokenCache.has(path)) return tokenCache.get(path)!


  function crash(message) {
    throw new Error(`ERR (${state})/"${buffer}": ${message}`);
  }

  let state = 0
  /* TokenizerState.Static */
  ;
  let previousState = state;
  const tokens = []; // the segment will always be valid because we get into the initial state
  // with the leading /

  let segment;

  function finalizeSegment() {
    if (segment) tokens.push(segment);
    segment = [];
  } // index on the path


  let i = 0; // char at index

  let char; // buffer of the value read

  let buffer = ''; // custom regexp for a param

  let customRe = '';

  function consumeBuffer() {
    if (!buffer) return;

    if (state === 0
    /* TokenizerState.Static */
    ) {
      segment.push({
        type: 0
        /* TokenType.Static */
        ,
        value: buffer
      });
    } else if (state === 1
    /* TokenizerState.Param */
    || state === 2
    /* TokenizerState.ParamRegExp */
    || state === 3
    /* TokenizerState.ParamRegExpEnd */
    ) {
      if (segment.length > 1 && (char === '*' || char === '+')) crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: 1
        /* TokenType.Param */
        ,
        value: buffer,
        regexp: customRe,
        repeatable: char === '*' || char === '+',
        optional: char === '*' || char === '?'
      });
    } else {
      crash('Invalid state to consume buffer');
    }

    buffer = '';
  }

  function addCharToBuffer() {
    buffer += char;
  }

  while (i < path.length) {
    char = path[i++];

    if (char === '\\' && state !== 2
    /* TokenizerState.ParamRegExp */
    ) {
      previousState = state;
      state = 4
      /* TokenizerState.EscapeNext */
      ;
      continue;
    }

    switch (state) {
      case 0
      /* TokenizerState.Static */
      :
        if (char === '/') {
          if (buffer) {
            consumeBuffer();
          }

          finalizeSegment();
        } else if (char === ':') {
          consumeBuffer();
          state = 1
          /* TokenizerState.Param */
          ;
        } else {
          addCharToBuffer();
        }

        break;

      case 4
      /* TokenizerState.EscapeNext */
      :
        addCharToBuffer();
        state = previousState;
        break;

      case 1
      /* TokenizerState.Param */
      :
        if (char === '(') {
          state = 2
          /* TokenizerState.ParamRegExp */
          ;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state = 0
          /* TokenizerState.Static */
          ; // go back one character if we were not modifying

          if (char !== '*' && char !== '?' && char !== '+') i--;
        }

        break;

      case 2
      /* TokenizerState.ParamRegExp */
      :
        // TODO: is it worth handling nested regexp? like :p(?:prefix_([^/]+)_suffix)
        // it already works by escaping the closing )
        // https://paths.esm.dev/?p=AAMeJbiAwQEcDKbAoAAkP60PG2R6QAvgNaA6AFACM2ABuQBB#
        // is this really something people need since you can also write
        // /prefix_:p()_suffix
        if (char === ')') {
          // handle the escaped )
          if (customRe[customRe.length - 1] == '\\') customRe = customRe.slice(0, -1) + char;else state = 3
          /* TokenizerState.ParamRegExpEnd */
          ;
        } else {
          customRe += char;
        }

        break;

      case 3
      /* TokenizerState.ParamRegExpEnd */
      :
        // same as finalizing a param
        consumeBuffer();
        state = 0
        /* TokenizerState.Static */
        ; // go back one character if we were not modifying

        if (char !== '*' && char !== '?' && char !== '+') i--;
        customRe = '';
        break;

      default:
        crash('Unknown state');
        break;
    }
  }

  if (state === 2
  /* TokenizerState.ParamRegExp */
  ) crash(`Unfinished custom RegExp for param "${buffer}"`);
  consumeBuffer();
  finalizeSegment(); // tokenCache.set(path, tokens)

  return tokens;
}

function createRouteRecordMatcher(record, parent, options) {
  const parser = tokensToParser(tokenizePath(record.path), options); // warn against params with the same name

  if (process.env.NODE_ENV !== 'production') {
    const existingKeys = new Set();

    for (const key of parser.keys) {
      if (existingKeys.has(key.name)) warn(`Found duplicated params with name "${key.name}" for path "${record.path}". Only the last one will be available on "$route.params".`);
      existingKeys.add(key.name);
    }
  }

  const matcher = assign(parser, {
    record,
    parent,
    // these needs to be populated by the parent
    children: [],
    alias: []
  });

  if (parent) {
    // both are aliases or both are not aliases
    // we don't want to mix them because the order is used when
    // passing originalRecord in Matcher.addRoute
    if (!matcher.record.aliasOf === !parent.record.aliasOf) parent.children.push(matcher);
  }

  return matcher;
}
/**
 * Creates a Router Matcher.
 *
 * @internal
 * @param routes - array of initial routes
 * @param globalOptions - global route options
 */


function createRouterMatcher(routes, globalOptions) {
  // normalized ordered array of matchers
  const matchers = [];
  const matcherMap = new Map();
  globalOptions = mergeOptions({
    strict: false,
    end: true,
    sensitive: false
  }, globalOptions);

  function getRecordMatcher(name) {
    return matcherMap.get(name);
  }

  function addRoute(record, parent, originalRecord) {
    // used later on to remove by name
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);

    if (process.env.NODE_ENV !== 'production') {
      checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent);
    } // we might be the child of an alias


    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options = mergeOptions(globalOptions, record); // generate an array of records to correctly handle aliases

    const normalizedRecords = [mainNormalizedRecord];

    if ('alias' in record) {
      const aliases = typeof record.alias === 'string' ? [record.alias] : record.alias;

      for (const alias of aliases) {
        normalizedRecords.push(assign({}, mainNormalizedRecord, {
          // this allows us to hold a copy of the `components` option
          // so that async components cache is hold on the original record
          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
          path: alias,
          // we might be the child of an alias
          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord // the aliases are always of the same kind as the original since they
          // are defined on the same record

        }));
      }
    }

    let matcher;
    let originalMatcher;

    for (const normalizedRecord of normalizedRecords) {
      const {
        path
      } = normalizedRecord; // Build up the path for nested routes if the child isn't an absolute
      // route. Only add the / delimiter if the child path isn't empty and if the
      // parent path doesn't have a trailing slash

      if (parent && path[0] !== '/') {
        const parentPath = parent.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === '/' ? '' : '/';
        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
      }

      if (process.env.NODE_ENV !== 'production' && normalizedRecord.path === '*') {
        throw new Error('Catch all routes ("*") must now be defined using a param with a custom regexp.\n' + 'See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');
      } // create the object beforehand, so it can be passed to children


      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
      if (process.env.NODE_ENV !== 'production' && parent && path[0] === '/') checkMissingParamsInAbsolutePath(matcher, parent); // if we are an alias we must tell the original record that we exist,
      // so we can be removed

      if (originalRecord) {
        originalRecord.alias.push(matcher);

        if (process.env.NODE_ENV !== 'production') {
          checkSameParams(originalRecord, matcher);
        }
      } else {
        // otherwise, the first record is the original and others are aliases
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher) originalMatcher.alias.push(matcher); // remove the route if named and only for the top record (avoid in nested calls)
        // this works because the original record is the first one

        if (isRootAdd && record.name && !isAliasRecord(matcher)) removeRoute(record.name);
      }

      if (mainNormalizedRecord.children) {
        const children = mainNormalizedRecord.children;

        for (let i = 0; i < children.length; i++) {
          addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
        }
      } // if there was no original record, then the first one was not an alias and all
      // other aliases (if any) need to reference this record when adding children


      originalRecord = originalRecord || matcher; // TODO: add normalized records for more flexibility
      // if (parent && isAliasRecord(originalRecord)) {
      //   parent.children.push(originalRecord)
      // }
      // Avoid adding a record that doesn't display anything. This allows passing through records without a component to
      // not be reached and pass through the catch all route

      if (matcher.record.components && Object.keys(matcher.record.components).length || matcher.record.name || matcher.record.redirect) {
        insertMatcher(matcher);
      }
    }

    return originalMatcher ? () => {
      // since other matchers are aliases, they should be removed by the original matcher
      removeRoute(originalMatcher);
    } : noop$1;
  }

  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);

      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index = matchers.indexOf(matcherRef);

      if (index > -1) {
        matchers.splice(index, 1);
        if (matcherRef.record.name) matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }

  function getRoutes() {
    return matchers;
  }

  function insertMatcher(matcher) {
    let i = 0;

    while (i < matchers.length && comparePathParserScore(matcher, matchers[i]) >= 0 && ( // Adding children with empty path should still appear before the parent
    // https://github.com/vuejs/router/issues/1124
    matcher.record.path !== matchers[i].record.path || !isRecordChildOf(matcher, matchers[i]))) i++;

    matchers.splice(i, 0, matcher); // only add the original record to the name map

    if (matcher.record.name && !isAliasRecord(matcher)) matcherMap.set(matcher.record.name, matcher);
  }

  function resolve(location, currentLocation) {
    let matcher;
    let params = {};
    let path;
    let name;

    if ('name' in location && location.name) {
      matcher = matcherMap.get(location.name);
      if (!matcher) throw createRouterError(1
      /* ErrorTypes.MATCHER_NOT_FOUND */
      , {
        location
      }); // warn if the user is passing invalid params so they can debug it better when they get removed

      if (process.env.NODE_ENV !== 'production') {
        const invalidParams = Object.keys(location.params || {}).filter(paramName => !matcher.keys.find(k => k.name === paramName));

        if (invalidParams.length) {
          warn(`Discarded invalid param(s) "${invalidParams.join('", "')}" when navigating. See https://github.com/vuejs/router/blob/main/packages/router/CHANGELOG.md#414-2022-08-22 for more details.`);
        }
      }

      name = matcher.record.name;
      params = assign( // paramsFromLocation is a new object
      paramsFromLocation(currentLocation.params, // only keep params that exist in the resolved location
      // TODO: only keep optional params coming from a parent record
      matcher.keys.filter(k => !k.optional).map(k => k.name)), // discard any existing params in the current location that do not exist here
      // #1497 this ensures better active/exact matching
      location.params && paramsFromLocation(location.params, matcher.keys.map(k => k.name))); // throws if cannot be stringified

      path = matcher.stringify(params);
    } else if ('path' in location) {
      // no need to resolve the path with the matcher as it was provided
      // this also allows the user to control the encoding
      path = location.path;

      if (process.env.NODE_ENV !== 'production' && !path.startsWith('/')) {
        warn(`The Matcher cannot resolve relative paths but received "${path}". Unless you directly called \`matcher.resolve("${path}")\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/router.`);
      }

      matcher = matchers.find(m => m.re.test(path)); // matcher should have a value after the loop

      if (matcher) {
        // we know the matcher works because we tested the regexp
        params = matcher.parse(path);
        name = matcher.record.name;
      } // location is a relative path

    } else {
      // match by name or path of current route
      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find(m => m.re.test(currentLocation.path));
      if (!matcher) throw createRouterError(1
      /* ErrorTypes.MATCHER_NOT_FOUND */
      , {
        location,
        currentLocation
      });
      name = matcher.record.name; // since we are navigating to the same location, we don't need to pick the
      // params like when `name` is provided

      params = assign({}, currentLocation.params, location.params);
      path = matcher.stringify(params);
    }

    const matched = [];
    let parentMatcher = matcher;

    while (parentMatcher) {
      // reversed order so parents are at the beginning
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }

    return {
      name,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  } // add initial routes


  routes.forEach(route => addRoute(route));
  return {
    addRoute,
    resolve,
    removeRoute,
    getRoutes,
    getRecordMatcher
  };
}

function paramsFromLocation(params, keys) {
  const newParams = {};

  for (const key of keys) {
    if (key in params) newParams[key] = params[key];
  }

  return newParams;
}
/**
 * Normalizes a RouteRecordRaw. Creates a copy
 *
 * @param record
 * @returns the normalized version
 */


function normalizeRouteRecord(record) {
  return {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: undefined,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: new Set(),
    updateGuards: new Set(),
    enterCallbacks: {},
    components: 'components' in record ? record.components || null : record.component && {
      default: record.component
    }
  };
}
/**
 * Normalize the optional `props` in a record to always be an object similar to
 * components. Also accept a boolean for components.
 * @param record
 */


function normalizeRecordProps(record) {
  const propsObject = {}; // props does not exist on redirect records, but we can set false directly

  const props = record.props || false;

  if ('component' in record) {
    propsObject.default = props;
  } else {
    // NOTE: we could also allow a function to be applied to every component.
    // Would need user feedback for use cases
    for (const name in record.components) propsObject[name] = typeof props === 'boolean' ? props : props[name];
  }

  return propsObject;
}
/**
 * Checks if a record or any of its parent is an alias
 * @param record
 */


function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf) return true;
    record = record.parent;
  }

  return false;
}
/**
 * Merge meta fields of an array of records
 *
 * @param matched - array of matched records
 */


function mergeMetaFields(matched) {
  return matched.reduce((meta, record) => assign(meta, record.meta), {});
}

function mergeOptions(defaults, partialOptions) {
  const options = {};

  for (const key in defaults) {
    options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
  }

  return options;
}

function isSameParam(a, b) {
  return a.name === b.name && a.optional === b.optional && a.repeatable === b.repeatable;
}
/**
 * Check if a path and its alias have the same required params
 *
 * @param a - original record
 * @param b - alias record
 */


function checkSameParams(a, b) {
  for (const key of a.keys) {
    if (!key.optional && !b.keys.find(isSameParam.bind(null, key))) return warn(`Alias "${b.record.path}" and the original record: "${a.record.path}" must have the exact same param named "${key.name}"`);
  }

  for (const key of b.keys) {
    if (!key.optional && !a.keys.find(isSameParam.bind(null, key))) return warn(`Alias "${b.record.path}" and the original record: "${a.record.path}" must have the exact same param named "${key.name}"`);
  }
}
/**
 * A route with a name and a child with an empty path without a name should warn when adding the route
 *
 * @param mainNormalizedRecord - RouteRecordNormalized
 * @param parent - RouteRecordMatcher
 */


function checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent) {
  if (parent && parent.record.name && !mainNormalizedRecord.name && !mainNormalizedRecord.path) {
    warn(`The route named "${String(parent.record.name)}" has a child without a name and an empty path. Using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to remove the warning.`);
  }
}

function checkMissingParamsInAbsolutePath(record, parent) {
  for (const key of parent.keys) {
    if (!record.keys.find(isSameParam.bind(null, key))) return warn(`Absolute path "${record.record.path}" must have the exact same param named "${key.name}" as its parent "${parent.record.path}".`);
  }
}

function isRecordChildOf(record, parent) {
  return parent.children.some(child => child === record || isRecordChildOf(record, child));
}
/**
 * Encoding Rules ␣ = Space Path: ␣ " < > # ? { } Query: ␣ " < > # & = Hash: ␣ "
 * < > `
 *
 * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)
 * defines some extra characters to be encoded. Most browsers do not encode them
 * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to
 * also encode `!'()*`. Leaving un-encoded only ASCII alphanumeric(`a-zA-Z0-9`)
 * plus `-._~`. This extra safety should be applied to query by patching the
 * string returned by encodeURIComponent encodeURI also encodes `[\]^`. `\`
 * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\`
 * into a `/` if directly typed in. The _backtick_ (`````) should also be
 * encoded everywhere because some browsers like FF encode it when directly
 * written while others don't. Safari and IE don't encode ``"<>{}``` in hash.
 */
// const EXTRA_RESERVED_RE = /[!'()*]/g
// const encodeReservedReplacer = (c: string) => '%' + c.charCodeAt(0).toString(16)


const HASH_RE = /#/g; // %23

const AMPERSAND_RE = /&/g; // %26

const SLASH_RE = /\//g; // %2F

const EQUAL_RE = /=/g; // %3D

const IM_RE = /\?/g; // %3F

const PLUS_RE = /\+/g; // %2B

/**
 * NOTE: It's not clear to me if we should encode the + symbol in queries, it
 * seems to be less flexible than not doing so and I can't find out the legacy
 * systems requiring this for regular requests like text/html. In the standard,
 * the encoding of the plus character is only mentioned for
 * application/x-www-form-urlencoded
 * (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo
 * leave the plus character as is in queries. To be more flexible, we allow the
 * plus character on the query, but it can also be manually encoded by the user.
 *
 * Resources:
 * - https://url.spec.whatwg.org/#urlencoded-parsing
 * - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20
 */

const ENC_BRACKET_OPEN_RE = /%5B/g; // [

const ENC_BRACKET_CLOSE_RE = /%5D/g; // ]

const ENC_CARET_RE = /%5E/g; // ^

const ENC_BACKTICK_RE = /%60/g; // `

const ENC_CURLY_OPEN_RE = /%7B/g; // {

const ENC_PIPE_RE = /%7C/g; // |

const ENC_CURLY_CLOSE_RE = /%7D/g; // }

const ENC_SPACE_RE = /%20/g; // }

/**
 * Encode characters that need to be encoded on the path, search and hash
 * sections of the URL.
 *
 * @internal
 * @param text - string to encode
 * @returns encoded string
 */

function commonEncode(text) {
  return encodeURI('' + text).replace(ENC_PIPE_RE, '|').replace(ENC_BRACKET_OPEN_RE, '[').replace(ENC_BRACKET_CLOSE_RE, ']');
}
/**
 * Encode characters that need to be encoded on the hash section of the URL.
 *
 * @param text - string to encode
 * @returns encoded string
 */


function encodeHash(text) {
  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, '{').replace(ENC_CURLY_CLOSE_RE, '}').replace(ENC_CARET_RE, '^');
}
/**
 * Encode characters that need to be encoded query values on the query
 * section of the URL.
 *
 * @param text - string to encode
 * @returns encoded string
 */


function encodeQueryValue(text) {
  return commonEncode(text) // Encode the space as +, encode the + to differentiate it from the space
  .replace(PLUS_RE, '%2B').replace(ENC_SPACE_RE, '+').replace(HASH_RE, '%23').replace(AMPERSAND_RE, '%26').replace(ENC_BACKTICK_RE, '`').replace(ENC_CURLY_OPEN_RE, '{').replace(ENC_CURLY_CLOSE_RE, '}').replace(ENC_CARET_RE, '^');
}
/**
 * Like `encodeQueryValue` but also encodes the `=` character.
 *
 * @param text - string to encode
 */


function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, '%3D');
}
/**
 * Encode characters that need to be encoded on the path section of the URL.
 *
 * @param text - string to encode
 * @returns encoded string
 */


function encodePath(text) {
  return commonEncode(text).replace(HASH_RE, '%23').replace(IM_RE, '%3F');
}
/**
 * Encode characters that need to be encoded on the path section of the URL as a
 * param. This function encodes everything {@link encodePath} does plus the
 * slash (`/`) character. If `text` is `null` or `undefined`, returns an empty
 * string instead.
 *
 * @param text - string to encode
 * @returns encoded string
 */


function encodeParam(text) {
  return text == null ? '' : encodePath(text).replace(SLASH_RE, '%2F');
}
/**
 * Decode text using `decodeURIComponent`. Returns the original text if it
 * fails.
 *
 * @param text - string to decode
 * @returns decoded string
 */


function decode(text) {
  try {
    return decodeURIComponent('' + text);
  } catch (err) {
    process.env.NODE_ENV !== 'production' && warn(`Error decoding "${text}". Using original value`);
  }

  return '' + text;
}
/**
 * Transforms a queryString into a {@link LocationQuery} object. Accept both, a
 * version with the leading `?` and without Should work as URLSearchParams

 * @internal
 *
 * @param search - search string to parse
 * @returns a query object
 */


function parseQuery(search) {
  const query = {}; // avoid creating an object with an empty key and empty value
  // because of split('&')

  if (search === '' || search === '?') return query;
  const hasLeadingIM = search[0] === '?';
  const searchParams = (hasLeadingIM ? search.slice(1) : search).split('&');

  for (let i = 0; i < searchParams.length; ++i) {
    // pre decode the + into space
    const searchParam = searchParams[i].replace(PLUS_RE, ' '); // allow the = character

    const eqPos = searchParam.indexOf('=');
    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));

    if (key in query) {
      // an extra variable for ts types
      let currentValue = query[key];

      if (!isArray$1(currentValue)) {
        currentValue = query[key] = [currentValue];
      }

      currentValue.push(value);
    } else {
      query[key] = value;
    }
  }

  return query;
}
/**
 * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it
 * doesn't prepend a `?`
 *
 * @internal
 *
 * @param query - query object to stringify
 * @returns string version of the query without the leading `?`
 */


function stringifyQuery(query) {
  let search = '';

  for (let key in query) {
    const value = query[key];
    key = encodeQueryKey(key);

    if (value == null) {
      // only null adds the value
      if (value !== undefined) {
        search += (search.length ? '&' : '') + key;
      }

      continue;
    } // keep null values


    const values = isArray$1(value) ? value.map(v => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];
    values.forEach(value => {
      // skip undefined values in arrays as if they were not present
      // smaller code than using filter
      if (value !== undefined) {
        // only append & with non-empty search
        search += (search.length ? '&' : '') + key;
        if (value != null) search += '=' + value;
      }
    });
  }

  return search;
}
/**
 * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting
 * numbers into strings, removing keys with an undefined value and replacing
 * undefined with null in arrays
 *
 * @param query - query object to normalize
 * @returns a normalized query object
 */


function normalizeQuery(query) {
  const normalizedQuery = {};

  for (const key in query) {
    const value = query[key];

    if (value !== undefined) {
      normalizedQuery[key] = isArray$1(value) ? value.map(v => v == null ? null : '' + v) : value == null ? value : '' + value;
    }
  }

  return normalizedQuery;
}
/**
 * RouteRecord being rendered by the closest ancestor Router View. Used for
 * `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View
 * Location Matched
 *
 * @internal
 */


const matchedRouteKey = Symbol(process.env.NODE_ENV !== 'production' ? 'router view location matched' : '');
/**
 * Allows overriding the router view depth to control which component in
 * `matched` is rendered. rvd stands for Router View Depth
 *
 * @internal
 */

const viewDepthKey = Symbol(process.env.NODE_ENV !== 'production' ? 'router view depth' : '');
/**
 * Allows overriding the router instance returned by `useRouter` in tests. r
 * stands for router
 *
 * @internal
 */

const routerKey = Symbol(process.env.NODE_ENV !== 'production' ? 'router' : '');
/**
 * Allows overriding the current route returned by `useRoute` in tests. rl
 * stands for route location
 *
 * @internal
 */

const routeLocationKey = Symbol(process.env.NODE_ENV !== 'production' ? 'route location' : '');
/**
 * Allows overriding the current route used by router-view. Internally this is
 * used when the `route` prop is passed.
 *
 * @internal
 */

const routerViewLocationKey = Symbol(process.env.NODE_ENV !== 'production' ? 'router view location' : '');
/**
 * Create a list of callbacks that can be reset. Used to create before and after navigation guards list
 */

function useCallbacks() {
  let handlers = [];

  function add(handler) {
    handlers.push(handler);
    return () => {
      const i = handlers.indexOf(handler);
      if (i > -1) handlers.splice(i, 1);
    };
  }

  function reset() {
    handlers = [];
  }

  return {
    add,
    list: () => handlers,
    reset
  };
}

function guardToPromiseFn(guard, to, from, record, name) {
  // keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place
  const enterCallbackArray = record && ( // name is defined if record is because of the function overload
  record.enterCallbacks[name] = record.enterCallbacks[name] || []);
  return () => new Promise((resolve, reject) => {
    const next = valid => {
      if (valid === false) {
        reject(createRouterError(4
        /* ErrorTypes.NAVIGATION_ABORTED */
        , {
          from,
          to
        }));
      } else if (valid instanceof Error) {
        reject(valid);
      } else if (isRouteLocation(valid)) {
        reject(createRouterError(2
        /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        , {
          from: to,
          to: valid
        }));
      } else {
        if (enterCallbackArray && // since enterCallbackArray is truthy, both record and name also are
        record.enterCallbacks[name] === enterCallbackArray && typeof valid === 'function') {
          enterCallbackArray.push(valid);
        }

        resolve();
      }
    }; // wrapping with Promise.resolve allows it to work with both async and sync guards


    const guardReturn = guard.call(record && record.instances[name], to, from, process.env.NODE_ENV !== 'production' ? canOnlyBeCalledOnce(next, to, from) : next);
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3) guardCall = guardCall.then(next);

    if (process.env.NODE_ENV !== 'production' && guard.length > 2) {
      const message = `The "next" callback was never called inside of ${guard.name ? '"' + guard.name + '"' : ''}:\n${guard.toString()}\n. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.`;

      if (typeof guardReturn === 'object' && 'then' in guardReturn) {
        guardCall = guardCall.then(resolvedValue => {
          // @ts-expect-error: _called is added at canOnlyBeCalledOnce
          if (!next._called) {
            warn(message);
            return Promise.reject(new Error('Invalid navigation guard'));
          }

          return resolvedValue;
        });
      } else if (guardReturn !== undefined) {
        // @ts-expect-error: _called is added at canOnlyBeCalledOnce
        if (!next._called) {
          warn(message);
          reject(new Error('Invalid navigation guard'));
          return;
        }
      }
    }

    guardCall.catch(err => reject(err));
  });
}

function canOnlyBeCalledOnce(next, to, from) {
  let called = 0;
  return function () {
    if (called++ === 1) warn(`The "next" callback was called more than once in one navigation guard when going from "${from.fullPath}" to "${to.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`); // @ts-expect-error: we put it in the original one because it's easier to check

    next._called = true;
    if (called === 1) next.apply(null, arguments);
  };
}

function extractComponentsGuards(matched, guardType, to, from) {
  const guards = [];

  for (const record of matched) {
    if (process.env.NODE_ENV !== 'production' && !record.components && !record.children.length) {
      warn(`Record with path "${record.path}" is either missing a "component(s)"` + ` or "children" property.`);
    }

    for (const name in record.components) {
      let rawComponent = record.components[name];

      if (process.env.NODE_ENV !== 'production') {
        if (!rawComponent || typeof rawComponent !== 'object' && typeof rawComponent !== 'function') {
          warn(`Component "${name}" in record with path "${record.path}" is not` + ` a valid component. Received "${String(rawComponent)}".`); // throw to ensure we stop here but warn to ensure the message isn't
          // missed by the user

          throw new Error('Invalid route component');
        } else if ('then' in rawComponent) {
          // warn if user wrote import('/component.vue') instead of () =>
          // import('./component.vue')
          warn(`Component "${name}" in record with path "${record.path}" is a ` + `Promise instead of a function that returns a Promise. Did you ` + `write "import('./MyPage.vue')" instead of ` + `"() => import('./MyPage.vue')" ? This will break in ` + `production if not fixed.`);
          const promise = rawComponent;

          rawComponent = () => promise;
        } else if (rawComponent.__asyncLoader && // warn only once per component
        !rawComponent.__warnedDefineAsync) {
          rawComponent.__warnedDefineAsync = true;
          warn(`Component "${name}" in record with path "${record.path}" is defined ` + `using "defineAsyncComponent()". ` + `Write "() => import('./MyPage.vue')" instead of ` + `"defineAsyncComponent(() => import('./MyPage.vue'))".`);
        }
      } // skip update and leave guards if the route component is not mounted


      if (guardType !== 'beforeRouteEnter' && !record.instances[name]) continue;

      if (isRouteComponent(rawComponent)) {
        // __vccOpts is added by vue-class-component and contain the regular options
        const options = rawComponent.__vccOpts || rawComponent;
        const guard = options[guardType];
        guard && guards.push(guardToPromiseFn(guard, to, from, record, name));
      } else {
        // start requesting the chunk already
        let componentPromise = rawComponent();

        if (process.env.NODE_ENV !== 'production' && !('catch' in componentPromise)) {
          warn(`Component "${name}" in record with path "${record.path}" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.`);
          componentPromise = Promise.resolve(componentPromise);
        }

        guards.push(() => componentPromise.then(resolved => {
          if (!resolved) return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved; // replace the function with the resolved component
          // cannot be null or undefined because we went into the for loop

          record.components[name] = resolvedComponent; // __vccOpts is added by vue-class-component and contain the regular options

          const options = resolvedComponent.__vccOpts || resolvedComponent;
          const guard = options[guardType];
          return guard && guardToPromiseFn(guard, to, from, record, name)();
        }));
      }
    }
  }

  return guards;
}
/**
 * Allows differentiating lazy components from functional components and vue-class-component
 * @internal
 *
 * @param component
 */


function isRouteComponent(component) {
  return typeof component === 'object' || 'displayName' in component || 'props' in component || '__vccOpts' in component;
}
// `isExactActive` behavior should go through an RFC


function useLink(props) {
  const router = inject(routerKey);
  const currentRoute = inject(routeLocationKey);
  const route = computed(() => router.resolve(unref(props.to)));
  const activeRecordIndex = computed(() => {
    const {
      matched
    } = route.value;
    const {
      length
    } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length) return -1;
    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index > -1) return index; // possible parent record

    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return (// we are dealing with nested routes
      length > 1 && // if the parent and matched route have the same path, this link is
      // referring to the empty child. Or we currently are on a different
      // child of the same parent
      getOriginalPath(routeMatched) === parentRecordPath && // avoid comparing the child with its parent
      currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index
    );
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));

  function navigate(e = {}) {
    if (guardEvent(e)) {
      return router[unref(props.replace) ? 'replace' : 'push'](unref(props.to) // avoid uncaught errors are they are logged anyway
      ).catch(noop$1);
    }

    return Promise.resolve();
  } // devtools only


  if ((process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) && isBrowser) {
    const instance = getCurrentInstance();

    if (instance) {
      const linkContextDevtools = {
        route: route.value,
        isActive: isActive.value,
        isExactActive: isExactActive.value
      }; // @ts-expect-error: this is internal

      instance.__vrl_devtools = instance.__vrl_devtools || []; // @ts-expect-error: this is internal

      instance.__vrl_devtools.push(linkContextDevtools);

      watchEffect(() => {
        linkContextDevtools.route = route.value;
        linkContextDevtools.isActive = isActive.value;
        linkContextDevtools.isExactActive = isExactActive.value;
      }, {
        flush: 'post'
      });
    }
  }
  /**
   * NOTE: update {@link _RouterLinkI}'s `$slots` type when updating this
   */


  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}

const RouterLinkImpl = /*#__PURE__*/defineComponent({
  name: 'RouterLink',
  compatConfig: {
    MODE: 3
  },
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    // inactiveClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: 'page'
    }
  },
  useLink,

  setup(props, {
    slots
  }) {
    const link = reactive(useLink(props));
    const {
      options
    } = inject(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props.activeClass, options.linkActiveClass, 'router-link-active')]: link.isActive,
      // [getLinkClass(
      //   props.inactiveClass,
      //   options.linkInactiveClass,
      //   'router-link-inactive'
      // )]: !link.isExactActive,
      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, 'router-link-exact-active')]: link.isExactActive
    }));
    return () => {
      const children = slots.default && slots.default(link);
      return props.custom ? children : h('a', {
        'aria-current': link.isExactActive ? props.ariaCurrentValue : null,
        href: link.href,
        // this would override user added attrs but Vue will still add
        // the listener, so we end up triggering both
        onClick: link.navigate,
        class: elClass.value
      }, children);
    };
  }

}); // export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files

/**
 * Component to render a link that triggers a navigation on click.
 */

const RouterLink = RouterLinkImpl;

function guardEvent(e) {
  // don't redirect with control keys
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return; // don't redirect when preventDefault called

  if (e.defaultPrevented) return; // don't redirect on right click

  if (e.button !== undefined && e.button !== 0) return; // don't redirect if `target="_blank"`
  // @ts-expect-error getAttribute does exist

  if (e.currentTarget && e.currentTarget.getAttribute) {
    // @ts-expect-error getAttribute exists
    const target = e.currentTarget.getAttribute('target');
    if (/\b_blank\b/i.test(target)) return;
  } // this may be a Weex event which doesn't have this method


  if (e.preventDefault) e.preventDefault();
  return true;
}

function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];

    if (typeof innerValue === 'string') {
      if (innerValue !== outerValue) return false;
    } else {
      if (!isArray$1(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i])) return false;
    }
  }

  return true;
}
/**
 * Get the original path value of a record by following its aliasOf
 * @param record
 */


function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : '';
}
/**
 * Utility class to get the active class based on defaults.
 * @param propClass
 * @param globalClass
 * @param defaultClass
 */


const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;

const RouterViewImpl = /*#__PURE__*/defineComponent({
  name: 'RouterView',
  // #674 we manually inherit them
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: 'default'
    },
    route: Object
  },
  // Better compat for @vue/compat users
  // https://github.com/vuejs/router/issues/1315
  compatConfig: {
    MODE: 3
  },

  setup(props, {
    attrs,
    slots
  }) {
    process.env.NODE_ENV !== 'production' && warnDeprecatedUsage();
    const injectedRoute = inject(routerViewLocationKey);
    const routeToDisplay = computed(() => props.route || injectedRoute.value);
    const injectedDepth = inject(viewDepthKey, 0); // The depth changes based on empty components option, which allows passthrough routes e.g. routes with children
    // that are used to reuse the `path` property

    const depth = computed(() => {
      let initialDepth = unref(injectedDepth);
      const {
        matched
      } = routeToDisplay.value;
      let matchedRoute;

      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
        initialDepth++;
      }

      return initialDepth;
    });
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
    provide(viewDepthKey, computed(() => depth.value + 1));
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref(); // watch at the same time the component instance, the route record we are
    // rendering, and the name

    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {
      // copy reused instances
      if (to) {
        // this will update the instance for new instances as well as reused
        // instances when navigating to a new route
        to.instances[name] = instance; // the component instance is reused for a different route or name, so
        // we copy any saved update or leave guards. With async setup, the
        // mounting component will mount before the matchedRoute changes,
        // making instance === oldInstance, so we check if guards have been
        // added before. This works because we remove guards when
        // unmounting/deactivating components

        if (from && from !== to && instance && instance === oldInstance) {
          if (!to.leaveGuards.size) {
            to.leaveGuards = from.leaveGuards;
          }

          if (!to.updateGuards.size) {
            to.updateGuards = from.updateGuards;
          }
        }
      } // trigger beforeRouteEnter next callbacks


      if (instance && to && ( // if there is no instance but to and from are the same this might be
      // the first visit
      !from || !isSameRouteRecord(to, from) || !oldInstance)) {
        (to.enterCallbacks[name] || []).forEach(callback => callback(instance));
      }
    }, {
      flush: 'post'
    });
    return () => {
      const route = routeToDisplay.value; // we need the value at the time we render because when we unmount, we
      // navigated to a different location so the value is different

      const currentName = props.name;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[currentName];

      if (!ViewComponent) {
        return normalizeSlot(slots.default, {
          Component: ViewComponent,
          route
        });
      } // props from route configuration


      const routePropsOption = matchedRoute.props[currentName];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === 'function' ? routePropsOption(route) : routePropsOption : null;

      const onVnodeUnmounted = vnode => {
        // remove the instance reference to prevent leak
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };

      const component = h(ViewComponent, assign({}, routeProps, attrs, {
        onVnodeUnmounted,
        ref: viewRef
      }));

      if ((process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) && isBrowser && component.ref) {
        // TODO: can display if it's an alias, its props
        const info = {
          depth: depth.value,
          name: matchedRoute.name,
          path: matchedRoute.path,
          meta: matchedRoute.meta
        };
        const internalInstances = isArray$1(component.ref) ? component.ref.map(r => r.i) : [component.ref.i];
        internalInstances.forEach(instance => {
          // @ts-expect-error
          instance.__vrv_devtools = info;
        });
      }

      return (// pass the vnode to the slot as a prop.
        // h and <component :is="..."> both accept vnodes
        normalizeSlot(slots.default, {
          Component: component,
          route
        }) || component
      );
    };
  }

});

function normalizeSlot(slot, data) {
  if (!slot) return null;
  const slotContent = slot(data);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
} // export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files

/**
 * Component to display the current route the user is at.
 */


const RouterView = RouterViewImpl; // warn against deprecated usage with <transition> & <keep-alive>
// due to functional component being no longer eager in Vue 3

function warnDeprecatedUsage() {
  const instance = getCurrentInstance();
  const parentName = instance.parent && instance.parent.type.name;

  if (parentName && (parentName === 'KeepAlive' || parentName.includes('Transition'))) {
    const comp = parentName === 'KeepAlive' ? 'keep-alive' : 'transition';
    warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\n` + `Use slot props instead:\n\n` + `<router-view v-slot="{ Component }">\n` + `  <${comp}>\n` + `    <component :is="Component" />\n` + `  </${comp}>\n` + `</router-view>`);
  }
}
/**
 * Copies a route location and removes any problematic properties that cannot be shown in devtools (e.g. Vue instances).
 *
 * @param routeLocation - routeLocation to format
 * @param tooltip - optional tooltip
 * @returns a copy of the routeLocation
 */


function formatRouteLocation(routeLocation, tooltip) {
  const copy = assign({}, routeLocation, {
    // remove variables that can contain vue instances
    matched: routeLocation.matched.map(matched => omit(matched, ['instances', 'children', 'aliasOf']))
  });
  return {
    _custom: {
      type: null,
      readOnly: true,
      display: routeLocation.fullPath,
      tooltip,
      value: copy
    }
  };
}

function formatDisplay(display) {
  return {
    _custom: {
      display
    }
  };
} // to support multiple router instances


let routerId = 0;

function addDevtools(app, router, matcher) {
  // Take over router.beforeEach and afterEach
  // make sure we are not registering the devtool twice
  if (router.__hasDevtools) return;
  router.__hasDevtools = true; // increment to support multiple router instances

  const id = routerId++;
  setupDevtoolsPlugin({
    id: 'org.vuejs.router' + (id ? '.' + id : ''),
    label: 'Vue Router',
    packageName: 'vue-router',
    homepage: 'https://router.vuejs.org',
    logo: 'https://router.vuejs.org/logo.png',
    componentStateTypes: ['Routing'],
    app
  }, api => {
    if (typeof api.now !== 'function') {
      console.warn('[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.');
    } // display state added by the router


    api.on.inspectComponent((payload, ctx) => {
      if (payload.instanceData) {
        payload.instanceData.state.push({
          type: 'Routing',
          key: '$route',
          editable: false,
          value: formatRouteLocation(router.currentRoute.value, 'Current Route')
        });
      }
    }); // mark router-link as active and display tags on router views

    api.on.visitComponentTree(({
      treeNode: node,
      componentInstance
    }) => {
      if (componentInstance.__vrv_devtools) {
        const info = componentInstance.__vrv_devtools;
        node.tags.push({
          label: (info.name ? `${info.name.toString()}: ` : '') + info.path,
          textColor: 0,
          tooltip: 'This component is rendered by &lt;router-view&gt;',
          backgroundColor: PINK_500
        });
      } // if multiple useLink are used


      if (isArray$1(componentInstance.__vrl_devtools)) {
        componentInstance.__devtoolsApi = api;

        componentInstance.__vrl_devtools.forEach(devtoolsData => {
          let backgroundColor = ORANGE_400;
          let tooltip = '';

          if (devtoolsData.isExactActive) {
            backgroundColor = LIME_500;
            tooltip = 'This is exactly active';
          } else if (devtoolsData.isActive) {
            backgroundColor = BLUE_600;
            tooltip = 'This link is active';
          }

          node.tags.push({
            label: devtoolsData.route.path,
            textColor: 0,
            tooltip,
            backgroundColor
          });
        });
      }
    });
    watch(router.currentRoute, () => {
      // refresh active state
      refreshRoutesView();
      api.notifyComponentUpdate();
      api.sendInspectorTree(routerInspectorId);
      api.sendInspectorState(routerInspectorId);
    });
    const navigationsLayerId = 'router:navigations:' + id;
    api.addTimelineLayer({
      id: navigationsLayerId,
      label: `Router${id ? ' ' + id : ''} Navigations`,
      color: 0x40a8c4
    }); // const errorsLayerId = 'router:errors'
    // api.addTimelineLayer({
    //   id: errorsLayerId,
    //   label: 'Router Errors',
    //   color: 0xea5455,
    // })

    router.onError((error, to) => {
      api.addTimelineEvent({
        layerId: navigationsLayerId,
        event: {
          title: 'Error during Navigation',
          subtitle: to.fullPath,
          logType: 'error',
          time: api.now(),
          data: {
            error
          },
          groupId: to.meta.__navigationId
        }
      });
    }); // attached to `meta` and used to group events

    let navigationId = 0;
    router.beforeEach((to, from) => {
      const data = {
        guard: formatDisplay('beforeEach'),
        from: formatRouteLocation(from, 'Current Location during this navigation'),
        to: formatRouteLocation(to, 'Target location')
      }; // Used to group navigations together, hide from devtools

      Object.defineProperty(to.meta, '__navigationId', {
        value: navigationId++
      });
      api.addTimelineEvent({
        layerId: navigationsLayerId,
        event: {
          time: api.now(),
          title: 'Start of navigation',
          subtitle: to.fullPath,
          data,
          groupId: to.meta.__navigationId
        }
      });
    });
    router.afterEach((to, from, failure) => {
      const data = {
        guard: formatDisplay('afterEach')
      };

      if (failure) {
        data.failure = {
          _custom: {
            type: Error,
            readOnly: true,
            display: failure ? failure.message : '',
            tooltip: 'Navigation Failure',
            value: failure
          }
        };
        data.status = formatDisplay('❌');
      } else {
        data.status = formatDisplay('✅');
      } // we set here to have the right order


      data.from = formatRouteLocation(from, 'Current Location during this navigation');
      data.to = formatRouteLocation(to, 'Target location');
      api.addTimelineEvent({
        layerId: navigationsLayerId,
        event: {
          title: 'End of navigation',
          subtitle: to.fullPath,
          time: api.now(),
          data,
          logType: failure ? 'warning' : 'default',
          groupId: to.meta.__navigationId
        }
      });
    });
    /**
     * Inspector of Existing routes
     */

    const routerInspectorId = 'router-inspector:' + id;
    api.addInspector({
      id: routerInspectorId,
      label: 'Routes' + (id ? ' ' + id : ''),
      icon: 'book',
      treeFilterPlaceholder: 'Search routes'
    });

    function refreshRoutesView() {
      // the routes view isn't active
      if (!activeRoutesPayload) return;
      const payload = activeRoutesPayload; // children routes will appear as nested

      let routes = matcher.getRoutes().filter(route => !route.parent); // reset match state to false

      routes.forEach(resetMatchStateOnRouteRecord); // apply a match state if there is a payload

      if (payload.filter) {
        routes = routes.filter(route => // save matches state based on the payload
        isRouteMatching(route, payload.filter.toLowerCase()));
      } // mark active routes


      routes.forEach(route => markRouteRecordActive(route, router.currentRoute.value));
      payload.rootNodes = routes.map(formatRouteRecordForInspector);
    }

    let activeRoutesPayload;
    api.on.getInspectorTree(payload => {
      activeRoutesPayload = payload;

      if (payload.app === app && payload.inspectorId === routerInspectorId) {
        refreshRoutesView();
      }
    });
    /**
     * Display information about the currently selected route record
     */

    api.on.getInspectorState(payload => {
      if (payload.app === app && payload.inspectorId === routerInspectorId) {
        const routes = matcher.getRoutes();
        const route = routes.find(route => route.record.__vd_id === payload.nodeId);

        if (route) {
          payload.state = {
            options: formatRouteRecordMatcherForStateInspector(route)
          };
        }
      }
    });
    api.sendInspectorTree(routerInspectorId);
    api.sendInspectorState(routerInspectorId);
  });
}

function modifierForKey(key) {
  if (key.optional) {
    return key.repeatable ? '*' : '?';
  } else {
    return key.repeatable ? '+' : '';
  }
}

function formatRouteRecordMatcherForStateInspector(route) {
  const {
    record
  } = route;
  const fields = [{
    editable: false,
    key: 'path',
    value: record.path
  }];

  if (record.name != null) {
    fields.push({
      editable: false,
      key: 'name',
      value: record.name
    });
  }

  fields.push({
    editable: false,
    key: 'regexp',
    value: route.re
  });

  if (route.keys.length) {
    fields.push({
      editable: false,
      key: 'keys',
      value: {
        _custom: {
          type: null,
          readOnly: true,
          display: route.keys.map(key => `${key.name}${modifierForKey(key)}`).join(' '),
          tooltip: 'Param keys',
          value: route.keys
        }
      }
    });
  }

  if (record.redirect != null) {
    fields.push({
      editable: false,
      key: 'redirect',
      value: record.redirect
    });
  }

  if (route.alias.length) {
    fields.push({
      editable: false,
      key: 'aliases',
      value: route.alias.map(alias => alias.record.path)
    });
  }

  if (Object.keys(route.record.meta).length) {
    fields.push({
      editable: false,
      key: 'meta',
      value: route.record.meta
    });
  }

  fields.push({
    key: 'score',
    editable: false,
    value: {
      _custom: {
        type: null,
        readOnly: true,
        display: route.score.map(score => score.join(', ')).join(' | '),
        tooltip: 'Score used to sort routes',
        value: route.score
      }
    }
  });
  return fields;
}
/**
 * Extracted from tailwind palette
 */


const PINK_500 = 0xec4899;
const BLUE_600 = 0x2563eb;
const LIME_500 = 0x84cc16;
const CYAN_400 = 0x22d3ee;
const ORANGE_400 = 0xfb923c; // const GRAY_100 = 0xf4f4f5

const DARK = 0x666666;

function formatRouteRecordForInspector(route) {
  const tags = [];
  const {
    record
  } = route;

  if (record.name != null) {
    tags.push({
      label: String(record.name),
      textColor: 0,
      backgroundColor: CYAN_400
    });
  }

  if (record.aliasOf) {
    tags.push({
      label: 'alias',
      textColor: 0,
      backgroundColor: ORANGE_400
    });
  }

  if (route.__vd_match) {
    tags.push({
      label: 'matches',
      textColor: 0,
      backgroundColor: PINK_500
    });
  }

  if (route.__vd_exactActive) {
    tags.push({
      label: 'exact',
      textColor: 0,
      backgroundColor: LIME_500
    });
  }

  if (route.__vd_active) {
    tags.push({
      label: 'active',
      textColor: 0,
      backgroundColor: BLUE_600
    });
  }

  if (record.redirect) {
    tags.push({
      label: typeof record.redirect === 'string' ? `redirect: ${record.redirect}` : 'redirects',
      textColor: 0xffffff,
      backgroundColor: DARK
    });
  } // add an id to be able to select it. Using the `path` is not possible because
  // empty path children would collide with their parents


  let id = record.__vd_id;

  if (id == null) {
    id = String(routeRecordId++);
    record.__vd_id = id;
  }

  return {
    id,
    label: record.path,
    tags,
    children: route.children.map(formatRouteRecordForInspector)
  };
} //  incremental id for route records and inspector state


let routeRecordId = 0;
const EXTRACT_REGEXP_RE = /^\/(.*)\/([a-z]*)$/;

function markRouteRecordActive(route, currentRoute) {
  // no route will be active if matched is empty
  // reset the matching state
  const isExactActive = currentRoute.matched.length && isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);
  route.__vd_exactActive = route.__vd_active = isExactActive;

  if (!isExactActive) {
    route.__vd_active = currentRoute.matched.some(match => isSameRouteRecord(match, route.record));
  }

  route.children.forEach(childRoute => markRouteRecordActive(childRoute, currentRoute));
}

function resetMatchStateOnRouteRecord(route) {
  route.__vd_match = false;
  route.children.forEach(resetMatchStateOnRouteRecord);
}

function isRouteMatching(route, filter) {
  const found = String(route.re).match(EXTRACT_REGEXP_RE);
  route.__vd_match = false;

  if (!found || found.length < 3) {
    return false;
  } // use a regexp without $ at the end to match nested routes better


  const nonEndingRE = new RegExp(found[1].replace(/\$$/, ''), found[2]);

  if (nonEndingRE.test(filter)) {
    // mark children as matches
    route.children.forEach(child => isRouteMatching(child, filter)); // exception case: `/`

    if (route.record.path !== '/' || filter === '/') {
      route.__vd_match = route.re.test(filter);
      return true;
    } // hide the / route


    return false;
  }

  const path = route.record.path.toLowerCase();
  const decodedPath = decode(path); // also allow partial matching on the path

  if (!filter.startsWith('/') && (decodedPath.includes(filter) || path.includes(filter))) return true;
  if (decodedPath.startsWith(filter) || path.startsWith(filter)) return true;
  if (route.record.name && String(route.record.name).includes(filter)) return true;
  return route.children.some(child => isRouteMatching(child, filter));
}

function omit(obj, keys) {
  const ret = {};

  for (const key in obj) {
    if (!keys.includes(key)) {
      // @ts-expect-error
      ret[key] = obj[key];
    }
  }

  return ret;
}
/**
 * Creates a Router instance that can be used by a Vue app.
 *
 * @param options - {@link RouterOptions}
 */


function createRouter(options) {
  const matcher = createRouterMatcher(options.routes, options);
  const parseQuery$1 = options.parseQuery || parseQuery;
  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
  const routerHistory = options.history;
  if (process.env.NODE_ENV !== 'production' && !routerHistory) throw new Error('Provide the "history" option when calling "createRouter()":' + ' https://next.router.vuejs.org/api/#history.');
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED; // leave the scrollRestoration if no scrollBehavior is provided

  if (isBrowser && options.scrollBehavior && 'scrollRestoration' in history) {
    history.scrollRestoration = 'manual';
  }

  const normalizeParams = applyToParams.bind(null, paramValue => '' + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = // @ts-expect-error: intentionally avoid the type check
  applyToParams.bind(null, decode);

  function addRoute(parentOrRoute, route) {
    let parent;
    let record;

    if (isRouteName(parentOrRoute)) {
      parent = matcher.getRecordMatcher(parentOrRoute);
      record = route;
    } else {
      record = parentOrRoute;
    }

    return matcher.addRoute(record, parent);
  }

  function removeRoute(name) {
    const recordMatcher = matcher.getRecordMatcher(name);

    if (recordMatcher) {
      matcher.removeRoute(recordMatcher);
    } else if (process.env.NODE_ENV !== 'production') {
      warn(`Cannot remove non-existent route "${String(name)}"`);
    }
  }

  function getRoutes() {
    return matcher.getRoutes().map(routeMatcher => routeMatcher.record);
  }

  function hasRoute(name) {
    return !!matcher.getRecordMatcher(name);
  }

  function resolve(rawLocation, currentLocation) {
    // const objectLocation = routerLocationAsObject(rawLocation)
    // we create a copy to modify it later
    currentLocation = assign({}, currentLocation || currentRoute.value);

    if (typeof rawLocation === 'string') {
      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
      const matchedRoute = matcher.resolve({
        path: locationNormalized.path
      }, currentLocation);
      const href = routerHistory.createHref(locationNormalized.fullPath);

      if (process.env.NODE_ENV !== 'production') {
        if (href.startsWith('//')) warn(`Location "${rawLocation}" resolved to "${href}". A resolved location cannot start with multiple slashes.`);else if (!matchedRoute.matched.length) {
          warn(`No match found for location with path "${rawLocation}"`);
        }
      } // locationNormalized is always a new object


      return assign(locationNormalized, matchedRoute, {
        params: decodeParams(matchedRoute.params),
        hash: decode(locationNormalized.hash),
        redirectedFrom: undefined,
        href
      });
    }

    let matcherLocation; // path could be relative in object as well

    if ('path' in rawLocation) {
      if (process.env.NODE_ENV !== 'production' && 'params' in rawLocation && !('name' in rawLocation) && // @ts-expect-error: the type is never
      Object.keys(rawLocation.params).length) {
        warn(`Path "${// @ts-expect-error: the type is never
        rawLocation.path}" was passed with params but they will be ignored. Use a named route alongside params instead.`);
      }

      matcherLocation = assign({}, rawLocation, {
        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
      });
    } else {
      // remove any nullish param
      const targetParams = assign({}, rawLocation.params);

      for (const key in targetParams) {
        if (targetParams[key] == null) {
          delete targetParams[key];
        }
      } // pass encoded values to the matcher, so it can produce encoded path and fullPath


      matcherLocation = assign({}, rawLocation, {
        params: encodeParams(rawLocation.params)
      }); // current location params are decoded, we need to encode them in case the
      // matcher merges the params

      currentLocation.params = encodeParams(currentLocation.params);
    }

    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash = rawLocation.hash || '';

    if (process.env.NODE_ENV !== 'production' && hash && !hash.startsWith('#')) {
      warn(`A \`hash\` should always start with the character "#". Replace "${hash}" with "#${hash}".`);
    } // the matcher might have merged current location params, so
    // we need to run the decoding again


    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
      hash: encodeHash(hash),
      path: matchedRoute.path
    }));
    const href = routerHistory.createHref(fullPath);

    if (process.env.NODE_ENV !== 'production') {
      if (href.startsWith('//')) {
        warn(`Location "${rawLocation}" resolved to "${href}". A resolved location cannot start with multiple slashes.`);
      } else if (!matchedRoute.matched.length) {
        warn(`No match found for location with path "${'path' in rawLocation ? rawLocation.path : rawLocation}"`);
      }
    }

    return assign({
      fullPath,
      // keep the hash encoded so fullPath is effectively path + encodedQuery +
      // hash
      hash,
      query: // if the user is using a custom query lib like qs, we might have
      // nested objects, so we keep the query as is, meaning it can contain
      // numbers at `$route.query`, but at the point, the user will have to
      // use their own type anyway.
      // https://github.com/vuejs/router/issues/328#issuecomment-649481567
      stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
    }, matchedRoute, {
      redirectedFrom: undefined,
      href
    });
  }

  function locationAsObject(to) {
    return typeof to === 'string' ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);
  }

  function checkCanceledNavigation(to, from) {
    if (pendingLocation !== to) {
      return createRouterError(8
      /* ErrorTypes.NAVIGATION_CANCELLED */
      , {
        from,
        to
      });
    }
  }

  function push(to) {
    return pushWithRedirect(to);
  }

  function replace(to) {
    return push(assign(locationAsObject(to), {
      replace: true
    }));
  }

  function handleRedirectRecord(to) {
    const lastMatched = to.matched[to.matched.length - 1];

    if (lastMatched && lastMatched.redirect) {
      const {
        redirect
      } = lastMatched;
      let newTargetLocation = typeof redirect === 'function' ? redirect(to) : redirect;

      if (typeof newTargetLocation === 'string') {
        newTargetLocation = newTargetLocation.includes('?') || newTargetLocation.includes('#') ? newTargetLocation = locationAsObject(newTargetLocation) : // force empty params
        {
          path: newTargetLocation
        }; // @ts-expect-error: force empty params when a string is passed to let
        // the router parse them again

        newTargetLocation.params = {};
      }

      if (process.env.NODE_ENV !== 'production' && !('path' in newTargetLocation) && !('name' in newTargetLocation)) {
        warn(`Invalid redirect found:\n${JSON.stringify(newTargetLocation, null, 2)}\n when navigating to "${to.fullPath}". A redirect must contain a name or path. This will break in production.`);
        throw new Error('Invalid redirect');
      }

      return assign({
        query: to.query,
        hash: to.hash,
        // avoid transferring params if the redirect has a path
        params: 'path' in newTargetLocation ? {} : to.params
      }, newTargetLocation);
    }
  }

  function pushWithRedirect(to, redirectedFrom) {
    const targetLocation = pendingLocation = resolve(to);
    const from = currentRoute.value;
    const data = to.state;
    const force = to.force; // to could be a string where `replace` is a function

    const replace = to.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect) return pushWithRedirect(assign(locationAsObject(shouldRedirect), {
      state: typeof shouldRedirect === 'object' ? assign({}, data, shouldRedirect.state) : data,
      force,
      replace
    }), // keep original redirectedFrom if it exists
    redirectedFrom || targetLocation); // if it was a redirect we already called `pushWithRedirect` above

    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;

    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
      failure = createRouterError(16
      /* ErrorTypes.NAVIGATION_DUPLICATED */
      , {
        to: toLocation,
        from
      }); // trigger scroll to allow scrolling to the same anchor

      handleScroll(from, from, // this is a push, the only way for it to be triggered from a
      // history.listen is with a redirect, which makes it become a push
      true, // This cannot be the first navigation because the initial location
      // cannot be manually navigated to
      false);
    }

    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch(error => isNavigationFailure(error) ? // navigation redirects still mark the router as ready
    isNavigationFailure(error, 2
    /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
    ) ? error : markAsReady(error) // also returns the error
    : // reject any unknown error
    triggerError(error, toLocation, from)).then(failure => {
      if (failure) {
        if (isNavigationFailure(failure, 2
        /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        )) {
          if (process.env.NODE_ENV !== 'production' && // we are redirecting to the same location we were already at
          isSameRouteLocation(stringifyQuery$1, resolve(failure.to), toLocation) && // and we have done it a couple of times
          redirectedFrom && // @ts-expect-error: added only in dev
          (redirectedFrom._count = redirectedFrom._count ? // @ts-expect-error
          redirectedFrom._count + 1 : 1) > 10) {
            warn(`Detected an infinite redirection in a navigation guard when going from "${from.fullPath}" to "${toLocation.fullPath}". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`);
            return Promise.reject(new Error('Infinite redirect in navigation guard'));
          }

          return pushWithRedirect( // keep options
          assign({
            // preserve an existing replacement but allow the redirect to override it
            replace
          }, locationAsObject(failure.to), {
            state: typeof failure.to === 'object' ? assign({}, data, failure.to.state) : data,
            force
          }), // preserve the original redirectedFrom if any
          redirectedFrom || toLocation);
        }
      } else {
        // if we fail we don't finalize the navigation
        failure = finalizeNavigation(toLocation, from, true, replace, data);
      }

      triggerAfterEach(toLocation, from, failure);
      return failure;
    });
  }
  /**
   * Helper to reject and skip all navigation guards if a new navigation happened
   * @param to
   * @param from
   */


  function checkCanceledNavigationAndReject(to, from) {
    const error = checkCanceledNavigation(to, from);
    return error ? Promise.reject(error) : Promise.resolve();
  } // TODO: refactor the whole before guards by internally using router.beforeEach


  function navigate(to, from) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from); // all components here have been resolved once because we are leaving

    guards = extractComponentsGuards(leavingRecords.reverse(), 'beforeRouteLeave', to, from); // leavingRecords is already reversed

    for (const record of leavingRecords) {
      record.leaveGuards.forEach(guard => {
        guards.push(guardToPromiseFn(guard, to, from));
      });
    }

    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
    guards.push(canceledNavigationCheck); // run the queue of per route beforeRouteLeave guards

    return runGuardQueue(guards).then(() => {
      // check global guards beforeEach
      guards = [];

      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }

      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      // check in components beforeRouteUpdate
      guards = extractComponentsGuards(updatingRecords, 'beforeRouteUpdate', to, from);

      for (const record of updatingRecords) {
        record.updateGuards.forEach(guard => {
          guards.push(guardToPromiseFn(guard, to, from));
        });
      }

      guards.push(canceledNavigationCheck); // run the queue of per route beforeEnter guards

      return runGuardQueue(guards);
    }).then(() => {
      // check the route beforeEnter
      guards = [];

      for (const record of to.matched) {
        // do not trigger beforeEnter on reused views
        if (record.beforeEnter && !from.matched.includes(record)) {
          if (isArray$1(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter) guards.push(guardToPromiseFn(beforeEnter, to, from));
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to, from));
          }
        }
      }

      guards.push(canceledNavigationCheck); // run the queue of per route beforeEnter guards

      return runGuardQueue(guards);
    }).then(() => {
      // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>
      // clear existing enterCallbacks, these are added by extractComponentsGuards
      to.matched.forEach(record => record.enterCallbacks = {}); // check in-component beforeRouteEnter

      guards = extractComponentsGuards(enteringRecords, 'beforeRouteEnter', to, from);
      guards.push(canceledNavigationCheck); // run the queue of per route beforeEnter guards

      return runGuardQueue(guards);
    }).then(() => {
      // check global guards beforeResolve
      guards = [];

      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }

      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }) // catch any navigation canceled
    .catch(err => isNavigationFailure(err, 8
    /* ErrorTypes.NAVIGATION_CANCELLED */
    ) ? err : Promise.reject(err));
  }

  function triggerAfterEach(to, from, failure) {
    // navigation is confirmed, call afterGuards
    // TODO: wrap with error handlers
    for (const guard of afterGuards.list()) guard(to, from, failure);
  }
  /**
   * - Cleans up any navigation guards
   * - Changes the url if necessary
   * - Calls the scrollBehavior
   */


  function finalizeNavigation(toLocation, from, isPush, replace, data) {
    // a more recent navigation took place
    const error = checkCanceledNavigation(toLocation, from);
    if (error) return error; // only consider as push if it's not the first navigation

    const isFirstNavigation = from === START_LOCATION_NORMALIZED;
    const state = !isBrowser ? {} : history.state; // change URL only if the user did a push/replace and if it's not the initial navigation because
    // it's just reflecting the url

    if (isPush) {
      // on the initial navigation, we want to reuse the scroll position from
      // history state if it exists
      if (replace || isFirstNavigation) routerHistory.replace(toLocation.fullPath, assign({
        scroll: isFirstNavigation && state && state.scroll
      }, data));else routerHistory.push(toLocation.fullPath, data);
    } // accept current navigation


    currentRoute.value = toLocation;
    handleScroll(toLocation, from, isPush, isFirstNavigation);
    markAsReady();
  }

  let removeHistoryListener; // attach listener to history to trigger navigations

  function setupListeners() {
    // avoid setting up listeners twice due to an invalid first navigation
    if (removeHistoryListener) return;
    removeHistoryListener = routerHistory.listen((to, _from, info) => {
      if (!router.listening) return; // cannot be a redirect route because it was in history

      const toLocation = resolve(to); // due to dynamic routing, and to hash history with manual navigation
      // (manually changing the url or calling history.hash = '#/somewhere'),
      // there could be a redirect record in history

      const shouldRedirect = handleRedirectRecord(toLocation);

      if (shouldRedirect) {
        pushWithRedirect(assign(shouldRedirect, {
          replace: true
        }), toLocation).catch(noop$1);
        return;
      }

      pendingLocation = toLocation;
      const from = currentRoute.value; // TODO: should be moved to web history?

      if (isBrowser) {
        saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
      }

      navigate(toLocation, from).catch(error => {
        if (isNavigationFailure(error, 4
        /* ErrorTypes.NAVIGATION_ABORTED */
        | 8
        /* ErrorTypes.NAVIGATION_CANCELLED */
        )) {
          return error;
        }

        if (isNavigationFailure(error, 2
        /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        )) {
          // Here we could call if (info.delta) routerHistory.go(-info.delta,
          // false) but this is bug prone as we have no way to wait the
          // navigation to be finished before calling pushWithRedirect. Using
          // a setTimeout of 16ms seems to work but there is no guarantee for
          // it to work on every browser. So instead we do not restore the
          // history entry and trigger a new navigation as requested by the
          // navigation guard.
          // the error is already handled by router.push we just want to avoid
          // logging the error
          pushWithRedirect(error.to, toLocation // avoid an uncaught rejection, let push call triggerError
          ).then(failure => {
            // manual change in hash history #916 ending up in the URL not
            // changing, but it was changed by the manual url change, so we
            // need to manually change it ourselves
            if (isNavigationFailure(failure, 4
            /* ErrorTypes.NAVIGATION_ABORTED */
            | 16
            /* ErrorTypes.NAVIGATION_DUPLICATED */
            ) && !info.delta && info.type === NavigationType.pop) {
              routerHistory.go(-1, false);
            }
          }).catch(noop$1); // avoid the then branch

          return Promise.reject();
        } // do not restore history on unknown direction


        if (info.delta) {
          routerHistory.go(-info.delta, false);
        } // unrecognized error, transfer to the global handler


        return triggerError(error, toLocation, from);
      }).then(failure => {
        failure = failure || finalizeNavigation( // after navigation, all matched components are resolved
        toLocation, from, false); // revert the navigation

        if (failure) {
          if (info.delta && // a new navigation has been triggered, so we do not want to revert, that will change the current history
          // entry while a different route is displayed
          !isNavigationFailure(failure, 8
          /* ErrorTypes.NAVIGATION_CANCELLED */
          )) {
            routerHistory.go(-info.delta, false);
          } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4
          /* ErrorTypes.NAVIGATION_ABORTED */
          | 16
          /* ErrorTypes.NAVIGATION_DUPLICATED */
          )) {
            // manual change in hash history #916
            // it's like a push but lacks the information of the direction
            routerHistory.go(-1, false);
          }
        }

        triggerAfterEach(toLocation, from, failure);
      }).catch(noop$1);
    });
  } // Initialization and Errors


  let readyHandlers = useCallbacks();
  let errorHandlers = useCallbacks();
  let ready;
  /**
   * Trigger errorHandlers added via onError and throws the error as well
   *
   * @param error - error to throw
   * @param to - location we were navigating to when the error happened
   * @param from - location we were navigating from when the error happened
   * @returns the error as a rejected promise
   */

  function triggerError(error, to, from) {
    markAsReady(error);
    const list = errorHandlers.list();

    if (list.length) {
      list.forEach(handler => handler(error, to, from));
    } else {
      if (process.env.NODE_ENV !== 'production') {
        warn('uncaught error during route navigation:');
      }

      console.error(error);
    }

    return Promise.reject(error);
  }

  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED) return Promise.resolve();
    return new Promise((resolve, reject) => {
      readyHandlers.add([resolve, reject]);
    });
  }

  function markAsReady(err) {
    if (!ready) {
      // still not ready if an error happened
      ready = !err;
      setupListeners();
      readyHandlers.list().forEach(([resolve, reject]) => err ? reject(err) : resolve());
      readyHandlers.reset();
    }

    return err;
  } // Scroll behavior


  function handleScroll(to, from, isPush, isFirstNavigation) {
    const {
      scrollBehavior
    } = options;
    if (!isBrowser || !scrollBehavior) return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then(position => position && scrollToPosition(position)).catch(err => triggerError(err, to, from));
  }

  const go = delta => routerHistory.go(delta);

  let started;
  const installedApps = new Set();
  const router = {
    currentRoute,
    listening: true,
    addRoute,
    removeRoute,
    hasRoute,
    getRoutes,
    resolve,
    options,
    push,
    replace,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorHandlers.add,
    isReady,

    install(app) {
      const router = this;
      app.component('RouterLink', RouterLink);
      app.component('RouterView', RouterView);
      app.config.globalProperties.$router = router;
      Object.defineProperty(app.config.globalProperties, '$route', {
        enumerable: true,
        get: () => unref(currentRoute)
      }); // this initial navigation is only necessary on client, on server it doesn't
      // make sense because it will create an extra unnecessary navigation and could
      // lead to problems

      if (isBrowser && // used for the initial navigation client side to avoid pushing
      // multiple times when the router is used in multiple apps
      !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        // see above
        started = true;
        push(routerHistory.location).catch(err => {
          if (process.env.NODE_ENV !== 'production') warn('Unexpected error when starting the router:', err);
        });
      }

      const reactiveRoute = {};

      for (const key in START_LOCATION_NORMALIZED) {
        // @ts-expect-error: the key matches
        reactiveRoute[key] = computed(() => currentRoute.value[key]);
      }

      app.provide(routerKey, router);
      app.provide(routeLocationKey, reactive(reactiveRoute));
      app.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app.unmount;
      installedApps.add(app);

      app.unmount = function () {
        installedApps.delete(app); // the router is not attached to an app anymore

        if (installedApps.size < 1) {
          // invalidate the current navigation
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          removeHistoryListener = null;
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }

        unmountApp();
      }; // TODO: this probably needs to be updated so it can be used by vue-termui


      if ((process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) && isBrowser) {
        addDevtools(app, router, matcher);
      }
    }

  };
  return router;
}

function runGuardQueue(guards) {
  return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());
}

function extractChangingRecords(to, from) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len = Math.max(from.matched.length, to.matched.length);

  for (let i = 0; i < len; i++) {
    const recordFrom = from.matched[i];

    if (recordFrom) {
      if (to.matched.find(record => isSameRouteRecord(record, recordFrom))) updatingRecords.push(recordFrom);else leavingRecords.push(recordFrom);
    }

    const recordTo = to.matched[i];

    if (recordTo) {
      // the type doesn't matter because we are comparing per reference
      if (!from.matched.find(record => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }

  return [leavingRecords, updatingRecords, enteringRecords];
}

var script$1$3 = {
  name: 'BreadcrumbItem',
  props: {
    item: null,
    template: null,
    exact: null
  },
  methods: {
    onClick(event, navigate) {
      if (this.item.command) {
        this.item.command({
          originalEvent: event,
          item: this.item
        });
      }

      if (this.item.to && navigate) {
        navigate(event);
      }
    },

    containerClass() {
      return ['p-menuitem', {
        'p-disabled': this.disabled()
      }, this.item.class];
    },

    linkClass(routerProps) {
      return ['p-menuitem-link', {
        'router-link-active': routerProps && routerProps.isActive,
        'router-link-active-exact': this.exact && routerProps && routerProps.isExactActive
      }];
    },

    visible() {
      return typeof this.item.visible === 'function' ? this.item.visible() : this.item.visible !== false;
    },

    disabled() {
      return typeof this.item.disabled === 'function' ? this.item.disabled() : this.item.disabled;
    },

    label() {
      return typeof this.item.label === 'function' ? this.item.label() : this.item.label;
    },

    isCurrentUrl() {
      const {
        to,
        url
      } = this.item;
      let lastPath = this.$router ? this.$router.currentRoute.path : '';
      return to === lastPath || url === lastPath ? 'page' : undefined;
    }

  },
  computed: {
    iconClass() {
      return ['p-menuitem-icon', this.item.icon];
    }

  }
};
const _hoisted_1$1$3 = ["href", "aria-current", "onClick"];
const _hoisted_2$1$3 = {
  key: 1,
  class: "p-menuitem-text"
};
const _hoisted_3$1$2 = ["href", "target", "aria-current"];
const _hoisted_4$e = {
  key: 1,
  class: "p-menuitem-text"
};

function render$1$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_router_link = resolveComponent("router-link");

  return $options.visible() ? (openBlock(), createElementBlock("li", {
    key: 0,
    class: normalizeClass($options.containerClass())
  }, [!$props.template ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [$props.item.to ? (openBlock(), createBlock(_component_router_link, {
    key: 0,
    to: $props.item.to,
    custom: ""
  }, {
    default: withCtx(({
      navigate,
      href,
      isActive,
      isExactActive
    }) => [createElementVNode("a", {
      href: href,
      class: normalizeClass($options.linkClass({
        isActive,
        isExactActive
      })),
      "aria-current": $options.isCurrentUrl(),
      onClick: $event => $options.onClick($event, navigate)
    }, [$props.item.icon ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass($options.iconClass)
    }, null, 2)) : createCommentVNode("", true), $props.item.label ? (openBlock(), createElementBlock("span", _hoisted_2$1$3, toDisplayString$1($options.label()), 1)) : createCommentVNode("", true)], 10, _hoisted_1$1$3)]),
    _: 1
  }, 8, ["to"])) : (openBlock(), createElementBlock("a", {
    key: 1,
    href: $props.item.url || '#',
    class: normalizeClass($options.linkClass()),
    target: $props.item.target,
    "aria-current": $options.isCurrentUrl(),
    onClick: _cache[0] || (_cache[0] = (...args) => $options.onClick && $options.onClick(...args))
  }, [$props.item.icon ? (openBlock(), createElementBlock("span", {
    key: 0,
    class: normalizeClass($options.iconClass)
  }, null, 2)) : createCommentVNode("", true), $props.item.label ? (openBlock(), createElementBlock("span", _hoisted_4$e, toDisplayString$1($options.label()), 1)) : createCommentVNode("", true)], 10, _hoisted_3$1$2))], 64)) : (openBlock(), createBlock(resolveDynamicComponent($props.template), {
    key: 1,
    item: $props.item
  }, null, 8, ["item"]))], 2)) : createCommentVNode("", true);
}

script$1$3.render = render$1$3;
var script$T = {
  name: 'Breadcrumb',
  props: {
    model: {
      type: Array,
      default: null
    },
    home: {
      type: null,
      default: null
    },
    exact: {
      type: Boolean,
      default: true
    }
  },
  components: {
    BreadcrumbItem: script$1$3
  }
};
const _hoisted_1$p = {
  class: "p-breadcrumb p-component"
};
const _hoisted_2$m = {
  class: "p-breadcrumb-list"
};

const _hoisted_3$j = /*#__PURE__*/createElementVNode("li", {
  class: "p-menuitem-separator"
}, [/*#__PURE__*/createElementVNode("span", {
  class: "pi pi-chevron-right",
  "aria-hidden": "true"
})], -1);

function render$g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_BreadcrumbItem = resolveComponent("BreadcrumbItem");

  return openBlock(), createElementBlock("nav", _hoisted_1$p, [createElementVNode("ol", _hoisted_2$m, [$props.home ? (openBlock(), createBlock(_component_BreadcrumbItem, {
    key: 0,
    item: $props.home,
    class: "p-breadcrumb-home",
    template: _ctx.$slots.item,
    exact: $props.exact
  }, null, 8, ["item", "template", "exact"])) : createCommentVNode("", true), (openBlock(true), createElementBlock(Fragment, null, renderList($props.model, item => {
    return openBlock(), createElementBlock(Fragment, {
      key: item.label
    }, [_hoisted_3$j, createVNode(_component_BreadcrumbItem, {
      item: item,
      template: _ctx.$slots.item,
      exact: $props.exact
    }, null, 8, ["item", "template", "exact"])], 64);
  }), 128))])]);
}

function styleInject$c(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$j = "\n.p-breadcrumb {\n    overflow-x: auto;\n}\n.p-breadcrumb .p-breadcrumb-list {\n    margin: 0;\n    padding: 0;\n    list-style-type: none;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -ms-flex-wrap: nowrap;\n        flex-wrap: nowrap;\n}\n.p-breadcrumb .p-menuitem-text {\n    line-height: 1;\n}\n.p-breadcrumb .p-menuitem-link {\n    text-decoration: none;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n.p-breadcrumb .p-menuitem-separator {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n.p-breadcrumb::-webkit-scrollbar {\n    display: none;\n}\n";
styleInject$c(css_248z$j);
script$T.render = render$g;

var script$S = {
  name: 'OverlayPanel',
  inheritAttrs: false,
  emits: ['show', 'hide'],
  props: {
    dismissable: {
      type: Boolean,
      default: true
    },
    showCloseIcon: {
      type: Boolean,
      default: false
    },
    appendTo: {
      type: String,
      default: 'body'
    },
    baseZIndex: {
      type: Number,
      default: 0
    },
    autoZIndex: {
      type: Boolean,
      default: true
    },
    ariaCloseLabel: {
      type: String,
      default: 'close'
    },
    breakpoints: {
      type: Object,
      default: null
    }
  },

  data() {
    return {
      visible: false
    };
  },

  watch: {
    dismissable: {
      immediate: true,

      handler(newValue) {
        if (newValue) {
          this.bindOutsideClickListener();
        } else {
          this.unbindOutsideClickListener();
        }
      }

    }
  },
  selfClick: false,
  target: null,
  eventTarget: null,
  outsideClickListener: null,
  scrollHandler: null,
  resizeListener: null,
  container: null,
  styleElement: null,
  overlayEventListener: null,

  beforeUnmount() {
    if (this.dismissable) {
      this.unbindOutsideClickListener();
    }

    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }

    this.destroyStyle();
    this.unbindResizeListener();
    this.target = null;

    if (this.container && this.autoZIndex) {
      ZIndexUtils.clear(this.container);
    }

    if (this.overlayEventListener) {
      OverlayEventBus.off('overlay-click', this.overlayEventListener);
      this.overlayEventListener = null;
    }

    this.container = null;
  },

  mounted() {
    if (this.breakpoints) {
      this.createStyle();
    }
  },

  methods: {
    toggle(event, target) {
      if (this.visible) this.hide();else this.show(event, target);
    },

    show(event, target) {
      this.visible = true;
      this.eventTarget = event.currentTarget;
      this.target = target || event.currentTarget;
    },

    hide() {
      this.visible = false;
      DomHandler.focus(this.target);
    },

    onContentClick() {
      this.selfClick = true;
    },

    onEnter(el) {
      this.container.setAttribute(this.attributeSelector, '');
      this.alignOverlay();

      if (this.dismissable) {
        this.bindOutsideClickListener();
      }

      this.bindScrollListener();
      this.bindResizeListener();

      if (this.autoZIndex) {
        ZIndexUtils.set('overlay', el, this.baseZIndex + this.$primevue.config.zIndex.overlay);
      }

      this.overlayEventListener = e => {
        if (this.container.contains(e.target)) {
          this.selfClick = true;
        }
      };

      this.focus();
      OverlayEventBus.on('overlay-click', this.overlayEventListener);
      this.$emit('show');
    },

    onLeave() {
      this.unbindOutsideClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
      OverlayEventBus.off('overlay-click', this.overlayEventListener);
      this.overlayEventListener = null;
      this.$emit('hide');
    },

    onAfterLeave(el) {
      if (this.autoZIndex) {
        ZIndexUtils.clear(el);
      }
    },

    alignOverlay() {
      DomHandler.absolutePosition(this.container, this.target);
      const containerOffset = DomHandler.getOffset(this.container);
      const targetOffset = DomHandler.getOffset(this.target);
      let arrowLeft = 0;

      if (containerOffset.left < targetOffset.left) {
        arrowLeft = targetOffset.left - containerOffset.left;
      }

      this.container.style.setProperty('--overlayArrowLeft', `${arrowLeft}px`);

      if (containerOffset.top < targetOffset.top) {
        DomHandler.addClass(this.container, 'p-overlaypanel-flipped');
      }
    },

    onContentKeydown(event) {
      event.code === 'Escape' && this.hide();
    },

    onButtonKeydown(event) {
      switch (event.code) {
        case 'ArrowDown':
        case 'ArrowUp':
        case 'ArrowLeft':
        case 'ArrowRight':
          event.preventDefault();
      }
    },

    focus() {
      let focusTarget = this.container.querySelector('[autofocus]');

      if (focusTarget) {
        focusTarget.focus();
      }
    },

    bindOutsideClickListener() {
      if (!this.outsideClickListener && DomHandler.isClient()) {
        this.outsideClickListener = event => {
          if (this.visible && !this.selfClick && !this.isTargetClicked(event)) {
            this.visible = false;
          }

          this.selfClick = false;
        };

        document.addEventListener('click', this.outsideClickListener);
      }
    },

    unbindOutsideClickListener() {
      if (this.outsideClickListener) {
        document.removeEventListener('click', this.outsideClickListener);
        this.outsideClickListener = null;
        this.selfClick = false;
      }
    },

    bindScrollListener() {
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.target, () => {
          if (this.visible) {
            this.visible = false;
          }
        });
      }

      this.scrollHandler.bindScrollListener();
    },

    unbindScrollListener() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    },

    bindResizeListener() {
      if (!this.resizeListener) {
        this.resizeListener = () => {
          if (this.visible && !DomHandler.isTouchDevice()) {
            this.visible = false;
          }
        };

        window.addEventListener('resize', this.resizeListener);
      }
    },

    unbindResizeListener() {
      if (this.resizeListener) {
        window.removeEventListener('resize', this.resizeListener);
        this.resizeListener = null;
      }
    },

    isTargetClicked(event) {
      return this.eventTarget && (this.eventTarget === event.target || this.eventTarget.contains(event.target));
    },

    containerRef(el) {
      this.container = el;
    },

    createStyle() {
      if (!this.styleElement) {
        this.styleElement = document.createElement('style');
        this.styleElement.type = 'text/css';
        document.head.appendChild(this.styleElement);
        let innerHTML = '';

        for (let breakpoint in this.breakpoints) {
          innerHTML += `
                        @media screen and (max-width: ${breakpoint}) {
                            .p-overlaypanel[${this.attributeSelector}] {
                                width: ${this.breakpoints[breakpoint]} !important;
                            }
                        }
                    `;
        }

        this.styleElement.innerHTML = innerHTML;
      }
    },

    destroyStyle() {
      if (this.styleElement) {
        document.head.removeChild(this.styleElement);
        this.styleElement = null;
      }
    },

    onOverlayClick(event) {
      OverlayEventBus.emit('overlay-click', {
        originalEvent: event,
        target: this.target
      });
    }

  },
  computed: {
    containerClass() {
      return ['p-overlaypanel p-component', {
        'p-input-filled': this.$primevue.config.inputStyle === 'filled',
        'p-ripple-disabled': this.$primevue.config.ripple === false
      }];
    },

    attributeSelector() {
      return UniqueComponentId();
    }

  },
  directives: {
    focustrap: FocusTrap,
    ripple: Ripple
  },
  components: {
    Portal: script$1C
  }
};
const _hoisted_1$o = ["aria-modal"];
const _hoisted_2$l = ["aria-label"];

const _hoisted_3$i = /*#__PURE__*/createElementVNode("span", {
  class: "p-overlaypanel-close-icon pi pi-times"
}, null, -1);

const _hoisted_4$d = [_hoisted_3$i];

function render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Portal = resolveComponent("Portal");

  const _directive_ripple = resolveDirective("ripple");

  const _directive_focustrap = resolveDirective("focustrap");

  return openBlock(), createBlock(_component_Portal, {
    appendTo: $props.appendTo
  }, {
    default: withCtx(() => [createVNode(Transition, {
      name: "p-overlaypanel",
      onEnter: $options.onEnter,
      onLeave: $options.onLeave,
      onAfterLeave: $options.onAfterLeave
    }, {
      default: withCtx(() => [$data.visible ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        ref: $options.containerRef,
        role: "dialog",
        class: $options.containerClass,
        "aria-modal": $data.visible,
        onClick: _cache[5] || (_cache[5] = (...args) => $options.onOverlayClick && $options.onOverlayClick(...args))
      }, _ctx.$attrs), [createElementVNode("div", {
        class: "p-overlaypanel-content",
        onClick: _cache[0] || (_cache[0] = (...args) => $options.onContentClick && $options.onContentClick(...args)),
        onMousedown: _cache[1] || (_cache[1] = (...args) => $options.onContentClick && $options.onContentClick(...args)),
        onKeydown: _cache[2] || (_cache[2] = (...args) => $options.onContentKeydown && $options.onContentKeydown(...args))
      }, [renderSlot(_ctx.$slots, "default")], 32), $props.showCloseIcon ? withDirectives((openBlock(), createElementBlock("button", {
        key: 0,
        class: "p-overlaypanel-close p-link",
        "aria-label": $props.ariaCloseLabel,
        type: "button",
        autofocus: "",
        onClick: _cache[3] || (_cache[3] = (...args) => $options.hide && $options.hide(...args)),
        onKeydown: _cache[4] || (_cache[4] = (...args) => $options.onButtonKeydown && $options.onButtonKeydown(...args))
      }, _hoisted_4$d, 40, _hoisted_2$l)), [[_directive_ripple]]) : createCommentVNode("", true)], 16, _hoisted_1$o)), [[_directive_focustrap]]) : createCommentVNode("", true)]),
      _: 3
    }, 8, ["onEnter", "onLeave", "onAfterLeave"])]),
    _: 3
  }, 8, ["appendTo"]);
}

function styleInject$b(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$i = "\n.p-overlaypanel {\n    position: absolute;\n    margin-top: 10px;\n    top: 0;\n    left: 0;\n}\n.p-overlaypanel-flipped {\n    margin-top: 0;\n    margin-bottom: 10px;\n}\n.p-overlaypanel-close {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    overflow: hidden;\n    position: relative;\n}\n\n/* Animation */\n.p-overlaypanel-enter-from {\n    opacity: 0;\n    -webkit-transform: scaleY(0.8);\n            transform: scaleY(0.8);\n}\n.p-overlaypanel-leave-to {\n    opacity: 0;\n}\n.p-overlaypanel-enter-active {\n    -webkit-transition: opacity 0.12s cubic-bezier(0, 0, 0.2, 1), -webkit-transform 0.12s cubic-bezier(0, 0, 0.2, 1);\n    transition: opacity 0.12s cubic-bezier(0, 0, 0.2, 1), -webkit-transform 0.12s cubic-bezier(0, 0, 0.2, 1);\n    transition: transform 0.12s cubic-bezier(0, 0, 0.2, 1), opacity 0.12s cubic-bezier(0, 0, 0.2, 1);\n    transition: transform 0.12s cubic-bezier(0, 0, 0.2, 1), opacity 0.12s cubic-bezier(0, 0, 0.2, 1), -webkit-transform 0.12s cubic-bezier(0, 0, 0.2, 1);\n}\n.p-overlaypanel-leave-active {\n    -webkit-transition: opacity 0.1s linear;\n    transition: opacity 0.1s linear;\n}\n.p-overlaypanel:after,\n.p-overlaypanel:before {\n    bottom: 100%;\n    left: calc(var(--overlayArrowLeft, 0) + 1.25rem);\n    content: ' ';\n    height: 0;\n    width: 0;\n    position: absolute;\n    pointer-events: none;\n}\n.p-overlaypanel:after {\n    border-width: 8px;\n    margin-left: -8px;\n}\n.p-overlaypanel:before {\n    border-width: 10px;\n    margin-left: -10px;\n}\n.p-overlaypanel-flipped:after,\n.p-overlaypanel-flipped:before {\n    bottom: auto;\n    top: 100%;\n}\n.p-overlaypanel.p-overlaypanel-flipped:after {\n    border-bottom-color: transparent;\n}\n.p-overlaypanel.p-overlaypanel-flipped:before {\n    border-bottom-color: transparent;\n}\n";
styleInject$b(css_248z$i);
script$S.render = render$f;

const _hoisted_1$n = ["href", "onClick"];
const _hoisted_2$k = { class: "p-menuitem-text" };
const _hoisted_3$h = { class: "row" };
const _hoisted_4$c = /*#__PURE__*/createTextVNode();


var script$R = {
  props: {
    item : Object
},
  setup(__props) {

const props = __props;




const info = ref();

function toggleInfo(e) {
    if (props.item && props.item.info && info.value) info.value.toggle(e);
}


return (_ctx, _cache) => {
  const _component_router_link = resolveComponent("router-link");

  return (openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_router_link, {
      to: __props.item.to,
      custom: ""
    }, {
      default: withCtx(({isActive, href, navigate, isExactActive}) => [
        createElementVNode("a", {
          class: normalizeClass([{'active-link': isActive}, "p-menuitem-link"]),
          href: href,
          onClick: navigate,
          onMouseover: toggleInfo,
          onMouseout: toggleInfo
        }, [
          (__props.item.icon)
            ? (openBlock(), createElementBlock("i", {
                key: 0,
                class: normalizeClass(["pi", __props.item.icon])
              }, null, 2 /* CLASS */))
            : createCommentVNode("v-if", true),
          createElementVNode("span", _hoisted_2$k, toDisplayString$1(__props.item.label), 1 /* TEXT */)
        ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_1$n)
      ]),
      _: 1 /* STABLE */
    }, 8 /* PROPS */, ["to"]),
    (__props.item.info)
      ? (openBlock(), createBlock(unref(script$S), {
          key: 0,
          ref_key: "info",
          ref: info,
          appendTo: "body"
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(__props.item.info, (row) => {
              return (openBlock(), createElementBlock("dl", null, [
                createElementVNode("div", _hoisted_3$h, [
                  createElementVNode("dt", null, toDisplayString$1(row.label), 1 /* TEXT */),
                  _hoisted_4$c,
                  createElementVNode("dd", null, toDisplayString$1(row.value), 1 /* TEXT */)
                ])
              ]))
            }), 256 /* UNKEYED_FRAGMENT */))
          ]),
          _: 1 /* STABLE */
        }, 512 /* NEED_PATCH */))
      : createCommentVNode("v-if", true)
  ], 64 /* STABLE_FRAGMENT */))
}
}

};

var css_248z$h = "\ndl[data-v-0b46fb32] {\r\n        position : relative;\r\n        display: flex;\r\n        flex-direction: column;\n}\ndt[data-v-0b46fb32] {\r\n        float : left;\r\n        font-weight : 700;\r\n        width : 50%\n}\ndd[data-v-0b46fb32] {\r\n        position : relative;\r\n        margin-left : 50%;\r\n        padding : 2px;\n}\ndl > div[data-v-0b46fb32] {\r\n        position : relative;\r\n        clear : both;\r\n        display : block;\n}\r\n";
styleInject$t(css_248z$h);

script$R.__scopeId = "data-v-0b46fb32";
script$R.__file = "presstojam/src/components/slugtrail/crumb.vue";

var script$Q = {
  props: {
    name : String,
    parent_id : Number,
    store : {
        type : Object,
        required : true
    }
},
  async setup(__props) {

let __temp, __restore;

const props = __props;

const Client = inject("client");
const i18n = inject("i18n");

const t = i18n.t;






let parent_id;

let entity = getEntity(props.store.model.name);
let structure = [];
let parent = entity.parent;

//if no get permissions, then no slug trail
if (hasEntity(parent) && getEntity(parent).perms.includes("get")) {

    if (props.store.type == "active") {
        structure.push(entity);
    }

    while(entity.parent) {
        const iparent = getEntity(entity.parent);
        if (iparent && iparent.perms.includes("get")) {
            structure.push(iparent);
            entity = iparent;
        } else {
            break;
        }
    }
    structure = structure.reverse();
} else {
    parent = null;
}

async function getData() {
    if (parent) {
      if (props.store.type == "active") {
        const data = await 
        props.store.load()
        .then(response => {
            parent_id = response["--parent"];
            return Client.get("/data/" + parent + "/active?__to=*&--id=" + response['--parent'])
        }).then(response => {
            return rowToTree(response, parent)
        });
        return data;
      } else {
        const data = await Client.get("/data/" + parent + "/active?__to=*&--id=" + props.store.parent_id)
        .then(response => {
            return rowToTree(response, parent)
        });
        return data;
      }
    } else {
        return {};
    }
}

const trail = (
  ([__temp,__restore] = withAsyncContext(() => getData())),
  __temp = await __temp,
  __restore(),
  __temp
);

function trailRouteInfo(trail, route) {
    let info = [];
    let summary = [];
    for(let i in trail[route.name]) {
        if (route.cells[i].background) continue;
        if (route.cells[i].summary) summary.push(trail[route.name][i]);
        info.push({label : t("models." + route.name + ".fields." + i + ".label"), value : trail[route.name][i]});
    }
    
    const label = (summary.length > 0) ? summary.join(" ") : route.name + " - " + trail[route.name]["--id"];
    return {
        label,
        info
    }
}

let crumbs = computed(() => {
    let arr = [];
    for(const entity of structure) {
        //add an entity store route
        //need to get the parent id

        const obj = { label : entity.name, to : { name : "repo", params : { model : entity.name } } };
        
        if (entity.parent) {
            if (trail[entity.name]) obj.to.params.id = trail[entity.name]["--parent"];
            else obj.to.params.id = parent_id;
        }
         
        arr.push(obj);
        
        //set the active route
        if (trail[entity.name]) {
            const { label, info } = trailRouteInfo(trail, entity);
            const obj = {
                label : label,
                to : { name : "primary", params : { model : entity.name, id : trail[entity.name]["--id"]} }
            };
            if (info.length > 0) obj.info = info;
            
            arr.push(obj);
        }
    }
    return arr;
});


return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$T), { model: unref(crumbs) }, {
    item: withCtx(({item}) => [
      createVNode(script$R, { item: item }, null, 8 /* PROPS */, ["item"])
    ]),
    _: 1 /* STABLE */
  }, 8 /* PROPS */, ["model"]))
}
}

};

var css_248z$g = "\n.slug-trail-vue-vue-type-style-index-0-id-027b103d-scoped-true-lang_p-breadcrumb__D8PaD[data-v-027b103d] {\r\n    background: #ffffff;\r\n    border: 1px solid #dee2e6;\r\n    border-radius: 6px;\r\n    padding: 1rem;\n}\r\n";
styleInject$t(css_248z$g);

script$Q.__scopeId = "data-v-027b103d";
script$Q.__file = "presstojam/src/components/slugtrail/slug-trail.vue";

var slugTrail = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': script$Q
});

var script$P = {
  props: {
        id : {
            type : Number,
            default : 0
        },
        name : String
    },
  setup(__props) {

const props = __props;

    

 
    subscribe("form_saved", "update", (response, method, model) => {
        if (model.name == props.name && method == "put") {
            trigger("effect_edited", props.name, props.id);
        }
    });

    onBeforeUnmount(() => {
        unsubscribe("form_saved", "update");
    });



return (_ctx, _cache) => {
  return (openBlock(), createBlock(script$X, {
    entity_name: __props.name,
    id: __props.id,
    method: "put",
    key: "edit"
  }, null, 8 /* PROPS */, ["entity_name", "id"]))
}
}

};

script$P.__file = "presstojam/src/components/effects/edit-effect.vue";

var script$O = {
  name: 'Dropdown',
  emits: ['update:modelValue', 'change', 'focus', 'blur', 'before-show', 'before-hide', 'show', 'hide', 'filter'],
  props: {
    modelValue: null,
    options: Array,
    optionLabel: null,
    optionValue: null,
    optionDisabled: null,
    optionGroupLabel: null,
    optionGroupChildren: null,
    scrollHeight: {
      type: String,
      default: '200px'
    },
    filter: Boolean,
    filterPlaceholder: String,
    filterLocale: String,
    filterMatchMode: {
      type: String,
      default: 'contains'
    },
    filterFields: {
      type: Array,
      default: null
    },
    editable: Boolean,
    placeholder: {
      type: String,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    dataKey: null,
    showClear: {
      type: Boolean,
      default: false
    },
    inputId: {
      type: String,
      default: null
    },
    inputClass: {
      type: String,
      default: null
    },
    inputStyle: {
      type: null,
      default: null
    },
    inputProps: {
      type: null,
      default: null
    },
    panelClass: {
      type: String,
      default: null
    },
    panelStyle: {
      type: null,
      default: null
    },
    panelProps: {
      type: null,
      default: null
    },
    filterInputProps: {
      type: null,
      default: null
    },
    clearIconProps: {
      type: null,
      default: null
    },
    appendTo: {
      type: String,
      default: 'body'
    },
    loading: {
      type: Boolean,
      default: false
    },
    clearIcon: {
      type: String,
      default: 'pi pi-times'
    },
    dropdownIcon: {
      type: String,
      default: 'pi pi-chevron-down'
    },
    filterIcon: {
      type: String,
      default: 'pi pi-search'
    },
    loadingIcon: {
      type: String,
      default: 'pi pi-spinner pi-spin'
    },
    resetFilterOnHide: {
      type: Boolean,
      default: false
    },
    virtualScrollerOptions: {
      type: Object,
      default: null
    },
    autoOptionFocus: {
      type: Boolean,
      default: true
    },
    autoFilterFocus: {
      type: Boolean,
      default: false
    },
    selectOnFocus: {
      type: Boolean,
      default: false
    },
    filterMessage: {
      type: String,
      default: null
    },
    selectionMessage: {
      type: String,
      default: null
    },
    emptySelectionMessage: {
      type: String,
      default: null
    },
    emptyFilterMessage: {
      type: String,
      default: null
    },
    emptyMessage: {
      type: String,
      default: null
    },
    tabindex: {
      type: Number,
      default: 0
    },
    'aria-label': {
      type: String,
      default: null
    },
    'aria-labelledby': {
      type: String,
      default: null
    }
  },
  outsideClickListener: null,
  scrollHandler: null,
  resizeListener: null,
  overlay: null,
  list: null,
  virtualScroller: null,
  searchTimeout: null,
  searchValue: null,
  isModelValueChanged: false,
  focusOnHover: false,

  data() {
    return {
      focused: false,
      focusedOptionIndex: -1,
      filterValue: null,
      overlayVisible: false
    };
  },

  watch: {
    modelValue() {
      this.isModelValueChanged = true;
    },

    options() {
      this.autoUpdateModel();
    }

  },

  mounted() {
    this.autoUpdateModel();
  },

  updated() {
    if (this.overlayVisible && this.isModelValueChanged) {
      this.scrollInView(this.findSelectedOptionIndex());
    }

    this.isModelValueChanged = false;
  },

  beforeUnmount() {
    this.unbindOutsideClickListener();
    this.unbindResizeListener();

    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }

    if (this.overlay) {
      ZIndexUtils.clear(this.overlay);
      this.overlay = null;
    }
  },

  methods: {
    getOptionIndex(index, fn) {
      return this.virtualScrollerDisabled ? index : fn && fn(index)['index'];
    },

    getOptionLabel(option) {
      return this.optionLabel ? ObjectUtils.resolveFieldData(option, this.optionLabel) : option;
    },

    getOptionValue(option) {
      return this.optionValue ? ObjectUtils.resolveFieldData(option, this.optionValue) : option;
    },

    getOptionRenderKey(option, index) {
      return (this.dataKey ? ObjectUtils.resolveFieldData(option, this.dataKey) : this.getOptionLabel(option)) + '_' + index;
    },

    isOptionDisabled(option) {
      return this.optionDisabled ? ObjectUtils.resolveFieldData(option, this.optionDisabled) : false;
    },

    isOptionGroup(option) {
      return this.optionGroupLabel && option.optionGroup && option.group;
    },

    getOptionGroupLabel(optionGroup) {
      return ObjectUtils.resolveFieldData(optionGroup, this.optionGroupLabel);
    },

    getOptionGroupChildren(optionGroup) {
      return ObjectUtils.resolveFieldData(optionGroup, this.optionGroupChildren);
    },

    getAriaPosInset(index) {
      return (this.optionGroupLabel ? index - this.visibleOptions.slice(0, index).filter(option => this.isOptionGroup(option)).length : index) + 1;
    },

    show(isFocus) {
      this.$emit('before-show');
      this.overlayVisible = true;
      this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : -1;
      isFocus && DomHandler.focus(this.$refs.focusInput);
    },

    hide(isFocus) {
      const _hide = () => {
        this.$emit('before-hide');
        this.overlayVisible = false;
        this.focusedOptionIndex = -1;
        this.searchValue = '';
        this.resetFilterOnHide && (this.filterValue = null);
        isFocus && DomHandler.focus(this.$refs.focusInput);
      };

      setTimeout(() => {
        _hide();
      }, 0); // For ScreenReaders
    },

    onFocus(event) {
      this.focused = true;
      this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.overlayVisible && this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : -1;
      this.overlayVisible && this.scrollInView(this.focusedOptionIndex);
      this.$emit('focus', event);
    },

    onBlur(event) {
      this.focused = false;
      this.focusedOptionIndex = -1;
      this.searchValue = '';
      this.$emit('blur', event);
    },

    onKeyDown(event) {
      const metaKey = event.metaKey || event.ctrlKey;

      switch (event.code) {
        case 'ArrowDown':
          this.onArrowDownKey(event);
          break;

        case 'ArrowUp':
          this.onArrowUpKey(event, this.editable);
          break;

        case 'ArrowLeft':
        case 'ArrowRight':
          this.onArrowLeftKey(event, this.editable);
          break;

        case 'Home':
          this.onHomeKey(event, this.editable);
          break;

        case 'End':
          this.onEndKey(event, this.editable);
          break;

        case 'PageDown':
          this.onPageDownKey(event);
          break;

        case 'PageUp':
          this.onPageUpKey(event);
          break;

        case 'Space':
          this.onSpaceKey(event, this.editable);
          break;

        case 'Enter':
          this.onEnterKey(event);
          break;

        case 'Escape':
          this.onEscapeKey(event);
          break;

        case 'Tab':
          this.onTabKey(event);
          break;

        case 'Backspace':
          this.onBackspaceKey(event, this.editable);
          break;

        case 'ShiftLeft':
        case 'ShiftRight':
          //NOOP
          break;

        default:
          if (!metaKey && ObjectUtils.isPrintableCharacter(event.key)) {
            !this.overlayVisible && this.show();
            !this.editable && this.searchOptions(event, event.key);
          }

          break;
      }
    },

    onEditableInput(event) {
      const value = event.target.value;
      this.searchValue = '';
      const matched = this.searchOptions(event, value);
      !matched && (this.focusedOptionIndex = -1);
      this.$emit('update:modelValue', value);
    },

    onContainerClick(event) {
      if (this.disabled || this.loading) {
        return;
      }

      if (DomHandler.hasClass(event.target, 'p-dropdown-clear-icon') || event.target.tagName === 'INPUT') {
        return;
      } else if (!this.overlay || !this.overlay.contains(event.target)) {
        this.overlayVisible ? this.hide(true) : this.show(true);
      }
    },

    onClearClick(event) {
      this.updateModel(event, null);
    },

    onFirstHiddenFocus(event) {
      const relatedTarget = event.relatedTarget;

      if (relatedTarget === this.$refs.focusInput) {
        const firstFocusableEl = DomHandler.getFirstFocusableElement(this.overlay, ':not(.p-hidden-focusable)');
        DomHandler.focus(firstFocusableEl);
      } else {
        DomHandler.focus(this.$refs.focusInput);
      }
    },

    onLastHiddenFocus() {
      DomHandler.focus(this.$refs.firstHiddenFocusableElementOnOverlay);
    },

    onOptionSelect(event, option, isHide = true) {
      const value = this.getOptionValue(option);
      this.updateModel(event, value);
      isHide && this.hide(true);
    },

    onOptionMouseMove(event, index) {
      if (this.focusOnHover) {
        this.changeFocusedOptionIndex(event, index);
      }
    },

    onFilterChange(event) {
      const value = event.target.value;
      this.filterValue = value;
      this.focusedOptionIndex = -1;
      this.$emit('filter', {
        originalEvent: event,
        value
      });
      !this.virtualScrollerDisabled && this.virtualScroller.scrollToIndex(0);
    },

    onFilterKeyDown(event) {
      switch (event.code) {
        case 'ArrowDown':
          this.onArrowDownKey(event);
          break;

        case 'ArrowUp':
          this.onArrowUpKey(event, true);
          break;

        case 'ArrowLeft':
        case 'ArrowRight':
          this.onArrowLeftKey(event, true);
          break;

        case 'Home':
          this.onHomeKey(event, true);
          break;

        case 'End':
          this.onEndKey(event, true);
          break;

        case 'Enter':
          this.onEnterKey(event);
          break;

        case 'Escape':
          this.onEscapeKey(event);
          break;

        case 'Tab':
          this.onTabKey(event, true);
          break;
      }
    },

    onFilterBlur() {
      this.focusedOptionIndex = -1;
    },

    onFilterUpdated() {
      if (this.overlayVisible) {
        this.alignOverlay();
      }
    },

    onOverlayClick(event) {
      OverlayEventBus.emit('overlay-click', {
        originalEvent: event,
        target: this.$el
      });
    },

    onOverlayKeyDown(event) {
      switch (event.code) {
        case 'Escape':
          this.onEscapeKey(event);
          break;
      }
    },

    onArrowDownKey(event) {
      const optionIndex = this.focusedOptionIndex !== -1 ? this.findNextOptionIndex(this.focusedOptionIndex) : this.findFirstFocusedOptionIndex();
      this.changeFocusedOptionIndex(event, optionIndex);
      !this.overlayVisible && this.show();
      event.preventDefault();
    },

    onArrowUpKey(event, pressedInInputText = false) {
      if (event.altKey && !pressedInInputText) {
        if (this.focusedOptionIndex !== -1) {
          this.onOptionSelect(event, this.visibleOptions[this.focusedOptionIndex]);
        }

        this.overlayVisible && this.hide();
        event.preventDefault();
      } else {
        const optionIndex = this.focusedOptionIndex !== -1 ? this.findPrevOptionIndex(this.focusedOptionIndex) : this.findLastFocusedOptionIndex();
        this.changeFocusedOptionIndex(event, optionIndex);
        !this.overlayVisible && this.show();
        event.preventDefault();
      }
    },

    onArrowLeftKey(event, pressedInInputText = false) {
      pressedInInputText && (this.focusedOptionIndex = -1);
    },

    onHomeKey(event, pressedInInputText = false) {
      if (pressedInInputText) {
        event.currentTarget.setSelectionRange(0, 0);
        this.focusedOptionIndex = -1;
      } else {
        this.changeFocusedOptionIndex(event, this.findFirstOptionIndex());
        !this.overlayVisible && this.show();
      }

      event.preventDefault();
    },

    onEndKey(event, pressedInInputText = false) {
      if (pressedInInputText) {
        const target = event.currentTarget;
        const len = target.value.length;
        target.setSelectionRange(len, len);
        this.focusedOptionIndex = -1;
      } else {
        this.changeFocusedOptionIndex(event, this.findLastOptionIndex());
        !this.overlayVisible && this.show();
      }

      event.preventDefault();
    },

    onPageUpKey(event) {
      this.scrollInView(0);
      event.preventDefault();
    },

    onPageDownKey(event) {
      this.scrollInView(this.visibleOptions.length - 1);
      event.preventDefault();
    },

    onEnterKey(event) {
      if (!this.overlayVisible) {
        this.onArrowDownKey(event);
      } else {
        if (this.focusedOptionIndex !== -1) {
          this.onOptionSelect(event, this.visibleOptions[this.focusedOptionIndex]);
        }

        this.hide();
      }

      event.preventDefault();
    },

    onSpaceKey(event, pressedInInputText = false) {
      !pressedInInputText && this.onEnterKey(event);
    },

    onEscapeKey(event) {
      this.overlayVisible && this.hide(true);
      event.preventDefault();
    },

    onTabKey(event, pressedInInputText = false) {
      if (!pressedInInputText) {
        if (this.overlayVisible && this.hasFocusableElements()) {
          DomHandler.focus(this.$refs.firstHiddenFocusableElementOnOverlay);
          event.preventDefault();
        } else {
          if (this.focusedOptionIndex !== -1) {
            this.onOptionSelect(event, this.visibleOptions[this.focusedOptionIndex]);
          }

          this.overlayVisible && this.hide(this.filter);
        }
      }
    },

    onBackspaceKey(event, pressedInInputText = false) {
      if (pressedInInputText) {
        !this.overlayVisible && this.show();
      }
    },

    onOverlayEnter(el) {
      ZIndexUtils.set('overlay', el, this.$primevue.config.zIndex.overlay);
      this.alignOverlay();
      this.scrollInView();
      this.autoFilterFocus && DomHandler.focus(this.$refs.filterInput);
    },

    onOverlayAfterEnter() {
      this.bindOutsideClickListener();
      this.bindScrollListener();
      this.bindResizeListener();
      this.$emit('show');
    },

    onOverlayLeave() {
      this.unbindOutsideClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
      this.$emit('hide');
      this.overlay = null;
    },

    onOverlayAfterLeave(el) {
      ZIndexUtils.clear(el);
    },

    alignOverlay() {
      if (this.appendTo === 'self') {
        DomHandler.relativePosition(this.overlay, this.$el);
      } else {
        this.overlay.style.minWidth = DomHandler.getOuterWidth(this.$el) + 'px';
        DomHandler.absolutePosition(this.overlay, this.$el);
      }
    },

    bindOutsideClickListener() {
      if (!this.outsideClickListener) {
        this.outsideClickListener = event => {
          if (this.overlayVisible && this.overlay && !this.$el.contains(event.target) && !this.overlay.contains(event.target)) {
            this.hide();
          }
        };

        document.addEventListener('click', this.outsideClickListener);
      }
    },

    unbindOutsideClickListener() {
      if (this.outsideClickListener) {
        document.removeEventListener('click', this.outsideClickListener);
        this.outsideClickListener = null;
      }
    },

    bindScrollListener() {
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.$refs.container, () => {
          if (this.overlayVisible) {
            this.hide();
          }
        });
      }

      this.scrollHandler.bindScrollListener();
    },

    unbindScrollListener() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    },

    bindResizeListener() {
      if (!this.resizeListener) {
        this.resizeListener = () => {
          if (this.overlayVisible && !DomHandler.isTouchDevice()) {
            this.hide();
          }
        };

        window.addEventListener('resize', this.resizeListener);
      }
    },

    unbindResizeListener() {
      if (this.resizeListener) {
        window.removeEventListener('resize', this.resizeListener);
        this.resizeListener = null;
      }
    },

    hasFocusableElements() {
      return DomHandler.getFocusableElements(this.overlay, ':not(.p-hidden-focusable)').length > 0;
    },

    isOptionMatched(option) {
      return this.isValidOption(option) && this.getOptionLabel(option).toLocaleLowerCase(this.filterLocale).startsWith(this.searchValue.toLocaleLowerCase(this.filterLocale));
    },

    isValidOption(option) {
      return option && !(this.isOptionDisabled(option) || this.isOptionGroup(option));
    },

    isValidSelectedOption(option) {
      return this.isValidOption(option) && this.isSelected(option);
    },

    isSelected(option) {
      return ObjectUtils.equals(this.modelValue, this.getOptionValue(option), this.equalityKey);
    },

    findFirstOptionIndex() {
      return this.visibleOptions.findIndex(option => this.isValidOption(option));
    },

    findLastOptionIndex() {
      return ObjectUtils.findLastIndex(this.visibleOptions, option => this.isValidOption(option));
    },

    findNextOptionIndex(index) {
      const matchedOptionIndex = index < this.visibleOptions.length - 1 ? this.visibleOptions.slice(index + 1).findIndex(option => this.isValidOption(option)) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex + index + 1 : index;
    },

    findPrevOptionIndex(index) {
      const matchedOptionIndex = index > 0 ? ObjectUtils.findLastIndex(this.visibleOptions.slice(0, index), option => this.isValidOption(option)) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex : index;
    },

    findSelectedOptionIndex() {
      return this.hasSelectedOption ? this.visibleOptions.findIndex(option => this.isValidSelectedOption(option)) : -1;
    },

    findFirstFocusedOptionIndex() {
      const selectedIndex = this.findSelectedOptionIndex();
      return selectedIndex < 0 ? this.findFirstOptionIndex() : selectedIndex;
    },

    findLastFocusedOptionIndex() {
      const selectedIndex = this.findSelectedOptionIndex();
      return selectedIndex < 0 ? this.findLastOptionIndex() : selectedIndex;
    },

    searchOptions(event, char) {
      this.searchValue = (this.searchValue || '') + char;
      let optionIndex = -1;
      let matched = false;

      if (this.focusedOptionIndex !== -1) {
        optionIndex = this.visibleOptions.slice(this.focusedOptionIndex).findIndex(option => this.isOptionMatched(option));
        optionIndex = optionIndex === -1 ? this.visibleOptions.slice(0, this.focusedOptionIndex).findIndex(option => this.isOptionMatched(option)) : optionIndex + this.focusedOptionIndex;
      } else {
        optionIndex = this.visibleOptions.findIndex(option => this.isOptionMatched(option));
      }

      if (optionIndex !== -1) {
        matched = true;
      }

      if (optionIndex === -1 && this.focusedOptionIndex === -1) {
        optionIndex = this.findFirstFocusedOptionIndex();
      }

      if (optionIndex !== -1) {
        this.changeFocusedOptionIndex(event, optionIndex);
      }

      if (this.searchTimeout) {
        clearTimeout(this.searchTimeout);
      }

      this.searchTimeout = setTimeout(() => {
        this.searchValue = '';
        this.searchTimeout = null;
      }, 500);
      return matched;
    },

    changeFocusedOptionIndex(event, index) {
      if (this.focusedOptionIndex !== index) {
        this.focusedOptionIndex = index;
        this.scrollInView();

        if (this.selectOnFocus) {
          this.onOptionSelect(event, this.visibleOptions[index], false);
        }
      }
    },

    scrollInView(index = -1) {
      const id = index !== -1 ? `${this.id}_${index}` : this.focusedOptionId;
      const element = DomHandler.findSingle(this.list, `li[id="${id}"]`);

      if (element) {
        element.scrollIntoView && element.scrollIntoView({
          block: 'nearest',
          inline: 'start'
        });
      } else if (!this.virtualScrollerDisabled) {
        setTimeout(() => {
          this.virtualScroller && this.virtualScroller.scrollToIndex(index !== -1 ? index : this.focusedOptionIndex);
        }, 0);
      }
    },

    autoUpdateModel() {
      if (this.selectOnFocus && this.autoOptionFocus && !this.hasSelectedOption) {
        this.focusedOptionIndex = this.findFirstFocusedOptionIndex();
        this.onOptionSelect(null, this.visibleOptions[this.focusedOptionIndex], false);
      }
    },

    updateModel(event, value) {
      this.$emit('update:modelValue', value);
      this.$emit('change', {
        originalEvent: event,
        value
      });
    },

    flatOptions(options) {
      return (options || []).reduce((result, option, index) => {
        result.push({
          optionGroup: option,
          group: true,
          index
        });
        const optionGroupChildren = this.getOptionGroupChildren(option);
        optionGroupChildren && optionGroupChildren.forEach(o => result.push(o));
        return result;
      }, []);
    },

    overlayRef(el) {
      this.overlay = el;
    },

    listRef(el, contentRef) {
      this.list = el;
      contentRef && contentRef(el); // For VirtualScroller
    },

    virtualScrollerRef(el) {
      this.virtualScroller = el;
    }

  },
  computed: {
    containerClass() {
      return ['p-dropdown p-component p-inputwrapper', {
        'p-disabled': this.disabled,
        'p-dropdown-clearable': this.showClear && !this.disabled,
        'p-focus': this.focused,
        'p-inputwrapper-filled': this.modelValue,
        'p-inputwrapper-focus': this.focused || this.overlayVisible,
        'p-overlay-open': this.overlayVisible
      }];
    },

    inputStyleClass() {
      return ['p-dropdown-label p-inputtext', this.inputClass, {
        'p-placeholder': !this.editable && this.label === this.placeholder,
        'p-dropdown-label-empty': !this.editable && !this.$slots['value'] && (this.label === 'p-emptylabel' || this.label.length === 0)
      }];
    },

    panelStyleClass() {
      return ['p-dropdown-panel p-component', this.panelClass, {
        'p-input-filled': this.$primevue.config.inputStyle === 'filled',
        'p-ripple-disabled': this.$primevue.config.ripple === false
      }];
    },

    dropdownIconClass() {
      return ['p-dropdown-trigger-icon', this.loading ? this.loadingIcon : this.dropdownIcon];
    },

    visibleOptions() {
      const options = this.optionGroupLabel ? this.flatOptions(this.options) : this.options || [];

      if (this.filterValue) {
        const filteredOptions = FilterService.filter(options, this.searchFields, this.filterValue, this.filterMatchMode, this.filterLocale);

        if (this.optionGroupLabel) {
          const optionGroups = this.options || [];
          const filtered = [];
          optionGroups.forEach(group => {
            const filteredItems = group.items.filter(item => filteredOptions.includes(item));
            if (filteredItems.length > 0) filtered.push({ ...group,
              items: [...filteredItems]
            });
          });
          return this.flatOptions(filtered);
        }

        return filteredOptions;
      }

      return options;
    },

    hasSelectedOption() {
      return ObjectUtils.isNotEmpty(this.modelValue);
    },

    label() {
      const selectedOptionIndex = this.findSelectedOptionIndex();
      return selectedOptionIndex !== -1 ? this.getOptionLabel(this.visibleOptions[selectedOptionIndex]) : this.placeholder || 'p-emptylabel';
    },

    editableInputValue() {
      const selectedOptionIndex = this.findSelectedOptionIndex();
      return selectedOptionIndex !== -1 ? this.getOptionLabel(this.visibleOptions[selectedOptionIndex]) : this.modelValue || '';
    },

    equalityKey() {
      return this.optionValue ? null : this.dataKey;
    },

    searchFields() {
      return this.filterFields || [this.optionLabel];
    },

    filterResultMessageText() {
      return ObjectUtils.isNotEmpty(this.visibleOptions) ? this.filterMessageText.replaceAll('{0}', this.visibleOptions.length) : this.emptyFilterMessageText;
    },

    filterMessageText() {
      return this.filterMessage || this.$primevue.config.locale.searchMessage || '';
    },

    emptyFilterMessageText() {
      return this.emptyFilterMessage || this.$primevue.config.locale.emptySearchMessage || this.$primevue.config.locale.emptyFilterMessage || '';
    },

    emptyMessageText() {
      return this.emptyMessage || this.$primevue.config.locale.emptyMessage || '';
    },

    selectionMessageText() {
      return this.selectionMessage || this.$primevue.config.locale.selectionMessage || '';
    },

    emptySelectionMessageText() {
      return this.emptySelectionMessage || this.$primevue.config.locale.emptySelectionMessage || '';
    },

    selectedMessageText() {
      return this.hasSelectedOption ? this.selectionMessageText.replaceAll('{0}', '1') : this.emptySelectionMessageText;
    },

    id() {
      return this.$attrs.id || UniqueComponentId();
    },

    focusedOptionId() {
      return this.focusedOptionIndex !== -1 ? `${this.id}_${this.focusedOptionIndex}` : null;
    },

    ariaSetSize() {
      return this.visibleOptions.filter(option => !this.isOptionGroup(option)).length;
    },

    virtualScrollerDisabled() {
      return !this.virtualScrollerOptions;
    }

  },
  directives: {
    ripple: Ripple
  },
  components: {
    VirtualScroller: script$1g,
    Portal: script$1C
  }
};
const _hoisted_1$m = ["id"];
const _hoisted_2$j = ["id", "value", "placeholder", "tabindex", "disabled", "aria-label", "aria-labelledby", "aria-expanded", "aria-controls", "aria-activedescendant"];
const _hoisted_3$g = ["id", "tabindex", "aria-label", "aria-labelledby", "aria-expanded", "aria-controls", "aria-activedescendant", "aria-disabled"];
const _hoisted_4$b = {
  class: "p-dropdown-trigger"
};
const _hoisted_5$a = {
  key: 0,
  class: "p-dropdown-header"
};
const _hoisted_6$9 = {
  class: "p-dropdown-filter-container"
};
const _hoisted_7$6 = ["value", "placeholder", "aria-owns", "aria-activedescendant"];
const _hoisted_8$5 = {
  role: "status",
  "aria-live": "polite",
  class: "p-hidden-accessible"
};
const _hoisted_9$3 = ["id"];
const _hoisted_10$3 = ["id"];
const _hoisted_11$3 = ["id", "aria-label", "aria-selected", "aria-disabled", "aria-setsize", "aria-posinset", "onClick", "onMousemove"];
const _hoisted_12$3 = {
  key: 0,
  class: "p-dropdown-empty-message",
  role: "option"
};
const _hoisted_13$3 = {
  key: 1,
  class: "p-dropdown-empty-message",
  role: "option"
};
const _hoisted_14$2 = {
  key: 0,
  role: "status",
  "aria-live": "polite",
  class: "p-hidden-accessible"
};
const _hoisted_15$1 = {
  role: "status",
  "aria-live": "polite",
  class: "p-hidden-accessible"
};

function render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VirtualScroller = resolveComponent("VirtualScroller");

  const _component_Portal = resolveComponent("Portal");

  const _directive_ripple = resolveDirective("ripple");

  return openBlock(), createElementBlock("div", {
    ref: "container",
    id: $options.id,
    class: normalizeClass($options.containerClass),
    onClick: _cache[16] || (_cache[16] = (...args) => $options.onContainerClick && $options.onContainerClick(...args))
  }, [$props.editable ? (openBlock(), createElementBlock("input", mergeProps({
    key: 0,
    ref: "focusInput",
    id: $props.inputId,
    type: "text",
    style: $props.inputStyle,
    class: $options.inputStyleClass,
    value: $options.editableInputValue,
    placeholder: $props.placeholder,
    tabindex: !$props.disabled ? $props.tabindex : -1,
    disabled: $props.disabled,
    autocomplete: "off",
    role: "combobox",
    "aria-label": _ctx.ariaLabel,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-haspopup": "listbox",
    "aria-expanded": $data.overlayVisible,
    "aria-controls": $options.id + '_list',
    "aria-activedescendant": $data.focused ? $options.focusedOptionId : undefined,
    onFocus: _cache[0] || (_cache[0] = (...args) => $options.onFocus && $options.onFocus(...args)),
    onBlur: _cache[1] || (_cache[1] = (...args) => $options.onBlur && $options.onBlur(...args)),
    onKeydown: _cache[2] || (_cache[2] = (...args) => $options.onKeyDown && $options.onKeyDown(...args)),
    onInput: _cache[3] || (_cache[3] = (...args) => $options.onEditableInput && $options.onEditableInput(...args))
  }, $props.inputProps), null, 16, _hoisted_2$j)) : (openBlock(), createElementBlock("span", mergeProps({
    key: 1,
    ref: "focusInput",
    id: $props.inputId,
    style: $props.inputStyle,
    class: $options.inputStyleClass,
    tabindex: !$props.disabled ? $props.tabindex : -1,
    role: "combobox",
    "aria-label": _ctx.ariaLabel || ($options.label === 'p-emptylabel' ? undefined : $options.label),
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-haspopup": "listbox",
    "aria-expanded": $data.overlayVisible,
    "aria-controls": $options.id + '_list',
    "aria-activedescendant": $data.focused ? $options.focusedOptionId : undefined,
    "aria-disabled": $props.disabled,
    onFocus: _cache[4] || (_cache[4] = (...args) => $options.onFocus && $options.onFocus(...args)),
    onBlur: _cache[5] || (_cache[5] = (...args) => $options.onBlur && $options.onBlur(...args)),
    onKeydown: _cache[6] || (_cache[6] = (...args) => $options.onKeyDown && $options.onKeyDown(...args))
  }, $props.inputProps), [renderSlot(_ctx.$slots, "value", {
    value: $props.modelValue,
    placeholder: $props.placeholder
  }, () => [createTextVNode(toDisplayString$1($options.label === 'p-emptylabel' ? ' ' : $options.label || 'empty'), 1)])], 16, _hoisted_3$g)), $props.showClear && $props.modelValue != null ? (openBlock(), createElementBlock("i", mergeProps({
    key: 2,
    class: ['p-dropdown-clear-icon', $props.clearIcon],
    onClick: _cache[7] || (_cache[7] = (...args) => $options.onClearClick && $options.onClearClick(...args))
  }, $props.clearIconProps), null, 16)) : createCommentVNode("", true), createElementVNode("div", _hoisted_4$b, [renderSlot(_ctx.$slots, "indicator", {}, () => [createElementVNode("span", {
    class: normalizeClass($options.dropdownIconClass),
    "aria-hidden": "true"
  }, null, 2)])]), createVNode(_component_Portal, {
    appendTo: $props.appendTo
  }, {
    default: withCtx(() => [createVNode(Transition, {
      name: "p-connected-overlay",
      onEnter: $options.onOverlayEnter,
      onAfterEnter: $options.onOverlayAfterEnter,
      onLeave: $options.onOverlayLeave,
      onAfterLeave: $options.onOverlayAfterLeave
    }, {
      default: withCtx(() => [$data.overlayVisible ? (openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        ref: $options.overlayRef,
        style: $props.panelStyle,
        class: $options.panelStyleClass,
        onClick: _cache[14] || (_cache[14] = (...args) => $options.onOverlayClick && $options.onOverlayClick(...args)),
        onKeydown: _cache[15] || (_cache[15] = (...args) => $options.onOverlayKeyDown && $options.onOverlayKeyDown(...args))
      }, $props.panelProps), [createElementVNode("span", {
        ref: "firstHiddenFocusableElementOnOverlay",
        role: "presentation",
        "aria-hidden": "true",
        class: "p-hidden-accessible p-hidden-focusable",
        tabindex: 0,
        onFocus: _cache[8] || (_cache[8] = (...args) => $options.onFirstHiddenFocus && $options.onFirstHiddenFocus(...args))
      }, null, 544), renderSlot(_ctx.$slots, "header", {
        value: $props.modelValue,
        options: $options.visibleOptions
      }), $props.filter ? (openBlock(), createElementBlock("div", _hoisted_5$a, [createElementVNode("div", _hoisted_6$9, [createElementVNode("input", mergeProps({
        ref: "filterInput",
        type: "text",
        value: $data.filterValue,
        onVnodeUpdated: _cache[9] || (_cache[9] = (...args) => $options.onFilterUpdated && $options.onFilterUpdated(...args)),
        class: "p-dropdown-filter p-inputtext p-component",
        placeholder: $props.filterPlaceholder,
        role: "searchbox",
        autocomplete: "off",
        "aria-owns": $options.id + '_list',
        "aria-activedescendant": $options.focusedOptionId,
        onKeydown: _cache[10] || (_cache[10] = (...args) => $options.onFilterKeyDown && $options.onFilterKeyDown(...args)),
        onBlur: _cache[11] || (_cache[11] = (...args) => $options.onFilterBlur && $options.onFilterBlur(...args)),
        onInput: _cache[12] || (_cache[12] = (...args) => $options.onFilterChange && $options.onFilterChange(...args))
      }, $props.filterInputProps), null, 16, _hoisted_7$6), createElementVNode("span", {
        class: normalizeClass(['p-dropdown-filter-icon', $props.filterIcon])
      }, null, 2)]), createElementVNode("span", _hoisted_8$5, toDisplayString$1($options.filterResultMessageText), 1)])) : createCommentVNode("", true), createElementVNode("div", {
        class: "p-dropdown-items-wrapper",
        style: normalizeStyle({
          'max-height': $options.virtualScrollerDisabled ? $props.scrollHeight : ''
        })
      }, [createVNode(_component_VirtualScroller, mergeProps({
        ref: $options.virtualScrollerRef
      }, $props.virtualScrollerOptions, {
        items: $options.visibleOptions,
        style: {
          height: $props.scrollHeight
        },
        tabindex: -1,
        disabled: $options.virtualScrollerDisabled
      }), createSlots({
        content: withCtx(({
          styleClass,
          contentRef,
          items,
          getItemOptions,
          contentStyle,
          itemSize
        }) => [createElementVNode("ul", {
          ref: el => $options.listRef(el, contentRef),
          id: $options.id + '_list',
          class: normalizeClass(['p-dropdown-items', styleClass]),
          style: normalizeStyle(contentStyle),
          role: "listbox"
        }, [(openBlock(true), createElementBlock(Fragment, null, renderList(items, (option, i) => {
          return openBlock(), createElementBlock(Fragment, {
            key: $options.getOptionRenderKey(option, $options.getOptionIndex(i, getItemOptions))
          }, [$options.isOptionGroup(option) ? (openBlock(), createElementBlock("li", {
            key: 0,
            id: $options.id + '_' + $options.getOptionIndex(i, getItemOptions),
            style: normalizeStyle({
              height: itemSize ? itemSize + 'px' : undefined
            }),
            class: "p-dropdown-item-group",
            role: "option"
          }, [renderSlot(_ctx.$slots, "optiongroup", {
            option: option.optionGroup,
            index: $options.getOptionIndex(i, getItemOptions)
          }, () => [createTextVNode(toDisplayString$1($options.getOptionGroupLabel(option.optionGroup)), 1)])], 12, _hoisted_10$3)) : withDirectives((openBlock(), createElementBlock("li", {
            key: 1,
            id: $options.id + '_' + $options.getOptionIndex(i, getItemOptions),
            style: normalizeStyle({
              height: itemSize ? itemSize + 'px' : undefined
            }),
            class: normalizeClass(['p-dropdown-item', {
              'p-highlight': $options.isSelected(option),
              'p-focus': $data.focusedOptionIndex === $options.getOptionIndex(i, getItemOptions),
              'p-disabled': $options.isOptionDisabled(option)
            }]),
            role: "option",
            "aria-label": $options.getOptionLabel(option),
            "aria-selected": $options.isSelected(option),
            "aria-disabled": $options.isOptionDisabled(option),
            "aria-setsize": $options.ariaSetSize,
            "aria-posinset": $options.getAriaPosInset($options.getOptionIndex(i, getItemOptions)),
            onClick: $event => $options.onOptionSelect($event, option),
            onMousemove: $event => $options.onOptionMouseMove($event, $options.getOptionIndex(i, getItemOptions))
          }, [renderSlot(_ctx.$slots, "option", {
            option: option,
            index: $options.getOptionIndex(i, getItemOptions)
          }, () => [createTextVNode(toDisplayString$1($options.getOptionLabel(option)), 1)])], 46, _hoisted_11$3)), [[_directive_ripple]])], 64);
        }), 128)), $data.filterValue && (!items || items && items.length === 0) ? (openBlock(), createElementBlock("li", _hoisted_12$3, [renderSlot(_ctx.$slots, "emptyfilter", {}, () => [createTextVNode(toDisplayString$1($options.emptyFilterMessageText), 1)])])) : !$props.options || $props.options && $props.options.length === 0 ? (openBlock(), createElementBlock("li", _hoisted_13$3, [renderSlot(_ctx.$slots, "empty", {}, () => [createTextVNode(toDisplayString$1($options.emptyMessageText), 1)])])) : createCommentVNode("", true)], 14, _hoisted_9$3), !$props.options || $props.options && $props.options.length === 0 ? (openBlock(), createElementBlock("span", _hoisted_14$2, toDisplayString$1($options.emptyMessageText), 1)) : createCommentVNode("", true), createElementVNode("span", _hoisted_15$1, toDisplayString$1($options.selectedMessageText), 1)]),
        _: 2
      }, [_ctx.$slots.loader ? {
        name: "loader",
        fn: withCtx(({
          options
        }) => [renderSlot(_ctx.$slots, "loader", {
          options: options
        })]),
        key: "0"
      } : undefined]), 1040, ["items", "style", "disabled"])], 4), renderSlot(_ctx.$slots, "footer", {
        value: $props.modelValue,
        options: $options.visibleOptions
      }), createElementVNode("span", {
        ref: "lastHiddenFocusableElementOnOverlay",
        role: "presentation",
        "aria-hidden": "true",
        class: "p-hidden-accessible p-hidden-focusable",
        tabindex: 0,
        onFocus: _cache[13] || (_cache[13] = (...args) => $options.onLastHiddenFocus && $options.onLastHiddenFocus(...args))
      }, null, 544)], 16)) : createCommentVNode("", true)]),
      _: 3
    }, 8, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])]),
    _: 3
  }, 8, ["appendTo"])], 10, _hoisted_1$m);
}

function styleInject$a(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$f = "\n.p-dropdown {\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    cursor: pointer;\n    position: relative;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n}\n.p-dropdown-clear-icon {\n    position: absolute;\n    top: 50%;\n    margin-top: -0.5rem;\n}\n.p-dropdown-trigger {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    -ms-flex-negative: 0;\n        flex-shrink: 0;\n}\n.p-dropdown-label {\n    display: block;\n    white-space: nowrap;\n    overflow: hidden;\n    -webkit-box-flex: 1;\n        -ms-flex: 1 1 auto;\n            flex: 1 1 auto;\n    width: 1%;\n    text-overflow: ellipsis;\n    cursor: pointer;\n}\n.p-dropdown-label-empty {\n    overflow: hidden;\n    opacity: 0;\n}\ninput.p-dropdown-label {\n    cursor: default;\n}\n.p-dropdown .p-dropdown-panel {\n    min-width: 100%;\n}\n.p-dropdown-panel {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.p-dropdown-items-wrapper {\n    overflow: auto;\n}\n.p-dropdown-item {\n    cursor: pointer;\n    font-weight: normal;\n    white-space: nowrap;\n    position: relative;\n    overflow: hidden;\n}\n.p-dropdown-item-group {\n    cursor: auto;\n}\n.p-dropdown-items {\n    margin: 0;\n    padding: 0;\n    list-style-type: none;\n}\n.p-dropdown-filter {\n    width: 100%;\n}\n.p-dropdown-filter-container {\n    position: relative;\n}\n.p-dropdown-filter-icon {\n    position: absolute;\n    top: 50%;\n    margin-top: -0.5rem;\n}\n.p-fluid .p-dropdown {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n}\n.p-fluid .p-dropdown .p-dropdown-label {\n    width: 1%;\n}\n";
styleInject$a(css_248z$f);
script$O.render = render$e;

var script$9$2 = {
  name: 'CurrentPageReport',
  inheritAttrs: false,
  props: {
    pageCount: {
      type: Number,
      default: 0
    },
    currentPage: {
      type: Number,
      default: 0
    },
    page: {
      type: Number,
      default: 0
    },
    first: {
      type: Number,
      default: 0
    },
    rows: {
      type: Number,
      default: 0
    },
    totalRecords: {
      type: Number,
      default: 0
    },
    template: {
      type: String,
      default: '({currentPage} of {totalPages})'
    }
  },
  computed: {
    text() {
      let text = this.template.replace('{currentPage}', this.currentPage).replace('{totalPages}', this.pageCount).replace('{first}', this.pageCount > 0 ? this.first + 1 : 0).replace('{last}', Math.min(this.first + this.rows, this.totalRecords)).replace('{rows}', this.rows).replace('{totalRecords}', this.totalRecords);
      return text;
    }

  }
};
const _hoisted_1$6$2 = {
  class: "p-paginator-current"
};

function render$9$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", _hoisted_1$6$2, toDisplayString$1($options.text), 1);
}

script$9$2.render = render$9$2;
var script$8$2 = {
  name: 'FirstPageLink',
  computed: {
    containerClass() {
      return ['p-paginator-first p-paginator-element p-link', {
        'p-disabled': this.$attrs.disabled
      }];
    }

  },
  directives: {
    ripple: Ripple
  }
};

const _hoisted_1$5$2 = /*#__PURE__*/createElementVNode("span", {
  class: "p-paginator-icon pi pi-angle-double-left"
}, null, -1);

const _hoisted_2$5$2 = [_hoisted_1$5$2];

function render$8$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_ripple = resolveDirective("ripple");

  return withDirectives((openBlock(), createElementBlock("button", {
    class: normalizeClass($options.containerClass),
    type: "button"
  }, _hoisted_2$5$2, 2)), [[_directive_ripple]]);
}

script$8$2.render = render$8$2;
var script$7$2 = {
  name: 'JumpToPageDropdown',
  inheritAttrs: false,
  emits: ['page-change'],
  props: {
    page: Number,
    pageCount: Number,
    disabled: Boolean
  },
  methods: {
    onChange(value) {
      this.$emit('page-change', value);
    }

  },
  computed: {
    pageOptions() {
      let opts = [];

      for (let i = 0; i < this.pageCount; i++) {
        opts.push({
          label: String(i + 1),
          value: i
        });
      }

      return opts;
    }

  },
  components: {
    JTPDropdown: script$O
  }
};

function render$7$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_JTPDropdown = resolveComponent("JTPDropdown");

  return openBlock(), createBlock(_component_JTPDropdown, {
    modelValue: $props.page,
    options: $options.pageOptions,
    optionLabel: "label",
    optionValue: "value",
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => $options.onChange($event)),
    class: "p-paginator-page-options",
    disabled: $props.disabled
  }, null, 8, ["modelValue", "options", "disabled"]);
}

script$7$2.render = render$7$2;
var script$6$2 = {
  name: 'JumpToPageInput',
  inheritAttrs: false,
  emits: ['page-change'],
  props: {
    page: Number,
    pageCount: Number,
    disabled: Boolean
  },
  methods: {
    onChange(value) {
      this.$emit('page-change', value - 1);
    }

  },
  components: {
    JTPInput: script$1n
  }
};

function render$6$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_JTPInput = resolveComponent("JTPInput");

  return openBlock(), createBlock(_component_JTPInput, {
    modelValue: $props.page,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => $options.onChange($event)),
    class: "p-paginator-page-input",
    disabled: $props.disabled
  }, null, 8, ["modelValue", "disabled"]);
}

script$6$2.render = render$6$2;
var script$5$2 = {
  name: 'LastPageLink',
  computed: {
    containerClass() {
      return ['p-paginator-last p-paginator-element p-link', {
        'p-disabled': this.$attrs.disabled
      }];
    }

  },
  directives: {
    ripple: Ripple
  }
};

const _hoisted_1$4$2 = /*#__PURE__*/createElementVNode("span", {
  class: "p-paginator-icon pi pi-angle-double-right"
}, null, -1);

const _hoisted_2$4$2 = [_hoisted_1$4$2];

function render$5$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_ripple = resolveDirective("ripple");

  return withDirectives((openBlock(), createElementBlock("button", {
    class: normalizeClass($options.containerClass),
    type: "button"
  }, _hoisted_2$4$2, 2)), [[_directive_ripple]]);
}

script$5$2.render = render$5$2;
var script$4$2 = {
  name: 'NextPageLink',
  computed: {
    containerClass() {
      return ['p-paginator-next p-paginator-element p-link', {
        'p-disabled': this.$attrs.disabled
      }];
    }

  },
  directives: {
    ripple: Ripple
  }
};

const _hoisted_1$3$2 = /*#__PURE__*/createElementVNode("span", {
  class: "p-paginator-icon pi pi-angle-right"
}, null, -1);

const _hoisted_2$3$2 = [_hoisted_1$3$2];

function render$4$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_ripple = resolveDirective("ripple");

  return withDirectives((openBlock(), createElementBlock("button", {
    class: normalizeClass($options.containerClass),
    type: "button"
  }, _hoisted_2$3$2, 2)), [[_directive_ripple]]);
}

script$4$2.render = render$4$2;
var script$3$2 = {
  name: 'PageLinks',
  inheritAttrs: false,
  emits: ['click'],
  props: {
    value: Array,
    page: Number
  },
  methods: {
    onPageLinkClick(event, pageLink) {
      this.$emit('click', {
        originalEvent: event,
        value: pageLink
      });
    }

  },
  directives: {
    ripple: Ripple
  }
};
const _hoisted_1$2$2 = {
  class: "p-paginator-pages"
};
const _hoisted_2$2$2 = ["onClick"];

function render$3$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_ripple = resolveDirective("ripple");

  return openBlock(), createElementBlock("span", _hoisted_1$2$2, [(openBlock(true), createElementBlock(Fragment, null, renderList($props.value, pageLink => {
    return withDirectives((openBlock(), createElementBlock("button", {
      key: pageLink,
      class: normalizeClass(['p-paginator-page p-paginator-element p-link', {
        'p-highlight': pageLink - 1 === $props.page
      }]),
      type: "button",
      onClick: $event => $options.onPageLinkClick($event, pageLink)
    }, [createTextVNode(toDisplayString$1(pageLink), 1)], 10, _hoisted_2$2$2)), [[_directive_ripple]]);
  }), 128))]);
}

script$3$2.render = render$3$2;
var script$2$2 = {
  name: 'PrevPageLink',
  computed: {
    containerClass() {
      return ['p-paginator-prev p-paginator-element p-link', {
        'p-disabled': this.$attrs.disabled
      }];
    }

  },
  directives: {
    ripple: Ripple
  }
};

const _hoisted_1$1$2 = /*#__PURE__*/createElementVNode("span", {
  class: "p-paginator-icon pi pi-angle-left"
}, null, -1);

const _hoisted_2$1$2 = [_hoisted_1$1$2];

function render$2$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_ripple = resolveDirective("ripple");

  return withDirectives((openBlock(), createElementBlock("button", {
    class: normalizeClass($options.containerClass),
    type: "button"
  }, _hoisted_2$1$2, 2)), [[_directive_ripple]]);
}

script$2$2.render = render$2$2;
var script$1$2 = {
  name: 'RowsPerPageDropdown',
  inheritAttrs: false,
  emits: ['rows-change'],
  props: {
    options: Array,
    rows: Number,
    disabled: Boolean
  },
  methods: {
    onChange(value) {
      this.$emit('rows-change', value);
    }

  },
  computed: {
    rowsOptions() {
      let opts = [];

      if (this.options) {
        for (let i = 0; i < this.options.length; i++) {
          opts.push({
            label: String(this.options[i]),
            value: this.options[i]
          });
        }
      }

      return opts;
    }

  },
  components: {
    RPPDropdown: script$O
  }
};

function render$1$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_RPPDropdown = resolveComponent("RPPDropdown");

  return openBlock(), createBlock(_component_RPPDropdown, {
    modelValue: $props.rows,
    options: $options.rowsOptions,
    optionLabel: "label",
    optionValue: "value",
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => $options.onChange($event)),
    class: "p-paginator-rpp-options",
    disabled: $props.disabled
  }, null, 8, ["modelValue", "options", "disabled"]);
}

script$1$2.render = render$1$2;
var script$N = {
  name: 'Paginator',
  emits: ['update:first', 'update:rows', 'page'],
  props: {
    totalRecords: {
      type: Number,
      default: 0
    },
    rows: {
      type: Number,
      default: 0
    },
    first: {
      type: Number,
      default: 0
    },
    pageLinkSize: {
      type: Number,
      default: 5
    },
    rowsPerPageOptions: {
      type: Array,
      default: null
    },
    template: {
      type: [Object, String],
      default: 'FirstPageLink PrevPageLink PageLinks NextPageLink LastPageLink RowsPerPageDropdown'
    },
    currentPageReportTemplate: {
      type: null,
      default: '({currentPage} of {totalPages})'
    },
    alwaysShow: {
      type: Boolean,
      default: true
    }
  },

  data() {
    return {
      d_first: this.first,
      d_rows: this.rows
    };
  },

  watch: {
    first(newValue) {
      this.d_first = newValue;
    },

    rows(newValue) {
      this.d_rows = newValue;
    },

    totalRecords(newValue) {
      if (this.page > 0 && newValue && this.d_first >= newValue) {
        this.changePage(this.pageCount - 1);
      }
    }

  },

  mounted() {
    this.setPaginatorAttribute();
    this.createStyle();
  },

  methods: {
    changePage(p) {
      const pc = this.pageCount;

      if (p >= 0 && p < pc) {
        this.d_first = this.d_rows * p;
        const state = {
          page: p,
          first: this.d_first,
          rows: this.d_rows,
          pageCount: pc
        };
        this.$emit('update:first', this.d_first);
        this.$emit('update:rows', this.d_rows);
        this.$emit('page', state);
      }
    },

    changePageToFirst(event) {
      if (!this.isFirstPage) {
        this.changePage(0);
      }

      event.preventDefault();
    },

    changePageToPrev(event) {
      this.changePage(this.page - 1);
      event.preventDefault();
    },

    changePageLink(event) {
      this.changePage(event.value - 1);
      event.originalEvent.preventDefault();
    },

    changePageToNext(event) {
      this.changePage(this.page + 1);
      event.preventDefault();
    },

    changePageToLast(event) {
      if (!this.isLastPage) {
        this.changePage(this.pageCount - 1);
      }

      event.preventDefault();
    },

    onRowChange(value) {
      this.d_rows = value;
      this.changePage(this.page);
    },

    createStyle() {
      if (this.hasBreakpoints()) {
        this.styleElement = document.createElement('style');
        this.styleElement.type = 'text/css';
        document.head.appendChild(this.styleElement);
        let innerHTML = '';
        const keys = Object.keys(this.template);
        const sortedBreakpoints = {};
        keys.sort((a, b) => parseInt(a) - parseInt(b)).forEach(key => {
          sortedBreakpoints[key] = this.template[key];
        });

        for (const [index, [key]] of Object.entries(Object.entries(sortedBreakpoints))) {
          const minValue = Object.entries(sortedBreakpoints)[index - 1] ? `and (min-width:${Object.keys(sortedBreakpoints)[index - 1]})` : '';

          if (key === 'default') {
            innerHTML += `
                            @media screen ${minValue} {
                                .paginator[${this.attributeSelector}],
                                .p-paginator-default{
                                    display: flex !important;
                                }
                            }
                        `;
          } else {
            innerHTML += `
                        .paginator[${this.attributeSelector}], .p-paginator-${key} {
                                display: none !important;
                            }
                        @media screen ${minValue} and (max-width: ${key}) {
                            .paginator[${this.attributeSelector}], .p-paginator-${key} {
                                display: flex !important;
                            }
                            .paginator[${this.attributeSelector}],
                            .p-paginator-default{
                                display: none !important;
                            }
                        }
                    `;
          }
        }

        this.styleElement.innerHTML = innerHTML;
      }
    },

    hasBreakpoints() {
      return typeof this.template === 'object';
    },

    getPaginatorClasses(key) {
      return [{
        'p-paginator-default': !this.hasBreakpoints(),
        [`p-paginator-${key}`]: this.hasBreakpoints()
      }];
    },

    setPaginatorAttribute() {
      if (this.$refs.paginator && this.$refs.paginator.length >= 0) {
        [...this.$refs.paginator].forEach(el => {
          el.setAttribute(this.attributeSelector, '');
        });
      }
    }

  },
  computed: {
    templateItems() {
      let keys = {};

      if (this.hasBreakpoints()) {
        keys = this.template;

        if (!keys.default) {
          keys.default = 'FirstPageLink PrevPageLink PageLinks NextPageLink LastPageLink RowsPerPageDropdown';
        }

        for (const item in keys) {
          keys[item] = this.template[item].split(' ').map(value => {
            return value.trim();
          });
        }

        return keys;
      }

      keys['default'] = this.template.split(' ').map(value => {
        return value.trim();
      });
      return keys;
    },

    page() {
      return Math.floor(this.d_first / this.d_rows);
    },

    pageCount() {
      return Math.ceil(this.totalRecords / this.d_rows);
    },

    isFirstPage() {
      return this.page === 0;
    },

    isLastPage() {
      return this.page === this.pageCount - 1;
    },

    calculatePageLinkBoundaries() {
      const numberOfPages = this.pageCount;
      const visiblePages = Math.min(this.pageLinkSize, numberOfPages); //calculate range, keep current in middle if necessary

      let start = Math.max(0, Math.ceil(this.page - visiblePages / 2));
      let end = Math.min(numberOfPages - 1, start + visiblePages - 1); //check when approaching to last page

      const delta = this.pageLinkSize - (end - start + 1);
      start = Math.max(0, start - delta);
      return [start, end];
    },

    pageLinks() {
      let pageLinks = [];
      let boundaries = this.calculatePageLinkBoundaries;
      let start = boundaries[0];
      let end = boundaries[1];

      for (var i = start; i <= end; i++) {
        pageLinks.push(i + 1);
      }

      return pageLinks;
    },

    currentState() {
      return {
        page: this.page,
        first: this.d_first,
        rows: this.d_rows
      };
    },

    empty() {
      return this.pageCount === 0;
    },

    currentPage() {
      return this.pageCount > 0 ? this.page + 1 : 0;
    },

    attributeSelector() {
      return UniqueComponentId();
    }

  },
  components: {
    CurrentPageReport: script$9$2,
    FirstPageLink: script$8$2,
    LastPageLink: script$5$2,
    NextPageLink: script$4$2,
    PageLinks: script$3$2,
    PrevPageLink: script$2$2,
    RowsPerPageDropdown: script$1$2,
    JumpToPageDropdown: script$7$2,
    JumpToPageInput: script$6$2
  }
};
const _hoisted_1$l = {
  key: 0
};
const _hoisted_2$i = {
  key: 0,
  class: "p-paginator-left-content"
};
const _hoisted_3$f = {
  key: 1,
  class: "p-paginator-right-content"
};

function render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_FirstPageLink = resolveComponent("FirstPageLink");

  const _component_PrevPageLink = resolveComponent("PrevPageLink");

  const _component_NextPageLink = resolveComponent("NextPageLink");

  const _component_LastPageLink = resolveComponent("LastPageLink");

  const _component_PageLinks = resolveComponent("PageLinks");

  const _component_CurrentPageReport = resolveComponent("CurrentPageReport");

  const _component_RowsPerPageDropdown = resolveComponent("RowsPerPageDropdown");

  const _component_JumpToPageDropdown = resolveComponent("JumpToPageDropdown");

  const _component_JumpToPageInput = resolveComponent("JumpToPageInput");

  return ($props.alwaysShow ? true : $options.pageLinks && $options.pageLinks.length > 1) ? (openBlock(), createElementBlock("div", _hoisted_1$l, [(openBlock(true), createElementBlock(Fragment, null, renderList($options.templateItems, (value, key) => {
    return openBlock(), createElementBlock("div", {
      key: key,
      ref_for: true,
      ref: "paginator",
      class: normalizeClass(["p-paginator p-component", $options.getPaginatorClasses(key)])
    }, [_ctx.$slots.start ? (openBlock(), createElementBlock("div", _hoisted_2$i, [renderSlot(_ctx.$slots, "start", {
      state: $options.currentState
    })])) : createCommentVNode("", true), (openBlock(true), createElementBlock(Fragment, null, renderList(value, item => {
      return openBlock(), createElementBlock(Fragment, {
        key: item
      }, [item === 'FirstPageLink' ? (openBlock(), createBlock(_component_FirstPageLink, {
        key: 0,
        onClick: _cache[0] || (_cache[0] = $event => $options.changePageToFirst($event)),
        disabled: $options.isFirstPage || $options.empty
      }, null, 8, ["disabled"])) : item === 'PrevPageLink' ? (openBlock(), createBlock(_component_PrevPageLink, {
        key: 1,
        onClick: _cache[1] || (_cache[1] = $event => $options.changePageToPrev($event)),
        disabled: $options.isFirstPage || $options.empty
      }, null, 8, ["disabled"])) : item === 'NextPageLink' ? (openBlock(), createBlock(_component_NextPageLink, {
        key: 2,
        onClick: _cache[2] || (_cache[2] = $event => $options.changePageToNext($event)),
        disabled: $options.isLastPage || $options.empty
      }, null, 8, ["disabled"])) : item === 'LastPageLink' ? (openBlock(), createBlock(_component_LastPageLink, {
        key: 3,
        onClick: _cache[3] || (_cache[3] = $event => $options.changePageToLast($event)),
        disabled: $options.isLastPage || $options.empty
      }, null, 8, ["disabled"])) : item === 'PageLinks' ? (openBlock(), createBlock(_component_PageLinks, {
        key: 4,
        value: $options.pageLinks,
        page: $options.page,
        onClick: _cache[4] || (_cache[4] = $event => $options.changePageLink($event))
      }, null, 8, ["value", "page"])) : item === 'CurrentPageReport' ? (openBlock(), createBlock(_component_CurrentPageReport, {
        key: 5,
        template: $props.currentPageReportTemplate,
        currentPage: $options.currentPage,
        page: $options.page,
        pageCount: $options.pageCount,
        first: $data.d_first,
        rows: $data.d_rows,
        totalRecords: $props.totalRecords
      }, null, 8, ["template", "currentPage", "page", "pageCount", "first", "rows", "totalRecords"])) : item === 'RowsPerPageDropdown' && $props.rowsPerPageOptions ? (openBlock(), createBlock(_component_RowsPerPageDropdown, {
        key: 6,
        rows: $data.d_rows,
        options: $props.rowsPerPageOptions,
        onRowsChange: _cache[5] || (_cache[5] = $event => $options.onRowChange($event)),
        disabled: $options.empty
      }, null, 8, ["rows", "options", "disabled"])) : item === 'JumpToPageDropdown' ? (openBlock(), createBlock(_component_JumpToPageDropdown, {
        key: 7,
        page: $options.page,
        pageCount: $options.pageCount,
        onPageChange: _cache[6] || (_cache[6] = $event => $options.changePage($event)),
        disabled: $options.empty
      }, null, 8, ["page", "pageCount", "disabled"])) : item === 'JumpToPageInput' ? (openBlock(), createBlock(_component_JumpToPageInput, {
        key: 8,
        page: $options.currentPage,
        onPageChange: _cache[7] || (_cache[7] = $event => $options.changePage($event)),
        disabled: $options.empty
      }, null, 8, ["page", "disabled"])) : createCommentVNode("", true)], 64);
    }), 128)), _ctx.$slots.end ? (openBlock(), createElementBlock("div", _hoisted_3$f, [renderSlot(_ctx.$slots, "end", {
      state: $options.currentState
    })])) : createCommentVNode("", true)], 2);
  }), 128))])) : createCommentVNode("", true);
}

function styleInject$9(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$e = "\n.p-paginator-default {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n}\n.p-paginator {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    -ms-flex-wrap: wrap;\n        flex-wrap: wrap;\n}\n.p-paginator-left-content {\n    margin-right: auto;\n}\n.p-paginator-right-content {\n    margin-left: auto;\n}\n.p-paginator-page,\n.p-paginator-next,\n.p-paginator-last,\n.p-paginator-first,\n.p-paginator-prev,\n.p-paginator-current {\n    cursor: pointer;\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    line-height: 1;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n    overflow: hidden;\n    position: relative;\n}\n.p-paginator-element:focus {\n    z-index: 1;\n    position: relative;\n}\n";
styleInject$9(css_248z$e);
script$N.render = render$d;

var script$a$1 = {
  name: 'RowRadioButton',
  inheritAttrs: false,
  emits: ['change'],
  props: {
    value: null,
    checked: null
  },

  data() {
    return {
      focused: false
    };
  },

  methods: {
    onClick(event) {
      if (!this.disabled) {
        if (!this.checked) {
          this.$emit('change', {
            originalEvent: event,
            data: this.value
          });
        }
      }
    },

    onFocus() {
      this.focused = true;
    },

    onBlur() {
      this.focused = false;
    }

  }
};
const _hoisted_1$a$1 = ["aria-checked"];

const _hoisted_2$7$1 = /*#__PURE__*/createElementVNode("div", {
  class: "p-radiobutton-icon"
}, null, -1);

const _hoisted_3$6$1 = [_hoisted_2$7$1];

function render$a$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(['p-radiobutton p-component', {
      'p-radiobutton-focused': $data.focused
    }]),
    onClick: _cache[0] || (_cache[0] = (...args) => $options.onClick && $options.onClick(...args)),
    tabindex: "0",
    onFocus: _cache[1] || (_cache[1] = $event => $options.onFocus($event)),
    onBlur: _cache[2] || (_cache[2] = $event => $options.onBlur($event)),
    onKeydown: _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => $options.onClick && $options.onClick(...args), ["prevent"]), ["space"]))
  }, [createElementVNode("div", {
    ref: "box",
    class: normalizeClass(['p-radiobutton-box p-component', {
      'p-highlight': $props.checked,
      'p-disabled': _ctx.$attrs.disabled,
      'p-focus': $data.focused
    }]),
    role: "radio",
    "aria-checked": $props.checked
  }, _hoisted_3$6$1, 10, _hoisted_1$a$1)], 34);
}

script$a$1.render = render$a$1;
var script$9$1 = {
  name: 'RowCheckbox',
  inheritAttrs: false,
  emits: ['change'],
  props: {
    value: null,
    checked: null
  },

  data() {
    return {
      focused: false
    };
  },

  methods: {
    onClick(event) {
      if (!this.$attrs.disabled) {
        this.focused = true;
        this.$emit('change', {
          originalEvent: event,
          data: this.value
        });
      }
    },

    onFocus() {
      this.focused = true;
    },

    onBlur() {
      this.focused = false;
    }

  }
};
const _hoisted_1$9$1 = ["aria-checked", "tabindex"];

function render$9$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(['p-checkbox p-component', {
      'p-checkbox-focused': $data.focused
    }]),
    onClick: _cache[3] || (_cache[3] = withModifiers((...args) => $options.onClick && $options.onClick(...args), ["stop", "prevent"]))
  }, [createElementVNode("div", {
    ref: "box",
    class: normalizeClass(['p-checkbox-box p-component', {
      'p-highlight': $props.checked,
      'p-disabled': _ctx.$attrs.disabled,
      'p-focus': $data.focused
    }]),
    role: "checkbox",
    "aria-checked": $props.checked,
    tabindex: _ctx.$attrs.disabled ? null : '0',
    onKeydown: _cache[0] || (_cache[0] = withKeys(withModifiers((...args) => $options.onClick && $options.onClick(...args), ["prevent"]), ["space"])),
    onFocus: _cache[1] || (_cache[1] = $event => $options.onFocus($event)),
    onBlur: _cache[2] || (_cache[2] = $event => $options.onBlur($event))
  }, [createElementVNode("span", {
    class: normalizeClass(['p-checkbox-icon', {
      'pi pi-check': $props.checked
    }])
  }, null, 2)], 42, _hoisted_1$9$1)], 2);
}

script$9$1.render = render$9$1;
var script$8$1 = {
  name: 'BodyCell',
  emits: ['cell-edit-init', 'cell-edit-complete', 'cell-edit-cancel', 'row-edit-init', 'row-edit-save', 'row-edit-cancel', 'row-toggle', 'radio-change', 'checkbox-change', 'editing-meta-change'],
  props: {
    rowData: {
      type: Object,
      default: null
    },
    column: {
      type: Object,
      default: null
    },
    frozenRow: {
      type: Boolean,
      default: false
    },
    rowIndex: {
      type: Number,
      default: null
    },
    index: {
      type: Number,
      default: null
    },
    rowTogglerIcon: {
      type: Array,
      default: null
    },
    selected: {
      type: Boolean,
      default: false
    },
    editing: {
      type: Boolean,
      default: false
    },
    editingMeta: {
      type: Object,
      default: null
    },
    editMode: {
      type: String,
      default: null
    },
    responsiveLayout: {
      type: String,
      default: 'stack'
    },
    virtualScrollerContentProps: {
      type: Object,
      default: null
    }
  },
  documentEditListener: null,
  selfClick: false,
  overlayEventListener: null,

  data() {
    return {
      d_editing: this.editing,
      styleObject: {}
    };
  },

  watch: {
    editing(newValue) {
      this.d_editing = newValue;
    },

    '$data.d_editing': function (newValue) {
      this.$emit('editing-meta-change', {
        data: this.rowData,
        field: this.field || `field_${this.index}`,
        index: this.rowIndex,
        editing: newValue
      });
    }
  },

  mounted() {
    if (this.columnProp('frozen')) {
      this.updateStickyPosition();
    }
  },

  updated() {
    if (this.columnProp('frozen')) {
      this.updateStickyPosition();
    }

    if (this.d_editing && (this.editMode === 'cell' || this.editMode === 'row' && this.columnProp('rowEditor'))) {
      const focusableEl = DomHandler.getFirstFocusableElement(this.$el);
      focusableEl && focusableEl.focus();
    }
  },

  beforeUnmount() {
    if (this.overlayEventListener) {
      OverlayEventBus.off('overlay-click', this.overlayEventListener);
      this.overlayEventListener = null;
    }
  },

  methods: {
    columnProp(prop) {
      return ObjectUtils.getVNodeProp(this.column, prop);
    },

    resolveFieldData() {
      return ObjectUtils.resolveFieldData(this.rowData, this.field);
    },

    toggleRow(event) {
      this.$emit('row-toggle', {
        originalEvent: event,
        data: this.rowData
      });
    },

    toggleRowWithRadio(event, index) {
      this.$emit('radio-change', {
        originalEvent: event.originalEvent,
        index: index,
        data: event.data
      });
    },

    toggleRowWithCheckbox(event, index) {
      this.$emit('checkbox-change', {
        originalEvent: event.originalEvent,
        index: index,
        data: event.data
      });
    },

    isEditable() {
      return this.column.children && this.column.children.editor != null;
    },

    bindDocumentEditListener() {
      if (!this.documentEditListener) {
        this.documentEditListener = event => {
          if (!this.selfClick) {
            this.completeEdit(event, 'outside');
          }

          this.selfClick = false;
        };

        document.addEventListener('click', this.documentEditListener);
      }
    },

    unbindDocumentEditListener() {
      if (this.documentEditListener) {
        document.removeEventListener('click', this.documentEditListener);
        this.documentEditListener = null;
        this.selfClick = false;
      }
    },

    switchCellToViewMode() {
      this.d_editing = false;
      this.unbindDocumentEditListener();
      OverlayEventBus.off('overlay-click', this.overlayEventListener);
      this.overlayEventListener = null;
    },

    onClick(event) {
      if (this.editMode === 'cell' && this.isEditable()) {
        this.selfClick = true;

        if (!this.d_editing) {
          this.d_editing = true;
          this.bindDocumentEditListener();
          this.$emit('cell-edit-init', {
            originalEvent: event,
            data: this.rowData,
            field: this.field,
            index: this.rowIndex
          });

          this.overlayEventListener = e => {
            if (this.$el && this.$el.contains(e.target)) {
              this.selfClick = true;
            }
          };

          OverlayEventBus.on('overlay-click', this.overlayEventListener);
        }
      }
    },

    completeEdit(event, type) {
      const completeEvent = {
        originalEvent: event,
        data: this.rowData,
        newData: this.editingRowData,
        value: this.rowData[this.field],
        newValue: this.editingRowData[this.field],
        field: this.field,
        index: this.rowIndex,
        type: type,
        defaultPrevented: false,
        preventDefault: function () {
          this.defaultPrevented = true;
        }
      };
      this.$emit('cell-edit-complete', completeEvent);

      if (!completeEvent.defaultPrevented) {
        this.switchCellToViewMode();
      }
    },

    onKeyDown(event) {
      if (this.editMode === 'cell') {
        switch (event.which) {
          case 13:
            this.completeEdit(event, 'enter');
            break;

          case 27:
            this.switchCellToViewMode();
            this.$emit('cell-edit-cancel', {
              originalEvent: event,
              data: this.rowData,
              field: this.field,
              index: this.rowIndex
            });
            break;

          case 9:
            this.completeEdit(event, 'tab');
            if (event.shiftKey) this.moveToPreviousCell(event);else this.moveToNextCell(event);
            break;
        }
      }
    },

    moveToPreviousCell(event) {
      let currentCell = this.findCell(event.target);
      let targetCell = this.findPreviousEditableColumn(currentCell);

      if (targetCell) {
        DomHandler.invokeElementMethod(targetCell, 'click');
        event.preventDefault();
      }
    },

    moveToNextCell(event) {
      let currentCell = this.findCell(event.target);
      let targetCell = this.findNextEditableColumn(currentCell);

      if (targetCell) {
        DomHandler.invokeElementMethod(targetCell, 'click');
        event.preventDefault();
      }
    },

    findCell(element) {
      if (element) {
        let cell = element;

        while (cell && !DomHandler.hasClass(cell, 'p-cell-editing')) {
          cell = cell.parentElement;
        }

        return cell;
      } else {
        return null;
      }
    },

    findPreviousEditableColumn(cell) {
      let prevCell = cell.previousElementSibling;

      if (!prevCell) {
        let previousRow = cell.parentElement.previousElementSibling;

        if (previousRow) {
          prevCell = previousRow.lastElementChild;
        }
      }

      if (prevCell) {
        if (DomHandler.hasClass(prevCell, 'p-editable-column')) return prevCell;else return this.findPreviousEditableColumn(prevCell);
      } else {
        return null;
      }
    },

    findNextEditableColumn(cell) {
      let nextCell = cell.nextElementSibling;

      if (!nextCell) {
        let nextRow = cell.parentElement.nextElementSibling;

        if (nextRow) {
          nextCell = nextRow.firstElementChild;
        }
      }

      if (nextCell) {
        if (DomHandler.hasClass(nextCell, 'p-editable-column')) return nextCell;else return this.findNextEditableColumn(nextCell);
      } else {
        return null;
      }
    },

    isEditingCellValid() {
      return DomHandler.find(this.$el, '.p-invalid').length === 0;
    },

    onRowEditInit(event) {
      this.$emit('row-edit-init', {
        originalEvent: event,
        data: this.rowData,
        newData: this.editingRowData,
        field: this.field,
        index: this.rowIndex
      });
    },

    onRowEditSave(event) {
      this.$emit('row-edit-save', {
        originalEvent: event,
        data: this.rowData,
        newData: this.editingRowData,
        field: this.field,
        index: this.rowIndex
      });
    },

    onRowEditCancel(event) {
      this.$emit('row-edit-cancel', {
        originalEvent: event,
        data: this.rowData,
        newData: this.editingRowData,
        field: this.field,
        index: this.rowIndex
      });
    },

    editorInitCallback(event) {
      this.$emit('row-edit-init', {
        originalEvent: event,
        data: this.rowData,
        newData: this.editingRowData,
        field: this.field,
        index: this.rowIndex
      });
    },

    editorSaveCallback(event) {
      if (this.editMode === 'row') {
        this.$emit('row-edit-save', {
          originalEvent: event,
          data: this.rowData,
          newData: this.editingRowData,
          field: this.field,
          index: this.rowIndex
        });
      } else {
        this.completeEdit(event, 'enter');
      }
    },

    editorCancelCallback(event) {
      if (this.editMode === 'row') {
        this.$emit('row-edit-cancel', {
          originalEvent: event,
          data: this.rowData,
          newData: this.editingRowData,
          field: this.field,
          index: this.rowIndex
        });
      } else {
        this.switchCellToViewMode();
        this.$emit('cell-edit-cancel', {
          originalEvent: event,
          data: this.rowData,
          field: this.field,
          index: this.rowIndex
        });
      }
    },

    updateStickyPosition() {
      if (this.columnProp('frozen')) {
        let align = this.columnProp('alignFrozen');

        if (align === 'right') {
          let right = 0;
          let next = this.$el.nextElementSibling;

          if (next) {
            right = DomHandler.getOuterWidth(next) + parseFloat(next.style.right || 0);
          }

          this.styleObject.right = right + 'px';
        } else {
          let left = 0;
          let prev = this.$el.previousElementSibling;

          if (prev) {
            left = DomHandler.getOuterWidth(prev) + parseFloat(prev.style.left || 0);
          }

          this.styleObject.left = left + 'px';
        }
      }
    },

    getVirtualScrollerProp(option) {
      return this.virtualScrollerContentProps ? this.virtualScrollerContentProps[option] : null;
    }

  },
  computed: {
    editingRowData() {
      return this.editingMeta[this.rowIndex] ? this.editingMeta[this.rowIndex].data : this.rowData;
    },

    field() {
      return this.columnProp('field');
    },

    containerClass() {
      return [this.columnProp('bodyClass'), this.columnProp('class'), {
        'p-selection-column': this.columnProp('selectionMode') != null,
        'p-editable-column': this.isEditable(),
        'p-cell-editing': this.d_editing,
        'p-frozen-column': this.columnProp('frozen')
      }];
    },

    containerStyle() {
      let bodyStyle = this.columnProp('bodyStyle');
      let columnStyle = this.columnProp('style');
      return this.columnProp('frozen') ? [columnStyle, bodyStyle, this.styleObject] : [columnStyle, bodyStyle];
    },

    loading() {
      return this.getVirtualScrollerProp('loading');
    },

    loadingOptions() {
      const getLoaderOptions = this.getVirtualScrollerProp('getLoaderOptions');
      return getLoaderOptions && getLoaderOptions(this.rowIndex, {
        cellIndex: this.index,
        cellFirst: this.index === 0,
        cellLast: this.index === this.getVirtualScrollerProp('columns').length - 1,
        cellEven: this.index % 2 === 0,
        cellOdd: this.index % 2 !== 0,
        column: this.column,
        field: this.field
      });
    }

  },
  components: {
    DTRadioButton: script$a$1,
    DTCheckbox: script$9$1
  },
  directives: {
    ripple: Ripple
  }
};
const _hoisted_1$8$1 = {
  key: 0,
  class: "p-column-title"
};

const _hoisted_2$6$1 = /*#__PURE__*/createElementVNode("span", {
  class: "p-row-editor-init-icon pi pi-fw pi-pencil"
}, null, -1);

const _hoisted_3$5$1 = [_hoisted_2$6$1];

const _hoisted_4$4$1 = /*#__PURE__*/createElementVNode("span", {
  class: "p-row-editor-save-icon pi pi-fw pi-check"
}, null, -1);

const _hoisted_5$3$1 = [_hoisted_4$4$1];

const _hoisted_6$3$1 = /*#__PURE__*/createElementVNode("span", {
  class: "p-row-editor-cancel-icon pi pi-fw pi-times"
}, null, -1);

const _hoisted_7$1$1 = [_hoisted_6$3$1];

function render$8$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DTRadioButton = resolveComponent("DTRadioButton");

  const _component_DTCheckbox = resolveComponent("DTCheckbox");

  const _directive_ripple = resolveDirective("ripple");

  return $options.loading ? (openBlock(), createElementBlock("td", {
    key: 0,
    style: normalizeStyle($options.containerStyle),
    class: normalizeClass($options.containerClass)
  }, [(openBlock(), createBlock(resolveDynamicComponent($props.column.children.loading), {
    data: $props.rowData,
    column: $props.column,
    field: $options.field,
    index: $props.rowIndex,
    frozenRow: $props.frozenRow,
    loadingOptions: $options.loadingOptions
  }, null, 8, ["data", "column", "field", "index", "frozenRow", "loadingOptions"]))], 6)) : (openBlock(), createElementBlock("td", {
    key: 1,
    style: normalizeStyle($options.containerStyle),
    class: normalizeClass($options.containerClass),
    onClick: _cache[6] || (_cache[6] = (...args) => $options.onClick && $options.onClick(...args)),
    onKeydown: _cache[7] || (_cache[7] = (...args) => $options.onKeyDown && $options.onKeyDown(...args)),
    role: "cell"
  }, [$props.responsiveLayout === 'stack' ? (openBlock(), createElementBlock("span", _hoisted_1$8$1, toDisplayString$1($options.columnProp('header')), 1)) : createCommentVNode("", true), $props.column.children && $props.column.children.body && !$data.d_editing ? (openBlock(), createBlock(resolveDynamicComponent($props.column.children.body), {
    key: 1,
    data: $props.rowData,
    column: $props.column,
    field: $options.field,
    index: $props.rowIndex,
    frozenRow: $props.frozenRow,
    editorInitCallback: $options.editorInitCallback
  }, null, 8, ["data", "column", "field", "index", "frozenRow", "editorInitCallback"])) : $props.column.children && $props.column.children.editor && $data.d_editing ? (openBlock(), createBlock(resolveDynamicComponent($props.column.children.editor), {
    key: 2,
    data: $options.editingRowData,
    column: $props.column,
    field: $options.field,
    index: $props.rowIndex,
    frozenRow: $props.frozenRow,
    editorSaveCallback: $options.editorSaveCallback,
    editorCancelCallback: $options.editorCancelCallback
  }, null, 8, ["data", "column", "field", "index", "frozenRow", "editorSaveCallback", "editorCancelCallback"])) : $props.column.children && $props.column.children.body && !$props.column.children.editor && $data.d_editing ? (openBlock(), createBlock(resolveDynamicComponent($props.column.children.body), {
    key: 3,
    data: $options.editingRowData,
    column: $props.column,
    field: $options.field,
    index: $props.rowIndex,
    frozenRow: $props.frozenRow
  }, null, 8, ["data", "column", "field", "index", "frozenRow"])) : $options.columnProp('selectionMode') ? (openBlock(), createElementBlock(Fragment, {
    key: 4
  }, [$options.columnProp('selectionMode') === 'single' ? (openBlock(), createBlock(_component_DTRadioButton, {
    key: 0,
    value: $props.rowData,
    checked: $props.selected,
    onChange: _cache[0] || (_cache[0] = $event => $options.toggleRowWithRadio($event, $props.rowIndex))
  }, null, 8, ["value", "checked"])) : $options.columnProp('selectionMode') === 'multiple' ? (openBlock(), createBlock(_component_DTCheckbox, {
    key: 1,
    value: $props.rowData,
    checked: $props.selected,
    onChange: _cache[1] || (_cache[1] = $event => $options.toggleRowWithCheckbox($event, $props.rowIndex))
  }, null, 8, ["value", "checked"])) : createCommentVNode("", true)], 64)) : $options.columnProp('rowReorder') ? (openBlock(), createElementBlock("i", {
    key: 5,
    class: normalizeClass(['p-datatable-reorderablerow-handle', $options.columnProp('rowReorderIcon') || 'pi pi-bars'])
  }, null, 2)) : $options.columnProp('expander') ? withDirectives((openBlock(), createElementBlock("button", {
    key: 6,
    class: "p-row-toggler p-link",
    onClick: _cache[2] || (_cache[2] = (...args) => $options.toggleRow && $options.toggleRow(...args)),
    type: "button"
  }, [createElementVNode("span", {
    class: normalizeClass($props.rowTogglerIcon)
  }, null, 2)])), [[_directive_ripple]]) : $props.editMode === 'row' && $options.columnProp('rowEditor') ? (openBlock(), createElementBlock(Fragment, {
    key: 7
  }, [!$data.d_editing ? withDirectives((openBlock(), createElementBlock("button", {
    key: 0,
    class: "p-row-editor-init p-link",
    onClick: _cache[3] || (_cache[3] = (...args) => $options.onRowEditInit && $options.onRowEditInit(...args)),
    type: "button"
  }, _hoisted_3$5$1)), [[_directive_ripple]]) : createCommentVNode("", true), $data.d_editing ? withDirectives((openBlock(), createElementBlock("button", {
    key: 1,
    class: "p-row-editor-save p-link",
    onClick: _cache[4] || (_cache[4] = (...args) => $options.onRowEditSave && $options.onRowEditSave(...args)),
    type: "button"
  }, _hoisted_5$3$1)), [[_directive_ripple]]) : createCommentVNode("", true), $data.d_editing ? withDirectives((openBlock(), createElementBlock("button", {
    key: 2,
    class: "p-row-editor-cancel p-link",
    onClick: _cache[5] || (_cache[5] = (...args) => $options.onRowEditCancel && $options.onRowEditCancel(...args)),
    type: "button"
  }, _hoisted_7$1$1)), [[_directive_ripple]]) : createCommentVNode("", true)], 64)) : (openBlock(), createElementBlock(Fragment, {
    key: 8
  }, [createTextVNode(toDisplayString$1($options.resolveFieldData()), 1)], 64))], 38));
}

script$8$1.render = render$8$1;
var script$7$1 = {
  name: 'TableBody',
  emits: ['rowgroup-toggle', 'row-click', 'row-dblclick', 'row-rightclick', 'row-touchend', 'row-keydown', 'row-mousedown', 'row-dragstart', 'row-dragover', 'row-dragleave', 'row-dragend', 'row-drop', 'row-toggle', 'radio-change', 'checkbox-change', 'cell-edit-init', 'cell-edit-complete', 'cell-edit-cancel', 'row-edit-init', 'row-edit-save', 'row-edit-cancel', 'editing-meta-change'],
  props: {
    value: {
      type: Array,
      default: null
    },
    columns: {
      type: null,
      default: null
    },
    frozenRow: {
      type: Boolean,
      default: false
    },
    empty: {
      type: Boolean,
      default: false
    },
    rowGroupMode: {
      type: String,
      default: null
    },
    groupRowsBy: {
      type: [Array, String, Function],
      default: null
    },
    expandableRowGroups: {
      type: Boolean,
      default: false
    },
    expandedRowGroups: {
      type: Array,
      default: null
    },
    dataKey: {
      type: String,
      default: null
    },
    expandedRowIcon: {
      type: String,
      default: null
    },
    collapsedRowIcon: {
      type: String,
      default: null
    },
    expandedRows: {
      type: Array,
      default: null
    },
    expandedRowKeys: {
      type: null,
      default: null
    },
    selection: {
      type: [Array, Object],
      default: null
    },
    selectionKeys: {
      type: null,
      default: null
    },
    selectionMode: {
      type: String,
      default: null
    },
    contextMenu: {
      type: Boolean,
      default: false
    },
    contextMenuSelection: {
      type: Object,
      default: null
    },
    rowClass: {
      type: null,
      default: null
    },
    rowStyle: {
      type: null,
      default: null
    },
    editMode: {
      type: String,
      default: null
    },
    compareSelectionBy: {
      type: String,
      default: 'deepEquals'
    },
    editingRows: {
      type: Array,
      default: null
    },
    editingRowKeys: {
      type: null,
      default: null
    },
    editingMeta: {
      type: Object,
      default: null
    },
    templates: {
      type: null,
      default: null
    },
    scrollable: {
      type: Boolean,
      default: false
    },
    responsiveLayout: {
      type: String,
      default: 'stack'
    },
    virtualScrollerContentProps: {
      type: Object,
      default: null
    },
    isVirtualScrollerDisabled: {
      type: Boolean,
      default: false
    }
  },

  data() {
    return {
      rowGroupHeaderStyleObject: {}
    };
  },

  watch: {
    virtualScrollerContentProps(newValue, oldValue) {
      if (!this.isVirtualScrollerDisabled && this.getVirtualScrollerProp('vertical') && this.getVirtualScrollerProp('itemSize', oldValue) !== this.getVirtualScrollerProp('itemSize', newValue)) {
        this.updateVirtualScrollerPosition();
      }
    }

  },

  mounted() {
    if (this.frozenRow) {
      this.updateFrozenRowStickyPosition();
    }

    if (this.scrollable && this.rowGroupMode === 'subheader') {
      this.updateFrozenRowGroupHeaderStickyPosition();
    }

    if (!this.isVirtualScrollerDisabled && this.getVirtualScrollerProp('vertical')) {
      this.updateVirtualScrollerPosition();
    }
  },

  updated() {
    if (this.frozenRow) {
      this.updateFrozenRowStickyPosition();
    }

    if (this.scrollable && this.rowGroupMode === 'subheader') {
      this.updateFrozenRowGroupHeaderStickyPosition();
    }
  },

  methods: {
    columnProp(col, prop) {
      return ObjectUtils.getVNodeProp(col, prop);
    },

    shouldRenderRowGroupHeader(value, rowData, i) {
      let currentRowFieldData = ObjectUtils.resolveFieldData(rowData, this.groupRowsBy);
      let prevRowData = value[i - 1];

      if (prevRowData) {
        let previousRowFieldData = ObjectUtils.resolveFieldData(prevRowData, this.groupRowsBy);
        return currentRowFieldData !== previousRowFieldData;
      } else {
        return true;
      }
    },

    getRowKey(rowData, index) {
      return this.dataKey ? ObjectUtils.resolveFieldData(rowData, this.dataKey) : index;
    },

    getRowIndex(index) {
      const getItemOptions = this.getVirtualScrollerProp('getItemOptions');
      return getItemOptions ? getItemOptions(index).index : index;
    },

    getRowClass(rowData) {
      let rowStyleClass = [];

      if (this.selectionMode) {
        rowStyleClass.push('p-selectable-row');
      }

      if (this.selection) {
        rowStyleClass.push({
          'p-highlight': this.isSelected(rowData)
        });
      }

      if (this.contextMenuSelection) {
        rowStyleClass.push({
          'p-highlight-contextmenu': this.isSelectedWithContextMenu(rowData)
        });
      }

      if (this.rowClass) {
        let rowClassValue = this.rowClass(rowData);

        if (rowClassValue) {
          rowStyleClass.push(rowClassValue);
        }
      }

      return rowStyleClass;
    },

    shouldRenderRowGroupFooter(value, rowData, i) {
      if (this.expandableRowGroups && !this.isRowGroupExpanded(rowData)) {
        return false;
      } else {
        let currentRowFieldData = ObjectUtils.resolveFieldData(rowData, this.groupRowsBy);
        let nextRowData = value[i + 1];

        if (nextRowData) {
          let nextRowFieldData = ObjectUtils.resolveFieldData(nextRowData, this.groupRowsBy);
          return currentRowFieldData !== nextRowFieldData;
        } else {
          return true;
        }
      }
    },

    shouldRenderBodyCell(value, column, i) {
      if (this.rowGroupMode) {
        if (this.rowGroupMode === 'subheader') {
          return this.groupRowsBy !== this.columnProp(column, 'field');
        } else if (this.rowGroupMode === 'rowspan') {
          if (this.isGrouped(column)) {
            let prevRowData = value[i - 1];

            if (prevRowData) {
              let currentRowFieldData = ObjectUtils.resolveFieldData(value[i], this.columnProp(column, 'field'));
              let previousRowFieldData = ObjectUtils.resolveFieldData(prevRowData, this.columnProp(column, 'field'));
              return currentRowFieldData !== previousRowFieldData;
            } else {
              return true;
            }
          } else {
            return true;
          }
        }
      } else {
        return !this.columnProp(column, 'hidden');
      }
    },

    calculateRowGroupSize(value, column, index) {
      if (this.isGrouped(column)) {
        let currentRowFieldData = ObjectUtils.resolveFieldData(value[index], this.columnProp(column, 'field'));
        let nextRowFieldData = currentRowFieldData;
        let groupRowSpan = 0;

        while (currentRowFieldData === nextRowFieldData) {
          groupRowSpan++;
          let nextRowData = value[++index];

          if (nextRowData) {
            nextRowFieldData = ObjectUtils.resolveFieldData(nextRowData, this.columnProp(column, 'field'));
          } else {
            break;
          }
        }

        return groupRowSpan === 1 ? null : groupRowSpan;
      } else {
        return null;
      }
    },

    rowTogglerIcon(rowData) {
      const icon = this.isRowExpanded(rowData) ? this.expandedRowIcon : this.collapsedRowIcon;
      return ['p-row-toggler-icon pi', icon];
    },

    rowGroupTogglerIcon(rowData) {
      const icon = this.isRowGroupExpanded(rowData) ? this.expandedRowIcon : this.collapsedRowIcon;
      return ['p-row-toggler-icon pi', icon];
    },

    isGrouped(column) {
      if (this.groupRowsBy && this.columnProp(column, 'field')) {
        if (Array.isArray(this.groupRowsBy)) return this.groupRowsBy.indexOf(column.props.field) > -1;else return this.groupRowsBy === column.props.field;
      } else {
        return false;
      }
    },

    isRowEditing(rowData) {
      if (rowData && this.editingRows) {
        if (this.dataKey) return this.editingRowKeys ? this.editingRowKeys[ObjectUtils.resolveFieldData(rowData, this.dataKey)] !== undefined : false;else return this.findIndex(rowData, this.editingRows) > -1;
      }

      return false;
    },

    isRowExpanded(rowData) {
      if (rowData && this.expandedRows) {
        if (this.dataKey) return this.expandedRowKeys ? this.expandedRowKeys[ObjectUtils.resolveFieldData(rowData, this.dataKey)] !== undefined : false;else return this.findIndex(rowData, this.expandedRows) > -1;
      }

      return false;
    },

    isRowGroupExpanded(rowData) {
      if (this.expandableRowGroups && this.expandedRowGroups) {
        let groupFieldValue = ObjectUtils.resolveFieldData(rowData, this.groupRowsBy);
        return this.expandedRowGroups.indexOf(groupFieldValue) > -1;
      }

      return false;
    },

    isSelected(rowData) {
      if (rowData && this.selection) {
        if (this.dataKey) {
          return this.selectionKeys ? this.selectionKeys[ObjectUtils.resolveFieldData(rowData, this.dataKey)] !== undefined : false;
        } else {
          if (this.selection instanceof Array) return this.findIndexInSelection(rowData) > -1;else return this.equals(rowData, this.selection);
        }
      }

      return false;
    },

    isSelectedWithContextMenu(rowData) {
      if (rowData && this.contextMenuSelection) {
        return this.equals(rowData, this.contextMenuSelection, this.dataKey);
      }

      return false;
    },

    findIndexInSelection(rowData) {
      return this.findIndex(rowData, this.selection);
    },

    findIndex(rowData, collection) {
      let index = -1;

      if (collection && collection.length) {
        for (let i = 0; i < collection.length; i++) {
          if (this.equals(rowData, collection[i])) {
            index = i;
            break;
          }
        }
      }

      return index;
    },

    equals(data1, data2) {
      return this.compareSelectionBy === 'equals' ? data1 === data2 : ObjectUtils.equals(data1, data2, this.dataKey);
    },

    onRowGroupToggle(event, data) {
      this.$emit('rowgroup-toggle', {
        originalEvent: event,
        data: data
      });
    },

    onRowClick(event, rowData, rowIndex) {
      this.$emit('row-click', {
        originalEvent: event,
        data: rowData,
        index: rowIndex
      });
    },

    onRowDblClick(event, rowData, rowIndex) {
      this.$emit('row-dblclick', {
        originalEvent: event,
        data: rowData,
        index: rowIndex
      });
    },

    onRowRightClick(event, rowData, rowIndex) {
      this.$emit('row-rightclick', {
        originalEvent: event,
        data: rowData,
        index: rowIndex
      });
    },

    onRowTouchEnd(event) {
      this.$emit('row-touchend', event);
    },

    onRowKeyDown(event, rowData, rowIndex) {
      this.$emit('row-keydown', {
        originalEvent: event,
        data: rowData,
        index: rowIndex
      });
    },

    onRowMouseDown(event) {
      this.$emit('row-mousedown', event);
    },

    onRowDragStart(event, rowIndex) {
      this.$emit('row-dragstart', {
        originalEvent: event,
        index: rowIndex
      });
    },

    onRowDragOver(event, rowIndex) {
      this.$emit('row-dragover', {
        originalEvent: event,
        index: rowIndex
      });
    },

    onRowDragLeave(event) {
      this.$emit('row-dragleave', event);
    },

    onRowDragEnd(event) {
      this.$emit('row-dragend', event);
    },

    onRowDrop(event) {
      this.$emit('row-drop', event);
    },

    onRowToggle(event) {
      this.$emit('row-toggle', event);
    },

    onRadioChange(event) {
      this.$emit('radio-change', event);
    },

    onCheckboxChange(event) {
      this.$emit('checkbox-change', event);
    },

    onCellEditInit(event) {
      this.$emit('cell-edit-init', event);
    },

    onCellEditComplete(event) {
      this.$emit('cell-edit-complete', event);
    },

    onCellEditCancel(event) {
      this.$emit('cell-edit-cancel', event);
    },

    onRowEditInit(event) {
      this.$emit('row-edit-init', event);
    },

    onRowEditSave(event) {
      this.$emit('row-edit-save', event);
    },

    onRowEditCancel(event) {
      this.$emit('row-edit-cancel', event);
    },

    onEditingMetaChange(event) {
      this.$emit('editing-meta-change', event);
    },

    updateFrozenRowStickyPosition() {
      this.$el.style.top = DomHandler.getOuterHeight(this.$el.previousElementSibling) + 'px';
    },

    updateFrozenRowGroupHeaderStickyPosition() {
      let tableHeaderHeight = DomHandler.getOuterHeight(this.$el.previousElementSibling);
      this.rowGroupHeaderStyleObject.top = tableHeaderHeight + 'px';
    },

    updateVirtualScrollerPosition() {
      const tableHeaderHeight = DomHandler.getOuterHeight(this.$el.previousElementSibling);
      this.$el.style.top = (this.$el.style.top || 0) + tableHeaderHeight + 'px';
    },

    getVirtualScrollerProp(option, options) {
      options = options || this.virtualScrollerContentProps;
      return options ? options[option] : null;
    },

    bodyRef(el) {
      // For VirtualScroller
      const contentRef = this.getVirtualScrollerProp('contentRef');
      contentRef && contentRef(el);
    }

  },
  computed: {
    columnsLength() {
      let hiddenColLength = 0;
      this.columns.forEach(column => {
        if (this.columnProp(column, 'hidden')) hiddenColLength++;
      });
      return this.columns ? this.columns.length - hiddenColLength : 0;
    },

    rowGroupHeaderStyle() {
      if (this.scrollable) {
        return {
          top: this.rowGroupHeaderStyleObject.top
        };
      }

      return null;
    },

    bodyStyle() {
      return this.getVirtualScrollerProp('contentStyle');
    }

  },
  components: {
    DTBodyCell: script$8$1
  }
};
const _hoisted_1$7$1 = ["colspan"];
const _hoisted_2$5$1 = ["onClick"];
const _hoisted_3$4$1 = ["onClick", "onDblclick", "onContextmenu", "onKeydown", "tabindex", "onDragstart", "onDragover"];
const _hoisted_4$3$1 = ["colspan"];
const _hoisted_5$2$1 = {
  key: 1,
  class: "p-datatable-emptymessage",
  role: "row"
};
const _hoisted_6$2$1 = ["colspan"];

function render$7$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DTBodyCell = resolveComponent("DTBodyCell");

  return openBlock(), createElementBlock("tbody", {
    ref: $options.bodyRef,
    class: "p-datatable-tbody",
    role: "rowgroup",
    style: normalizeStyle($options.bodyStyle)
  }, [!$props.empty ? (openBlock(true), createElementBlock(Fragment, {
    key: 0
  }, renderList($props.value, (rowData, index) => {
    return openBlock(), createElementBlock(Fragment, {
      key: $options.getRowKey(rowData, $options.getRowIndex(index)) + '_subheader'
    }, [$props.templates['groupheader'] && $props.rowGroupMode === 'subheader' && $options.shouldRenderRowGroupHeader($props.value, rowData, $options.getRowIndex(index)) ? (openBlock(), createElementBlock("tr", {
      key: 0,
      class: "p-rowgroup-header",
      style: normalizeStyle($options.rowGroupHeaderStyle),
      role: "row"
    }, [createElementVNode("td", {
      colspan: $options.columnsLength - 1
    }, [$props.expandableRowGroups ? (openBlock(), createElementBlock("button", {
      key: 0,
      class: "p-row-toggler p-link",
      onClick: $event => $options.onRowGroupToggle($event, rowData),
      type: "button"
    }, [createElementVNode("span", {
      class: normalizeClass($options.rowGroupTogglerIcon(rowData))
    }, null, 2)], 8, _hoisted_2$5$1)) : createCommentVNode("", true), (openBlock(), createBlock(resolveDynamicComponent($props.templates['groupheader']), {
      data: rowData,
      index: $options.getRowIndex(index)
    }, null, 8, ["data", "index"]))], 8, _hoisted_1$7$1)], 4)) : createCommentVNode("", true), ($props.expandableRowGroups ? $options.isRowGroupExpanded(rowData) : true) ? (openBlock(), createElementBlock("tr", {
      key: $options.getRowKey(rowData, $options.getRowIndex(index)),
      class: normalizeClass($options.getRowClass(rowData)),
      style: normalizeStyle($props.rowStyle),
      onClick: $event => $options.onRowClick($event, rowData, $options.getRowIndex(index)),
      onDblclick: $event => $options.onRowDblClick($event, rowData, $options.getRowIndex(index)),
      onContextmenu: $event => $options.onRowRightClick($event, rowData, $options.getRowIndex(index)),
      onTouchend: _cache[9] || (_cache[9] = $event => $options.onRowTouchEnd($event)),
      onKeydown: $event => $options.onRowKeyDown($event, rowData, $options.getRowIndex(index)),
      tabindex: $props.selectionMode || $props.contextMenu ? '0' : null,
      onMousedown: _cache[10] || (_cache[10] = $event => $options.onRowMouseDown($event)),
      onDragstart: $event => $options.onRowDragStart($event, $options.getRowIndex(index)),
      onDragover: $event => $options.onRowDragOver($event, $options.getRowIndex(index)),
      onDragleave: _cache[11] || (_cache[11] = $event => $options.onRowDragLeave($event)),
      onDragend: _cache[12] || (_cache[12] = $event => $options.onRowDragEnd($event)),
      onDrop: _cache[13] || (_cache[13] = $event => $options.onRowDrop($event)),
      role: "row"
    }, [(openBlock(true), createElementBlock(Fragment, null, renderList($props.columns, (col, i) => {
      return openBlock(), createElementBlock(Fragment, {
        key: $options.columnProp(col, 'columnKey') || $options.columnProp(col, 'field') || i
      }, [$options.shouldRenderBodyCell($props.value, col, $options.getRowIndex(index)) ? (openBlock(), createBlock(_component_DTBodyCell, {
        key: 0,
        rowData: rowData,
        column: col,
        rowIndex: $options.getRowIndex(index),
        index: i,
        selected: $options.isSelected(rowData),
        rowTogglerIcon: $options.columnProp(col, 'expander') ? $options.rowTogglerIcon(rowData) : null,
        frozenRow: $props.frozenRow,
        rowspan: $props.rowGroupMode === 'rowspan' ? $options.calculateRowGroupSize($props.value, col, $options.getRowIndex(index)) : null,
        editMode: $props.editMode,
        editing: $props.editMode === 'row' && $options.isRowEditing(rowData),
        responsiveLayout: $props.responsiveLayout,
        onRadioChange: _cache[0] || (_cache[0] = $event => $options.onRadioChange($event)),
        onCheckboxChange: _cache[1] || (_cache[1] = $event => $options.onCheckboxChange($event)),
        onRowToggle: _cache[2] || (_cache[2] = $event => $options.onRowToggle($event)),
        onCellEditInit: _cache[3] || (_cache[3] = $event => $options.onCellEditInit($event)),
        onCellEditComplete: _cache[4] || (_cache[4] = $event => $options.onCellEditComplete($event)),
        onCellEditCancel: _cache[5] || (_cache[5] = $event => $options.onCellEditCancel($event)),
        onRowEditInit: _cache[6] || (_cache[6] = $event => $options.onRowEditInit($event)),
        onRowEditSave: _cache[7] || (_cache[7] = $event => $options.onRowEditSave($event)),
        onRowEditCancel: _cache[8] || (_cache[8] = $event => $options.onRowEditCancel($event)),
        editingMeta: $props.editingMeta,
        onEditingMetaChange: $options.onEditingMetaChange,
        virtualScrollerContentProps: $props.virtualScrollerContentProps
      }, null, 8, ["rowData", "column", "rowIndex", "index", "selected", "rowTogglerIcon", "frozenRow", "rowspan", "editMode", "editing", "responsiveLayout", "editingMeta", "onEditingMetaChange", "virtualScrollerContentProps"])) : createCommentVNode("", true)], 64);
    }), 128))], 46, _hoisted_3$4$1)) : createCommentVNode("", true), $props.templates['expansion'] && $props.expandedRows && $options.isRowExpanded(rowData) ? (openBlock(), createElementBlock("tr", {
      key: $options.getRowKey(rowData, $options.getRowIndex(index)) + '_expansion',
      class: "p-datatable-row-expansion",
      role: "row"
    }, [createElementVNode("td", {
      colspan: $options.columnsLength
    }, [(openBlock(), createBlock(resolveDynamicComponent($props.templates['expansion']), {
      data: rowData,
      index: $options.getRowIndex(index)
    }, null, 8, ["data", "index"]))], 8, _hoisted_4$3$1)])) : createCommentVNode("", true), $props.templates['groupfooter'] && $props.rowGroupMode === 'subheader' && $options.shouldRenderRowGroupFooter($props.value, rowData, $options.getRowIndex(index)) ? (openBlock(), createElementBlock("tr", {
      key: $options.getRowKey(rowData, $options.getRowIndex(index)) + '_subfooter',
      class: "p-rowgroup-footer",
      role: "row"
    }, [(openBlock(), createBlock(resolveDynamicComponent($props.templates['groupfooter']), {
      data: rowData,
      index: $options.getRowIndex(index)
    }, null, 8, ["data", "index"]))])) : createCommentVNode("", true)], 64);
  }), 128)) : (openBlock(), createElementBlock("tr", _hoisted_5$2$1, [createElementVNode("td", {
    colspan: $options.columnsLength
  }, [$props.templates.empty ? (openBlock(), createBlock(resolveDynamicComponent($props.templates.empty), {
    key: 0
  })) : createCommentVNode("", true)], 8, _hoisted_6$2$1)]))], 4);
}

script$7$1.render = render$7$1;
var script$6$1 = {
  name: 'FooterCell',
  props: {
    column: {
      type: null,
      default: null
    }
  },

  data() {
    return {
      styleObject: {}
    };
  },

  mounted() {
    if (this.columnProp('frozen')) {
      this.updateStickyPosition();
    }
  },

  updated() {
    if (this.columnProp('frozen')) {
      this.updateStickyPosition();
    }
  },

  methods: {
    columnProp(prop) {
      return ObjectUtils.getVNodeProp(this.column, prop);
    },

    updateStickyPosition() {
      if (this.columnProp('frozen')) {
        let align = this.columnProp('alignFrozen');

        if (align === 'right') {
          let right = 0;
          let next = this.$el.nextElementSibling;

          if (next) {
            right = DomHandler.getOuterWidth(next) + parseFloat(next.style.left);
          }

          this.styleObject.right = right + 'px';
        } else {
          let left = 0;
          let prev = this.$el.previousElementSibling;

          if (prev) {
            left = DomHandler.getOuterWidth(prev) + parseFloat(prev.style.left);
          }

          this.styleObject.left = left + 'px';
        }
      }
    }

  },
  computed: {
    containerClass() {
      return [this.columnProp('footerClass'), this.columnProp('class'), {
        'p-frozen-column': this.columnProp('frozen')
      }];
    },

    containerStyle() {
      let bodyStyle = this.columnProp('footerStyle');
      let columnStyle = this.columnProp('style');
      return this.columnProp('frozen') ? [columnStyle, bodyStyle, this.styleObject] : [columnStyle, bodyStyle];
    }

  }
};
const _hoisted_1$6$1 = ["colspan", "rowspan"];

function render$6$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("td", {
    style: normalizeStyle($options.containerStyle),
    class: normalizeClass($options.containerClass),
    role: "cell",
    colspan: $options.columnProp('colspan'),
    rowspan: $options.columnProp('rowspan')
  }, [$props.column.children && $props.column.children.footer ? (openBlock(), createBlock(resolveDynamicComponent($props.column.children.footer), {
    key: 0,
    column: $props.column
  }, null, 8, ["column"])) : createCommentVNode("", true), createTextVNode(" " + toDisplayString$1($options.columnProp('footer')), 1)], 14, _hoisted_1$6$1);
}

script$6$1.render = render$6$1;
var script$5$1 = {
  name: 'TableFooter',
  props: {
    columnGroup: {
      type: null,
      default: null
    },
    columns: {
      type: null,
      default: null
    }
  },
  methods: {
    columnProp(col, prop) {
      return ObjectUtils.getVNodeProp(col, prop);
    },

    getFooterRows() {
      let rows = [];
      let columnGroup = this.columnGroup;

      if (columnGroup.children && columnGroup.children.default) {
        for (let child of columnGroup.children.default()) {
          if (child.type.name === 'Row') {
            rows.push(child);
          } else if (child.children && child.children instanceof Array) {
            rows = child.children;
          }
        }

        return rows;
      }
    },

    getFooterColumns(row) {
      let cols = [];

      if (row.children && row.children.default) {
        row.children.default().forEach(child => {
          if (child.children && child.children instanceof Array) cols = [...cols, ...child.children];else if (child.type.name === 'Column') cols.push(child);
        });
        return cols;
      }
    }

  },
  computed: {
    hasFooter() {
      let hasFooter = false;

      if (this.columnGroup) {
        hasFooter = true;
      } else if (this.columns) {
        for (let col of this.columns) {
          if (this.columnProp(col, 'footer') || col.children && col.children.footer) {
            hasFooter = true;
            break;
          }
        }
      }

      return hasFooter;
    }

  },
  components: {
    DTFooterCell: script$6$1
  }
};
const _hoisted_1$5$1 = {
  key: 0,
  class: "p-datatable-tfoot",
  role: "rowgroup"
};
const _hoisted_2$4$1 = {
  key: 0,
  role: "row"
};

function render$5$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DTFooterCell = resolveComponent("DTFooterCell");

  return $options.hasFooter ? (openBlock(), createElementBlock("tfoot", _hoisted_1$5$1, [!$props.columnGroup ? (openBlock(), createElementBlock("tr", _hoisted_2$4$1, [(openBlock(true), createElementBlock(Fragment, null, renderList($props.columns, (col, i) => {
    return openBlock(), createElementBlock(Fragment, {
      key: $options.columnProp(col, 'columnKey') || $options.columnProp(col, 'field') || i
    }, [!$options.columnProp(col, 'hidden') ? (openBlock(), createBlock(_component_DTFooterCell, {
      key: 0,
      column: col
    }, null, 8, ["column"])) : createCommentVNode("", true)], 64);
  }), 128))])) : (openBlock(true), createElementBlock(Fragment, {
    key: 1
  }, renderList($options.getFooterRows(), (row, i) => {
    return openBlock(), createElementBlock("tr", {
      key: i,
      role: "row"
    }, [(openBlock(true), createElementBlock(Fragment, null, renderList($options.getFooterColumns(row), (col, j) => {
      return openBlock(), createElementBlock(Fragment, {
        key: $options.columnProp(col, 'columnKey') || $options.columnProp(col, 'field') || j
      }, [!$options.columnProp(col, 'hidden') ? (openBlock(), createBlock(_component_DTFooterCell, {
        key: 0,
        column: col
      }, null, 8, ["column"])) : createCommentVNode("", true)], 64);
    }), 128))]);
  }), 128))])) : createCommentVNode("", true);
}

script$5$1.render = render$5$1;
var script$4$1 = {
  name: 'HeaderCheckbox',
  inheritAttrs: false,
  emits: ['change'],
  props: {
    checked: null
  },

  data() {
    return {
      focused: false
    };
  },

  methods: {
    onClick(event) {
      if (!this.$attrs.disabled) {
        this.focused = true;
        this.$emit('change', {
          originalEvent: event,
          checked: !this.checked
        });
      }
    },

    onFocus() {
      this.focused = true;
    },

    onBlur() {
      this.focused = false;
    }

  }
};
const _hoisted_1$4$1 = ["aria-checked", "tabindex"];

function render$4$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(['p-checkbox p-component', {
      'p-checkbox-focused': $data.focused,
      'p-disabled': _ctx.$attrs.disabled
    }]),
    onClick: _cache[2] || (_cache[2] = (...args) => $options.onClick && $options.onClick(...args)),
    onKeydown: _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => $options.onClick && $options.onClick(...args), ["prevent"]), ["space"]))
  }, [createElementVNode("div", {
    ref: "box",
    class: normalizeClass(['p-checkbox-box p-component', {
      'p-highlight': $props.checked,
      'p-disabled': _ctx.$attrs.disabled,
      'p-focus': $data.focused
    }]),
    role: "checkbox",
    "aria-checked": $props.checked,
    tabindex: _ctx.$attrs.disabled ? null : '0',
    onFocus: _cache[0] || (_cache[0] = $event => $options.onFocus($event)),
    onBlur: _cache[1] || (_cache[1] = $event => $options.onBlur($event))
  }, [createElementVNode("span", {
    class: normalizeClass(['p-checkbox-icon', {
      'pi pi-check': $props.checked
    }])
  }, null, 2)], 42, _hoisted_1$4$1)], 34);
}

script$4$1.render = render$4$1;
var script$3$1 = {
  name: 'ColumnFilter',
  emits: ['filter-change', 'filter-apply', 'operator-change', 'matchmode-change', 'constraint-add', 'constraint-remove', 'filter-clear', 'apply-click'],
  props: {
    field: {
      type: String,
      default: null
    },
    type: {
      type: String,
      default: 'text'
    },
    display: {
      type: String,
      default: null
    },
    showMenu: {
      type: Boolean,
      default: true
    },
    matchMode: {
      type: String,
      default: null
    },
    showOperator: {
      type: Boolean,
      default: true
    },
    showClearButton: {
      type: Boolean,
      default: true
    },
    showApplyButton: {
      type: Boolean,
      default: true
    },
    showMatchModes: {
      type: Boolean,
      default: true
    },
    showAddButton: {
      type: Boolean,
      default: true
    },
    matchModeOptions: {
      type: Array,
      default: null
    },
    maxConstraints: {
      type: Number,
      default: 2
    },
    filterElement: null,
    filterHeaderTemplate: null,
    filterFooterTemplate: null,
    filterClearTemplate: null,
    filterApplyTemplate: null,
    filters: {
      type: Object,
      default: null
    },
    filtersStore: {
      type: Object,
      default: null
    },
    filterMenuClass: {
      type: String,
      default: null
    },
    filterMenuStyle: {
      type: null,
      default: null
    }
  },

  data() {
    return {
      overlayVisible: false,
      defaultMatchMode: null,
      defaultOperator: null
    };
  },

  overlay: null,
  selfClick: false,
  overlayEventListener: null,

  beforeUnmount() {
    if (this.overlayEventListener) {
      OverlayEventBus.off('overlay-click', this.overlayEventListener);
      this.overlayEventListener = null;
    }

    if (this.overlay) {
      ZIndexUtils.clear(this.overlay);
      this.onOverlayHide();
    }
  },

  mounted() {
    if (this.filters && this.filters[this.field]) {
      let fieldFilters = this.filters[this.field];

      if (fieldFilters.operator) {
        this.defaultMatchMode = fieldFilters.constraints[0].matchMode;
        this.defaultOperator = fieldFilters.operator;
      } else {
        this.defaultMatchMode = this.filters[this.field].matchMode;
      }
    }
  },

  methods: {
    clearFilter() {
      let _filters = { ...this.filters
      };

      if (_filters[this.field].operator) {
        _filters[this.field].constraints.splice(1);

        _filters[this.field].operator = this.defaultOperator;
        _filters[this.field].constraints[0] = {
          value: null,
          matchMode: this.defaultMatchMode
        };
      } else {
        _filters[this.field].value = null;
        _filters[this.field].matchMode = this.defaultMatchMode;
      }

      this.$emit('filter-clear');
      this.$emit('filter-change', _filters);
      this.$emit('filter-apply');
      this.hide();
    },

    applyFilter() {
      this.$emit('apply-click', {
        field: this.field,
        constraints: this.filters[this.field]
      });
      this.$emit('filter-apply');
      this.hide();
    },

    hasFilter() {
      if (this.filtersStore) {
        let fieldFilter = this.filtersStore[this.field];

        if (fieldFilter) {
          if (fieldFilter.operator) return !this.isFilterBlank(fieldFilter.constraints[0].value);else return !this.isFilterBlank(fieldFilter.value);
        }
      }

      return false;
    },

    hasRowFilter() {
      return this.filters[this.field] && !this.isFilterBlank(this.filters[this.field].value);
    },

    isFilterBlank(filter) {
      if (filter !== null && filter !== undefined) {
        if (typeof filter === 'string' && filter.trim().length == 0 || filter instanceof Array && filter.length == 0) return true;else return false;
      }

      return true;
    },

    toggleMenu() {
      this.overlayVisible = !this.overlayVisible;
    },

    onToggleButtonKeyDown(event) {
      switch (event.key) {
        case 'Escape':
        case 'Tab':
          this.overlayVisible = false;
          break;

        case 'ArrowDown':
          if (this.overlayVisible) {
            let focusable = DomHandler.getFocusableElements(this.overlay);

            if (focusable) {
              focusable[0].focus();
            }

            event.preventDefault();
          } else if (event.altKey) {
            this.overlayVisible = true;
            event.preventDefault();
          }

          break;
      }
    },

    onEscape() {
      this.overlayVisible = false;

      if (this.$refs.icon) {
        this.$refs.icon.focus();
      }
    },

    onRowMatchModeChange(matchMode) {
      let _filters = { ...this.filters
      };
      _filters[this.field].matchMode = matchMode;
      this.$emit('matchmode-change', {
        field: this.field,
        matchMode: matchMode
      });
      this.$emit('filter-change', _filters);
      this.$emit('filter-apply');
      this.hide();
    },

    onRowMatchModeKeyDown(event) {
      let item = event.target;

      switch (event.key) {
        case 'ArrowDown':
          var nextItem = this.findNextItem(item);

          if (nextItem) {
            item.removeAttribute('tabindex');
            nextItem.tabIndex = '0';
            nextItem.focus();
          }

          event.preventDefault();
          break;

        case 'ArrowUp':
          var prevItem = this.findPrevItem(item);

          if (prevItem) {
            item.removeAttribute('tabindex');
            prevItem.tabIndex = '0';
            prevItem.focus();
          }

          event.preventDefault();
          break;
      }
    },

    isRowMatchModeSelected(matchMode) {
      return this.filters[this.field].matchMode === matchMode;
    },

    onOperatorChange(value) {
      let _filters = { ...this.filters
      };
      _filters[this.field].operator = value;
      this.$emit('filter-change', _filters);
      this.$emit('operator-change', {
        field: this.field,
        operator: value
      });

      if (!this.showApplyButton) {
        this.$emit('filter-apply');
      }
    },

    onMenuMatchModeChange(value, index) {
      let _filters = { ...this.filters
      };
      _filters[this.field].constraints[index].matchMode = value;
      this.$emit('matchmode-change', {
        field: this.field,
        matchMode: value,
        index: index
      });

      if (!this.showApplyButton) {
        this.$emit('filter-apply');
      }
    },

    addConstraint() {
      let _filters = { ...this.filters
      };
      let newConstraint = {
        value: null,
        matchMode: this.defaultMatchMode
      };

      _filters[this.field].constraints.push(newConstraint);

      this.$emit('constraint-add', {
        field: this.field,
        constraing: newConstraint
      });
      this.$emit('filter-change', _filters);

      if (!this.showApplyButton) {
        this.$emit('filter-apply');
      }
    },

    removeConstraint(index) {
      let _filters = { ...this.filters
      };

      let removedConstraint = _filters[this.field].constraints.splice(index, 1);

      this.$emit('constraint-remove', {
        field: this.field,
        constraing: removedConstraint
      });
      this.$emit('filter-change', _filters);

      if (!this.showApplyButton) {
        this.$emit('filter-apply');
      }
    },

    filterCallback() {
      this.$emit('filter-apply');
    },

    findNextItem(item) {
      let nextItem = item.nextElementSibling;
      if (nextItem) return DomHandler.hasClass(nextItem, 'p-column-filter-separator') ? this.findNextItem(nextItem) : nextItem;else return item.parentElement.firstElementChild;
    },

    findPrevItem(item) {
      let prevItem = item.previousElementSibling;
      if (prevItem) DomHandler.hasClass(prevItem, 'p-column-filter-separator') ? this.findPrevItem(prevItem) : prevItem;else return item.parentElement.lastElementChild;
    },

    hide() {
      this.overlayVisible = false;
    },

    onContentClick(event) {
      this.selfClick = true;
      OverlayEventBus.emit('overlay-click', {
        originalEvent: event,
        target: this.overlay
      });
    },

    onContentMouseDown() {
      this.selfClick = true;
    },

    onOverlayEnter(el) {
      if (this.filterMenuStyle) {
        DomHandler.applyStyle(this.overlay, this.filterMenuStyle);
      }

      ZIndexUtils.set('overlay', el, this.$primevue.config.zIndex.overlay);
      DomHandler.absolutePosition(this.overlay, this.$refs.icon);
      this.bindOutsideClickListener();
      this.bindScrollListener();
      this.bindResizeListener();

      this.overlayEventListener = e => {
        if (!this.isOutsideClicked(e.target)) {
          this.selfClick = true;
        }
      };

      OverlayEventBus.on('overlay-click', this.overlayEventListener);
    },

    onOverlayLeave() {
      this.onOverlayHide();
    },

    onOverlayAfterLeave(el) {
      ZIndexUtils.clear(el);
    },

    onOverlayHide() {
      this.unbindOutsideClickListener();
      this.unbindResizeListener();
      this.unbindScrollListener();
      this.overlay = null;
      OverlayEventBus.off('overlay-click', this.overlayEventListener);
      this.overlayEventListener = null;
    },

    overlayRef(el) {
      this.overlay = el;
    },

    isOutsideClicked(target) {
      return !this.isTargetClicked(target) && this.overlay && !(this.overlay.isSameNode(target) || this.overlay.contains(target));
    },

    isTargetClicked(target) {
      return this.$refs.icon && (this.$refs.icon.isSameNode(target) || this.$refs.icon.contains(target));
    },

    bindOutsideClickListener() {
      if (!this.outsideClickListener) {
        this.outsideClickListener = event => {
          if (this.overlayVisible && !this.selfClick && this.isOutsideClicked(event.target)) {
            this.overlayVisible = false;
          }

          this.selfClick = false;
        };

        document.addEventListener('click', this.outsideClickListener);
      }
    },

    unbindOutsideClickListener() {
      if (this.outsideClickListener) {
        document.removeEventListener('click', this.outsideClickListener);
        this.outsideClickListener = null;
        this.selfClick = false;
      }
    },

    bindScrollListener() {
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.$refs.icon, () => {
          if (this.overlayVisible) {
            this.hide();
          }
        });
      }

      this.scrollHandler.bindScrollListener();
    },

    unbindScrollListener() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    },

    bindResizeListener() {
      if (!this.resizeListener) {
        this.resizeListener = () => {
          if (this.overlayVisible && !DomHandler.isTouchDevice()) {
            this.hide();
          }
        };

        window.addEventListener('resize', this.resizeListener);
      }
    },

    unbindResizeListener() {
      if (this.resizeListener) {
        window.removeEventListener('resize', this.resizeListener);
        this.resizeListener = null;
      }
    }

  },
  computed: {
    containerClass() {
      return ['p-column-filter p-fluid', {
        'p-column-filter-row': this.display === 'row',
        'p-column-filter-menu': this.display === 'menu'
      }];
    },

    overlayClass() {
      return [this.filterMenuClass, {
        'p-column-filter-overlay p-component p-fluid': true,
        'p-column-filter-overlay-menu': this.display === 'menu',
        'p-input-filled': this.$primevue.config.inputStyle === 'filled',
        'p-ripple-disabled': this.$primevue.config.ripple === false
      }];
    },

    showMenuButton() {
      return this.showMenu && (this.display === 'row' ? this.type !== 'boolean' : true);
    },

    matchModes() {
      return this.matchModeOptions || this.$primevue.config.filterMatchModeOptions[this.type].map(key => {
        return {
          label: this.$primevue.config.locale[key],
          value: key
        };
      });
    },

    isShowMatchModes() {
      return this.type !== 'boolean' && this.showMatchModes && this.matchModes;
    },

    operatorOptions() {
      return [{
        label: this.$primevue.config.locale.matchAll,
        value: FilterOperator.AND
      }, {
        label: this.$primevue.config.locale.matchAny,
        value: FilterOperator.OR
      }];
    },

    noFilterLabel() {
      return this.$primevue.config.locale.noFilter;
    },

    isShowOperator() {
      return this.showOperator && this.filters[this.field].operator;
    },

    operator() {
      return this.filters[this.field].operator;
    },

    fieldConstraints() {
      return this.filters[this.field].constraints || [this.filters[this.field]];
    },

    showRemoveIcon() {
      return this.fieldConstraints.length > 1;
    },

    removeRuleButtonLabel() {
      return this.$primevue.config.locale.removeRule;
    },

    addRuleButtonLabel() {
      return this.$primevue.config.locale.addRule;
    },

    isShowAddConstraint() {
      return this.showAddButton && this.filters[this.field].operator && this.fieldConstraints && this.fieldConstraints.length < this.maxConstraints;
    },

    clearButtonLabel() {
      return this.$primevue.config.locale.clear;
    },

    applyButtonLabel() {
      return this.$primevue.config.locale.apply;
    }

  },
  components: {
    CFDropdown: script$O,
    CFButton: script$1L,
    Portal: script$1C
  }
};
const _hoisted_1$3$1 = {
  key: 0,
  class: "p-fluid p-column-filter-element"
};
const _hoisted_2$3$1 = ["aria-expanded"];

const _hoisted_3$3$1 = /*#__PURE__*/createElementVNode("span", {
  class: "pi pi-filter-icon pi-filter"
}, null, -1);

const _hoisted_4$2$1 = [_hoisted_3$3$1];

const _hoisted_5$1$1 = /*#__PURE__*/createElementVNode("span", {
  class: "pi pi-filter-slash"
}, null, -1);

const _hoisted_6$1$1 = [_hoisted_5$1$1];
const _hoisted_7$5 = {
  key: 0,
  class: "p-column-filter-row-items"
};
const _hoisted_8$4 = ["onClick", "onKeydown", "tabindex"];

const _hoisted_9$2 = /*#__PURE__*/createElementVNode("li", {
  class: "p-column-filter-separator"
}, null, -1);

const _hoisted_10$2 = {
  key: 0,
  class: "p-column-filter-operator"
};
const _hoisted_11$2 = {
  class: "p-column-filter-constraints"
};
const _hoisted_12$2 = {
  key: 1,
  class: "p-column-filter-add-rule"
};
const _hoisted_13$2 = {
  class: "p-column-filter-buttonbar"
};

function render$3$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CFDropdown = resolveComponent("CFDropdown");

  const _component_CFButton = resolveComponent("CFButton");

  const _component_Portal = resolveComponent("Portal");

  return openBlock(), createElementBlock("div", {
    class: normalizeClass($options.containerClass)
  }, [$props.display === 'row' ? (openBlock(), createElementBlock("div", _hoisted_1$3$1, [(openBlock(), createBlock(resolveDynamicComponent($props.filterElement), {
    field: $props.field,
    filterModel: $props.filters[$props.field],
    filterCallback: $options.filterCallback
  }, null, 8, ["field", "filterModel", "filterCallback"]))])) : createCommentVNode("", true), $options.showMenuButton ? (openBlock(), createElementBlock("button", {
    key: 1,
    ref: "icon",
    type: "button",
    class: normalizeClass(["p-column-filter-menu-button p-link", {
      'p-column-filter-menu-button-open': $data.overlayVisible,
      'p-column-filter-menu-button-active': $options.hasFilter()
    }]),
    "aria-haspopup": "true",
    "aria-expanded": $data.overlayVisible,
    onClick: _cache[0] || (_cache[0] = $event => $options.toggleMenu()),
    onKeydown: _cache[1] || (_cache[1] = $event => $options.onToggleButtonKeyDown($event))
  }, _hoisted_4$2$1, 42, _hoisted_2$3$1)) : createCommentVNode("", true), $props.showClearButton && $props.display === 'row' ? (openBlock(), createElementBlock("button", {
    key: 2,
    class: normalizeClass([{
      'p-hidden-space': !$options.hasRowFilter()
    }, "p-column-filter-clear-button p-link"]),
    type: "button",
    onClick: _cache[2] || (_cache[2] = $event => $options.clearFilter())
  }, _hoisted_6$1$1, 2)) : createCommentVNode("", true), createVNode(_component_Portal, null, {
    default: withCtx(() => [createVNode(Transition, {
      name: "p-connected-overlay",
      onEnter: $options.onOverlayEnter,
      onLeave: $options.onOverlayLeave,
      onAfterLeave: $options.onOverlayAfterLeave
    }, {
      default: withCtx(() => [$data.overlayVisible ? (openBlock(), createElementBlock("div", {
        key: 0,
        ref: $options.overlayRef,
        class: normalizeClass($options.overlayClass),
        onKeydown: _cache[11] || (_cache[11] = withKeys((...args) => $options.onEscape && $options.onEscape(...args), ["escape"])),
        onClick: _cache[12] || (_cache[12] = (...args) => $options.onContentClick && $options.onContentClick(...args)),
        onMousedown: _cache[13] || (_cache[13] = (...args) => $options.onContentMouseDown && $options.onContentMouseDown(...args))
      }, [(openBlock(), createBlock(resolveDynamicComponent($props.filterHeaderTemplate), {
        field: $props.field,
        filterModel: $props.filters[$props.field],
        filterCallback: $options.filterCallback
      }, null, 8, ["field", "filterModel", "filterCallback"])), $props.display === 'row' ? (openBlock(), createElementBlock("ul", _hoisted_7$5, [(openBlock(true), createElementBlock(Fragment, null, renderList($options.matchModes, (matchMode, i) => {
        return openBlock(), createElementBlock("li", {
          key: matchMode.label,
          class: normalizeClass(["p-column-filter-row-item", {
            'p-highlight': $options.isRowMatchModeSelected(matchMode.value)
          }]),
          onClick: $event => $options.onRowMatchModeChange(matchMode.value),
          onKeydown: [_cache[3] || (_cache[3] = $event => $options.onRowMatchModeKeyDown($event)), withKeys(withModifiers($event => $options.onRowMatchModeChange(matchMode.value), ["prevent"]), ["enter"])],
          tabindex: i === 0 ? '0' : null
        }, toDisplayString$1(matchMode.label), 43, _hoisted_8$4);
      }), 128)), _hoisted_9$2, createElementVNode("li", {
        class: "p-column-filter-row-item",
        onClick: _cache[4] || (_cache[4] = $event => $options.clearFilter()),
        onKeydown: [_cache[5] || (_cache[5] = $event => $options.onRowMatchModeKeyDown($event)), _cache[6] || (_cache[6] = withKeys($event => _ctx.onRowClearItemClick(), ["enter"]))]
      }, toDisplayString$1($options.noFilterLabel), 33)])) : (openBlock(), createElementBlock(Fragment, {
        key: 1
      }, [$options.isShowOperator ? (openBlock(), createElementBlock("div", _hoisted_10$2, [createVNode(_component_CFDropdown, {
        options: $options.operatorOptions,
        modelValue: $options.operator,
        "onUpdate:modelValue": _cache[7] || (_cache[7] = $event => $options.onOperatorChange($event)),
        class: "p-column-filter-operator-dropdown",
        optionLabel: "label",
        optionValue: "value"
      }, null, 8, ["options", "modelValue"])])) : createCommentVNode("", true), createElementVNode("div", _hoisted_11$2, [(openBlock(true), createElementBlock(Fragment, null, renderList($options.fieldConstraints, (fieldConstraint, i) => {
        return openBlock(), createElementBlock("div", {
          key: i,
          class: "p-column-filter-constraint"
        }, [$options.isShowMatchModes ? (openBlock(), createBlock(_component_CFDropdown, {
          key: 0,
          options: $options.matchModes,
          modelValue: fieldConstraint.matchMode,
          optionLabel: "label",
          optionValue: "value",
          "onUpdate:modelValue": $event => $options.onMenuMatchModeChange($event, i),
          class: "p-column-filter-matchmode-dropdown"
        }, null, 8, ["options", "modelValue", "onUpdate:modelValue"])) : createCommentVNode("", true), $props.display === 'menu' ? (openBlock(), createBlock(resolveDynamicComponent($props.filterElement), {
          key: 1,
          field: $props.field,
          filterModel: fieldConstraint,
          filterCallback: $options.filterCallback
        }, null, 8, ["field", "filterModel", "filterCallback"])) : createCommentVNode("", true), createElementVNode("div", null, [$options.showRemoveIcon ? (openBlock(), createBlock(_component_CFButton, {
          key: 0,
          type: "button",
          icon: "pi pi-trash",
          class: "p-column-filter-remove-button p-button-text p-button-danger p-button-sm",
          onClick: $event => $options.removeConstraint(i),
          label: $options.removeRuleButtonLabel
        }, null, 8, ["onClick", "label"])) : createCommentVNode("", true)])]);
      }), 128))]), $options.isShowAddConstraint ? (openBlock(), createElementBlock("div", _hoisted_12$2, [createVNode(_component_CFButton, {
        type: "button",
        label: $options.addRuleButtonLabel,
        icon: "pi pi-plus",
        class: "p-column-filter-add-button p-button-text p-button-sm",
        onClick: _cache[8] || (_cache[8] = $event => $options.addConstraint())
      }, null, 8, ["label"])])) : createCommentVNode("", true), createElementVNode("div", _hoisted_13$2, [!$props.filterClearTemplate && $props.showClearButton ? (openBlock(), createBlock(_component_CFButton, {
        key: 0,
        type: "button",
        class: "p-button-outlined p-button-sm",
        onClick: _cache[9] || (_cache[9] = $event => $options.clearFilter()),
        label: $options.clearButtonLabel
      }, null, 8, ["label"])) : (openBlock(), createBlock(resolveDynamicComponent($props.filterClearTemplate), {
        key: 1,
        field: $props.field,
        filterModel: $props.filters[$props.field],
        filterCallback: $options.clearFilter
      }, null, 8, ["field", "filterModel", "filterCallback"])), $props.showApplyButton ? (openBlock(), createElementBlock(Fragment, {
        key: 2
      }, [!$props.filterApplyTemplate ? (openBlock(), createBlock(_component_CFButton, {
        key: 0,
        type: "button",
        class: "p-button-sm",
        onClick: _cache[10] || (_cache[10] = $event => $options.applyFilter()),
        label: $options.applyButtonLabel
      }, null, 8, ["label"])) : (openBlock(), createBlock(resolveDynamicComponent($props.filterApplyTemplate), {
        key: 1,
        field: $props.field,
        filterModel: $props.filters[$props.field],
        filterCallback: $options.applyFilter
      }, null, 8, ["field", "filterModel", "filterCallback"]))], 64)) : createCommentVNode("", true)])], 64)), (openBlock(), createBlock(resolveDynamicComponent($props.filterFooterTemplate), {
        field: $props.field,
        filterModel: $props.filters[$props.field],
        filterCallback: $options.filterCallback
      }, null, 8, ["field", "filterModel", "filterCallback"]))], 34)) : createCommentVNode("", true)]),
      _: 1
    }, 8, ["onEnter", "onLeave", "onAfterLeave"])]),
    _: 1
  })], 2);
}

script$3$1.render = render$3$1;
var script$2$1 = {
  name: 'HeaderCell',
  emits: ['column-click', 'column-mousedown', 'column-dragstart', 'column-dragover', 'column-dragleave', 'column-drop', 'column-resizestart', 'checkbox-change', 'filter-change', 'filter-apply', 'operator-change', 'matchmode-change', 'constraint-add', 'constraint-remove', 'filter-clear', 'apply-click'],
  props: {
    column: {
      type: Object,
      default: null
    },
    resizableColumns: {
      type: Boolean,
      default: false
    },
    groupRowsBy: {
      type: [Array, String, Function],
      default: null
    },
    sortMode: {
      type: String,
      default: 'single'
    },
    groupRowSortField: {
      type: [String, Function],
      default: null
    },
    sortField: {
      type: [String, Function],
      default: null
    },
    sortOrder: {
      type: Number,
      default: null
    },
    multiSortMeta: {
      type: Array,
      default: null
    },
    allRowsSelected: {
      type: Boolean,
      default: false
    },
    empty: {
      type: Boolean,
      default: false
    },
    filterDisplay: {
      type: String,
      default: null
    },
    filters: {
      type: Object,
      default: null
    },
    filtersStore: {
      type: Object,
      default: null
    },
    filterColumn: {
      type: Boolean,
      default: false
    },
    reorderableColumns: {
      type: Boolean,
      default: false
    }
  },

  data() {
    return {
      styleObject: {}
    };
  },

  mounted() {
    if (this.columnProp('frozen')) {
      this.updateStickyPosition();
    }
  },

  updated() {
    if (this.columnProp('frozen')) {
      this.updateStickyPosition();
    }
  },

  methods: {
    columnProp(prop) {
      return ObjectUtils.getVNodeProp(this.column, prop);
    },

    onClick(event) {
      this.$emit('column-click', {
        originalEvent: event,
        column: this.column
      });
    },

    onKeyDown(event) {
      if (event.which === 13 && event.currentTarget.nodeName === 'TH' && DomHandler.hasClass(event.currentTarget, 'p-sortable-column')) {
        this.$emit('column-click', {
          originalEvent: event,
          column: this.column
        });
      }
    },

    onMouseDown(event) {
      this.$emit('column-mousedown', {
        originalEvent: event,
        column: this.column
      });
    },

    onDragStart(event) {
      this.$emit('column-dragstart', event);
    },

    onDragOver(event) {
      this.$emit('column-dragover', event);
    },

    onDragLeave(event) {
      this.$emit('column-dragleave', event);
    },

    onDrop(event) {
      this.$emit('column-drop', event);
    },

    onResizeStart(event) {
      this.$emit('column-resizestart', event);
    },

    getMultiSortMetaIndex() {
      return this.multiSortMeta.findIndex(meta => meta.field === this.columnProp('field') || meta.field === this.columnProp('sortField'));
    },

    getBadgeValue() {
      let index = this.getMultiSortMetaIndex();
      return this.groupRowsBy && this.groupRowsBy === this.groupRowSortField && index > -1 ? index : index + 1;
    },

    isMultiSorted() {
      return this.sortMode === 'multiple' && this.columnProp('sortable') && this.getMultiSortMetaIndex() > -1;
    },

    isColumnSorted() {
      return this.sortMode === 'single' ? this.sortField && (this.sortField === this.columnProp('field') || this.sortField === this.columnProp('sortField')) : this.isMultiSorted();
    },

    updateStickyPosition() {
      if (this.columnProp('frozen')) {
        let align = this.columnProp('alignFrozen');

        if (align === 'right') {
          let right = 0;
          let next = this.$el.nextElementSibling;

          if (next) {
            right = DomHandler.getOuterWidth(next) + parseFloat(next.style.right || 0);
          }

          this.styleObject.right = right + 'px';
        } else {
          let left = 0;
          let prev = this.$el.previousElementSibling;

          if (prev) {
            left = DomHandler.getOuterWidth(prev) + parseFloat(prev.style.left || 0);
          }

          this.styleObject.left = left + 'px';
        }

        let filterRow = this.$el.parentElement.nextElementSibling;

        if (filterRow) {
          let index = DomHandler.index(this.$el);
          filterRow.children[index].style.left = this.styleObject.left;
          filterRow.children[index].style.right = this.styleObject.right;
        }
      }
    },

    onHeaderCheckboxChange(event) {
      this.$emit('checkbox-change', event);
    }

  },
  computed: {
    containerClass() {
      return [this.filterColumn ? this.columnProp('filterHeaderClass') : this.columnProp('headerClass'), this.columnProp('class'), {
        'p-sortable-column': this.columnProp('sortable'),
        'p-resizable-column': this.resizableColumns,
        'p-highlight': this.isColumnSorted(),
        'p-filter-column': this.filterColumn,
        'p-frozen-column': this.columnProp('frozen'),
        'p-reorderable-column': this.reorderableColumns
      }];
    },

    containerStyle() {
      let headerStyle = this.filterColumn ? this.columnProp('filterHeaderStyle') : this.columnProp('headerStyle');
      let columnStyle = this.columnProp('style');
      return this.columnProp('frozen') ? [columnStyle, headerStyle, this.styleObject] : [columnStyle, headerStyle];
    },

    sortableColumnIcon() {
      let sorted = false;
      let sortOrder = null;

      if (this.sortMode === 'single') {
        sorted = this.sortField && (this.sortField === this.columnProp('field') || this.sortField === this.columnProp('sortField'));
        sortOrder = sorted ? this.sortOrder : 0;
      } else if (this.sortMode === 'multiple') {
        let metaIndex = this.getMultiSortMetaIndex();

        if (metaIndex > -1) {
          sorted = true;
          sortOrder = this.multiSortMeta[metaIndex].order;
        }
      }

      return ['p-sortable-column-icon pi pi-fw', {
        'pi-sort-alt': !sorted,
        'pi-sort-amount-up-alt': sorted && sortOrder > 0,
        'pi-sort-amount-down': sorted && sortOrder < 0
      }];
    },

    ariaSort() {
      if (this.columnProp('sortable')) {
        const sortIcon = this.sortableColumnIcon;
        if (sortIcon[1]['pi-sort-amount-down']) return 'descending';else if (sortIcon[1]['pi-sort-amount-up-alt']) return 'ascending';else return 'none';
      } else {
        return null;
      }
    }

  },
  components: {
    DTHeaderCheckbox: script$4$1,
    DTColumnFilter: script$3$1
  }
};
const _hoisted_1$2$1 = ["tabindex", "colspan", "rowspan", "aria-sort"];
const _hoisted_2$2$1 = {
  class: "p-column-header-content"
};
const _hoisted_3$2$1 = {
  key: 1,
  class: "p-column-title"
};
const _hoisted_4$1$1 = {
  key: 3,
  class: "p-sortable-column-badge"
};

function render$2$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DTHeaderCheckbox = resolveComponent("DTHeaderCheckbox");

  const _component_DTColumnFilter = resolveComponent("DTColumnFilter");

  return openBlock(), createElementBlock("th", {
    style: normalizeStyle($options.containerStyle),
    class: normalizeClass($options.containerClass),
    tabindex: $options.columnProp('sortable') ? '0' : null,
    role: "cell",
    onClick: _cache[8] || (_cache[8] = (...args) => $options.onClick && $options.onClick(...args)),
    onKeydown: _cache[9] || (_cache[9] = (...args) => $options.onKeyDown && $options.onKeyDown(...args)),
    onMousedown: _cache[10] || (_cache[10] = (...args) => $options.onMouseDown && $options.onMouseDown(...args)),
    onDragstart: _cache[11] || (_cache[11] = (...args) => $options.onDragStart && $options.onDragStart(...args)),
    onDragover: _cache[12] || (_cache[12] = (...args) => $options.onDragOver && $options.onDragOver(...args)),
    onDragleave: _cache[13] || (_cache[13] = (...args) => $options.onDragLeave && $options.onDragLeave(...args)),
    onDrop: _cache[14] || (_cache[14] = (...args) => $options.onDrop && $options.onDrop(...args)),
    colspan: $options.columnProp('colspan'),
    rowspan: $options.columnProp('rowspan'),
    "aria-sort": $options.ariaSort
  }, [$props.resizableColumns && !$options.columnProp('frozen') ? (openBlock(), createElementBlock("span", {
    key: 0,
    class: "p-column-resizer",
    onMousedown: _cache[0] || (_cache[0] = (...args) => $options.onResizeStart && $options.onResizeStart(...args))
  }, null, 32)) : createCommentVNode("", true), createElementVNode("div", _hoisted_2$2$1, [$props.column.children && $props.column.children.header ? (openBlock(), createBlock(resolveDynamicComponent($props.column.children.header), {
    key: 0,
    column: $props.column
  }, null, 8, ["column"])) : createCommentVNode("", true), $options.columnProp('header') ? (openBlock(), createElementBlock("span", _hoisted_3$2$1, toDisplayString$1($options.columnProp('header')), 1)) : createCommentVNode("", true), $options.columnProp('sortable') ? (openBlock(), createElementBlock("span", {
    key: 2,
    class: normalizeClass($options.sortableColumnIcon)
  }, null, 2)) : createCommentVNode("", true), $options.isMultiSorted() ? (openBlock(), createElementBlock("span", _hoisted_4$1$1, toDisplayString$1($options.getBadgeValue()), 1)) : createCommentVNode("", true), $options.columnProp('selectionMode') === 'multiple' && $props.filterDisplay !== 'row' ? (openBlock(), createBlock(_component_DTHeaderCheckbox, {
    key: 4,
    checked: $props.allRowsSelected,
    onChange: $options.onHeaderCheckboxChange,
    disabled: $props.empty
  }, null, 8, ["checked", "onChange", "disabled"])) : createCommentVNode("", true), $props.filterDisplay === 'menu' && $props.column.children && $props.column.children.filter ? (openBlock(), createBlock(_component_DTColumnFilter, {
    key: 5,
    field: $options.columnProp('filterField') || $options.columnProp('field'),
    type: $options.columnProp('dataType'),
    display: "menu",
    showMenu: $options.columnProp('showFilterMenu'),
    filterElement: $props.column.children && $props.column.children.filter,
    filterHeaderTemplate: $props.column.children && $props.column.children.filterheader,
    filterFooterTemplate: $props.column.children && $props.column.children.filterfooter,
    filterClearTemplate: $props.column.children && $props.column.children.filterclear,
    filterApplyTemplate: $props.column.children && $props.column.children.filterapply,
    filters: $props.filters,
    filtersStore: $props.filtersStore,
    onFilterChange: _cache[1] || (_cache[1] = $event => _ctx.$emit('filter-change', $event)),
    onFilterApply: _cache[2] || (_cache[2] = $event => _ctx.$emit('filter-apply')),
    filterMenuStyle: $options.columnProp('filterMenuStyle'),
    filterMenuClass: $options.columnProp('filterMenuClass'),
    showOperator: $options.columnProp('showFilterOperator'),
    showClearButton: $options.columnProp('showClearButton'),
    showApplyButton: $options.columnProp('showApplyButton'),
    showMatchModes: $options.columnProp('showFilterMatchModes'),
    showAddButton: $options.columnProp('showAddButton'),
    matchModeOptions: $options.columnProp('filterMatchModeOptions'),
    maxConstraints: $options.columnProp('maxConstraints'),
    onOperatorChange: _cache[3] || (_cache[3] = $event => _ctx.$emit('operator-change', $event)),
    onMatchmodeChange: _cache[4] || (_cache[4] = $event => _ctx.$emit('matchmode-change', $event)),
    onConstraintAdd: _cache[5] || (_cache[5] = $event => _ctx.$emit('constraint-add', $event)),
    onConstraintRemove: _cache[6] || (_cache[6] = $event => _ctx.$emit('constraint-remove', $event)),
    onApplyClick: _cache[7] || (_cache[7] = $event => _ctx.$emit('apply-click', $event))
  }, null, 8, ["field", "type", "showMenu", "filterElement", "filterHeaderTemplate", "filterFooterTemplate", "filterClearTemplate", "filterApplyTemplate", "filters", "filtersStore", "filterMenuStyle", "filterMenuClass", "showOperator", "showClearButton", "showApplyButton", "showMatchModes", "showAddButton", "matchModeOptions", "maxConstraints"])) : createCommentVNode("", true)])], 46, _hoisted_1$2$1);
}

script$2$1.render = render$2$1;
var script$1$1 = {
  name: 'TableHeader',
  emits: ['column-click', 'column-mousedown', 'column-dragstart', 'column-dragover', 'column-dragleave', 'column-drop', 'column-resizestart', 'checkbox-change', 'filter-change', 'filter-apply', 'operator-change', 'matchmode-change', 'constraint-add', 'constraint-remove', 'filter-clear', 'apply-click'],
  props: {
    columnGroup: {
      type: null,
      default: null
    },
    columns: {
      type: null,
      default: null
    },
    rowGroupMode: {
      type: String,
      default: null
    },
    groupRowsBy: {
      type: [Array, String, Function],
      default: null
    },
    resizableColumns: {
      type: Boolean,
      default: false
    },
    allRowsSelected: {
      type: Boolean,
      default: false
    },
    empty: {
      type: Boolean,
      default: false
    },
    sortMode: {
      type: String,
      default: 'single'
    },
    groupRowSortField: {
      type: [String, Function],
      default: null
    },
    sortField: {
      type: [String, Function],
      default: null
    },
    sortOrder: {
      type: Number,
      default: null
    },
    multiSortMeta: {
      type: Array,
      default: null
    },
    filterDisplay: {
      type: String,
      default: null
    },
    filters: {
      type: Object,
      default: null
    },
    filtersStore: {
      type: Object,
      default: null
    },
    reorderableColumns: {
      type: Boolean,
      default: false
    }
  },
  methods: {
    columnProp(col, prop) {
      return ObjectUtils.getVNodeProp(col, prop);
    },

    getFilterColumnHeaderClass(column) {
      return ['p-filter-column', this.columnProp(column, 'filterHeaderClass'), this.columnProp(column, 'class'), {
        'p-frozen-column': this.columnProp(column, 'frozen')
      }];
    },

    getFilterColumnHeaderStyle(column) {
      return [this.columnProp(column, 'filterHeaderStyle'), this.columnProp(column, 'style')];
    },

    getHeaderRows() {
      let rows = [];
      let columnGroup = this.columnGroup;

      if (columnGroup.children && columnGroup.children.default) {
        for (let child of columnGroup.children.default()) {
          if (child.type.name === 'Row') {
            rows.push(child);
          } else if (child.children && child.children instanceof Array) {
            rows = child.children;
          }
        }

        return rows;
      }
    },

    getHeaderColumns(row) {
      let cols = [];

      if (row.children && row.children.default) {
        row.children.default().forEach(child => {
          if (child.children && child.children instanceof Array) cols = [...cols, ...child.children];else if (child.type.name === 'Column') cols.push(child);
        });
        return cols;
      }
    }

  },
  components: {
    DTHeaderCell: script$2$1,
    DTHeaderCheckbox: script$4$1,
    DTColumnFilter: script$3$1
  }
};
const _hoisted_1$1$1 = {
  class: "p-datatable-thead",
  role: "rowgroup"
};
const _hoisted_2$1$1 = {
  role: "row"
};
const _hoisted_3$1$1 = {
  key: 0,
  role: "row"
};

function render$1$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DTHeaderCell = resolveComponent("DTHeaderCell");

  const _component_DTHeaderCheckbox = resolveComponent("DTHeaderCheckbox");

  const _component_DTColumnFilter = resolveComponent("DTColumnFilter");

  return openBlock(), createElementBlock("thead", _hoisted_1$1$1, [!$props.columnGroup ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [createElementVNode("tr", _hoisted_2$1$1, [(openBlock(true), createElementBlock(Fragment, null, renderList($props.columns, (col, i) => {
    return openBlock(), createElementBlock(Fragment, {
      key: $options.columnProp(col, 'columnKey') || $options.columnProp(col, 'field') || i
    }, [!$options.columnProp(col, 'hidden') && ($props.rowGroupMode !== 'subheader' || $props.groupRowsBy !== $options.columnProp(col, 'field')) ? (openBlock(), createBlock(_component_DTHeaderCell, {
      key: 0,
      column: col,
      onColumnClick: _cache[0] || (_cache[0] = $event => _ctx.$emit('column-click', $event)),
      onColumnMousedown: _cache[1] || (_cache[1] = $event => _ctx.$emit('column-mousedown', $event)),
      onColumnDragstart: _cache[2] || (_cache[2] = $event => _ctx.$emit('column-dragstart', $event)),
      onColumnDragover: _cache[3] || (_cache[3] = $event => _ctx.$emit('column-dragover', $event)),
      onColumnDragleave: _cache[4] || (_cache[4] = $event => _ctx.$emit('column-dragleave', $event)),
      onColumnDrop: _cache[5] || (_cache[5] = $event => _ctx.$emit('column-drop', $event)),
      groupRowsBy: $props.groupRowsBy,
      groupRowSortField: $props.groupRowSortField,
      reorderableColumns: $props.reorderableColumns,
      resizableColumns: $props.resizableColumns,
      onColumnResizestart: _cache[6] || (_cache[6] = $event => _ctx.$emit('column-resizestart', $event)),
      sortMode: $props.sortMode,
      sortField: $props.sortField,
      sortOrder: $props.sortOrder,
      multiSortMeta: $props.multiSortMeta,
      allRowsSelected: $props.allRowsSelected,
      empty: $props.empty,
      onCheckboxChange: _cache[7] || (_cache[7] = $event => _ctx.$emit('checkbox-change', $event)),
      filters: $props.filters,
      filterDisplay: $props.filterDisplay,
      filtersStore: $props.filtersStore,
      onFilterChange: _cache[8] || (_cache[8] = $event => _ctx.$emit('filter-change', $event)),
      onFilterApply: _cache[9] || (_cache[9] = $event => _ctx.$emit('filter-apply')),
      onOperatorChange: _cache[10] || (_cache[10] = $event => _ctx.$emit('operator-change', $event)),
      onMatchmodeChange: _cache[11] || (_cache[11] = $event => _ctx.$emit('matchmode-change', $event)),
      onConstraintAdd: _cache[12] || (_cache[12] = $event => _ctx.$emit('constraint-add', $event)),
      onConstraintRemove: _cache[13] || (_cache[13] = $event => _ctx.$emit('constraint-remove', $event)),
      onApplyClick: _cache[14] || (_cache[14] = $event => _ctx.$emit('apply-click', $event))
    }, null, 8, ["column", "groupRowsBy", "groupRowSortField", "reorderableColumns", "resizableColumns", "sortMode", "sortField", "sortOrder", "multiSortMeta", "allRowsSelected", "empty", "filters", "filterDisplay", "filtersStore"])) : createCommentVNode("", true)], 64);
  }), 128))]), $props.filterDisplay === 'row' ? (openBlock(), createElementBlock("tr", _hoisted_3$1$1, [(openBlock(true), createElementBlock(Fragment, null, renderList($props.columns, (col, i) => {
    return openBlock(), createElementBlock(Fragment, {
      key: $options.columnProp(col, 'columnKey') || $options.columnProp(col, 'field') || i
    }, [!$options.columnProp(col, 'hidden') && ($props.rowGroupMode !== 'subheader' || $props.groupRowsBy !== $options.columnProp(col, 'field')) ? (openBlock(), createElementBlock("th", {
      key: 0,
      style: normalizeStyle($options.getFilterColumnHeaderStyle(col)),
      class: normalizeClass($options.getFilterColumnHeaderClass(col))
    }, [$options.columnProp(col, 'selectionMode') === 'multiple' ? (openBlock(), createBlock(_component_DTHeaderCheckbox, {
      key: 0,
      checked: $props.allRowsSelected,
      onChange: _cache[15] || (_cache[15] = $event => _ctx.$emit('checkbox-change', $event)),
      disabled: $props.empty
    }, null, 8, ["checked", "disabled"])) : createCommentVNode("", true), col.children && col.children.filter ? (openBlock(), createBlock(_component_DTColumnFilter, {
      key: 1,
      field: $options.columnProp(col, 'filterField') || $options.columnProp(col, 'field'),
      type: $options.columnProp(col, 'dataType'),
      display: "row",
      showMenu: $options.columnProp(col, 'showFilterMenu'),
      filterElement: col.children && col.children.filter,
      filterHeaderTemplate: col.children && col.children.filterheader,
      filterFooterTemplate: col.children && col.children.filterfooter,
      filterClearTemplate: col.children && col.children.filterclear,
      filterApplyTemplate: col.children && col.children.filterapply,
      filters: $props.filters,
      filtersStore: $props.filtersStore,
      onFilterChange: _cache[16] || (_cache[16] = $event => _ctx.$emit('filter-change', $event)),
      onFilterApply: _cache[17] || (_cache[17] = $event => _ctx.$emit('filter-apply')),
      filterMenuStyle: $options.columnProp(col, 'filterMenuStyle'),
      filterMenuClass: $options.columnProp(col, 'filterMenuClass'),
      showOperator: $options.columnProp(col, 'showFilterOperator'),
      showClearButton: $options.columnProp(col, 'showClearButton'),
      showApplyButton: $options.columnProp(col, 'showApplyButton'),
      showMatchModes: $options.columnProp(col, 'showFilterMatchModes'),
      showAddButton: $options.columnProp(col, 'showAddButton'),
      matchModeOptions: $options.columnProp(col, 'filterMatchModeOptions'),
      maxConstraints: $options.columnProp(col, 'maxConstraints'),
      onOperatorChange: _cache[18] || (_cache[18] = $event => _ctx.$emit('operator-change', $event)),
      onMatchmodeChange: _cache[19] || (_cache[19] = $event => _ctx.$emit('matchmode-change', $event)),
      onConstraintAdd: _cache[20] || (_cache[20] = $event => _ctx.$emit('constraint-add', $event)),
      onConstraintRemove: _cache[21] || (_cache[21] = $event => _ctx.$emit('constraint-remove', $event)),
      onApplyClick: _cache[22] || (_cache[22] = $event => _ctx.$emit('apply-click', $event))
    }, null, 8, ["field", "type", "showMenu", "filterElement", "filterHeaderTemplate", "filterFooterTemplate", "filterClearTemplate", "filterApplyTemplate", "filters", "filtersStore", "filterMenuStyle", "filterMenuClass", "showOperator", "showClearButton", "showApplyButton", "showMatchModes", "showAddButton", "matchModeOptions", "maxConstraints"])) : createCommentVNode("", true)], 6)) : createCommentVNode("", true)], 64);
  }), 128))])) : createCommentVNode("", true)], 64)) : (openBlock(true), createElementBlock(Fragment, {
    key: 1
  }, renderList($options.getHeaderRows(), (row, i) => {
    return openBlock(), createElementBlock("tr", {
      key: i,
      role: "row"
    }, [(openBlock(true), createElementBlock(Fragment, null, renderList($options.getHeaderColumns(row), (col, j) => {
      return openBlock(), createElementBlock(Fragment, {
        key: $options.columnProp(col, 'columnKey') || $options.columnProp(col, 'field') || j
      }, [!$options.columnProp(col, 'hidden') && ($props.rowGroupMode !== 'subheader' || $props.groupRowsBy !== $options.columnProp(col, 'field')) && typeof col.children !== 'string' ? (openBlock(), createBlock(_component_DTHeaderCell, {
        key: 0,
        column: col,
        onColumnClick: _cache[23] || (_cache[23] = $event => _ctx.$emit('column-click', $event)),
        onColumnMousedown: _cache[24] || (_cache[24] = $event => _ctx.$emit('column-mousedown', $event)),
        groupRowsBy: $props.groupRowsBy,
        groupRowSortField: $props.groupRowSortField,
        sortMode: $props.sortMode,
        sortField: $props.sortField,
        sortOrder: $props.sortOrder,
        multiSortMeta: $props.multiSortMeta,
        allRowsSelected: $props.allRowsSelected,
        empty: $props.empty,
        onCheckboxChange: _cache[25] || (_cache[25] = $event => _ctx.$emit('checkbox-change', $event)),
        filters: $props.filters,
        filterDisplay: $props.filterDisplay,
        filtersStore: $props.filtersStore,
        onFilterChange: _cache[26] || (_cache[26] = $event => _ctx.$emit('filter-change', $event)),
        onFilterApply: _cache[27] || (_cache[27] = $event => _ctx.$emit('filter-apply')),
        onOperatorChange: _cache[28] || (_cache[28] = $event => _ctx.$emit('operator-change', $event)),
        onMatchmodeChange: _cache[29] || (_cache[29] = $event => _ctx.$emit('matchmode-change', $event)),
        onConstraintAdd: _cache[30] || (_cache[30] = $event => _ctx.$emit('constraint-add', $event)),
        onConstraintRemove: _cache[31] || (_cache[31] = $event => _ctx.$emit('constraint-remove', $event)),
        onApplyClick: _cache[32] || (_cache[32] = $event => _ctx.$emit('apply-click', $event))
      }, null, 8, ["column", "groupRowsBy", "groupRowSortField", "sortMode", "sortField", "sortOrder", "multiSortMeta", "allRowsSelected", "empty", "filters", "filterDisplay", "filtersStore"])) : createCommentVNode("", true)], 64);
    }), 128))]);
  }), 128))]);
}

script$1$1.render = render$1$1;
var script$M = {
  name: 'DataTable',
  emits: ['value-change', 'update:first', 'update:rows', 'page', 'update:sortField', 'update:sortOrder', 'update:multiSortMeta', 'sort', 'filter', 'row-click', 'row-dblclick', 'update:selection', 'row-select', 'row-unselect', 'update:contextMenuSelection', 'row-contextmenu', 'row-unselect-all', 'row-select-all', 'select-all-change', 'column-resize-end', 'column-reorder', 'row-reorder', 'update:expandedRows', 'row-collapse', 'row-expand', 'update:expandedRowGroups', 'rowgroup-collapse', 'rowgroup-expand', 'update:filters', 'state-restore', 'state-save', 'cell-edit-init', 'cell-edit-complete', 'cell-edit-cancel', 'update:editingRows', 'row-edit-init', 'row-edit-save', 'row-edit-cancel'],
  props: {
    value: {
      type: Array,
      default: null
    },
    dataKey: {
      type: [String, Function],
      default: null
    },
    rows: {
      type: Number,
      default: 0
    },
    first: {
      type: Number,
      default: 0
    },
    totalRecords: {
      type: Number,
      default: 0
    },
    paginator: {
      type: Boolean,
      default: false
    },
    paginatorPosition: {
      type: String,
      default: 'bottom'
    },
    alwaysShowPaginator: {
      type: Boolean,
      default: true
    },
    paginatorTemplate: {
      type: [Object, String],
      default: 'FirstPageLink PrevPageLink PageLinks NextPageLink LastPageLink RowsPerPageDropdown'
    },
    pageLinkSize: {
      type: Number,
      default: 5
    },
    rowsPerPageOptions: {
      type: Array,
      default: null
    },
    currentPageReportTemplate: {
      type: String,
      default: '({currentPage} of {totalPages})'
    },
    lazy: {
      type: Boolean,
      default: false
    },
    loading: {
      type: Boolean,
      default: false
    },
    loadingIcon: {
      type: String,
      default: 'pi pi-spinner'
    },
    sortField: {
      type: [String, Function],
      default: null
    },
    sortOrder: {
      type: Number,
      default: null
    },
    defaultSortOrder: {
      type: Number,
      default: 1
    },
    multiSortMeta: {
      type: Array,
      default: null
    },
    sortMode: {
      type: String,
      default: 'single'
    },
    removableSort: {
      type: Boolean,
      default: false
    },
    filters: {
      type: Object,
      default: null
    },
    filterDisplay: {
      type: String,
      default: null
    },
    globalFilterFields: {
      type: Array,
      default: null
    },
    filterLocale: {
      type: String,
      default: undefined
    },
    selection: {
      type: [Array, Object],
      default: null
    },
    selectionMode: {
      type: String,
      default: null
    },
    compareSelectionBy: {
      type: String,
      default: 'deepEquals'
    },
    metaKeySelection: {
      type: Boolean,
      default: true
    },
    contextMenu: {
      type: Boolean,
      default: false
    },
    contextMenuSelection: {
      type: Object,
      default: null
    },
    selectAll: {
      type: Boolean,
      default: null
    },
    rowHover: {
      type: Boolean,
      default: false
    },
    csvSeparator: {
      type: String,
      default: ','
    },
    exportFilename: {
      type: String,
      default: 'download'
    },
    exportFunction: {
      type: Function,
      default: null
    },
    autoLayout: {
      type: Boolean,
      default: false
    },
    resizableColumns: {
      type: Boolean,
      default: false
    },
    columnResizeMode: {
      type: String,
      default: 'fit'
    },
    reorderableColumns: {
      type: Boolean,
      default: false
    },
    expandedRows: {
      type: Array,
      default: null
    },
    expandedRowIcon: {
      type: String,
      default: 'pi-chevron-down'
    },
    collapsedRowIcon: {
      type: String,
      default: 'pi-chevron-right'
    },
    rowGroupMode: {
      type: String,
      default: null
    },
    groupRowsBy: {
      type: [Array, String, Function],
      default: null
    },
    expandableRowGroups: {
      type: Boolean,
      default: false
    },
    expandedRowGroups: {
      type: Array,
      default: null
    },
    stateStorage: {
      type: String,
      default: 'session'
    },
    stateKey: {
      type: String,
      default: null
    },
    editMode: {
      type: String,
      default: null
    },
    editingRows: {
      type: Array,
      default: null
    },
    rowClass: {
      type: null,
      default: null
    },
    rowStyle: {
      type: null,
      default: null
    },
    scrollable: {
      type: Boolean,
      default: false
    },
    scrollDirection: {
      type: String,
      default: 'vertical'
    },
    virtualScrollerOptions: {
      type: Object,
      default: null
    },
    scrollHeight: {
      type: String,
      default: null
    },
    frozenValue: {
      type: Array,
      default: null
    },
    responsiveLayout: {
      type: String,
      default: 'stack'
    },
    breakpoint: {
      type: String,
      default: '960px'
    },
    showGridlines: {
      type: Boolean,
      default: false
    },
    stripedRows: {
      type: Boolean,
      default: false
    },
    tableStyle: {
      type: null,
      default: null
    },
    tableClass: {
      type: String,
      default: null
    }
  },

  data() {
    return {
      d_first: this.first,
      d_rows: this.rows,
      d_sortField: this.sortField,
      d_sortOrder: this.sortOrder,
      d_multiSortMeta: this.multiSortMeta ? [...this.multiSortMeta] : [],
      d_groupRowsSortMeta: null,
      d_selectionKeys: null,
      d_expandedRowKeys: null,
      d_columnOrder: null,
      d_editingRowKeys: null,
      d_editingMeta: {},
      d_filters: this.cloneFilters(this.filters)
    };
  },

  rowTouched: false,
  anchorRowIndex: null,
  rangeRowIndex: null,
  documentColumnResizeListener: null,
  documentColumnResizeEndListener: null,
  lastResizeHelperX: null,
  resizeColumnElement: null,
  columnResizing: false,
  colReorderIconWidth: null,
  colReorderIconHeight: null,
  draggedColumn: null,
  draggedRowIndex: null,
  droppedRowIndex: null,
  rowDragging: null,
  columnWidthsState: null,
  tableWidthState: null,
  columnWidthsRestored: false,
  watch: {
    first(newValue) {
      this.d_first = newValue;
    },

    rows(newValue) {
      this.d_rows = newValue;
    },

    sortField(newValue) {
      this.d_sortField = newValue;
    },

    sortOrder(newValue) {
      this.d_sortOrder = newValue;
    },

    multiSortMeta(newValue) {
      this.d_multiSortMeta = newValue;
    },

    selection: {
      immediate: true,

      handler(newValue) {
        if (this.dataKey) {
          this.updateSelectionKeys(newValue);
        }
      }

    },

    expandedRows(newValue) {
      if (this.dataKey) {
        this.updateExpandedRowKeys(newValue);
      }
    },

    editingRows(newValue) {
      if (this.dataKey) {
        this.updateEditingRowKeys(newValue);
      }
    },

    filters: {
      deep: true,
      handler: function (newValue) {
        this.d_filters = this.cloneFilters(newValue);
      }
    }
  },

  beforeMount() {
    if (this.isStateful()) {
      this.restoreState();
    }
  },

  mounted() {
    this.$el.setAttribute(this.attributeSelector, '');

    if (this.responsiveLayout === 'stack' && !this.scrollable) {
      this.createResponsiveStyle();
    }

    if (this.isStateful() && this.resizableColumns) {
      this.restoreColumnWidths();
    }

    if (this.editMode === 'row' && this.dataKey && !this.d_editingRowKeys) {
      this.updateEditingRowKeys(this.editingRows);
    }
  },

  beforeUnmount() {
    this.unbindColumnResizeEvents();
    this.destroyStyleElement();
    this.destroyResponsiveStyle();
  },

  updated() {
    if (this.isStateful()) {
      this.saveState();
    }

    if (this.editMode === 'row' && this.dataKey && !this.d_editingRowKeys) {
      this.updateEditingRowKeys(this.editingRows);
    }
  },

  methods: {
    columnProp(col, prop) {
      return ObjectUtils.getVNodeProp(col, prop);
    },

    onPage(event) {
      this.clearEditingMetaData();
      this.d_first = event.first;
      this.d_rows = event.rows;
      let pageEvent = this.createLazyLoadEvent(event);
      pageEvent.pageCount = event.pageCount;
      pageEvent.page = event.page;
      this.$emit('update:first', this.d_first);
      this.$emit('update:rows', this.d_rows);
      this.$emit('page', pageEvent);
      this.$emit('value-change', this.processedData);
    },

    onColumnHeaderClick(e) {
      const event = e.originalEvent;
      const column = e.column;

      if (this.columnProp(column, 'sortable')) {
        const targetNode = event.target;
        const columnField = this.columnProp(column, 'sortField') || this.columnProp(column, 'field');

        if (DomHandler.hasClass(targetNode, 'p-sortable-column') || DomHandler.hasClass(targetNode, 'p-column-title') || DomHandler.hasClass(targetNode, 'p-column-header-content') || DomHandler.hasClass(targetNode, 'p-sortable-column-icon') || DomHandler.hasClass(targetNode.parentElement, 'p-sortable-column-icon')) {
          DomHandler.clearSelection();

          if (this.sortMode === 'single') {
            if (this.d_sortField === columnField) {
              if (this.removableSort && this.d_sortOrder * -1 === this.defaultSortOrder) {
                this.d_sortOrder = null;
                this.d_sortField = null;
              } else {
                this.d_sortOrder = this.d_sortOrder * -1;
              }
            } else {
              this.d_sortOrder = this.defaultSortOrder;
              this.d_sortField = columnField;
            }

            this.$emit('update:sortField', this.d_sortField);
            this.$emit('update:sortOrder', this.d_sortOrder);
            this.resetPage();
          } else if (this.sortMode === 'multiple') {
            let metaKey = event.metaKey || event.ctrlKey;

            if (!metaKey) {
              this.d_multiSortMeta = this.d_multiSortMeta.filter(meta => meta.field === columnField);
            }

            this.addMultiSortField(columnField);
            this.$emit('update:multiSortMeta', this.d_multiSortMeta);
          }

          this.$emit('sort', this.createLazyLoadEvent(event));
          this.$emit('value-change', this.processedData);
        }
      }
    },

    sortSingle(value) {
      this.clearEditingMetaData();

      if (this.groupRowsBy && this.groupRowsBy === this.sortField) {
        this.d_multiSortMeta = [{
          field: this.sortField,
          order: this.sortOrder || this.defaultSortOrder
        }, {
          field: this.d_sortField,
          order: this.d_sortOrder
        }];
        return this.sortMultiple(value);
      }

      let data = [...value];
      data.sort((data1, data2) => {
        let value1 = ObjectUtils.resolveFieldData(data1, this.d_sortField);
        let value2 = ObjectUtils.resolveFieldData(data2, this.d_sortField);
        let result = null;
        if (value1 == null && value2 != null) result = -1;else if (value1 != null && value2 == null) result = 1;else if (value1 == null && value2 == null) result = 0;else if (typeof value1 === 'string' && typeof value2 === 'string') result = value1.localeCompare(value2, undefined, {
          numeric: true
        });else result = value1 < value2 ? -1 : value1 > value2 ? 1 : 0;
        return this.d_sortOrder * result;
      });
      return data;
    },

    sortMultiple(value) {
      this.clearEditingMetaData();

      if (this.groupRowsBy && (this.d_groupRowsSortMeta || this.d_multiSortMeta.length && this.groupRowsBy === this.d_multiSortMeta[0].field)) {
        const firstSortMeta = this.d_multiSortMeta[0];
        !this.d_groupRowsSortMeta && (this.d_groupRowsSortMeta = firstSortMeta);

        if (firstSortMeta.field !== this.d_groupRowsSortMeta.field) {
          this.d_multiSortMeta = [this.d_groupRowsSortMeta, ...this.d_multiSortMeta];
        }
      }

      let data = [...value];
      data.sort((data1, data2) => {
        return this.multisortField(data1, data2, 0);
      });
      return data;
    },

    multisortField(data1, data2, index) {
      const value1 = ObjectUtils.resolveFieldData(data1, this.d_multiSortMeta[index].field);
      const value2 = ObjectUtils.resolveFieldData(data2, this.d_multiSortMeta[index].field);
      let result = null;

      if (typeof value1 === 'string' || value1 instanceof String) {
        if (value1.localeCompare && value1 !== value2) {
          return this.d_multiSortMeta[index].order * value1.localeCompare(value2, undefined, {
            numeric: true
          });
        }
      } else {
        result = value1 < value2 ? -1 : 1;
      }

      if (value1 === value2) {
        return this.d_multiSortMeta.length - 1 > index ? this.multisortField(data1, data2, index + 1) : 0;
      }

      return this.d_multiSortMeta[index].order * result;
    },

    addMultiSortField(field) {
      let index = this.d_multiSortMeta.findIndex(meta => meta.field === field);

      if (index >= 0) {
        if (this.removableSort && this.d_multiSortMeta[index].order * -1 === this.defaultSortOrder) this.d_multiSortMeta.splice(index, 1);else this.d_multiSortMeta[index] = {
          field: field,
          order: this.d_multiSortMeta[index].order * -1
        };
      } else {
        this.d_multiSortMeta.push({
          field: field,
          order: this.defaultSortOrder
        });
      }

      this.d_multiSortMeta = [...this.d_multiSortMeta];
    },

    filter(data) {
      if (!data) {
        return;
      }

      this.clearEditingMetaData();
      let globalFilterFieldsArray;

      if (this.filters['global']) {
        globalFilterFieldsArray = this.globalFilterFields || this.columns.map(col => this.columnProp(col, 'filterField') || this.columnProp(col, 'field'));
      }

      let filteredValue = [];

      for (let i = 0; i < data.length; i++) {
        let localMatch = true;
        let globalMatch = false;
        let localFiltered = false;

        for (let prop in this.filters) {
          if (Object.prototype.hasOwnProperty.call(this.filters, prop) && prop !== 'global') {
            localFiltered = true;
            let filterField = prop;
            let filterMeta = this.filters[filterField];

            if (filterMeta.operator) {
              for (let filterConstraint of filterMeta.constraints) {
                localMatch = this.executeLocalFilter(filterField, data[i], filterConstraint);

                if (filterMeta.operator === FilterOperator.OR && localMatch || filterMeta.operator === FilterOperator.AND && !localMatch) {
                  break;
                }
              }
            } else {
              localMatch = this.executeLocalFilter(filterField, data[i], filterMeta);
            }

            if (!localMatch) {
              break;
            }
          }
        }

        if (this.filters['global'] && !globalMatch && globalFilterFieldsArray) {
          for (let j = 0; j < globalFilterFieldsArray.length; j++) {
            let globalFilterField = globalFilterFieldsArray[j];
            globalMatch = FilterService.filters[this.filters['global'].matchMode || FilterMatchMode.CONTAINS](ObjectUtils.resolveFieldData(data[i], globalFilterField), this.filters['global'].value, this.filterLocale);

            if (globalMatch) {
              break;
            }
          }
        }

        let matches;

        if (this.filters['global']) {
          matches = localFiltered ? localFiltered && localMatch && globalMatch : globalMatch;
        } else {
          matches = localFiltered && localMatch;
        }

        if (matches) {
          filteredValue.push(data[i]);
        }
      }

      if (filteredValue.length === this.value.length) {
        filteredValue = data;
      }

      let filterEvent = this.createLazyLoadEvent();
      filterEvent.filteredValue = filteredValue;
      this.$emit('filter', filterEvent);
      this.$emit('value-change', filteredValue);
      return filteredValue;
    },

    executeLocalFilter(field, rowData, filterMeta) {
      let filterValue = filterMeta.value;
      let filterMatchMode = filterMeta.matchMode || FilterMatchMode.STARTS_WITH;
      let dataFieldValue = ObjectUtils.resolveFieldData(rowData, field);
      let filterConstraint = FilterService.filters[filterMatchMode];
      return filterConstraint(dataFieldValue, filterValue, this.filterLocale);
    },

    onRowClick(e) {
      const event = e.originalEvent;

      if (DomHandler.isClickable(event.target)) {
        return;
      }

      this.$emit('row-click', e);

      if (this.selectionMode) {
        const rowData = e.data;
        const rowIndex = this.d_first + e.index;

        if (this.isMultipleSelectionMode() && event.shiftKey && this.anchorRowIndex != null) {
          DomHandler.clearSelection();
          this.rangeRowIndex = rowIndex;
          this.selectRange(event);
        } else {
          const selected = this.isSelected(rowData);
          const metaSelection = this.rowTouched ? false : this.metaKeySelection;
          this.anchorRowIndex = rowIndex;
          this.rangeRowIndex = rowIndex;

          if (metaSelection) {
            let metaKey = event.metaKey || event.ctrlKey;

            if (selected && metaKey) {
              if (this.isSingleSelectionMode()) {
                this.$emit('update:selection', null);
              } else {
                const selectionIndex = this.findIndexInSelection(rowData);

                const _selection = this.selection.filter((val, i) => i != selectionIndex);

                this.$emit('update:selection', _selection);
              }

              this.$emit('row-unselect', {
                originalEvent: event,
                data: rowData,
                index: rowIndex,
                type: 'row'
              });
            } else {
              if (this.isSingleSelectionMode()) {
                this.$emit('update:selection', rowData);
              } else if (this.isMultipleSelectionMode()) {
                let _selection = metaKey ? this.selection || [] : [];

                _selection = [..._selection, rowData];
                this.$emit('update:selection', _selection);
              }

              this.$emit('row-select', {
                originalEvent: event,
                data: rowData,
                index: rowIndex,
                type: 'row'
              });
            }
          } else {
            if (this.selectionMode === 'single') {
              if (selected) {
                this.$emit('update:selection', null);
                this.$emit('row-unselect', {
                  originalEvent: event,
                  data: rowData,
                  index: rowIndex,
                  type: 'row'
                });
              } else {
                this.$emit('update:selection', rowData);
                this.$emit('row-select', {
                  originalEvent: event,
                  data: rowData,
                  index: rowIndex,
                  type: 'row'
                });
              }
            } else if (this.selectionMode === 'multiple') {
              if (selected) {
                const selectionIndex = this.findIndexInSelection(rowData);

                const _selection = this.selection.filter((val, i) => i != selectionIndex);

                this.$emit('update:selection', _selection);
                this.$emit('row-unselect', {
                  originalEvent: event,
                  data: rowData,
                  index: rowIndex,
                  type: 'row'
                });
              } else {
                const _selection = this.selection ? [...this.selection, rowData] : [rowData];

                this.$emit('update:selection', _selection);
                this.$emit('row-select', {
                  originalEvent: event,
                  data: rowData,
                  index: rowIndex,
                  type: 'row'
                });
              }
            }
          }
        }
      }

      this.rowTouched = false;
    },

    onRowDblClick(e) {
      const event = e.originalEvent;

      if (DomHandler.isClickable(event.target)) {
        return;
      }

      this.$emit('row-dblclick', e);
    },

    onRowRightClick(event) {
      DomHandler.clearSelection();
      event.originalEvent.target.focus();
      this.$emit('update:contextMenuSelection', event.data);
      this.$emit('row-contextmenu', event);
    },

    onRowTouchEnd() {
      this.rowTouched = true;
    },

    onRowKeyDown(e) {
      const event = e.originalEvent;
      const rowData = e.data;
      const rowIndex = e.index;

      if (this.selectionMode) {
        const row = event.target;

        switch (event.which) {
          //down arrow
          case 40:
            var nextRow = this.findNextSelectableRow(row);

            if (nextRow) {
              nextRow.focus();
            }

            event.preventDefault();
            break;
          //up arrow

          case 38:
            var prevRow = this.findPrevSelectableRow(row);

            if (prevRow) {
              prevRow.focus();
            }

            event.preventDefault();
            break;
          //enter

          case 13:
            this.onRowClick({
              originalEvent: event,
              data: rowData,
              index: rowIndex
            });
            break;
        }
      }
    },

    findNextSelectableRow(row) {
      let nextRow = row.nextElementSibling;

      if (nextRow) {
        if (DomHandler.hasClass(nextRow, 'p-selectable-row')) return nextRow;else return this.findNextSelectableRow(nextRow);
      } else {
        return null;
      }
    },

    findPrevSelectableRow(row) {
      let prevRow = row.previousElementSibling;

      if (prevRow) {
        if (DomHandler.hasClass(prevRow, 'p-selectable-row')) return prevRow;else return this.findPrevSelectableRow(prevRow);
      } else {
        return null;
      }
    },

    toggleRowWithRadio(event) {
      const rowData = event.data;

      if (this.isSelected(rowData)) {
        this.$emit('update:selection', null);
        this.$emit('row-unselect', {
          originalEvent: event.originalEvent,
          data: rowData,
          index: event.index,
          type: 'radiobutton'
        });
      } else {
        this.$emit('update:selection', rowData);
        this.$emit('row-select', {
          originalEvent: event.originalEvent,
          data: rowData,
          index: event.index,
          type: 'radiobutton'
        });
      }
    },

    toggleRowWithCheckbox(event) {
      const rowData = event.data;

      if (this.isSelected(rowData)) {
        const selectionIndex = this.findIndexInSelection(rowData);

        const _selection = this.selection.filter((val, i) => i != selectionIndex);

        this.$emit('update:selection', _selection);
        this.$emit('row-unselect', {
          originalEvent: event.originalEvent,
          data: rowData,
          index: event.index,
          type: 'checkbox'
        });
      } else {
        let _selection = this.selection ? [...this.selection] : [];

        _selection = [..._selection, rowData];
        this.$emit('update:selection', _selection);
        this.$emit('row-select', {
          originalEvent: event.originalEvent,
          data: rowData,
          index: event.index,
          type: 'checkbox'
        });
      }
    },

    toggleRowsWithCheckbox(event) {
      if (this.selectAll !== null) {
        this.$emit('select-all-change', event);
      } else {
        const {
          originalEvent,
          checked
        } = event;
        let _selection = [];

        if (checked) {
          _selection = this.frozenValue ? [...this.frozenValue, ...this.processedData] : this.processedData;
          this.$emit('row-select-all', {
            originalEvent,
            data: _selection
          });
        } else {
          this.$emit('row-unselect-all', {
            originalEvent
          });
        }

        this.$emit('update:selection', _selection);
      }
    },

    isSingleSelectionMode() {
      return this.selectionMode === 'single';
    },

    isMultipleSelectionMode() {
      return this.selectionMode === 'multiple';
    },

    isSelected(rowData) {
      if (rowData && this.selection) {
        if (this.dataKey) {
          return this.d_selectionKeys ? this.d_selectionKeys[ObjectUtils.resolveFieldData(rowData, this.dataKey)] !== undefined : false;
        } else {
          if (this.selection instanceof Array) return this.findIndexInSelection(rowData) > -1;else return this.equals(rowData, this.selection);
        }
      }

      return false;
    },

    findIndexInSelection(rowData) {
      return this.findIndex(rowData, this.selection);
    },

    findIndex(rowData, collection) {
      let index = -1;

      if (collection && collection.length) {
        for (let i = 0; i < collection.length; i++) {
          if (this.equals(rowData, collection[i])) {
            index = i;
            break;
          }
        }
      }

      return index;
    },

    updateSelectionKeys(selection) {
      this.d_selectionKeys = {};

      if (Array.isArray(selection)) {
        for (let data of selection) {
          this.d_selectionKeys[String(ObjectUtils.resolveFieldData(data, this.dataKey))] = 1;
        }
      } else {
        this.d_selectionKeys[String(ObjectUtils.resolveFieldData(selection, this.dataKey))] = 1;
      }
    },

    updateExpandedRowKeys(expandedRows) {
      if (expandedRows && expandedRows.length) {
        this.d_expandedRowKeys = {};

        for (let data of expandedRows) {
          this.d_expandedRowKeys[String(ObjectUtils.resolveFieldData(data, this.dataKey))] = 1;
        }
      } else {
        this.d_expandedRowKeys = null;
      }
    },

    updateEditingRowKeys(editingRows) {
      if (editingRows && editingRows.length) {
        this.d_editingRowKeys = {};

        for (let data of editingRows) {
          this.d_editingRowKeys[String(ObjectUtils.resolveFieldData(data, this.dataKey))] = 1;
        }
      } else {
        this.d_editingRowKeys = null;
      }
    },

    equals(data1, data2) {
      return this.compareSelectionBy === 'equals' ? data1 === data2 : ObjectUtils.equals(data1, data2, this.dataKey);
    },

    selectRange(event) {
      let rangeStart, rangeEnd;

      if (this.rangeRowIndex > this.anchorRowIndex) {
        rangeStart = this.anchorRowIndex;
        rangeEnd = this.rangeRowIndex;
      } else if (this.rangeRowIndex < this.anchorRowIndex) {
        rangeStart = this.rangeRowIndex;
        rangeEnd = this.anchorRowIndex;
      } else {
        rangeStart = this.rangeRowIndex;
        rangeEnd = this.rangeRowIndex;
      }

      if (this.lazy && this.paginator) {
        rangeStart -= this.first;
        rangeEnd -= this.first;
      }

      const value = this.processedData;
      let _selection = [];

      for (let i = rangeStart; i <= rangeEnd; i++) {
        let rangeRowData = value[i];

        _selection.push(rangeRowData);

        this.$emit('row-select', {
          originalEvent: event,
          data: rangeRowData,
          type: 'row'
        });
      }

      this.$emit('update:selection', _selection);
    },

    exportCSV(options, data) {
      let csv = '\ufeff';

      if (!data) {
        data = this.processedData;
        if (options && options.selectionOnly) data = this.selection || [];else if (this.frozenValue) data = data ? [...this.frozenValue, ...data] : this.frozenValue;
      } //headers


      let headerInitiated = false;

      for (let i = 0; i < this.columns.length; i++) {
        let column = this.columns[i];

        if (this.columnProp(column, 'exportable') !== false && this.columnProp(column, 'field')) {
          if (headerInitiated) csv += this.csvSeparator;else headerInitiated = true;
          csv += '"' + (this.columnProp(column, 'exportHeader') || this.columnProp(column, 'header') || this.columnProp(column, 'field')) + '"';
        }
      } //body


      if (data) {
        data.forEach(record => {
          csv += '\n';
          let rowInitiated = false;

          for (let i = 0; i < this.columns.length; i++) {
            let column = this.columns[i];

            if (this.columnProp(column, 'exportable') !== false && this.columnProp(column, 'field')) {
              if (rowInitiated) csv += this.csvSeparator;else rowInitiated = true;
              let cellData = ObjectUtils.resolveFieldData(record, this.columnProp(column, 'field'));

              if (cellData != null) {
                if (this.exportFunction) {
                  cellData = this.exportFunction({
                    data: cellData,
                    field: this.columnProp(column, 'field')
                  });
                } else cellData = String(cellData).replace(/"/g, '""');
              } else cellData = '';

              csv += '"' + cellData + '"';
            }
          }
        });
      } //footers


      let footerInitiated = false;

      for (let i = 0; i < this.columns.length; i++) {
        let column = this.columns[i];
        if (i === 0) csv += '\n';

        if (this.columnProp(column, 'exportable') !== false && this.columnProp(column, 'field')) {
          if (footerInitiated) csv += this.csvSeparator;else footerInitiated = true;
          csv += '"' + (this.columnProp(column, 'exportFooter') || this.columnProp(column, 'footer') || this.columnProp(column, 'field')) + '"';
        }
      }

      DomHandler.exportCSV(csv, this.exportFilename);
    },

    resetPage() {
      this.d_first = 0;
      this.$emit('update:first', this.d_first);
    },

    onColumnResizeStart(event) {
      let containerLeft = DomHandler.getOffset(this.$el).left;
      this.resizeColumnElement = event.target.parentElement;
      this.columnResizing = true;
      this.lastResizeHelperX = event.pageX - containerLeft + this.$el.scrollLeft;
      this.bindColumnResizeEvents();
    },

    onColumnResize(event) {
      let containerLeft = DomHandler.getOffset(this.$el).left;
      DomHandler.addClass(this.$el, 'p-unselectable-text');
      this.$refs.resizeHelper.style.height = this.$el.offsetHeight + 'px';
      this.$refs.resizeHelper.style.top = 0 + 'px';
      this.$refs.resizeHelper.style.left = event.pageX - containerLeft + this.$el.scrollLeft + 'px';
      this.$refs.resizeHelper.style.display = 'block';
    },

    onColumnResizeEnd() {
      let delta = this.$refs.resizeHelper.offsetLeft - this.lastResizeHelperX;
      let columnWidth = this.resizeColumnElement.offsetWidth;
      let newColumnWidth = columnWidth + delta;
      let minWidth = this.resizeColumnElement.style.minWidth || 15;

      if (columnWidth + delta > parseInt(minWidth, 10)) {
        if (this.columnResizeMode === 'fit') {
          let nextColumn = this.resizeColumnElement.nextElementSibling;
          let nextColumnWidth = nextColumn.offsetWidth - delta;

          if (newColumnWidth > 15 && nextColumnWidth > 15) {
            this.resizeTableCells(newColumnWidth, nextColumnWidth);
          }
        } else if (this.columnResizeMode === 'expand') {
          const tableWidth = this.$refs.table.offsetWidth + delta + 'px';

          const updateTableWidth = el => {
            !!el && (el.style.width = el.style.minWidth = tableWidth);
          };

          updateTableWidth(this.$refs.table);

          if (!this.virtualScrollerDisabled) {
            const body = this.$refs.bodyRef && this.$refs.bodyRef.$el;
            const frozenBody = this.$refs.frozenBodyRef && this.$refs.frozenBodyRef.$el;
            updateTableWidth(body);
            updateTableWidth(frozenBody);
          }

          this.resizeTableCells(newColumnWidth);
        }

        this.$emit('column-resize-end', {
          element: this.resizeColumnElement,
          delta: delta
        });
      }

      this.$refs.resizeHelper.style.display = 'none';
      this.resizeColumn = null;
      DomHandler.removeClass(this.$el, 'p-unselectable-text');
      this.unbindColumnResizeEvents();

      if (this.isStateful()) {
        this.saveState();
      }
    },

    resizeTableCells(newColumnWidth, nextColumnWidth) {
      let colIndex = DomHandler.index(this.resizeColumnElement);
      let widths = [];
      let headers = DomHandler.find(this.$refs.table, '.p-datatable-thead > tr > th');
      headers.forEach(header => widths.push(DomHandler.getOuterWidth(header)));
      this.destroyStyleElement();
      this.createStyleElement();
      let innerHTML = '';
      widths.forEach((width, index) => {
        let colWidth = index === colIndex ? newColumnWidth : nextColumnWidth && index === colIndex + 1 ? nextColumnWidth : width;
        let style = this.scrollable ? `flex: 1 1 ${colWidth}px !important` : `width: ${colWidth}px !important`;
        innerHTML += `
                    .p-datatable[${this.attributeSelector}] .p-datatable-thead > tr > th:nth-child(${index + 1}),
                    .p-datatable[${this.attributeSelector}] .p-datatable-tbody > tr > td:nth-child(${index + 1}),
                    .p-datatable[${this.attributeSelector}] .p-datatable-tfoot > tr > td:nth-child(${index + 1}) {
                        ${style}
                    }
                `;
      });
      this.styleElement.innerHTML = innerHTML;
    },

    bindColumnResizeEvents() {
      if (!this.documentColumnResizeListener) {
        this.documentColumnResizeListener = document.addEventListener('mousemove', () => {
          if (this.columnResizing) {
            this.onColumnResize(event);
          }
        });
      }

      if (!this.documentColumnResizeEndListener) {
        this.documentColumnResizeEndListener = document.addEventListener('mouseup', () => {
          if (this.columnResizing) {
            this.columnResizing = false;
            this.onColumnResizeEnd();
          }
        });
      }
    },

    unbindColumnResizeEvents() {
      if (this.documentColumnResizeListener) {
        document.removeEventListener('document', this.documentColumnResizeListener);
        this.documentColumnResizeListener = null;
      }

      if (this.documentColumnResizeEndListener) {
        document.removeEventListener('document', this.documentColumnResizeEndListener);
        this.documentColumnResizeEndListener = null;
      }
    },

    onColumnHeaderMouseDown(e) {
      const event = e.originalEvent;
      const column = e.column;

      if (this.reorderableColumns && this.columnProp(column, 'reorderableColumn') !== false) {
        if (event.target.nodeName === 'INPUT' || event.target.nodeName === 'TEXTAREA' || DomHandler.hasClass(event.target, 'p-column-resizer')) event.currentTarget.draggable = false;else event.currentTarget.draggable = true;
      }
    },

    onColumnHeaderDragStart(event) {
      if (this.columnResizing) {
        event.preventDefault();
        return;
      }

      this.colReorderIconWidth = DomHandler.getHiddenElementOuterWidth(this.$refs.reorderIndicatorUp);
      this.colReorderIconHeight = DomHandler.getHiddenElementOuterHeight(this.$refs.reorderIndicatorUp);
      this.draggedColumn = this.findParentHeader(event.target);
      event.dataTransfer.setData('text', 'b'); // Firefox requires this to make dragging possible
    },

    onColumnHeaderDragOver(event) {
      let dropHeader = this.findParentHeader(event.target);

      if (this.reorderableColumns && this.draggedColumn && dropHeader) {
        event.preventDefault();
        let containerOffset = DomHandler.getOffset(this.$el);
        let dropHeaderOffset = DomHandler.getOffset(dropHeader);

        if (this.draggedColumn !== dropHeader) {
          let targetLeft = dropHeaderOffset.left - containerOffset.left;
          let columnCenter = dropHeaderOffset.left + dropHeader.offsetWidth / 2;
          this.$refs.reorderIndicatorUp.style.top = dropHeaderOffset.top - containerOffset.top - (this.colReorderIconHeight - 1) + 'px';
          this.$refs.reorderIndicatorDown.style.top = dropHeaderOffset.top - containerOffset.top + dropHeader.offsetHeight + 'px';

          if (event.pageX > columnCenter) {
            this.$refs.reorderIndicatorUp.style.left = targetLeft + dropHeader.offsetWidth - Math.ceil(this.colReorderIconWidth / 2) + 'px';
            this.$refs.reorderIndicatorDown.style.left = targetLeft + dropHeader.offsetWidth - Math.ceil(this.colReorderIconWidth / 2) + 'px';
            this.dropPosition = 1;
          } else {
            this.$refs.reorderIndicatorUp.style.left = targetLeft - Math.ceil(this.colReorderIconWidth / 2) + 'px';
            this.$refs.reorderIndicatorDown.style.left = targetLeft - Math.ceil(this.colReorderIconWidth / 2) + 'px';
            this.dropPosition = -1;
          }

          this.$refs.reorderIndicatorUp.style.display = 'block';
          this.$refs.reorderIndicatorDown.style.display = 'block';
        }
      }
    },

    onColumnHeaderDragLeave(event) {
      if (this.reorderableColumns && this.draggedColumn) {
        event.preventDefault();
        this.$refs.reorderIndicatorUp.style.display = 'none';
        this.$refs.reorderIndicatorDown.style.display = 'none';
      }
    },

    onColumnHeaderDrop(event) {
      event.preventDefault();

      if (this.draggedColumn) {
        let dragIndex = DomHandler.index(this.draggedColumn);
        let dropIndex = DomHandler.index(this.findParentHeader(event.target));
        let allowDrop = dragIndex !== dropIndex;

        if (allowDrop && (dropIndex - dragIndex === 1 && this.dropPosition === -1 || dropIndex - dragIndex === -1 && this.dropPosition === 1)) {
          allowDrop = false;
        }

        if (allowDrop) {
          ObjectUtils.reorderArray(this.columns, dragIndex, dropIndex);
          this.updateReorderableColumns();
          this.$emit('column-reorder', {
            originalEvent: event,
            dragIndex: dragIndex,
            dropIndex: dropIndex
          });
        }

        this.$refs.reorderIndicatorUp.style.display = 'none';
        this.$refs.reorderIndicatorDown.style.display = 'none';
        this.draggedColumn.draggable = false;
        this.draggedColumn = null;
        this.dropPosition = null;
      }
    },

    findParentHeader(element) {
      if (element.nodeName === 'TH') {
        return element;
      } else {
        let parent = element.parentElement;

        while (parent.nodeName !== 'TH') {
          parent = parent.parentElement;
          if (!parent) break;
        }

        return parent;
      }
    },

    findColumnByKey(columns, key) {
      if (columns && columns.length) {
        for (let i = 0; i < columns.length; i++) {
          let column = columns[i];

          if (this.columnProp(column, 'columnKey') === key || this.columnProp(column, 'field') === key) {
            return column;
          }
        }
      }

      return null;
    },

    onRowMouseDown(event) {
      if (DomHandler.hasClass(event.target, 'p-datatable-reorderablerow-handle')) event.currentTarget.draggable = true;else event.currentTarget.draggable = false;
    },

    onRowDragStart(e) {
      const event = e.originalEvent;
      const index = e.index;
      this.rowDragging = true;
      this.draggedRowIndex = index;
      event.dataTransfer.setData('text', 'b'); // For firefox
    },

    onRowDragOver(e) {
      const event = e.originalEvent;
      const index = e.index;

      if (this.rowDragging && this.draggedRowIndex !== index) {
        let rowElement = event.currentTarget;
        let rowY = DomHandler.getOffset(rowElement).top + DomHandler.getWindowScrollTop();
        let pageY = event.pageY;
        let rowMidY = rowY + DomHandler.getOuterHeight(rowElement) / 2;
        let prevRowElement = rowElement.previousElementSibling;

        if (pageY < rowMidY) {
          DomHandler.removeClass(rowElement, 'p-datatable-dragpoint-bottom');
          this.droppedRowIndex = index;
          if (prevRowElement) DomHandler.addClass(prevRowElement, 'p-datatable-dragpoint-bottom');else DomHandler.addClass(rowElement, 'p-datatable-dragpoint-top');
        } else {
          if (prevRowElement) DomHandler.removeClass(prevRowElement, 'p-datatable-dragpoint-bottom');else DomHandler.addClass(rowElement, 'p-datatable-dragpoint-top');
          this.droppedRowIndex = index + 1;
          DomHandler.addClass(rowElement, 'p-datatable-dragpoint-bottom');
        }

        event.preventDefault();
      }
    },

    onRowDragLeave(event) {
      let rowElement = event.currentTarget;
      let prevRowElement = rowElement.previousElementSibling;

      if (prevRowElement) {
        DomHandler.removeClass(prevRowElement, 'p-datatable-dragpoint-bottom');
      }

      DomHandler.removeClass(rowElement, 'p-datatable-dragpoint-bottom');
      DomHandler.removeClass(rowElement, 'p-datatable-dragpoint-top');
    },

    onRowDragEnd(event) {
      this.rowDragging = false;
      this.draggedRowIndex = null;
      this.droppedRowIndex = null;
      event.currentTarget.draggable = false;
    },

    onRowDrop(event) {
      if (this.droppedRowIndex != null) {
        let dropIndex = this.draggedRowIndex > this.droppedRowIndex ? this.droppedRowIndex : this.droppedRowIndex === 0 ? 0 : this.droppedRowIndex - 1;
        let processedData = [...this.processedData];
        ObjectUtils.reorderArray(processedData, this.draggedRowIndex, dropIndex);
        this.$emit('row-reorder', {
          originalEvent: event,
          dragIndex: this.draggedRowIndex,
          dropIndex: dropIndex,
          value: processedData
        });
      } //cleanup


      this.onRowDragLeave(event);
      this.onRowDragEnd(event);
      event.preventDefault();
    },

    toggleRow(event) {
      let rowData = event.data;
      let expanded;
      let expandedRowIndex;

      let _expandedRows = this.expandedRows ? [...this.expandedRows] : [];

      if (this.dataKey) {
        expanded = this.d_expandedRowKeys ? this.d_expandedRowKeys[ObjectUtils.resolveFieldData(rowData, this.dataKey)] !== undefined : false;
      } else {
        expandedRowIndex = this.findIndex(rowData, this.expandedRows);
        expanded = expandedRowIndex > -1;
      }

      if (expanded) {
        if (expandedRowIndex == null) {
          expandedRowIndex = this.findIndex(rowData, this.expandedRows);
        }

        _expandedRows.splice(expandedRowIndex, 1);

        this.$emit('update:expandedRows', _expandedRows);
        this.$emit('row-collapse', event);
      } else {
        _expandedRows.push(rowData);

        this.$emit('update:expandedRows', _expandedRows);
        this.$emit('row-expand', event);
      }
    },

    toggleRowGroup(e) {
      const event = e.originalEvent;
      const data = e.data;
      const groupFieldValue = ObjectUtils.resolveFieldData(data, this.groupRowsBy);

      let _expandedRowGroups = this.expandedRowGroups ? [...this.expandedRowGroups] : [];

      if (this.isRowGroupExpanded(data)) {
        _expandedRowGroups = _expandedRowGroups.filter(group => group !== groupFieldValue);
        this.$emit('update:expandedRowGroups', _expandedRowGroups);
        this.$emit('rowgroup-collapse', {
          originalEvent: event,
          data: groupFieldValue
        });
      } else {
        _expandedRowGroups.push(groupFieldValue);

        this.$emit('update:expandedRowGroups', _expandedRowGroups);
        this.$emit('rowgroup-expand', {
          originalEvent: event,
          data: groupFieldValue
        });
      }
    },

    isRowGroupExpanded(rowData) {
      if (this.expandableRowGroups && this.expandedRowGroups) {
        let groupFieldValue = ObjectUtils.resolveFieldData(rowData, this.groupRowsBy);
        return this.expandedRowGroups.indexOf(groupFieldValue) > -1;
      }

      return false;
    },

    isStateful() {
      return this.stateKey != null;
    },

    getStorage() {
      switch (this.stateStorage) {
        case 'local':
          return window.localStorage;

        case 'session':
          return window.sessionStorage;

        default:
          throw new Error(this.stateStorage + ' is not a valid value for the state storage, supported values are "local" and "session".');
      }
    },

    saveState() {
      const storage = this.getStorage();
      let state = {};

      if (this.paginator) {
        state.first = this.d_first;
        state.rows = this.d_rows;
      }

      if (this.d_sortField) {
        state.sortField = this.d_sortField;
        state.sortOrder = this.d_sortOrder;
      }

      if (this.d_multiSortMeta) {
        state.multiSortMeta = this.d_multiSortMeta;
      }

      if (this.hasFilters) {
        state.filters = this.filters;
      }

      if (this.resizableColumns) {
        this.saveColumnWidths(state);
      }

      if (this.reorderableColumns) {
        state.columnOrder = this.d_columnOrder;
      }

      if (this.expandedRows) {
        state.expandedRows = this.expandedRows;
        state.expandedRowKeys = this.d_expandedRowKeys;
      }

      if (this.expandedRowGroups) {
        state.expandedRowGroups = this.expandedRowGroups;
      }

      if (this.selection) {
        state.selection = this.selection;
        state.selectionKeys = this.d_selectionKeys;
      }

      if (Object.keys(state).length) {
        storage.setItem(this.stateKey, JSON.stringify(state));
      }

      this.$emit('state-save', state);
    },

    restoreState() {
      const storage = this.getStorage();
      const stateString = storage.getItem(this.stateKey);
      const dateFormat = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/;

      const reviver = function (key, value) {
        if (typeof value === 'string' && dateFormat.test(value)) {
          return new Date(value);
        }

        return value;
      };

      if (stateString) {
        let restoredState = JSON.parse(stateString, reviver);

        if (this.paginator) {
          this.d_first = restoredState.first;
          this.d_rows = restoredState.rows;
        }

        if (restoredState.sortField) {
          this.d_sortField = restoredState.sortField;
          this.d_sortOrder = restoredState.sortOrder;
        }

        if (restoredState.multiSortMeta) {
          this.d_multiSortMeta = restoredState.multiSortMeta;
        }

        if (restoredState.filters) {
          this.$emit('update:filters', restoredState.filters);
        }

        if (this.resizableColumns) {
          this.columnWidthsState = restoredState.columnWidths;
          this.tableWidthState = restoredState.tableWidth;
        }

        if (this.reorderableColumns) {
          this.d_columnOrder = restoredState.columnOrder;
        }

        if (restoredState.expandedRows) {
          this.d_expandedRowKeys = restoredState.expandedRowKeys;
          this.$emit('update:expandedRows', restoredState.expandedRows);
        }

        if (restoredState.expandedRowGroups) {
          this.$emit('update:expandedRowGroups', restoredState.expandedRowGroups);
        }

        if (restoredState.selection) {
          this.d_selectionKeys = restoredState.d_selectionKeys;
          this.$emit('update:selection', restoredState.selection);
        }

        this.$emit('state-restore', restoredState);
      }
    },

    saveColumnWidths(state) {
      let widths = [];
      let headers = DomHandler.find(this.$el, '.p-datatable-thead > tr > th');
      headers.forEach(header => widths.push(DomHandler.getOuterWidth(header)));
      state.columnWidths = widths.join(',');

      if (this.columnResizeMode === 'expand') {
        state.tableWidth = DomHandler.getOuterWidth(this.$refs.table) + 'px';
      }
    },

    restoreColumnWidths() {
      if (this.columnWidthsState) {
        let widths = this.columnWidthsState.split(',');

        if (this.columnResizeMode === 'expand' && this.tableWidthState) {
          this.$refs.table.style.width = this.tableWidthState;
          this.$refs.table.style.minWidth = this.tableWidthState;
          this.$el.style.width = this.tableWidthState;
        }

        if (ObjectUtils.isNotEmpty(widths)) {
          this.createStyleElement();
          let innerHTML = '';
          widths.forEach((width, index) => {
            let style = this.scrollable ? `flex: 1 1 ${width}px !important` : `width: ${width}px !important`;
            innerHTML += `
                            .p-datatable[${this.attributeSelector}] .p-datatable-thead > tr > th:nth-child(${index + 1}),
                            .p-datatable[${this.attributeSelector}] .p-datatable-tbody > tr > td:nth-child(${index + 1}),
                            .p-datatable[${this.attributeSelector}] .p-datatable-tfoot > tr > td:nth-child(${index + 1}) {
                                ${style}
                            }
                        `;
          });
          this.styleElement.innerHTML = innerHTML;
        }
      }
    },

    onCellEditInit(event) {
      this.$emit('cell-edit-init', event);
    },

    onCellEditComplete(event) {
      this.$emit('cell-edit-complete', event);
    },

    onCellEditCancel(event) {
      this.$emit('cell-edit-cancel', event);
    },

    onRowEditInit(event) {
      let _editingRows = this.editingRows ? [...this.editingRows] : [];

      _editingRows.push(event.data);

      this.$emit('update:editingRows', _editingRows);
      this.$emit('row-edit-init', event);
    },

    onRowEditSave(event) {
      let _editingRows = [...this.editingRows];

      _editingRows.splice(this.findIndex(event.data, _editingRows), 1);

      this.$emit('update:editingRows', _editingRows);
      this.$emit('row-edit-save', event);
    },

    onRowEditCancel(event) {
      let _editingRows = [...this.editingRows];

      _editingRows.splice(this.findIndex(event.data, _editingRows), 1);

      this.$emit('update:editingRows', _editingRows);
      this.$emit('row-edit-cancel', event);
    },

    onEditingMetaChange(event) {
      let {
        data,
        field,
        index,
        editing
      } = event;
      let editingMeta = { ...this.d_editingMeta
      };
      let meta = editingMeta[index];

      if (editing) {
        !meta && (meta = editingMeta[index] = {
          data: { ...data
          },
          fields: []
        });
        meta['fields'].push(field);
      } else if (meta) {
        const fields = meta['fields'].filter(f => f !== field);
        !fields.length ? delete editingMeta[index] : meta['fields'] = fields;
      }

      this.d_editingMeta = editingMeta;
    },

    clearEditingMetaData() {
      if (this.editMode) {
        this.d_editingMeta = {};
      }
    },

    createLazyLoadEvent(event) {
      return {
        originalEvent: event,
        first: this.d_first,
        rows: this.d_rows,
        sortField: this.d_sortField,
        sortOrder: this.d_sortOrder,
        multiSortMeta: this.d_multiSortMeta,
        filters: this.d_filters
      };
    },

    hasGlobalFilter() {
      return this.filters && Object.prototype.hasOwnProperty.call(this.filters, 'global');
    },

    getChildren() {
      return this.$slots.default ? this.$slots.default() : null;
    },

    onFilterChange(filters) {
      this.d_filters = filters;
    },

    onFilterApply() {
      this.d_first = 0;
      this.$emit('update:first', this.d_first);
      this.$emit('update:filters', this.d_filters);

      if (this.lazy) {
        this.$emit('filter', this.createLazyLoadEvent());
      }
    },

    cloneFilters() {
      let cloned = {};

      if (this.filters) {
        Object.entries(this.filters).forEach(([prop, value]) => {
          cloned[prop] = value.operator ? {
            operator: value.operator,
            constraints: value.constraints.map(constraint => {
              return { ...constraint
              };
            })
          } : { ...value
          };
        });
      }

      return cloned;
    },

    updateReorderableColumns() {
      let columnOrder = [];
      this.columns.forEach(col => columnOrder.push(this.columnProp(col, 'columnKey') || this.columnProp(col, 'field')));
      this.d_columnOrder = columnOrder;
    },

    createStyleElement() {
      this.styleElement = document.createElement('style');
      this.styleElement.type = 'text/css';
      document.head.appendChild(this.styleElement);
    },

    createResponsiveStyle() {
      if (!this.responsiveStyleElement) {
        this.responsiveStyleElement = document.createElement('style');
        this.responsiveStyleElement.type = 'text/css';
        document.head.appendChild(this.responsiveStyleElement);
        let innerHTML = `
@media screen and (max-width: ${this.breakpoint}) {
    .p-datatable[${this.attributeSelector}] .p-datatable-thead > tr > th,
    .p-datatable[${this.attributeSelector}] .p-datatable-tfoot > tr > td {
        display: none !important;
    }

    .p-datatable[${this.attributeSelector}] .p-datatable-tbody > tr > td {
        display: flex;
        width: 100% !important;
        align-items: center;
        justify-content: space-between;
    }

    .p-datatable[${this.attributeSelector}] .p-datatable-tbody > tr > td:not(:last-child) {
        border: 0 none;
    }

    .p-datatable[${this.attributeSelector}].p-datatable-gridlines .p-datatable-tbody > tr > td:last-child {
        border-top: 0;
        border-right: 0;
        border-left: 0;
    }

    .p-datatable[${this.attributeSelector}] .p-datatable-tbody > tr > td > .p-column-title {
        display: block;
    }
}
`;
        this.responsiveStyleElement.innerHTML = innerHTML;
      }
    },

    destroyResponsiveStyle() {
      if (this.responsiveStyleElement) {
        document.head.removeChild(this.responsiveStyleElement);
        this.responsiveStyleElement = null;
      }
    },

    destroyStyleElement() {
      if (this.styleElement) {
        document.head.removeChild(this.styleElement);
        this.styleElement = null;
      }
    },

    recursiveGetChildren(children, results) {
      if (!results) {
        results = [];
      }

      if (children && children.length) {
        children.forEach(child => {
          if (child.children instanceof Array) {
            results.concat(this.recursiveGetChildren(child.children, results));
          } else if (child.type.name == 'Column') {
            results.push(child);
          }
        });
      }

      return results;
    },

    dataToRender(data) {
      const _data = data || this.processedData;

      if (_data && this.paginator) {
        const first = this.lazy ? 0 : this.d_first;
        return _data.slice(first, first + this.d_rows);
      }

      return _data;
    },

    getVirtualScrollerRef() {
      return this.$refs.virtualScroller;
    }

  },
  computed: {
    containerClass() {
      return ['p-datatable p-component', {
        'p-datatable-hoverable-rows': this.rowHover || this.selectionMode,
        'p-datatable-auto-layout': this.autoLayout,
        'p-datatable-resizable': this.resizableColumns,
        'p-datatable-resizable-fit': this.resizableColumns && this.columnResizeMode === 'fit',
        'p-datatable-scrollable': this.scrollable,
        'p-datatable-scrollable-vertical': this.scrollable && this.scrollDirection === 'vertical',
        'p-datatable-scrollable-horizontal': this.scrollable && this.scrollDirection === 'horizontal',
        'p-datatable-scrollable-both': this.scrollable && this.scrollDirection === 'both',
        'p-datatable-flex-scrollable': this.scrollable && this.scrollHeight === 'flex',
        'p-datatable-responsive-stack': this.responsiveLayout === 'stack',
        'p-datatable-responsive-scroll': this.responsiveLayout === 'scroll',
        'p-datatable-striped': this.stripedRows,
        'p-datatable-gridlines': this.showGridlines,
        'p-datatable-grouped-header': this.headerColumnGroup != null,
        'p-datatable-grouped-footer': this.footerColumnGroup != null
      }];
    },

    columns() {
      let children = this.getChildren();

      if (!children) {
        return;
      }

      const cols = this.recursiveGetChildren(children, []);

      if (this.reorderableColumns && this.d_columnOrder) {
        let orderedColumns = [];

        for (let columnKey of this.d_columnOrder) {
          let column = this.findColumnByKey(cols, columnKey);

          if (column && !this.columnProp(column, 'hidden')) {
            orderedColumns.push(column);
          }
        }

        return [...orderedColumns, ...cols.filter(item => orderedColumns.indexOf(item) < 0)];
      }

      return cols;
    },

    headerColumnGroup() {
      const children = this.getChildren();

      if (children) {
        for (let child of children) {
          if (child.type.name === 'ColumnGroup' && this.columnProp(child, 'type') === 'header') {
            return child;
          }
        }
      }

      return null;
    },

    footerColumnGroup() {
      const children = this.getChildren();

      if (children) {
        for (let child of children) {
          if (child.type.name === 'ColumnGroup' && this.columnProp(child, 'type') === 'footer') {
            return child;
          }
        }
      }

      return null;
    },

    hasFilters() {
      return this.filters && Object.keys(this.filters).length > 0 && this.filters.constructor === Object;
    },

    processedData() {
      let data = this.value || [];

      if (!this.lazy) {
        if (data && data.length) {
          if (this.hasFilters) {
            data = this.filter(data);
          }

          if (this.sorted) {
            if (this.sortMode === 'single') data = this.sortSingle(data);else if (this.sortMode === 'multiple') data = this.sortMultiple(data);
          }
        }
      }

      return data;
    },

    totalRecordsLength() {
      if (this.lazy) {
        return this.totalRecords;
      } else {
        const data = this.processedData;
        return data ? data.length : 0;
      }
    },

    empty() {
      const data = this.processedData;
      return !data || data.length === 0;
    },

    paginatorTop() {
      return this.paginator && (this.paginatorPosition !== 'bottom' || this.paginatorPosition === 'both');
    },

    paginatorBottom() {
      return this.paginator && (this.paginatorPosition !== 'top' || this.paginatorPosition === 'both');
    },

    sorted() {
      return this.d_sortField || this.d_multiSortMeta && this.d_multiSortMeta.length > 0;
    },

    loadingIconClass() {
      return ['p-datatable-loading-icon pi-spin', this.loadingIcon];
    },

    allRowsSelected() {
      if (this.selectAll !== null) {
        return this.selectAll;
      } else {
        const val = this.frozenValue ? [...this.frozenValue, ...this.processedData] : this.processedData;
        return ObjectUtils.isNotEmpty(val) && this.selection && Array.isArray(this.selection) && val.every(v => this.selection.some(s => this.equals(s, v)));
      }
    },

    attributeSelector() {
      return UniqueComponentId();
    },

    groupRowSortField() {
      return this.sortMode === 'single' ? this.sortField : this.d_groupRowsSortMeta ? this.d_groupRowsSortMeta.field : null;
    },

    virtualScrollerDisabled() {
      return ObjectUtils.isEmpty(this.virtualScrollerOptions) || !this.scrollable;
    }

  },
  components: {
    DTPaginator: script$N,
    DTTableHeader: script$1$1,
    DTTableBody: script$7$1,
    DTTableFooter: script$5$1,
    DTVirtualScroller: script$1g
  }
};
const _hoisted_1$k = {
  key: 0,
  class: "p-datatable-loading-overlay p-component-overlay"
};
const _hoisted_2$h = {
  key: 1,
  class: "p-datatable-header"
};
const _hoisted_3$e = {
  key: 4,
  class: "p-datatable-footer"
};
const _hoisted_4$a = {
  ref: "resizeHelper",
  class: "p-column-resizer-helper",
  style: {
    "display": "none"
  }
};
const _hoisted_5$9 = {
  key: 5,
  ref: "reorderIndicatorUp",
  class: "pi pi-arrow-down p-datatable-reorder-indicator-up",
  style: {
    "position": "absolute",
    "display": "none"
  }
};
const _hoisted_6$8 = {
  key: 6,
  ref: "reorderIndicatorDown",
  class: "pi pi-arrow-up p-datatable-reorder-indicator-down",
  style: {
    "position": "absolute",
    "display": "none"
  }
};

function render$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DTPaginator = resolveComponent("DTPaginator");

  const _component_DTTableHeader = resolveComponent("DTTableHeader");

  const _component_DTTableBody = resolveComponent("DTTableBody");

  const _component_DTTableFooter = resolveComponent("DTTableFooter");

  const _component_DTVirtualScroller = resolveComponent("DTVirtualScroller");

  return openBlock(), createElementBlock("div", {
    class: normalizeClass($options.containerClass),
    "data-scrollselectors": ".p-datatable-wrapper"
  }, [renderSlot(_ctx.$slots, "default"), $props.loading ? (openBlock(), createElementBlock("div", _hoisted_1$k, [_ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", {
    key: 0
  }) : (openBlock(), createElementBlock("i", {
    key: 1,
    class: normalizeClass($options.loadingIconClass)
  }, null, 2))])) : createCommentVNode("", true), _ctx.$slots.header ? (openBlock(), createElementBlock("div", _hoisted_2$h, [renderSlot(_ctx.$slots, "header")])) : createCommentVNode("", true), $options.paginatorTop ? (openBlock(), createBlock(_component_DTPaginator, {
    key: 2,
    rows: $data.d_rows,
    first: $data.d_first,
    totalRecords: $options.totalRecordsLength,
    pageLinkSize: $props.pageLinkSize,
    template: $props.paginatorTemplate,
    rowsPerPageOptions: $props.rowsPerPageOptions,
    currentPageReportTemplate: $props.currentPageReportTemplate,
    class: "p-paginator-top",
    onPage: _cache[0] || (_cache[0] = $event => $options.onPage($event)),
    alwaysShow: $props.alwaysShowPaginator
  }, createSlots({
    _: 2
  }, [_ctx.$slots.paginatorstart ? {
    name: "start",
    fn: withCtx(() => [renderSlot(_ctx.$slots, "paginatorstart")]),
    key: "0"
  } : undefined, _ctx.$slots.paginatorend ? {
    name: "end",
    fn: withCtx(() => [renderSlot(_ctx.$slots, "paginatorend")]),
    key: "1"
  } : undefined]), 1032, ["rows", "first", "totalRecords", "pageLinkSize", "template", "rowsPerPageOptions", "currentPageReportTemplate", "alwaysShow"])) : createCommentVNode("", true), createElementVNode("div", {
    class: "p-datatable-wrapper",
    style: normalizeStyle({
      maxHeight: $options.virtualScrollerDisabled ? $props.scrollHeight : ''
    })
  }, [createVNode(_component_DTVirtualScroller, mergeProps({
    ref: "virtualScroller"
  }, $props.virtualScrollerOptions, {
    items: $options.processedData,
    columns: $options.columns,
    style: {
      height: $props.scrollHeight
    },
    disabled: $options.virtualScrollerDisabled,
    loaderDisabled: "",
    showSpacer: false
  }), {
    content: withCtx(slotProps => [createElementVNode("table", {
      ref: "table",
      role: "table",
      class: normalizeClass([$props.tableClass, 'p-datatable-table']),
      style: normalizeStyle([$props.tableStyle, slotProps.spacerStyle])
    }, [createVNode(_component_DTTableHeader, {
      columnGroup: $options.headerColumnGroup,
      columns: slotProps.columns,
      rowGroupMode: $props.rowGroupMode,
      groupRowsBy: $props.groupRowsBy,
      groupRowSortField: $options.groupRowSortField,
      reorderableColumns: $props.reorderableColumns,
      resizableColumns: $props.resizableColumns,
      allRowsSelected: $options.allRowsSelected,
      empty: $options.empty,
      sortMode: $props.sortMode,
      sortField: $data.d_sortField,
      sortOrder: $data.d_sortOrder,
      multiSortMeta: $data.d_multiSortMeta,
      filters: $data.d_filters,
      filtersStore: $props.filters,
      filterDisplay: $props.filterDisplay,
      onColumnClick: _cache[1] || (_cache[1] = $event => $options.onColumnHeaderClick($event)),
      onColumnMousedown: _cache[2] || (_cache[2] = $event => $options.onColumnHeaderMouseDown($event)),
      onFilterChange: $options.onFilterChange,
      onFilterApply: $options.onFilterApply,
      onColumnDragstart: _cache[3] || (_cache[3] = $event => $options.onColumnHeaderDragStart($event)),
      onColumnDragover: _cache[4] || (_cache[4] = $event => $options.onColumnHeaderDragOver($event)),
      onColumnDragleave: _cache[5] || (_cache[5] = $event => $options.onColumnHeaderDragLeave($event)),
      onColumnDrop: _cache[6] || (_cache[6] = $event => $options.onColumnHeaderDrop($event)),
      onColumnResizestart: _cache[7] || (_cache[7] = $event => $options.onColumnResizeStart($event)),
      onCheckboxChange: _cache[8] || (_cache[8] = $event => $options.toggleRowsWithCheckbox($event))
    }, null, 8, ["columnGroup", "columns", "rowGroupMode", "groupRowsBy", "groupRowSortField", "reorderableColumns", "resizableColumns", "allRowsSelected", "empty", "sortMode", "sortField", "sortOrder", "multiSortMeta", "filters", "filtersStore", "filterDisplay", "onFilterChange", "onFilterApply"]), $props.frozenValue ? (openBlock(), createBlock(_component_DTTableBody, {
      key: 0,
      ref: "frozenBodyRef",
      value: $props.frozenValue,
      frozenRow: true,
      class: "p-datatable-frozen-tbody",
      columns: slotProps.columns,
      dataKey: $props.dataKey,
      selection: $props.selection,
      selectionKeys: $data.d_selectionKeys,
      selectionMode: $props.selectionMode,
      contextMenu: $props.contextMenu,
      contextMenuSelection: $props.contextMenuSelection,
      rowGroupMode: $props.rowGroupMode,
      groupRowsBy: $props.groupRowsBy,
      expandableRowGroups: $props.expandableRowGroups,
      rowClass: $props.rowClass,
      rowStyle: $props.rowStyle,
      editMode: $props.editMode,
      compareSelectionBy: $props.compareSelectionBy,
      scrollable: $props.scrollable,
      expandedRowIcon: $props.expandedRowIcon,
      collapsedRowIcon: $props.collapsedRowIcon,
      expandedRows: $props.expandedRows,
      expandedRowKeys: $data.d_expandedRowKeys,
      expandedRowGroups: $props.expandedRowGroups,
      editingRows: $props.editingRows,
      editingRowKeys: $data.d_editingRowKeys,
      templates: _ctx.$slots,
      responsiveLayout: $props.responsiveLayout,
      onRowgroupToggle: $options.toggleRowGroup,
      onRowClick: _cache[9] || (_cache[9] = $event => $options.onRowClick($event)),
      onRowDblclick: _cache[10] || (_cache[10] = $event => $options.onRowDblClick($event)),
      onRowRightclick: _cache[11] || (_cache[11] = $event => $options.onRowRightClick($event)),
      onRowTouchend: $options.onRowTouchEnd,
      onRowKeydown: $options.onRowKeyDown,
      onRowMousedown: $options.onRowMouseDown,
      onRowDragstart: _cache[12] || (_cache[12] = $event => $options.onRowDragStart($event)),
      onRowDragover: _cache[13] || (_cache[13] = $event => $options.onRowDragOver($event)),
      onRowDragleave: _cache[14] || (_cache[14] = $event => $options.onRowDragLeave($event)),
      onRowDragend: _cache[15] || (_cache[15] = $event => $options.onRowDragEnd($event)),
      onRowDrop: _cache[16] || (_cache[16] = $event => $options.onRowDrop($event)),
      onRowToggle: _cache[17] || (_cache[17] = $event => $options.toggleRow($event)),
      onRadioChange: _cache[18] || (_cache[18] = $event => $options.toggleRowWithRadio($event)),
      onCheckboxChange: _cache[19] || (_cache[19] = $event => $options.toggleRowWithCheckbox($event)),
      onCellEditInit: _cache[20] || (_cache[20] = $event => $options.onCellEditInit($event)),
      onCellEditComplete: _cache[21] || (_cache[21] = $event => $options.onCellEditComplete($event)),
      onCellEditCancel: _cache[22] || (_cache[22] = $event => $options.onCellEditCancel($event)),
      onRowEditInit: _cache[23] || (_cache[23] = $event => $options.onRowEditInit($event)),
      onRowEditSave: _cache[24] || (_cache[24] = $event => $options.onRowEditSave($event)),
      onRowEditCancel: _cache[25] || (_cache[25] = $event => $options.onRowEditCancel($event)),
      editingMeta: $data.d_editingMeta,
      onEditingMetaChange: $options.onEditingMetaChange,
      isVirtualScrollerDisabled: true
    }, null, 8, ["value", "columns", "dataKey", "selection", "selectionKeys", "selectionMode", "contextMenu", "contextMenuSelection", "rowGroupMode", "groupRowsBy", "expandableRowGroups", "rowClass", "rowStyle", "editMode", "compareSelectionBy", "scrollable", "expandedRowIcon", "collapsedRowIcon", "expandedRows", "expandedRowKeys", "expandedRowGroups", "editingRows", "editingRowKeys", "templates", "responsiveLayout", "onRowgroupToggle", "onRowTouchend", "onRowKeydown", "onRowMousedown", "editingMeta", "onEditingMetaChange"])) : createCommentVNode("", true), createVNode(_component_DTTableBody, {
      ref: "bodyRef",
      value: $options.dataToRender(slotProps.rows),
      class: normalizeClass(slotProps.styleClass),
      columns: slotProps.columns,
      empty: $options.empty,
      dataKey: $props.dataKey,
      selection: $props.selection,
      selectionKeys: $data.d_selectionKeys,
      selectionMode: $props.selectionMode,
      contextMenu: $props.contextMenu,
      contextMenuSelection: $props.contextMenuSelection,
      rowGroupMode: $props.rowGroupMode,
      groupRowsBy: $props.groupRowsBy,
      expandableRowGroups: $props.expandableRowGroups,
      rowClass: $props.rowClass,
      rowStyle: $props.rowStyle,
      editMode: $props.editMode,
      compareSelectionBy: $props.compareSelectionBy,
      scrollable: $props.scrollable,
      expandedRowIcon: $props.expandedRowIcon,
      collapsedRowIcon: $props.collapsedRowIcon,
      expandedRows: $props.expandedRows,
      expandedRowKeys: $data.d_expandedRowKeys,
      expandedRowGroups: $props.expandedRowGroups,
      editingRows: $props.editingRows,
      editingRowKeys: $data.d_editingRowKeys,
      templates: _ctx.$slots,
      responsiveLayout: $props.responsiveLayout,
      onRowgroupToggle: $options.toggleRowGroup,
      onRowClick: _cache[26] || (_cache[26] = $event => $options.onRowClick($event)),
      onRowDblclick: _cache[27] || (_cache[27] = $event => $options.onRowDblClick($event)),
      onRowRightclick: _cache[28] || (_cache[28] = $event => $options.onRowRightClick($event)),
      onRowTouchend: $options.onRowTouchEnd,
      onRowKeydown: $options.onRowKeyDown,
      onRowMousedown: $options.onRowMouseDown,
      onRowDragstart: _cache[29] || (_cache[29] = $event => $options.onRowDragStart($event)),
      onRowDragover: _cache[30] || (_cache[30] = $event => $options.onRowDragOver($event)),
      onRowDragleave: _cache[31] || (_cache[31] = $event => $options.onRowDragLeave($event)),
      onRowDragend: _cache[32] || (_cache[32] = $event => $options.onRowDragEnd($event)),
      onRowDrop: _cache[33] || (_cache[33] = $event => $options.onRowDrop($event)),
      onRowToggle: _cache[34] || (_cache[34] = $event => $options.toggleRow($event)),
      onRadioChange: _cache[35] || (_cache[35] = $event => $options.toggleRowWithRadio($event)),
      onCheckboxChange: _cache[36] || (_cache[36] = $event => $options.toggleRowWithCheckbox($event)),
      onCellEditInit: _cache[37] || (_cache[37] = $event => $options.onCellEditInit($event)),
      onCellEditComplete: _cache[38] || (_cache[38] = $event => $options.onCellEditComplete($event)),
      onCellEditCancel: _cache[39] || (_cache[39] = $event => $options.onCellEditCancel($event)),
      onRowEditInit: _cache[40] || (_cache[40] = $event => $options.onRowEditInit($event)),
      onRowEditSave: _cache[41] || (_cache[41] = $event => $options.onRowEditSave($event)),
      onRowEditCancel: _cache[42] || (_cache[42] = $event => $options.onRowEditCancel($event)),
      editingMeta: $data.d_editingMeta,
      onEditingMetaChange: $options.onEditingMetaChange,
      virtualScrollerContentProps: slotProps,
      isVirtualScrollerDisabled: $options.virtualScrollerDisabled
    }, null, 8, ["value", "class", "columns", "empty", "dataKey", "selection", "selectionKeys", "selectionMode", "contextMenu", "contextMenuSelection", "rowGroupMode", "groupRowsBy", "expandableRowGroups", "rowClass", "rowStyle", "editMode", "compareSelectionBy", "scrollable", "expandedRowIcon", "collapsedRowIcon", "expandedRows", "expandedRowKeys", "expandedRowGroups", "editingRows", "editingRowKeys", "templates", "responsiveLayout", "onRowgroupToggle", "onRowTouchend", "onRowKeydown", "onRowMousedown", "editingMeta", "onEditingMetaChange", "virtualScrollerContentProps", "isVirtualScrollerDisabled"]), createVNode(_component_DTTableFooter, {
      columnGroup: $options.footerColumnGroup,
      columns: slotProps.columns
    }, null, 8, ["columnGroup", "columns"])], 6)]),
    _: 1
  }, 16, ["items", "columns", "style", "disabled"])], 4), $options.paginatorBottom ? (openBlock(), createBlock(_component_DTPaginator, {
    key: 3,
    rows: $data.d_rows,
    first: $data.d_first,
    totalRecords: $options.totalRecordsLength,
    pageLinkSize: $props.pageLinkSize,
    template: $props.paginatorTemplate,
    rowsPerPageOptions: $props.rowsPerPageOptions,
    currentPageReportTemplate: $props.currentPageReportTemplate,
    class: "p-paginator-bottom",
    onPage: _cache[43] || (_cache[43] = $event => $options.onPage($event)),
    alwaysShow: $props.alwaysShowPaginator
  }, createSlots({
    _: 2
  }, [_ctx.$slots.paginatorstart ? {
    name: "start",
    fn: withCtx(() => [renderSlot(_ctx.$slots, "paginatorstart")]),
    key: "0"
  } : undefined, _ctx.$slots.paginatorend ? {
    name: "end",
    fn: withCtx(() => [renderSlot(_ctx.$slots, "paginatorend")]),
    key: "1"
  } : undefined]), 1032, ["rows", "first", "totalRecords", "pageLinkSize", "template", "rowsPerPageOptions", "currentPageReportTemplate", "alwaysShow"])) : createCommentVNode("", true), _ctx.$slots.footer ? (openBlock(), createElementBlock("div", _hoisted_3$e, [renderSlot(_ctx.$slots, "footer")])) : createCommentVNode("", true), createElementVNode("div", _hoisted_4$a, null, 512), $props.reorderableColumns ? (openBlock(), createElementBlock("span", _hoisted_5$9, null, 512)) : createCommentVNode("", true), $props.reorderableColumns ? (openBlock(), createElementBlock("span", _hoisted_6$8, null, 512)) : createCommentVNode("", true)], 2);
}

function styleInject$8(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$d = "\n.p-datatable {\n    position: relative;\n}\n.p-datatable table {\n    border-collapse: collapse;\n    min-width: 100%;\n    table-layout: fixed;\n}\n.p-datatable .p-sortable-column {\n    cursor: pointer;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n}\n.p-datatable .p-sortable-column .p-column-title,\n.p-datatable .p-sortable-column .p-sortable-column-icon,\n.p-datatable .p-sortable-column .p-sortable-column-badge {\n    vertical-align: middle;\n}\n.p-datatable .p-sortable-column .p-sortable-column-badge {\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n}\n.p-datatable-responsive-scroll > .p-datatable-wrapper {\n    overflow-x: auto;\n}\n.p-datatable-responsive-scroll > .p-datatable-wrapper > table,\n.p-datatable-auto-layout > .p-datatable-wrapper > table {\n    table-layout: auto;\n}\n.p-datatable-hoverable-rows .p-selectable-row {\n    cursor: pointer;\n}\n\n/* Scrollable */\n.p-datatable-scrollable .p-datatable-wrapper {\n    position: relative;\n    overflow: auto;\n}\n.p-datatable-scrollable .p-datatable-thead,\n.p-datatable-scrollable .p-datatable-tbody,\n.p-datatable-scrollable .p-datatable-tfoot {\n    display: block;\n}\n.p-datatable-scrollable .p-datatable-thead > tr,\n.p-datatable-scrollable .p-datatable-tbody > tr,\n.p-datatable-scrollable .p-datatable-tfoot > tr {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-wrap: nowrap;\n        flex-wrap: nowrap;\n    width: 100%;\n}\n.p-datatable-scrollable .p-datatable-thead > tr > th,\n.p-datatable-scrollable .p-datatable-tbody > tr > td,\n.p-datatable-scrollable .p-datatable-tfoot > tr > td {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-flex: 1;\n        -ms-flex: 1 1 0px;\n            flex: 1 1 0;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n.p-datatable-scrollable .p-datatable-thead {\n    position: sticky;\n    top: 0;\n    z-index: 1;\n}\n.p-datatable-scrollable .p-datatable-frozen-tbody {\n    position: sticky;\n    z-index: 1;\n}\n.p-datatable-scrollable .p-datatable-tfoot {\n    position: sticky;\n    bottom: 0;\n    z-index: 1;\n}\n.p-datatable-scrollable .p-frozen-column {\n    position: sticky;\n    background: inherit;\n}\n.p-datatable-scrollable th.p-frozen-column {\n    z-index: 1;\n}\n.p-datatable-scrollable-both .p-datatable-thead > tr > th,\n.p-datatable-scrollable-both .p-datatable-tbody > tr > td,\n.p-datatable-scrollable-both .p-datatable-tfoot > tr > td,\n.p-datatable-scrollable-horizontal .p-datatable-thead > tr > th .p-datatable-scrollable-horizontal .p-datatable-tbody > tr > td,\n.p-datatable-scrollable-horizontal .p-datatable-tfoot > tr > td {\n    -webkit-box-flex: 1;\n        -ms-flex: 1 0 auto;\n            flex: 1 0 auto;\n}\n.p-datatable-flex-scrollable {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n        -ms-flex-direction: column;\n            flex-direction: column;\n    height: 100%;\n}\n.p-datatable-flex-scrollable .p-datatable-wrapper {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n        -ms-flex-direction: column;\n            flex-direction: column;\n    -webkit-box-flex: 1;\n        -ms-flex: 1;\n            flex: 1;\n    height: 100%;\n}\n.p-datatable-scrollable .p-rowgroup-header {\n    position: sticky;\n    z-index: 1;\n}\n.p-datatable-scrollable.p-datatable-grouped-header .p-datatable-thead,\n.p-datatable-scrollable.p-datatable-grouped-footer .p-datatable-tfoot {\n    display: table;\n    border-collapse: collapse;\n    width: 100%;\n    table-layout: fixed;\n}\n.p-datatable-scrollable.p-datatable-grouped-header .p-datatable-thead > tr,\n.p-datatable-scrollable.p-datatable-grouped-footer .p-datatable-tfoot > tr {\n    display: table-row;\n}\n.p-datatable-scrollable.p-datatable-grouped-header .p-datatable-thead > tr > th,\n.p-datatable-scrollable.p-datatable-grouped-footer .p-datatable-tfoot > tr > td {\n    display: table-cell;\n}\n.p-datatable-scrollable .p-virtualscroller > .p-datatable-table {\n    display: inline-block; /* For Safari */\n}\n\n/* Resizable */\n.p-datatable-resizable > .p-datatable-wrapper {\n    overflow-x: auto;\n}\n.p-datatable-resizable .p-datatable-thead > tr > th,\n.p-datatable-resizable .p-datatable-tfoot > tr > td,\n.p-datatable-resizable .p-datatable-tbody > tr > td {\n    overflow: hidden;\n    white-space: nowrap;\n}\n.p-datatable-resizable .p-resizable-column:not(.p-frozen-column) {\n    background-clip: padding-box;\n    position: relative;\n}\n.p-datatable-resizable-fit .p-resizable-column:last-child .p-column-resizer {\n    display: none;\n}\n.p-datatable .p-column-resizer {\n    display: block;\n    position: absolute !important;\n    top: 0;\n    right: 0;\n    margin: 0;\n    width: 0.5rem;\n    height: 100%;\n    padding: 0px;\n    cursor: col-resize;\n    border: 1px solid transparent;\n}\n.p-datatable .p-column-header-content {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n.p-datatable .p-column-resizer-helper {\n    width: 1px;\n    position: absolute;\n    z-index: 10;\n    display: none;\n}\n.p-datatable .p-row-editor-init,\n.p-datatable .p-row-editor-save,\n.p-datatable .p-row-editor-cancel {\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    overflow: hidden;\n    position: relative;\n}\n\n/* Expand */\n.p-datatable .p-row-toggler {\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    overflow: hidden;\n    position: relative;\n}\n\n/* Reorder */\n.p-datatable-reorder-indicator-up,\n.p-datatable-reorder-indicator-down {\n    position: absolute;\n    display: none;\n}\n.p-reorderable-column,\n.p-datatable-reorderablerow-handle {\n    cursor: move;\n}\n\n/* Loader */\n.p-datatable .p-datatable-loading-overlay {\n    position: absolute;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    z-index: 2;\n}\n\n/* Filter */\n.p-column-filter-row {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    width: 100%;\n}\n.p-column-filter-menu {\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    margin-left: auto;\n}\n.p-column-filter-row .p-column-filter-element {\n    -webkit-box-flex: 1;\n        -ms-flex: 1 1 auto;\n            flex: 1 1 auto;\n    width: 1%;\n}\n.p-column-filter-menu-button,\n.p-column-filter-clear-button {\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    cursor: pointer;\n    text-decoration: none;\n    overflow: hidden;\n    position: relative;\n}\n.p-column-filter-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.p-column-filter-row-items {\n    margin: 0;\n    padding: 0;\n    list-style: none;\n}\n.p-column-filter-row-item {\n    cursor: pointer;\n}\n.p-column-filter-add-button,\n.p-column-filter-remove-button {\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n}\n.p-column-filter-add-button .p-button-label,\n.p-column-filter-remove-button .p-button-label {\n    -webkit-box-flex: 0;\n        -ms-flex-positive: 0;\n            flex-grow: 0;\n}\n.p-column-filter-buttonbar {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: justify;\n        -ms-flex-pack: justify;\n            justify-content: space-between;\n}\n.p-column-filter-buttonbar .p-button:not(.p-button-icon-only) {\n    width: auto;\n}\n\n/* Responsive */\n.p-datatable .p-datatable-tbody > tr > td > .p-column-title {\n    display: none;\n}\n\n/* VirtualScroller */\n.p-datatable .p-virtualscroller-loading {\n    -webkit-transform: none !important;\n            transform: none !important;\n    min-height: 0;\n    position: sticky;\n    top: 0;\n    left: 0;\n}\n";
styleInject$8(css_248z$d);
script$M.render = render$c;

var script$L = {
  name: 'Column',
  props: {
    columnKey: {
      type: null,
      default: null
    },
    field: {
      type: [String, Function],
      default: null
    },
    sortField: {
      type: [String, Function],
      default: null
    },
    filterField: {
      type: [String, Function],
      default: null
    },
    dataType: {
      type: String,
      default: 'text'
    },
    sortable: {
      type: Boolean,
      default: false
    },
    header: {
      type: null,
      default: null
    },
    footer: {
      type: null,
      default: null
    },
    style: {
      type: null,
      default: null
    },
    class: {
      type: String,
      default: null
    },
    headerStyle: {
      type: null,
      default: null
    },
    headerClass: {
      type: String,
      default: null
    },
    bodyStyle: {
      type: null,
      default: null
    },
    bodyClass: {
      type: String,
      default: null
    },
    footerStyle: {
      type: null,
      default: null
    },
    footerClass: {
      type: String,
      default: null
    },
    showFilterMenu: {
      type: Boolean,
      default: true
    },
    showFilterOperator: {
      type: Boolean,
      default: true
    },
    showClearButton: {
      type: Boolean,
      default: true
    },
    showApplyButton: {
      type: Boolean,
      default: true
    },
    showFilterMatchModes: {
      type: Boolean,
      default: true
    },
    showAddButton: {
      type: Boolean,
      default: true
    },
    filterMatchModeOptions: {
      type: Array,
      default: null
    },
    maxConstraints: {
      type: Number,
      default: 2
    },
    excludeGlobalFilter: {
      type: Boolean,
      default: false
    },
    filterHeaderClass: {
      type: String,
      default: null
    },
    filterHeaderStyle: {
      type: null,
      default: null
    },
    filterMenuClass: {
      type: String,
      default: null
    },
    filterMenuStyle: {
      type: null,
      default: null
    },
    selectionMode: {
      type: String,
      default: null
    },
    expander: {
      type: Boolean,
      default: false
    },
    colspan: {
      type: Number,
      default: null
    },
    rowspan: {
      type: Number,
      default: null
    },
    rowReorder: {
      type: Boolean,
      default: false
    },
    rowReorderIcon: {
      type: String,
      default: 'pi pi-bars'
    },
    reorderableColumn: {
      type: Boolean,
      default: true
    },
    rowEditor: {
      type: Boolean,
      default: false
    },
    frozen: {
      type: Boolean,
      default: false
    },
    alignFrozen: {
      type: String,
      default: 'left'
    },
    exportable: {
      type: Boolean,
      default: true
    },
    exportHeader: {
      type: String,
      default: null
    },
    exportFooter: {
      type: String,
      default: null
    },
    filterMatchMode: {
      type: String,
      default: null
    },
    hidden: {
      type: Boolean,
      default: false
    }
  },

  render() {
    return null;
  }

};

var script$K = {
  props: {
    model : {
        type : Object,
        required : true
    },
    id : {
        type : Number,
        required : true
    }
},
  setup(__props) {

const props = __props;



const client = inject("client");
const data = ref([]);
client.get("/audit/" + props.model.name + "/" + props.id)
.then(response => {
    for(const obj of response) {
        if (obj.action == "POST") obj.action = "Created";
        else if (obj.action == "PUT") obj.action = "Updated";
        else if (obj.action == "DELETE") obj.action = "Deleted";
        //obj['--created'] = (!obj['--created']) ? obj['--created'] : obj['--created'].toLocaleDateString("en-UK");
    }
    data.value = response;
});




return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$M), { value: data.value }, {
    default: withCtx(() => [
      createVNode(unref(script$L), {
        field: "user-login-id/name",
        header: "User"
      }),
      createVNode(unref(script$L), {
        field: "action",
        header: "Type"
      }),
      createVNode(unref(script$L), {
        field: "log",
        header: "Values"
      }, {
        body: withCtx((slotProps) => [
          createElementVNode("ul", null, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(slotProps.data.log, (log, key) => {
              return (openBlock(), createElementBlock("li", null, toDisplayString$1(key) + ": " + toDisplayString$1(log), 1 /* TEXT */))
            }), 256 /* UNKEYED_FRAGMENT */))
          ])
        ]),
        _: 1 /* STABLE */
      }),
      createVNode(unref(script$L), {
        field: "--created",
        header: "Date"
      })
    ]),
    _: 1 /* STABLE */
  }, 8 /* PROPS */, ["value"]))
}
}

};

script$K.__file = "presstojam/src/components/effects/audit-effect.vue";

var script$J = {
  props: {
        model : Object,
        data : Object,
        long : false
    },
  setup(__props) {

const props = __props;

    

    function showAudit() {
        trigger(
            "dialog_open",    
            script$K, 
            {model : props.model, id : props.data['--id']}, 
            "Audit Log");
    }

    const label = (props.long) ? "Audit" : "";
    const classes = (props.long) ? "p-button-help" : "p-button-rounded p-button-success";


return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$1L), {
    icon: "pi pi-history",
    class: normalizeClass(["mr-2", unref(classes)]),
    label: unref(label),
    onClick: _cache[0] || (_cache[0] = $event => (showAudit()))
  }, null, 8 /* PROPS */, ["class", "label"]))
}
}

};

script$J.__file = "presstojam/src/components/actions/audit-action.vue";

class SingleData extends Data {
  constructor(model) {
    super(model);
    this._active_id = 0;
    this._model.limit = 1;
    this._model.order = {
      "--id": "ASC"
    };
    this._data.value = {};
  }

  get type() {
    return "single";
  }

  get active_id() {
    return this._active_id;
  }

  load() {
    if (!this._load_promise) {
      this._is_loading.value = true;
      this._load_promise = this._model.load();
    }

    this._load_promise.then(response => {
      this._is_loading.value = false;
      if (Array.isArray(response)) this._data.value = response.pop();else this._data.value = response;
      this._active_id = this._data.value['--id'];
    }).catch(e => {
      console.log(e);
      this._is_loading.value = false;
      throw e;
    });

    return this._load_promise;
  }

  reload() {
    this._active.value = {};
    this._load_promise = null;
    return this.load();
  }

  overwrite(obj) {
    for (let i in obj) {
      this._data.value[i] = obj[i];
    }
  }

}

var script$I = {
  props: {
    model : String,
    base : String
},
  setup(__props) {

const props = __props;

const i18n = inject("i18n");
const t = i18n.t;





const single = new SingleData(props.model);
const store = single.model;

single.load()
.then(() => {
    console.log("Value is", single.data);
})
.catch(e => console.log(e));


const label = computed(() => {
    return t('models.' + props.model + '.title') + ': ';// + single.label.value;
});


subscribe("effect_edited", props.model, response => {
    console.log(response, arguments);
});


onBeforeUnmount(() => {
    unsubscribe("effect_edited", props.model);
});


return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("div", null, [
    createVNode(script$Q, {
      name: __props.model,
      store: unref(single)
    }, null, 8 /* PROPS */, ["name", "store"]),
    createVNode(unref(script$Z), { header: unref(label) }, {
      icons: withCtx(() => [
        (unref(store).audit)
          ? (openBlock(), createBlock(script$J, {
              key: 0,
              model: unref(store),
              data: _ctx.data,
              long: true
            }, null, 8 /* PROPS */, ["model", "data"]))
          : createCommentVNode("v-if", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(store).actions, (component) => {
          return (openBlock(), createBlock(resolveDynamicComponent(component.component), mergeProps({ data: _ctx.data }, component.atts), null, 16 /* FULL_PROPS */, ["data"]))
        }), 256 /* UNKEYED_FRAGMENT */))
      ]),
      default: withCtx(() => [
        (unref(single).data.value['--id'])
          ? (openBlock(), createBlock(script$P, {
              key: 0,
              id: unref(single).data.value['--id'],
              name: props.model
            }, null, 8 /* PROPS */, ["id", "name"]))
          : createCommentVNode("v-if", true)
      ]),
      _: 1 /* STABLE */
    }, 8 /* PROPS */, ["header"])
  ]))
}
}

};

script$I.__file = "presstojam/src/components/active/single.vue";

var script$H = {
  name: 'Chart',
  emits: ['select', 'loaded'],
  props: {
    type: String,
    data: null,
    options: null,
    plugins: null,
    width: {
      type: Number,
      default: 300
    },
    height: {
      type: Number,
      default: 150
    }
  },
  chart: null,
  watch: {
    /*
     * Use deep watch to enable triggering watch for changes within structure
     * otherwise the entire data object needs to be replaced to trigger watch
     */
    data: {
      handler() {
        this.reinit();
      },

      deep: true
    },

    type() {
      this.reinit();
    },

    options() {
      this.reinit();
    }

  },

  mounted() {
    this.initChart();
  },

  beforeUnmount() {
    if (this.chart) {
      this.chart.destroy();
      this.chart = null;
    }
  },

  methods: {
    initChart() {
      Promise.resolve().then(function () { return auto; }).then(module => {
        if (this.chart) {
          this.chart.destroy();
          this.chart = null;
        }

        if (module && module.default) {
          this.chart = new module.default(this.$refs.canvas, {
            type: this.type,
            data: this.data,
            options: this.options,
            plugins: this.plugins
          });
        }

        this.$emit('loaded', this.chart);
      });
    },

    getCanvas() {
      return this.$canvas;
    },

    getChart() {
      return this.chart;
    },

    getBase64Image() {
      return this.chart.toBase64Image();
    },

    refresh() {
      if (this.chart) {
        this.chart.update();
      }
    },

    reinit() {
      this.initChart();
    },

    onCanvasClick(event) {
      if (this.chart) {
        const element = this.chart.getElementsAtEventForMode(event, 'nearest', {
          intersect: true
        }, false);
        const dataset = this.chart.getElementsAtEventForMode(event, 'dataset', {
          intersect: true
        }, false);

        if (element && element[0] && dataset) {
          this.$emit('select', {
            originalEvent: event,
            element: element[0],
            dataset: dataset
          });
        }
      }
    },

    generateLegend() {
      if (this.chart) {
        return this.chart.generateLegend();
      }
    }

  }
};
const _hoisted_1$j = {
  class: "p-chart"
};
const _hoisted_2$g = ["width", "height"];

function render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$j, [createElementVNode("canvas", {
    ref: "canvas",
    width: $props.width,
    height: $props.height,
    onClick: _cache[0] || (_cache[0] = $event => $options.onCanvasClick($event))
  }, null, 8, _hoisted_2$g)]);
}

function styleInject$7(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$c = "\n.p-chart {\n    position: relative;\n}\n";
styleInject$7(css_248z$c);
script$H.render = render$b;

var script$G = {
  props: {
    repo : Object,
    type : [String]
},
  setup(__props) {

const props = __props;





const chart_data = computed(() => {
    const obj = {
        labels : ['Count'],
        datasets : props.repo.data
    };
    return obj;
});

const options = {
	responsive: true,
	hoverMode: 'index',
	stacked: false,
	/*scales: {
        yAxes: [{
            type: 'linear',
            display: true,
            position: 'left',
            id: 'y-axis-1',
        },
        {
            type: 'linear',
            display: true,
            position: 'right',
            id: 'y-axis-2',
            gridLines: {
                drawOnChartArea: false
            }
        }]
	}*/
};

const bar_options = {
    indexAxis : 'y'
};

return (_ctx, _cache) => {
  return (__props.type=='bar')
    ? (openBlock(), createBlock(unref(script$H), {
        key: 0,
        type: "bar",
        data: unref(chart_data),
        options: bar_options
      }, null, 8 /* PROPS */, ["data"]))
    : (openBlock(), createBlock(unref(script$H), {
        key: 1,
        type: "line",
        data: unref(chart_data),
        options: options
      }, null, 8 /* PROPS */, ["data"]))
}
}

};

script$G.__file = "presstojam/src/components/reports/report-chart.vue";

const _hoisted_1$i = { class: "p-inputgroup" };
const _hoisted_2$f = /*#__PURE__*/createElementVNode("span", { class: "p-inputgroup-addon" }, "min", -1 /* HOISTED */);
const _hoisted_3$d = /*#__PURE__*/createElementVNode("span", { class: "p-inputgroup-addon" }, " - ", -1 /* HOISTED */);
const _hoisted_4$9 = /*#__PURE__*/createElementVNode("span", { class: "p-inputgroup-addon" }, "max", -1 /* HOISTED */);


var script$F = {
  props: {
   bind : Object
},
  setup(__props) {

const props = __props;




const field = props.bind.cell;
const repo = inject("repo");
const name = props.bind.cell.name;

const min = computed({
    get() {
        return (repo.filters[name]) ? repo.filters[name].min : null;
    },
    set(val) {
        const filters = repo.filters;
        if (!filters[name]) filters[bind.name] = {};
        filters[props.bind.name].min = val;
        repo.reload();
    }
});

const max = computed({
    get() {
        return max_value.value;
    },
    set(val) {
        if (val < min_value.value) val = min_value.value;
        const filters = repo.filters;
        if (!filters[props.bind.name]) filters[props.bind.name] = {};
        filters[props.bind.name].max = val;
        repo.reload();
    }
}); 

function clear() {
    min_value.value = null;
    max_value.value = null;
    const filters = repo.filters;
    if (filters[props.bind.name]) {
        delete filters[props.bind.name];
        repo.reload();
    }
}



const atts = computed(() => {
    let atts = {};
    if (props.field.round) {
        let step = "0.";
        for(let i=0; i<props.field.round - 1; ++i) {
            step += "0";
        }
        step += "1";
        atts["step"]  = parseInt(step);
    }
    return atts;
});

return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("div", _hoisted_1$i, [
    _hoisted_2$f,
    createVNode(unref(script$1n), mergeProps({
      name: unref(field).name,
      modelValue: unref(min),
      "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (isRef(min) ? (min).value = $event : null))
    }, unref(atts), {
      onBlur: _cache[1] || (_cache[1] = $event => (unref(field).validateon = true))
    }), null, 16 /* FULL_PROPS */, ["name", "modelValue"]),
    _hoisted_3$d,
    createVNode(unref(script$1n), mergeProps({
      name: unref(field).name,
      modelValue: unref(max),
      "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => (isRef(max) ? (max).value = $event : null))
    }, unref(atts), {
      onBlur: _cache[3] || (_cache[3] = $event => (unref(field).validateon = true))
    }), null, 16 /* FULL_PROPS */, ["name", "modelValue"]),
    _hoisted_4$9,
    createVNode(unref(script$1L), {
      label: "clear",
      onClick: clear
    })
  ]))
}
}

};

script$F.__file = "presstojam/src/components/filter/number-filter.vue";

var script$E = {
  props: {
    bind : Object
},
  setup(__props) {

const props = __props;



const repo = inject("repo");

const value = computed({
    get() {
        return (!repo.filters[props.bind.cell.name]) ? { value : 0, label : 'All'} : repo.filters[props.bind.cell.name];
    },
    set(val) {
        if (val == 0) val = null;
        else if (val == 2) val = 0;
        if (val != repo.filters[props.bind.cell.name]) {
            repo.filters[props.bind.cell.name] = val;
            repo.reload();
        }
    }
});



return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$O), {
    name: __props.bind.cell.name,
    modelValue: unref(value),
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (isRef(value) ? (value).value = $event : null)),
    optionLabel: "label",
    optionValue: "value",
    options: [
            {value : 0, label : 'All' }, 
            { value : 1, label : 'Checked' }, 
            { value : 2, label : 'Unchecked'}]
  }, null, 8 /* PROPS */, ["name", "modelValue"]))
}
}

};

script$E.__file = "presstojam/src/components/filter/flag-filter.vue";

var script$D = {
  name: 'MultiSelect',
  emits: ['update:modelValue', 'change', 'focus', 'blur', 'before-show', 'before-hide', 'show', 'hide', 'filter', 'selectall-change'],
  props: {
    modelValue: null,
    options: Array,
    optionLabel: null,
    optionValue: null,
    optionDisabled: null,
    optionGroupLabel: null,
    optionGroupChildren: null,
    scrollHeight: {
      type: String,
      default: '200px'
    },
    placeholder: String,
    disabled: Boolean,
    inputId: {
      type: String,
      default: null
    },
    inputProps: {
      type: null,
      default: null
    },
    panelClass: {
      type: String,
      default: null
    },
    panelStyle: {
      type: null,
      default: null
    },
    panelProps: {
      type: null,
      default: null
    },
    filterInputProps: {
      type: null,
      default: null
    },
    closeButtonProps: {
      type: null,
      default: null
    },
    dataKey: null,
    filter: Boolean,
    filterPlaceholder: String,
    filterLocale: String,
    filterMatchMode: {
      type: String,
      default: 'contains'
    },
    filterFields: {
      type: Array,
      default: null
    },
    appendTo: {
      type: String,
      default: 'body'
    },
    display: {
      type: String,
      default: 'comma'
    },
    selectedItemsLabel: {
      type: String,
      default: '{0} items selected'
    },
    maxSelectedLabels: {
      type: Number,
      default: null
    },
    selectionLimit: {
      type: Number,
      default: null
    },
    showToggleAll: {
      type: Boolean,
      default: true
    },
    loading: {
      type: Boolean,
      default: false
    },
    checkboxIcon: {
      type: String,
      default: 'pi pi-check'
    },
    closeIcon: {
      type: String,
      default: 'pi pi-times'
    },
    dropdownIcon: {
      type: String,
      default: 'pi pi-chevron-down'
    },
    filterIcon: {
      type: String,
      default: 'pi pi-search'
    },
    loadingIcon: {
      type: String,
      default: 'pi pi-spinner pi-spin'
    },
    removeTokenIcon: {
      type: String,
      default: 'pi pi-times-circle'
    },
    selectAll: {
      type: Boolean,
      default: null
    },
    resetFilterOnHide: {
      type: Boolean,
      default: false
    },
    virtualScrollerOptions: {
      type: Object,
      default: null
    },
    autoOptionFocus: {
      type: Boolean,
      default: true
    },
    autoFilterFocus: {
      type: Boolean,
      default: false
    },
    filterMessage: {
      type: String,
      default: null
    },
    selectionMessage: {
      type: String,
      default: null
    },
    emptySelectionMessage: {
      type: String,
      default: null
    },
    emptyFilterMessage: {
      type: String,
      default: null
    },
    emptyMessage: {
      type: String,
      default: null
    },
    tabindex: {
      type: Number,
      default: 0
    },
    'aria-label': {
      type: String,
      default: null
    },
    'aria-labelledby': {
      type: String,
      default: null
    }
  },
  outsideClickListener: null,
  scrollHandler: null,
  resizeListener: null,
  overlay: null,
  list: null,
  virtualScroller: null,
  startRangeIndex: -1,
  searchTimeout: null,
  searchValue: '',
  selectOnFocus: false,
  focusOnHover: false,

  data() {
    return {
      focused: false,
      focusedOptionIndex: -1,
      headerCheckboxFocused: false,
      filterValue: null,
      overlayVisible: false
    };
  },

  watch: {
    options() {
      this.autoUpdateModel();
    }

  },

  mounted() {
    this.autoUpdateModel();
  },

  beforeUnmount() {
    this.unbindOutsideClickListener();
    this.unbindResizeListener();

    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }

    if (this.overlay) {
      ZIndexUtils.clear(this.overlay);
      this.overlay = null;
    }
  },

  methods: {
    getOptionIndex(index, fn) {
      return this.virtualScrollerDisabled ? index : fn && fn(index)['index'];
    },

    getOptionLabel(option) {
      return this.optionLabel ? ObjectUtils.resolveFieldData(option, this.optionLabel) : option;
    },

    getOptionValue(option) {
      return this.optionValue ? ObjectUtils.resolveFieldData(option, this.optionValue) : option;
    },

    getOptionRenderKey(option) {
      return this.dataKey ? ObjectUtils.resolveFieldData(option, this.dataKey) : this.getOptionLabel(option);
    },

    isOptionDisabled(option) {
      if (this.maxSelectionLimitReached && !this.isSelected(option)) {
        return true;
      }

      return this.optionDisabled ? ObjectUtils.resolveFieldData(option, this.optionDisabled) : false;
    },

    isOptionGroup(option) {
      return this.optionGroupLabel && option.optionGroup && option.group;
    },

    getOptionGroupLabel(optionGroup) {
      return ObjectUtils.resolveFieldData(optionGroup, this.optionGroupLabel);
    },

    getOptionGroupChildren(optionGroup) {
      return ObjectUtils.resolveFieldData(optionGroup, this.optionGroupChildren);
    },

    getAriaPosInset(index) {
      return (this.optionGroupLabel ? index - this.visibleOptions.slice(0, index).filter(option => this.isOptionGroup(option)).length : index) + 1;
    },

    show(isFocus) {
      this.$emit('before-show');
      this.overlayVisible = true;
      this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : -1;
      isFocus && DomHandler.focus(this.$refs.focusInput);
    },

    hide(isFocus) {
      this.$emit('before-hide');
      this.overlayVisible = false;
      this.focusedOptionIndex = -1;
      this.searchValue = '';
      this.resetFilterOnHide && (this.filterValue = null);
      isFocus && DomHandler.focus(this.$refs.focusInput);
    },

    onFocus(event) {
      this.focused = true;
      this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.overlayVisible && this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : -1;
      this.overlayVisible && this.scrollInView(this.focusedOptionIndex);
      this.$emit('focus', event);
    },

    onBlur(event) {
      this.focused = false;
      this.focusedOptionIndex = -1;
      this.searchValue = '';
      this.$emit('blur', event);
    },

    onKeyDown(event) {
      const metaKey = event.metaKey || event.ctrlKey;

      switch (event.code) {
        case 'ArrowDown':
          this.onArrowDownKey(event);
          break;

        case 'ArrowUp':
          this.onArrowUpKey(event);
          break;

        case 'Home':
          this.onHomeKey(event);
          break;

        case 'End':
          this.onEndKey(event);
          break;

        case 'PageDown':
          this.onPageDownKey(event);
          break;

        case 'PageUp':
          this.onPageUpKey(event);
          break;

        case 'Enter':
        case 'Space':
          this.onEnterKey(event);
          break;

        case 'Escape':
          this.onEscapeKey(event);
          break;

        case 'Tab':
          this.onTabKey(event);
          break;

        case 'ShiftLeft':
        case 'ShiftRight':
          this.onShiftKey(event);
          break;

        default:
          if (event.code === 'KeyA' && metaKey) {
            const value = this.visibleOptions.filter(option => this.isValidOption(option)).map(option => this.getOptionValue(option));
            this.updateModel(event, value);
            event.preventDefault();
            break;
          }

          if (!metaKey && ObjectUtils.isPrintableCharacter(event.key)) {
            !this.overlayVisible && this.show();
            this.searchOptions(event);
            event.preventDefault();
          }

          break;
      }
    },

    onContainerClick(event) {
      if (this.disabled || this.loading) {
        return;
      }

      if (!this.overlay || !this.overlay.contains(event.target)) {
        this.overlayVisible ? this.hide(true) : this.show(true);
      }
    },

    onFirstHiddenFocus(event) {
      const relatedTarget = event.relatedTarget;

      if (relatedTarget === this.$refs.focusInput) {
        const firstFocusableEl = DomHandler.getFirstFocusableElement(this.overlay, ':not(.p-hidden-focusable)');
        DomHandler.focus(firstFocusableEl);
      } else {
        DomHandler.focus(this.$refs.focusInput);
      }
    },

    onLastHiddenFocus() {
      DomHandler.focus(this.$refs.firstHiddenFocusableElementOnOverlay);
    },

    onCloseClick() {
      this.hide(true);
    },

    onHeaderCheckboxFocus() {
      this.headerCheckboxFocused = true;
    },

    onHeaderCheckboxBlur() {
      this.headerCheckboxFocused = false;
    },

    onOptionSelect(event, option, index = -1, isFocus = false) {
      if (this.disabled || this.isOptionDisabled(option)) {
        return;
      }

      let selected = this.isSelected(option);
      let value = null;
      if (selected) value = this.modelValue.filter(val => !ObjectUtils.equals(val, this.getOptionValue(option), this.equalityKey));else value = [...(this.modelValue || []), this.getOptionValue(option)];
      this.updateModel(event, value);
      index !== -1 && (this.focusedOptionIndex = index);
      isFocus && DomHandler.focus(this.$refs.focusInput);
    },

    onOptionMouseMove(event, index) {
      if (this.focusOnHover) {
        this.changeFocusedOptionIndex(event, index);
      }
    },

    onOptionSelectRange(event, start = -1, end = -1) {
      start === -1 && (start = this.findNearestSelectedOptionIndex(end, true));
      end === -1 && (end = this.findNearestSelectedOptionIndex(start));

      if (start !== -1 && end !== -1) {
        const rangeStart = Math.min(start, end);
        const rangeEnd = Math.max(start, end);
        const value = this.visibleOptions.slice(rangeStart, rangeEnd + 1).filter(option => this.isValidOption(option)).map(option => this.getOptionValue(option));
        this.updateModel(event, value);
      }
    },

    onFilterChange(event) {
      const value = event.target.value;
      this.filterValue = value;
      this.focusedOptionIndex = -1;
      this.$emit('filter', {
        originalEvent: event,
        value
      });
      !this.virtualScrollerDisabled && this.virtualScroller.scrollToIndex(0);
    },

    onFilterKeyDown(event) {
      switch (event.code) {
        case 'ArrowDown':
          this.onArrowDownKey(event);
          break;

        case 'ArrowUp':
          this.onArrowUpKey(event, true);
          break;

        case 'ArrowLeft':
        case 'ArrowRight':
          this.onArrowLeftKey(event, true);
          break;

        case 'Home':
          this.onHomeKey(event, true);
          break;

        case 'End':
          this.onEndKey(event, true);
          break;

        case 'Enter':
          this.onEnterKey(event);
          break;

        case 'Escape':
          this.onEscapeKey(event);
          break;

        case 'Tab':
          this.onTabKey(event, true);
          break;
      }
    },

    onFilterBlur() {
      this.focusedOptionIndex = -1;
    },

    onFilterUpdated() {
      if (this.overlayVisible) {
        this.alignOverlay();
      }
    },

    onOverlayClick(event) {
      OverlayEventBus.emit('overlay-click', {
        originalEvent: event,
        target: this.$el
      });
    },

    onOverlayKeyDown(event) {
      switch (event.code) {
        case 'Escape':
          this.onEscapeKey(event);
          break;
      }
    },

    onArrowDownKey(event) {
      const optionIndex = this.focusedOptionIndex !== -1 ? this.findNextOptionIndex(this.focusedOptionIndex) : this.findFirstFocusedOptionIndex();

      if (event.shiftKey) {
        this.onOptionSelectRange(event, this.startRangeIndex, optionIndex);
      }

      this.changeFocusedOptionIndex(event, optionIndex);
      !this.overlayVisible && this.show();
      event.preventDefault();
    },

    onArrowUpKey(event, pressedInInputText = false) {
      if (event.altKey && !pressedInInputText) {
        if (this.focusedOptionIndex !== -1) {
          this.onOptionSelect(event, this.visibleOptions[this.focusedOptionIndex]);
        }

        this.overlayVisible && this.hide();
        event.preventDefault();
      } else {
        const optionIndex = this.focusedOptionIndex !== -1 ? this.findPrevOptionIndex(this.focusedOptionIndex) : this.findLastFocusedOptionIndex();

        if (event.shiftKey) {
          this.onOptionSelectRange(event, optionIndex, this.startRangeIndex);
        }

        this.changeFocusedOptionIndex(event, optionIndex);
        !this.overlayVisible && this.show();
        event.preventDefault();
      }
    },

    onArrowLeftKey(event, pressedInInputText = false) {
      pressedInInputText && (this.focusedOptionIndex = -1);
    },

    onHomeKey(event, pressedInInputText = false) {
      if (pressedInInputText) {
        event.currentTarget.setSelectionRange(0, 0);
        this.focusedOptionIndex = -1;
      } else {
        let metaKey = event.metaKey || event.ctrlKey;
        let optionIndex = this.findFirstOptionIndex();

        if (event.shiftKey && metaKey) {
          this.onOptionSelectRange(event, optionIndex, this.startRangeIndex);
        }

        this.changeFocusedOptionIndex(event, optionIndex);
        !this.overlayVisible && this.show();
      }

      event.preventDefault();
    },

    onEndKey(event, pressedInInputText = false) {
      if (pressedInInputText) {
        const target = event.currentTarget;
        const len = target.value.length;
        target.setSelectionRange(len, len);
        this.focusedOptionIndex = -1;
      } else {
        let metaKey = event.metaKey || event.ctrlKey;
        let optionIndex = this.findLastOptionIndex();

        if (event.shiftKey && metaKey) {
          this.onOptionSelectRange(event, this.startRangeIndex, optionIndex);
        }

        this.changeFocusedOptionIndex(event, optionIndex);
        !this.overlayVisible && this.show();
      }

      event.preventDefault();
    },

    onPageUpKey(event) {
      this.scrollInView(0);
      event.preventDefault();
    },

    onPageDownKey(event) {
      this.scrollInView(this.visibleOptions.length - 1);
      event.preventDefault();
    },

    onEnterKey(event) {
      if (!this.overlayVisible) {
        this.onArrowDownKey(event);
      } else {
        if (this.focusedOptionIndex !== -1) {
          if (event.shiftKey) this.onOptionSelectRange(event, this.focusedOptionIndex);else this.onOptionSelect(event, this.visibleOptions[this.focusedOptionIndex]);
        }
      }

      event.preventDefault();
    },

    onEscapeKey(event) {
      this.overlayVisible && this.hide(true);
      event.preventDefault();
    },

    onTabKey(event, pressedInInputText = false) {
      if (!pressedInInputText) {
        if (this.overlayVisible && this.hasFocusableElements()) {
          DomHandler.focus(this.$refs.firstHiddenFocusableElementOnOverlay);
          event.preventDefault();
        } else {
          if (this.focusedOptionIndex !== -1) {
            this.onOptionSelect(event, this.visibleOptions[this.focusedOptionIndex]);
          }

          this.overlayVisible && this.hide(this.filter);
        }
      }
    },

    onShiftKey() {
      this.startRangeIndex = this.focusedOptionIndex;
    },

    onOverlayEnter(el) {
      ZIndexUtils.set('overlay', el, this.$primevue.config.zIndex.overlay);
      this.alignOverlay();
      this.scrollInView();
      this.autoFilterFocus && DomHandler.focus(this.$refs.filterInput);
    },

    onOverlayAfterEnter() {
      this.bindOutsideClickListener();
      this.bindScrollListener();
      this.bindResizeListener();
      this.$emit('show');
    },

    onOverlayLeave() {
      this.unbindOutsideClickListener();
      this.unbindScrollListener();
      this.unbindResizeListener();
      this.$emit('hide');
      this.overlay = null;
    },

    onOverlayAfterLeave(el) {
      ZIndexUtils.clear(el);
    },

    alignOverlay() {
      if (this.appendTo === 'self') {
        DomHandler.relativePosition(this.overlay, this.$el);
      } else {
        this.overlay.style.minWidth = DomHandler.getOuterWidth(this.$el) + 'px';
        DomHandler.absolutePosition(this.overlay, this.$el);
      }
    },

    bindOutsideClickListener() {
      if (!this.outsideClickListener) {
        this.outsideClickListener = event => {
          if (this.overlayVisible && this.isOutsideClicked(event)) {
            this.hide();
          }
        };

        document.addEventListener('click', this.outsideClickListener);
      }
    },

    unbindOutsideClickListener() {
      if (this.outsideClickListener) {
        document.removeEventListener('click', this.outsideClickListener);
        this.outsideClickListener = null;
      }
    },

    bindScrollListener() {
      if (!this.scrollHandler) {
        this.scrollHandler = new ConnectedOverlayScrollHandler(this.$refs.container, () => {
          if (this.overlayVisible) {
            this.hide();
          }
        });
      }

      this.scrollHandler.bindScrollListener();
    },

    unbindScrollListener() {
      if (this.scrollHandler) {
        this.scrollHandler.unbindScrollListener();
      }
    },

    bindResizeListener() {
      if (!this.resizeListener) {
        this.resizeListener = () => {
          if (this.overlayVisible && !DomHandler.isTouchDevice()) {
            this.hide();
          }
        };

        window.addEventListener('resize', this.resizeListener);
      }
    },

    unbindResizeListener() {
      if (this.resizeListener) {
        window.removeEventListener('resize', this.resizeListener);
        this.resizeListener = null;
      }
    },

    isOutsideClicked(event) {
      return !(this.$el.isSameNode(event.target) || this.$el.contains(event.target) || this.overlay && this.overlay.contains(event.target));
    },

    getLabelByValue(value) {
      const options = this.optionGroupLabel ? this.flatOptions(this.options) : this.options || [];
      const matchedOption = options.find(option => !this.isOptionGroup(option) && ObjectUtils.equals(this.getOptionValue(option), value, this.equalityKey));
      return matchedOption ? this.getOptionLabel(matchedOption) : null;
    },

    getSelectedItemsLabel() {
      let pattern = /{(.*?)}/;

      if (pattern.test(this.selectedItemsLabel)) {
        return this.selectedItemsLabel.replace(this.selectedItemsLabel.match(pattern)[0], this.modelValue.length + '');
      }

      return this.selectedItemsLabel;
    },

    onToggleAll(event) {
      if (this.selectAll !== null) {
        this.$emit('selectall-change', {
          originalEvent: event,
          checked: !this.allSelected
        });
      } else {
        const value = this.allSelected ? [] : this.visibleOptions.filter(option => !this.isOptionDisabled(option) && !this.isOptionGroup(option)).map(option => this.getOptionValue(option));
        this.updateModel(event, value);
      }

      this.headerCheckboxFocused = true;
    },

    removeOption(event, optionValue) {
      let value = this.modelValue.filter(val => !ObjectUtils.equals(val, optionValue, this.equalityKey));
      this.updateModel(event, value);
    },

    clearFilter() {
      this.filterValue = null;
    },

    hasFocusableElements() {
      return DomHandler.getFocusableElements(this.overlay, ':not(.p-hidden-focusable)').length > 0;
    },

    isOptionMatched(option) {
      return this.isValidOption(option) && this.getOptionLabel(option).toLocaleLowerCase(this.filterLocale).startsWith(this.searchValue.toLocaleLowerCase(this.filterLocale));
    },

    isValidOption(option) {
      return option && !(this.isOptionDisabled(option) || this.isOptionGroup(option));
    },

    isValidSelectedOption(option) {
      return this.isValidOption(option) && this.isSelected(option);
    },

    isSelected(option) {
      const optionValue = this.getOptionValue(option);
      return (this.modelValue || []).some(value => ObjectUtils.equals(value, optionValue, this.equalityKey));
    },

    findFirstOptionIndex() {
      return this.visibleOptions.findIndex(option => this.isValidOption(option));
    },

    findLastOptionIndex() {
      return ObjectUtils.findLastIndex(this.visibleOptions, option => this.isValidOption(option));
    },

    findNextOptionIndex(index) {
      const matchedOptionIndex = index < this.visibleOptions.length - 1 ? this.visibleOptions.slice(index + 1).findIndex(option => this.isValidOption(option)) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex + index + 1 : index;
    },

    findPrevOptionIndex(index) {
      const matchedOptionIndex = index > 0 ? ObjectUtils.findLastIndex(this.visibleOptions.slice(0, index), option => this.isValidOption(option)) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex : index;
    },

    findFirstSelectedOptionIndex() {
      return this.hasSelectedOption ? this.visibleOptions.findIndex(option => this.isValidSelectedOption(option)) : -1;
    },

    findLastSelectedOptionIndex() {
      return this.hasSelectedOption ? ObjectUtils.findLastIndex(this.visibleOptions, option => this.isValidSelectedOption(option)) : -1;
    },

    findNextSelectedOptionIndex(index) {
      const matchedOptionIndex = this.hasSelectedOption && index < this.visibleOptions.length - 1 ? this.visibleOptions.slice(index + 1).findIndex(option => this.isValidSelectedOption(option)) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex + index + 1 : -1;
    },

    findPrevSelectedOptionIndex(index) {
      const matchedOptionIndex = this.hasSelectedOption && index > 0 ? ObjectUtils.findLastIndex(this.visibleOptions.slice(0, index), option => this.isValidSelectedOption(option)) : -1;
      return matchedOptionIndex > -1 ? matchedOptionIndex : -1;
    },

    findNearestSelectedOptionIndex(index, firstCheckUp = false) {
      let matchedOptionIndex = -1;

      if (this.hasSelectedOption) {
        if (firstCheckUp) {
          matchedOptionIndex = this.findPrevSelectedOptionIndex(index);
          matchedOptionIndex = matchedOptionIndex === -1 ? this.findNextSelectedOptionIndex(index) : matchedOptionIndex;
        } else {
          matchedOptionIndex = this.findNextSelectedOptionIndex(index);
          matchedOptionIndex = matchedOptionIndex === -1 ? this.findPrevSelectedOptionIndex(index) : matchedOptionIndex;
        }
      }

      return matchedOptionIndex > -1 ? matchedOptionIndex : index;
    },

    findFirstFocusedOptionIndex() {
      const selectedIndex = this.findFirstSelectedOptionIndex();
      return selectedIndex < 0 ? this.findFirstOptionIndex() : selectedIndex;
    },

    findLastFocusedOptionIndex() {
      const selectedIndex = this.findLastSelectedOptionIndex();
      return selectedIndex < 0 ? this.findLastOptionIndex() : selectedIndex;
    },

    searchOptions(event) {
      this.searchValue = (this.searchValue || '') + event.key;
      let optionIndex = -1;

      if (this.focusedOptionIndex !== -1) {
        optionIndex = this.visibleOptions.slice(this.focusedOptionIndex).findIndex(option => this.isOptionMatched(option));
        optionIndex = optionIndex === -1 ? this.visibleOptions.slice(0, this.focusedOptionIndex).findIndex(option => this.isOptionMatched(option)) : optionIndex + this.focusedOptionIndex;
      } else {
        optionIndex = this.visibleOptions.findIndex(option => this.isOptionMatched(option));
      }

      if (optionIndex === -1 && this.focusedOptionIndex === -1) {
        const selectedIndex = this.findSelectedOptionIndex();
        optionIndex = selectedIndex < 0 ? this.findFirstOptionIndex() : selectedIndex;
      }

      if (optionIndex !== -1) {
        this.changeFocusedOptionIndex(event, optionIndex);
      }

      if (this.searchTimeout) {
        clearTimeout(this.searchTimeout);
      }

      this.searchTimeout = setTimeout(() => {
        this.searchValue = '';
        this.searchTimeout = null;
      }, 500);
    },

    changeFocusedOptionIndex(event, index) {
      if (this.focusedOptionIndex !== index) {
        this.focusedOptionIndex = index;
        this.scrollInView();
      }
    },

    scrollInView(index = -1) {
      const id = index !== -1 ? `${this.id}_${index}` : this.focusedOptionId;
      const element = DomHandler.findSingle(this.list, `li[id="${id}"]`);

      if (element) {
        element.scrollIntoView && element.scrollIntoView({
          block: 'nearest',
          inline: 'nearest'
        });
      } else if (!this.virtualScrollerDisabled) {
        this.virtualScroller && this.virtualScroller.scrollToIndex(index !== -1 ? index : this.focusedOptionIndex);
      }
    },

    autoUpdateModel() {
      if (this.selectOnFocus && this.autoOptionFocus && !this.hasSelectedOption) {
        this.focusedOptionIndex = this.findFirstFocusedOptionIndex();
        const value = this.getOptionValue(this.visibleOptions[this.focusedOptionIndex]);
        this.updateModel(null, [value]);
      }
    },

    updateModel(event, value) {
      this.$emit('update:modelValue', value);
      this.$emit('change', {
        originalEvent: event,
        value
      });
    },

    flatOptions(options) {
      return (options || []).reduce((result, option, index) => {
        result.push({
          optionGroup: option,
          group: true,
          index
        });
        const optionGroupChildren = this.getOptionGroupChildren(option);
        optionGroupChildren && optionGroupChildren.forEach(o => result.push(o));
        return result;
      }, []);
    },

    overlayRef(el) {
      this.overlay = el;
    },

    listRef(el, contentRef) {
      this.list = el;
      contentRef && contentRef(el); // For VirtualScroller
    },

    virtualScrollerRef(el) {
      this.virtualScroller = el;
    }

  },
  computed: {
    containerClass() {
      return ['p-multiselect p-component p-inputwrapper', {
        'p-multiselect-chip': this.display === 'chip',
        'p-disabled': this.disabled,
        'p-focus': this.focused,
        'p-inputwrapper-filled': this.modelValue && this.modelValue.length,
        'p-inputwrapper-focus': this.focused || this.overlayVisible,
        'p-overlay-open': this.overlayVisible
      }];
    },

    labelClass() {
      return ['p-multiselect-label', {
        'p-placeholder': this.label === this.placeholder,
        'p-multiselect-label-empty': !this.placeholder && (!this.modelValue || this.modelValue.length === 0)
      }];
    },

    dropdownIconClass() {
      return ['p-multiselect-trigger-icon', this.loading ? this.loadingIcon : this.dropdownIcon];
    },

    panelStyleClass() {
      return ['p-multiselect-panel p-component', this.panelClass, {
        'p-input-filled': this.$primevue.config.inputStyle === 'filled',
        'p-ripple-disabled': this.$primevue.config.ripple === false
      }];
    },

    headerCheckboxClass() {
      return ['p-checkbox p-component', {
        'p-checkbox-checked': this.allSelected,
        'p-checkbox-focused': this.headerCheckboxFocused
      }];
    },

    visibleOptions() {
      const options = this.optionGroupLabel ? this.flatOptions(this.options) : this.options || [];

      if (this.filterValue) {
        const filteredOptions = FilterService.filter(options, this.searchFields, this.filterValue, this.filterMatchMode, this.filterLocale);

        if (this.optionGroupLabel) {
          const optionGroups = this.options || [];
          const filtered = [];
          optionGroups.forEach(group => {
            const filteredItems = group.items.filter(item => filteredOptions.includes(item));
            if (filteredItems.length > 0) filtered.push({ ...group,
              items: [...filteredItems]
            });
          });
          return this.flatOptions(filtered);
        }

        return filteredOptions;
      }

      return options;
    },

    label() {
      // TODO: Refactor
      let label;

      if (this.modelValue && this.modelValue.length) {
        if (ObjectUtils.isNotEmpty(this.maxSelectedLabels) && this.modelValue.length > this.maxSelectedLabels) {
          return this.getSelectedItemsLabel();
        } else {
          label = '';

          for (let i = 0; i < this.modelValue.length; i++) {
            if (i !== 0) {
              label += ', ';
            }

            label += this.getLabelByValue(this.modelValue[i]);
          }
        }
      } else {
        label = this.placeholder;
      }

      return label;
    },

    allSelected() {
      return this.selectAll !== null ? this.selectAll : ObjectUtils.isNotEmpty(this.visibleOptions) && this.visibleOptions.filter(option => !this.isOptionDisabled(option)).every(option => this.isOptionGroup(option) || this.isValidSelectedOption(option));
    },

    hasSelectedOption() {
      return ObjectUtils.isNotEmpty(this.modelValue);
    },

    equalityKey() {
      return this.optionValue ? null : this.dataKey;
    },

    searchFields() {
      return this.filterFields || [this.optionLabel];
    },

    maxSelectionLimitReached() {
      return this.selectionLimit && this.modelValue && this.modelValue.length === this.selectionLimit;
    },

    filterResultMessageText() {
      return ObjectUtils.isNotEmpty(this.visibleOptions) ? this.filterMessageText.replaceAll('{0}', this.visibleOptions.length) : this.emptyFilterMessageText;
    },

    filterMessageText() {
      return this.filterMessage || this.$primevue.config.locale.searchMessage || '';
    },

    emptyFilterMessageText() {
      return this.emptyFilterMessage || this.$primevue.config.locale.emptySearchMessage || this.$primevue.config.locale.emptyFilterMessage || '';
    },

    emptyMessageText() {
      return this.emptyMessage || this.$primevue.config.locale.emptyMessage || '';
    },

    selectionMessageText() {
      return this.selectionMessage || this.$primevue.config.locale.selectionMessage || '';
    },

    emptySelectionMessageText() {
      return this.emptySelectionMessage || this.$primevue.config.locale.emptySelectionMessage || '';
    },

    selectedMessageText() {
      return this.hasSelectedOption ? this.selectionMessageText.replaceAll('{0}', this.modelValue.length) : this.emptySelectionMessageText;
    },

    id() {
      return this.$attrs.id || UniqueComponentId();
    },

    focusedOptionId() {
      return this.focusedOptionIndex !== -1 ? `${this.id}_${this.focusedOptionIndex}` : null;
    },

    ariaSetSize() {
      return this.visibleOptions.filter(option => !this.isOptionGroup(option)).length;
    },

    toggleAllAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria[this.allSelected ? 'selectAll' : 'unselectAll'] : undefined;
    },

    closeAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.close : undefined;
    },

    virtualScrollerDisabled() {
      return !this.virtualScrollerOptions;
    }

  },
  directives: {
    ripple: Ripple
  },
  components: {
    VirtualScroller: script$1g,
    Portal: script$1C
  }
};
const _hoisted_1$h = {
  class: "p-hidden-accessible"
};
const _hoisted_2$e = ["id", "disabled", "placeholder", "tabindex", "aria-label", "aria-labelledby", "aria-expanded", "aria-controls", "aria-activedescendant"];
const _hoisted_3$c = {
  class: "p-multiselect-label-container"
};
const _hoisted_4$8 = {
  class: "p-multiselect-token-label"
};
const _hoisted_5$8 = ["onClick"];
const _hoisted_6$7 = {
  class: "p-multiselect-trigger"
};
const _hoisted_7$4 = {
  key: 0,
  class: "p-multiselect-header"
};
const _hoisted_8$3 = {
  class: "p-hidden-accessible"
};
const _hoisted_9$1 = ["checked", "aria-label"];
const _hoisted_10$1 = {
  key: 1,
  class: "p-multiselect-filter-container"
};
const _hoisted_11$1 = ["value", "placeholder", "aria-owns", "aria-activedescendant"];
const _hoisted_12$1 = {
  key: 2,
  role: "status",
  "aria-live": "polite",
  class: "p-hidden-accessible"
};
const _hoisted_13$1 = ["aria-label"];
const _hoisted_14$1 = ["id"];
const _hoisted_15 = ["id"];
const _hoisted_16 = ["id", "aria-label", "aria-selected", "aria-disabled", "aria-setsize", "aria-posinset", "onClick", "onMousemove"];
const _hoisted_17 = {
  class: "p-checkbox p-component"
};
const _hoisted_18 = {
  key: 0,
  class: "p-multiselect-empty-message",
  role: "option"
};
const _hoisted_19 = {
  key: 1,
  class: "p-multiselect-empty-message",
  role: "option"
};
const _hoisted_20 = {
  key: 0,
  role: "status",
  "aria-live": "polite",
  class: "p-hidden-accessible"
};
const _hoisted_21 = {
  role: "status",
  "aria-live": "polite",
  class: "p-hidden-accessible"
};

function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VirtualScroller = resolveComponent("VirtualScroller");

  const _component_Portal = resolveComponent("Portal");

  const _directive_ripple = resolveDirective("ripple");

  return openBlock(), createElementBlock("div", {
    ref: "container",
    class: normalizeClass($options.containerClass),
    onClick: _cache[15] || (_cache[15] = (...args) => $options.onContainerClick && $options.onContainerClick(...args))
  }, [createElementVNode("div", _hoisted_1$h, [createElementVNode("input", mergeProps({
    ref: "focusInput",
    id: $props.inputId,
    type: "text",
    readonly: "",
    disabled: $props.disabled,
    placeholder: $props.placeholder,
    tabindex: !$props.disabled ? $props.tabindex : -1,
    role: "combobox",
    "aria-label": _ctx.ariaLabel,
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-haspopup": "listbox",
    "aria-expanded": $data.overlayVisible,
    "aria-controls": $options.id + '_list',
    "aria-activedescendant": $data.focused ? $options.focusedOptionId : undefined,
    onFocus: _cache[0] || (_cache[0] = (...args) => $options.onFocus && $options.onFocus(...args)),
    onBlur: _cache[1] || (_cache[1] = (...args) => $options.onBlur && $options.onBlur(...args)),
    onKeydown: _cache[2] || (_cache[2] = (...args) => $options.onKeyDown && $options.onKeyDown(...args))
  }, $props.inputProps), null, 16, _hoisted_2$e)]), createElementVNode("div", _hoisted_3$c, [createElementVNode("div", {
    class: normalizeClass($options.labelClass)
  }, [renderSlot(_ctx.$slots, "value", {
    value: $props.modelValue,
    placeholder: $props.placeholder
  }, () => [$props.display === 'comma' ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [createTextVNode(toDisplayString$1($options.label || 'empty'), 1)], 64)) : $props.display === 'chip' ? (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [(openBlock(true), createElementBlock(Fragment, null, renderList($props.modelValue, item => {
    return openBlock(), createElementBlock("div", {
      key: $options.getLabelByValue(item),
      class: "p-multiselect-token"
    }, [renderSlot(_ctx.$slots, "chip", {
      value: item
    }, () => [createElementVNode("span", _hoisted_4$8, toDisplayString$1($options.getLabelByValue(item)), 1)]), !$props.disabled ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass(['p-multiselect-token-icon', $props.removeTokenIcon]),
      onClick: $event => $options.removeOption($event, item)
    }, null, 10, _hoisted_5$8)) : createCommentVNode("", true)]);
  }), 128)), !$props.modelValue || $props.modelValue.length === 0 ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [createTextVNode(toDisplayString$1($props.placeholder || 'empty'), 1)], 64)) : createCommentVNode("", true)], 64)) : createCommentVNode("", true)])], 2)]), createElementVNode("div", _hoisted_6$7, [renderSlot(_ctx.$slots, "indicator", {}, () => [createElementVNode("span", {
    class: normalizeClass($options.dropdownIconClass),
    "aria-hidden": "true"
  }, null, 2)])]), createVNode(_component_Portal, {
    appendTo: $props.appendTo
  }, {
    default: withCtx(() => [createVNode(Transition, {
      name: "p-connected-overlay",
      onEnter: $options.onOverlayEnter,
      onAfterEnter: $options.onOverlayAfterEnter,
      onLeave: $options.onOverlayLeave,
      onAfterLeave: $options.onOverlayAfterLeave
    }, {
      default: withCtx(() => [$data.overlayVisible ? (openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        ref: $options.overlayRef,
        style: $props.panelStyle,
        class: $options.panelStyleClass,
        onClick: _cache[13] || (_cache[13] = (...args) => $options.onOverlayClick && $options.onOverlayClick(...args)),
        onKeydown: _cache[14] || (_cache[14] = (...args) => $options.onOverlayKeyDown && $options.onOverlayKeyDown(...args))
      }, $props.panelProps), [createElementVNode("span", {
        ref: "firstHiddenFocusableElementOnOverlay",
        role: "presentation",
        "aria-hidden": "true",
        class: "p-hidden-accessible p-hidden-focusable",
        tabindex: 0,
        onFocus: _cache[3] || (_cache[3] = (...args) => $options.onFirstHiddenFocus && $options.onFirstHiddenFocus(...args))
      }, null, 544), renderSlot(_ctx.$slots, "header", {
        value: $props.modelValue,
        options: $options.visibleOptions
      }), $props.showToggleAll && $props.selectionLimit == null || $props.filter ? (openBlock(), createElementBlock("div", _hoisted_7$4, [$props.showToggleAll && $props.selectionLimit == null ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass($options.headerCheckboxClass),
        onClick: _cache[6] || (_cache[6] = (...args) => $options.onToggleAll && $options.onToggleAll(...args))
      }, [createElementVNode("div", _hoisted_8$3, [createElementVNode("input", {
        type: "checkbox",
        readonly: "",
        checked: $options.allSelected,
        "aria-label": $options.toggleAllAriaLabel,
        onFocus: _cache[4] || (_cache[4] = (...args) => $options.onHeaderCheckboxFocus && $options.onHeaderCheckboxFocus(...args)),
        onBlur: _cache[5] || (_cache[5] = (...args) => $options.onHeaderCheckboxBlur && $options.onHeaderCheckboxBlur(...args))
      }, null, 40, _hoisted_9$1)]), createElementVNode("div", {
        class: normalizeClass(['p-checkbox-box', {
          'p-highlight': $options.allSelected,
          'p-focus': $data.headerCheckboxFocused
        }])
      }, [createElementVNode("span", {
        class: normalizeClass(['p-checkbox-icon', {
          [$props.checkboxIcon]: $options.allSelected
        }])
      }, null, 2)], 2)], 2)) : createCommentVNode("", true), $props.filter ? (openBlock(), createElementBlock("div", _hoisted_10$1, [createElementVNode("input", mergeProps({
        ref: "filterInput",
        type: "text",
        value: $data.filterValue,
        onVnodeUpdated: _cache[7] || (_cache[7] = (...args) => $options.onFilterUpdated && $options.onFilterUpdated(...args)),
        class: "p-multiselect-filter p-inputtext p-component",
        placeholder: $props.filterPlaceholder,
        role: "searchbox",
        autocomplete: "off",
        "aria-owns": $options.id + '_list',
        "aria-activedescendant": $options.focusedOptionId,
        onKeydown: _cache[8] || (_cache[8] = (...args) => $options.onFilterKeyDown && $options.onFilterKeyDown(...args)),
        onBlur: _cache[9] || (_cache[9] = (...args) => $options.onFilterBlur && $options.onFilterBlur(...args)),
        onInput: _cache[10] || (_cache[10] = (...args) => $options.onFilterChange && $options.onFilterChange(...args))
      }, $props.filterInputProps), null, 16, _hoisted_11$1), createElementVNode("span", {
        class: normalizeClass(['p-multiselect-filter-icon', $props.filterIcon])
      }, null, 2)])) : createCommentVNode("", true), $props.filter ? (openBlock(), createElementBlock("span", _hoisted_12$1, toDisplayString$1($options.filterResultMessageText), 1)) : createCommentVNode("", true), withDirectives((openBlock(), createElementBlock("button", mergeProps({
        class: "p-multiselect-close p-link",
        "aria-label": $options.closeAriaLabel,
        onClick: _cache[11] || (_cache[11] = (...args) => $options.onCloseClick && $options.onCloseClick(...args)),
        type: "button"
      }, $props.closeButtonProps), [createElementVNode("span", {
        class: normalizeClass(['p-multiselect-close-icon', $props.closeIcon])
      }, null, 2)], 16, _hoisted_13$1)), [[_directive_ripple]])])) : createCommentVNode("", true), createElementVNode("div", {
        class: "p-multiselect-items-wrapper",
        style: normalizeStyle({
          'max-height': $options.virtualScrollerDisabled ? $props.scrollHeight : ''
        })
      }, [createVNode(_component_VirtualScroller, mergeProps({
        ref: $options.virtualScrollerRef
      }, $props.virtualScrollerOptions, {
        items: $options.visibleOptions,
        style: {
          height: $props.scrollHeight
        },
        tabindex: -1,
        disabled: $options.virtualScrollerDisabled
      }), createSlots({
        content: withCtx(({
          styleClass,
          contentRef,
          items,
          getItemOptions,
          contentStyle,
          itemSize
        }) => [createElementVNode("ul", {
          ref: el => $options.listRef(el, contentRef),
          id: $options.id + '_list',
          class: normalizeClass(['p-multiselect-items p-component', styleClass]),
          style: normalizeStyle(contentStyle),
          role: "listbox",
          "aria-multiselectable": "true"
        }, [(openBlock(true), createElementBlock(Fragment, null, renderList(items, (option, i) => {
          return openBlock(), createElementBlock(Fragment, {
            key: $options.getOptionRenderKey(option, $options.getOptionIndex(i, getItemOptions))
          }, [$options.isOptionGroup(option) ? (openBlock(), createElementBlock("li", {
            key: 0,
            id: $options.id + '_' + $options.getOptionIndex(i, getItemOptions),
            style: normalizeStyle({
              height: itemSize ? itemSize + 'px' : undefined
            }),
            class: "p-multiselect-item-group",
            role: "option"
          }, [renderSlot(_ctx.$slots, "optiongroup", {
            option: option.optionGroup,
            index: $options.getOptionIndex(i, getItemOptions)
          }, () => [createTextVNode(toDisplayString$1($options.getOptionGroupLabel(option.optionGroup)), 1)])], 12, _hoisted_15)) : withDirectives((openBlock(), createElementBlock("li", {
            key: 1,
            id: $options.id + '_' + $options.getOptionIndex(i, getItemOptions),
            style: normalizeStyle({
              height: itemSize ? itemSize + 'px' : undefined
            }),
            class: normalizeClass(['p-multiselect-item', {
              'p-highlight': $options.isSelected(option),
              'p-focus': $data.focusedOptionIndex === $options.getOptionIndex(i, getItemOptions),
              'p-disabled': $options.isOptionDisabled(option)
            }]),
            role: "option",
            "aria-label": $options.getOptionLabel(option),
            "aria-selected": $options.isSelected(option),
            "aria-disabled": $options.isOptionDisabled(option),
            "aria-setsize": $options.ariaSetSize,
            "aria-posinset": $options.getAriaPosInset($options.getOptionIndex(i, getItemOptions)),
            onClick: $event => $options.onOptionSelect($event, option, $options.getOptionIndex(i, getItemOptions), true),
            onMousemove: $event => $options.onOptionMouseMove($event, $options.getOptionIndex(i, getItemOptions))
          }, [createElementVNode("div", _hoisted_17, [createElementVNode("div", {
            class: normalizeClass(['p-checkbox-box', {
              'p-highlight': $options.isSelected(option)
            }])
          }, [createElementVNode("span", {
            class: normalizeClass(['p-checkbox-icon', {
              [$props.checkboxIcon]: $options.isSelected(option)
            }])
          }, null, 2)], 2)]), renderSlot(_ctx.$slots, "option", {
            option: option,
            index: $options.getOptionIndex(i, getItemOptions)
          }, () => [createElementVNode("span", null, toDisplayString$1($options.getOptionLabel(option)), 1)])], 46, _hoisted_16)), [[_directive_ripple]])], 64);
        }), 128)), $data.filterValue && (!items || items && items.length === 0) ? (openBlock(), createElementBlock("li", _hoisted_18, [renderSlot(_ctx.$slots, "emptyfilter", {}, () => [createTextVNode(toDisplayString$1($options.emptyFilterMessageText), 1)])])) : !$props.options || $props.options && $props.options.length === 0 ? (openBlock(), createElementBlock("li", _hoisted_19, [renderSlot(_ctx.$slots, "empty", {}, () => [createTextVNode(toDisplayString$1($options.emptyMessageText), 1)])])) : createCommentVNode("", true)], 14, _hoisted_14$1), !$props.options || $props.options && $props.options.length === 0 ? (openBlock(), createElementBlock("span", _hoisted_20, toDisplayString$1($options.emptyMessageText), 1)) : createCommentVNode("", true), createElementVNode("span", _hoisted_21, toDisplayString$1($options.selectedMessageText), 1)]),
        _: 2
      }, [_ctx.$slots.loader ? {
        name: "loader",
        fn: withCtx(({
          options
        }) => [renderSlot(_ctx.$slots, "loader", {
          options: options
        })]),
        key: "0"
      } : undefined]), 1040, ["items", "style", "disabled"])], 4), renderSlot(_ctx.$slots, "footer", {
        value: $props.modelValue,
        options: $options.visibleOptions
      }), createElementVNode("span", {
        ref: "lastHiddenFocusableElementOnOverlay",
        role: "presentation",
        "aria-hidden": "true",
        class: "p-hidden-accessible p-hidden-focusable",
        tabindex: 0,
        onFocus: _cache[12] || (_cache[12] = (...args) => $options.onLastHiddenFocus && $options.onLastHiddenFocus(...args))
      }, null, 544)], 16)) : createCommentVNode("", true)]),
      _: 3
    }, 8, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])]),
    _: 3
  }, 8, ["appendTo"])], 2);
}

function styleInject$6(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$b = "\n.p-multiselect {\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    cursor: pointer;\n    position: relative;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n}\n.p-multiselect-trigger {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    -ms-flex-negative: 0;\n        flex-shrink: 0;\n}\n.p-multiselect-label-container {\n    overflow: hidden;\n    -webkit-box-flex: 1;\n        -ms-flex: 1 1 auto;\n            flex: 1 1 auto;\n    cursor: pointer;\n}\n.p-multiselect-label {\n    display: block;\n    white-space: nowrap;\n    cursor: pointer;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n.p-multiselect-label-empty {\n    overflow: hidden;\n    visibility: hidden;\n}\n.p-multiselect-token {\n    cursor: default;\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-flex: 0;\n        -ms-flex: 0 0 auto;\n            flex: 0 0 auto;\n}\n.p-multiselect-token-icon {\n    cursor: pointer;\n}\n.p-multiselect .p-multiselect-panel {\n    min-width: 100%;\n}\n.p-multiselect-panel {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.p-multiselect-items-wrapper {\n    overflow: auto;\n}\n.p-multiselect-items {\n    margin: 0;\n    padding: 0;\n    list-style-type: none;\n}\n.p-multiselect-item {\n    cursor: pointer;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    font-weight: normal;\n    white-space: nowrap;\n    position: relative;\n    overflow: hidden;\n}\n.p-multiselect-item-group {\n    cursor: auto;\n}\n.p-multiselect-header {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: justify;\n        -ms-flex-pack: justify;\n            justify-content: space-between;\n}\n.p-multiselect-filter-container {\n    position: relative;\n    -webkit-box-flex: 1;\n        -ms-flex: 1 1 auto;\n            flex: 1 1 auto;\n}\n.p-multiselect-filter-icon {\n    position: absolute;\n    top: 50%;\n    margin-top: -0.5rem;\n}\n.p-multiselect-filter-container .p-inputtext {\n    width: 100%;\n}\n.p-multiselect-close {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    -ms-flex-negative: 0;\n        flex-shrink: 0;\n    overflow: hidden;\n    position: relative;\n    margin-left: auto;\n}\n.p-fluid .p-multiselect {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n}\n";
styleInject$6(css_248z$b);
script$D.render = render$a;

var script$C = {
  name: 'Chips',
  emits: ['update:modelValue', 'add', 'remove', 'focus', 'blur'],
  props: {
    modelValue: {
      type: Array,
      default: null
    },
    max: {
      type: Number,
      default: null
    },
    separator: {
      type: [String, Object],
      default: null
    },
    addOnBlur: {
      type: Boolean,
      default: null
    },
    allowDuplicate: {
      type: Boolean,
      default: true
    },
    placeholder: {
      type: String,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    inputId: {
      type: String,
      default: null
    },
    inputClass: {
      type: String,
      default: null
    },
    inputStyle: {
      type: null,
      default: null
    },
    inputProps: {
      type: null,
      default: null
    },
    removeTokenIcon: {
      type: String,
      default: 'pi pi-times-circle'
    },
    'aria-labelledby': {
      type: String,
      default: null
    },
    'aria-label': {
      type: String,
      default: null
    }
  },

  data() {
    return {
      id: UniqueComponentId(),
      inputValue: null,
      focused: false,
      focusedIndex: null
    };
  },

  methods: {
    onWrapperClick() {
      this.$refs.input.focus();
    },

    onInput(event) {
      this.inputValue = event.target.value;
      this.focusedIndex = null;
    },

    onFocus(event) {
      this.focused = true;
      this.focusedIndex = null;
      this.$emit('focus', event);
    },

    onBlur(event) {
      this.focused = false;
      this.focusedIndex = null;

      if (this.addOnBlur) {
        this.addItem(event, event.target.value, false);
      }

      this.$emit('blur', event);
    },

    onKeyDown(event) {
      const inputValue = event.target.value;

      switch (event.code) {
        case 'Backspace':
          if (inputValue.length === 0 && this.modelValue && this.modelValue.length > 0) {
            if (this.focusedIndex !== null) {
              this.removeItem(event, this.focusedIndex);
            } else this.removeItem(event, this.modelValue.length - 1);
          }

          break;

        case 'Enter':
          if (inputValue && inputValue.trim().length && !this.maxedOut) {
            this.addItem(event, inputValue, true);
          }

          break;

        case 'ArrowLeft':
          if (inputValue.length === 0 && this.modelValue && this.modelValue.length > 0) {
            this.$refs.container.focus();
          }

          break;

        case 'ArrowRight':
          event.stopPropagation();
          break;

        default:
          if (this.separator) {
            if (this.separator === event.key || event.key.match(this.separator)) {
              this.addItem(event, inputValue, true);
            }
          }

          break;
      }
    },

    onPaste(event) {
      if (this.separator) {
        let pastedData = (event.clipboardData || window['clipboardData']).getData('Text');

        if (pastedData) {
          let value = this.modelValue || [];
          let pastedValues = pastedData.split(this.separator);
          pastedValues = pastedValues.filter(val => this.allowDuplicate || value.indexOf(val) === -1);
          value = [...value, ...pastedValues];
          this.updateModel(event, value, true);
        }
      }
    },

    onContainerFocus() {
      this.focused = true;
    },

    onContainerBlur() {
      this.focusedIndex = -1;
      this.focused = false;
    },

    onContainerKeyDown(event) {
      switch (event.code) {
        case 'ArrowLeft':
          this.onArrowLeftKeyOn(event);
          break;

        case 'ArrowRight':
          this.onArrowRightKeyOn(event);
          break;

        case 'Backspace':
          this.onBackspaceKeyOn(event);
          break;
      }
    },

    onArrowLeftKeyOn() {
      if (this.inputValue.length === 0 && this.modelValue && this.modelValue.length > 0) {
        this.focusedIndex = this.focusedIndex === null ? this.modelValue.length - 1 : this.focusedIndex - 1;
        if (this.focusedIndex < 0) this.focusedIndex = 0;
      }
    },

    onArrowRightKeyOn() {
      if (this.inputValue.length === 0 && this.modelValue && this.modelValue.length > 0) {
        if (this.focusedIndex === this.modelValue.length - 1) {
          this.focusedIndex = null;
          this.$refs.input.focus();
        } else {
          this.focusedIndex++;
        }
      }
    },

    onBackspaceKeyOn(event) {
      if (this.focusedIndex !== null) {
        this.removeItem(event, this.focusedIndex);
      }
    },

    updateModel(event, value, preventDefault) {
      this.$emit('update:modelValue', value);
      this.$emit('add', {
        originalEvent: event,
        value: value
      });
      this.$refs.input.value = '';
      this.inputValue = '';
      setTimeout(() => {
        this.maxedOut && (this.focused = false);
      }, 0);

      if (preventDefault) {
        event.preventDefault();
      }
    },

    addItem(event, item, preventDefault) {
      if (item && item.trim().length) {
        let value = this.modelValue ? [...this.modelValue] : [];

        if (this.allowDuplicate || value.indexOf(item) === -1) {
          value.push(item);
          this.updateModel(event, value, preventDefault);
        }
      }
    },

    removeItem(event, index) {
      if (this.disabled) {
        return;
      }

      let values = [...this.modelValue];
      const removedItem = values.splice(index, 1);
      this.focusedIndex = null;
      this.$refs.input.focus();
      this.$emit('update:modelValue', values);
      this.$emit('remove', {
        originalEvent: event,
        value: removedItem
      });
    }

  },
  computed: {
    maxedOut() {
      return this.max && this.modelValue && this.max === this.modelValue.length;
    },

    containerClass() {
      return ['p-chips p-component p-inputwrapper', {
        'p-disabled': this.disabled,
        'p-focus': this.focused,
        'p-inputwrapper-filled': this.modelValue && this.modelValue.length || this.inputValue && this.inputValue.length,
        'p-inputwrapper-focus': this.focused
      }];
    },

    focusedOptionId() {
      return this.focusedIndex !== null ? `${this.id}_chips_item_${this.focusedIndex}` : null;
    }

  }
};
const _hoisted_1$g = ["aria-labelledby", "aria-label", "aria-activedescendant"];
const _hoisted_2$d = ["id", "aria-label", "aria-setsize", "aria-posinset"];
const _hoisted_3$b = {
  class: "p-chips-token-label"
};
const _hoisted_4$7 = ["onClick"];
const _hoisted_5$7 = {
  class: "p-chips-input-token",
  role: "option"
};
const _hoisted_6$6 = ["id", "disabled", "placeholder"];

function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass($options.containerClass)
  }, [createElementVNode("ul", {
    ref: "container",
    class: "p-inputtext p-chips-multiple-container",
    tabindex: "-1",
    role: "listbox",
    "aria-orientation": "horizontal",
    "aria-labelledby": _ctx.ariaLabelledby,
    "aria-label": _ctx.ariaLabel,
    "aria-activedescendant": $data.focused ? $options.focusedOptionId : undefined,
    onClick: _cache[5] || (_cache[5] = $event => $options.onWrapperClick()),
    onFocus: _cache[6] || (_cache[6] = (...args) => $options.onContainerFocus && $options.onContainerFocus(...args)),
    onBlur: _cache[7] || (_cache[7] = (...args) => $options.onContainerBlur && $options.onContainerBlur(...args)),
    onKeydown: _cache[8] || (_cache[8] = (...args) => $options.onContainerKeyDown && $options.onContainerKeyDown(...args))
  }, [(openBlock(true), createElementBlock(Fragment, null, renderList($props.modelValue, (val, i) => {
    return openBlock(), createElementBlock("li", {
      key: `${i}_${val}`,
      id: $data.id + '_chips_item_' + i,
      role: "option",
      class: normalizeClass(['p-chips-token', {
        'p-focus': $data.focusedIndex === i
      }]),
      "aria-label": val,
      "aria-selected": true,
      "aria-setsize": $props.modelValue.length,
      "aria-posinset": i + 1
    }, [renderSlot(_ctx.$slots, "chip", {
      value: val
    }, () => [createElementVNode("span", _hoisted_3$b, toDisplayString$1(val), 1)]), createElementVNode("span", {
      class: normalizeClass(['p-chips-token-icon', $props.removeTokenIcon]),
      onClick: $event => $options.removeItem($event, i),
      "aria-hidden": "true"
    }, null, 10, _hoisted_4$7)], 10, _hoisted_2$d);
  }), 128)), createElementVNode("li", _hoisted_5$7, [createElementVNode("input", mergeProps({
    ref: "input",
    id: $props.inputId,
    type: "text",
    class: $props.inputClass,
    style: $props.inputStyle,
    disabled: $props.disabled || $options.maxedOut,
    placeholder: $props.placeholder,
    onFocus: _cache[0] || (_cache[0] = $event => $options.onFocus($event)),
    onBlur: _cache[1] || (_cache[1] = $event => $options.onBlur($event)),
    onInput: _cache[2] || (_cache[2] = (...args) => $options.onInput && $options.onInput(...args)),
    onKeydown: _cache[3] || (_cache[3] = $event => $options.onKeyDown($event)),
    onPaste: _cache[4] || (_cache[4] = $event => $options.onPaste($event))
  }, $props.inputProps), null, 16, _hoisted_6$6)])], 40, _hoisted_1$g)], 2);
}

function styleInject$5(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$a = "\n.p-chips {\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n}\n.p-chips-multiple-container {\n    margin: 0;\n    padding: 0;\n    list-style-type: none;\n    cursor: text;\n    overflow: hidden;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -ms-flex-wrap: wrap;\n        flex-wrap: wrap;\n}\n.p-chips-token {\n    cursor: default;\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-flex: 0;\n        -ms-flex: 0 0 auto;\n            flex: 0 0 auto;\n}\n.p-chips-input-token {\n    -webkit-box-flex: 1;\n        -ms-flex: 1 1 auto;\n            flex: 1 1 auto;\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n}\n.p-chips-token-icon {\n    cursor: pointer;\n}\n.p-chips-input-token input {\n    border: 0 none;\n    outline: 0 none;\n    background-color: transparent;\n    margin: 0;\n    padding: 0;\n    -webkit-box-shadow: none;\n            box-shadow: none;\n    border-radius: 0;\n    width: 100%;\n}\n.p-fluid .p-chips {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n}\n";
styleInject$5(css_248z$a);
script$C.render = render$9;

var script$B = {
  props: {
    modelValue : [Array],
    field : Object
},
  emits: [
    "update:modelValue"
],
  setup(__props, { emit: emits }) {

const props = __props;






const value = computed({
    get() {
        return props.modelValue;
    },
    set(val) {
        if (val.length == 0) val =null;
        emits('update:modelValue', val);
    }
});

const model = inject("model");
const store = new Model(model);
const id = (store.active_id) ? store.active_id : store.parent_id;
const client = inject("client");

const options = ref([]);

if (props.field.reference || props.field.recursive) {
    onMounted(() => {
        props.field.getOptions(client, model, id)
        .then(response => options.value =response);
    });
} else if (props.field.name == '--id') {
    let vals = [];
    for(let row of store.data) {
        vals.push({'key' : row['--id'], value : getLabel(store.fields, row) });
    }
    options.value = vals;
}



return (_ctx, _cache) => {
  return (__props.field.reference || __props.field.name =='--id')
    ? (openBlock(), createBlock(unref(script$D), {
        key: 0,
        placeholder: "Please Select",
        field: __props.field,
        options: options.value,
        optionLabel: "value",
        optionValue: "key",
        modelValue: unref(value),
        "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (isRef(value) ? (value).value = $event : null))
      }, null, 8 /* PROPS */, ["field", "options", "modelValue"]))
    : (openBlock(), createBlock(unref(script$C), {
        key: 1,
        modelValue: unref(value),
        "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => (isRef(value) ? (value).value = $event : null))
      }, null, 8 /* PROPS */, ["modelValue"]))
}
}

};

script$B.__file = "presstojam/src/components/filter/id-filter.vue";

var script$A = {
  props: {
    bind : Object
},
  setup(__props) {

const props = __props;




const repo = inject("repo");

const value = computed({
    get() {
        return repo.filters[props.bind.cell.name];
    },
    set(ival) {
        let obj = null;
        if (ival) {
            obj = {};
            if (ival[0]) obj.min = props.bind.cell.buildString(ival[0]);
            if (ival[1]) obj.max = props.bind.cell.buildString(ival[1]);
        }
        const filters = repo.filters;
        if (filters[props.bind.cell.name] != ival) {
            filters[props.bind.cell.name] = ival;
            repo.reload();
        }
    }
});




return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$1c), {
    modelValue: unref(value),
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (isRef(value) ? (value).value = $event : null)),
    selectionMode: "range",
    manualInput: false
  }, null, 8 /* PROPS */, ["modelValue"]))
}
}

};

script$A.__file = "presstojam/src/components/filter/time-filter.vue";

var script$z = {
  props: {
    bind : Object
},
  setup(__props) {

const props = __props;



const repo = inject("repo");

const options = ref([]);

const value = computed({
    get() {
        return repo.filters[props.bind.cell.name];
    },
    set(val) {
        const filter = repo.filters;
        if (!val.length) {
            if (filter[props.bind.name]) {
                delete filter[props.bind.cell.name];
                repo.reload();
            }
        } else {
            if (props.bind.cell.isEnum()) {
                filter[props.bind.cell.name] = val;
            } else {
                const oval = [];
                for(const i in val) {
                    oval.push("%" + val[i] + "%");
                }
            }
            repo.reload();
        }
    }
});

const tag = computed(() => {
if (props.bind.cell.isEnum()) {
    const coptions = [];
    for(let i in props.bind.cell.list) {
        coptions.push({ key : props.bind.cell.list[i], value : props.bind.cell.list[i] });
    }

    options.value = coptions;
    return "select";
} else {
    return "input";
}
});



return (_ctx, _cache) => {
  return (unref(tag)=='select')
    ? (openBlock(), createBlock(unref(script$D), {
        key: 0,
        display: "chip",
        placeholder: "Please Select",
        modelValue: unref(value),
        "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (isRef(value) ? (value).value = $event : null)),
        options: options.value,
        optionLabel: "key",
        optionValue: "value"
      }, null, 8 /* PROPS */, ["modelValue", "options"]))
    : (unref(tag)=='input')
      ? (openBlock(), createBlock(unref(script$C), {
          key: 1,
          modelValue: unref(value),
          "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => (isRef(value) ? (value).value = $event : null))
        }, null, 8 /* PROPS */, ["modelValue"]))
      : createCommentVNode("v-if", true)
}
}

};

script$z.__file = "presstojam/src/components/filter/string-filter.vue";

var script$y = {
  props: {
    bind : Object,
},
  setup(__props) {

 



return (_ctx, _cache) => {
  return (__props.bind.cell.type=='number')
    ? (openBlock(), createBlock(script$F, {
        key: 0,
        bind: __props.bind
      }, null, 8 /* PROPS */, ["bind"]))
    : (__props.bind.cell.type=='flag')
      ? (openBlock(), createBlock(script$E, {
          key: 1,
          bind: __props.bind
        }, null, 8 /* PROPS */, ["bind"]))
      : (__props.bind.cell.type=='id')
        ? (openBlock(), createBlock(script$B, {
            key: 2,
            bind: __props.bind
          }, null, 8 /* PROPS */, ["bind"]))
        : (__props.bind.cell.type=='time')
          ? (openBlock(), createBlock(script$A, {
              key: 3,
              bind: __props.bind
            }, null, 8 /* PROPS */, ["bind"]))
          : (__props.bind.cell.type=='string')
            ? (openBlock(), createBlock(script$z, {
                key: 4,
                bind: __props.bind
              }, null, 8 /* PROPS */, ["bind"]))
            : createCommentVNode("v-if", true)
}
}

};

script$y.__file = "presstojam/src/components/filter/filter-field.vue";

const _hoisted_1$f = { class: "ptj-filter" };
   
   
var script$x = {
  props: {
    bind : {
        type : Object,
        required : true
    }
   },
  setup(__props) {

const props = __props;

   
   

   const model = inject("model");
  
   let overlay = new ref();

  
   const val = computed({
        get() {
            return props.bind.value;
        },
        set(val) {
            if(Array.isArray(val)) {
                for(let vl of val) {
                    const res = props.bind.cell.validate(vl);
                    if (res) {
                        break;
                    }
                }
            } else {
                props.bind.cell.validate(val);
            }
        }
    });


   function toggle(e) {
        overlay.value.toggle(e);
   }

   const badge = computed(() => {
        if (props.bind.value) {
            if (Array.isArray(props.bind.value)) return props.bind.value.length.toString();
            else return "1";
        } else {
            return "";
        }
   });

   

return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("div", _hoisted_1$f, [
    createVNode(unref(script$1L), {
      type: "button",
      label: _ctx.$t('models.' + unref(model).name + '.fields.' + __props.bind.cell.name + '.label'),
      onClick: toggle,
      "aria-haspopup": "true",
      "aria-controls": "overlay",
      badge: unref(badge),
      class: "p-button-secondary"
    }, null, 8 /* PROPS */, ["label", "badge"]),
    createVNode(unref(script$S), {
      ref_key: "overlay",
      ref: overlay,
      appendTo: "body",
      showCloseIcon: true,
      id: 'overlay_' + __props.bind.cell.name,
      style: {"width":"450px"},
      breakpoints: {'960px': '75vw'}
    }, {
      default: withCtx(() => [
        createElementVNode("div", null, [
          createVNode(script$y, {
            bind: __props.bind,
            modelValue: unref(val),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (isRef(val) ? (val).value = $event : null))
          }, null, 8 /* PROPS */, ["bind", "modelValue"])
        ])
      ]),
      _: 1 /* STABLE */
    }, 8 /* PROPS */, ["id"])
  ]))
}
}

};

script$x.__file = "presstojam/src/components/filter/filter.vue";

var filter = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': script$x
});

const _hoisted_1$e = /*#__PURE__*/createElementVNode("i", { class: "pi pi-filter" }, null, -1 /* HOISTED */);
const _hoisted_2$c = /*#__PURE__*/createTextVNode(" Filters ");
const _hoisted_3$a = { class: "p-buttonset" };


var script$w = {
  props: {
    repo : {
        type : Object,
        required : true
    },
    name : String
},
  setup(__props) {

const props = __props;




const model = props.repo.model;

provide("model", model);
provide("repo", props.repo);

const fields = model.getEnabledCells();
const filtercells = {};

for(const i in fields) {
    const field = fields[i];
    if (i == "--owner" || i == "--sort" || i== "--parent" || field.type == "asset" || field.type == "json" || field.encrypted) continue;
    filtercells[i] = new Bind(field);
}



return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$13), {
    toggleable: true,
    collapsed: true
  }, {
    legend: withCtx(() => [
      _hoisted_1$e,
      _hoisted_2$c
    ]),
    default: withCtx(() => [
      createElementVNode("span", _hoisted_3$a, [
        (openBlock(), createElementBlock(Fragment, null, renderList(filtercells, (field) => {
          return createVNode(script$x, {
            class: "ptj-filter",
            bind: field,
            key: field.name
          }, null, 8 /* PROPS */, ["bind"])
        }), 64 /* STABLE_FRAGMENT */))
      ])
    ]),
    _: 1 /* STABLE */
  }))
}
}

};

var css_248z$9 = "\n.filter-form-vue-vue-type-style-index-0-id-46638ba7-lang_ptj-filter__24-2N { \r\n    display : inline-block;\n}\r\n";
styleInject$t(css_248z$9);

script$w.__file = "presstojam/src/components/filter/filter-form.vue";

const _hoisted_1$d = /*#__PURE__*/createElementVNode("i", { class: "pi pi-filter" }, null, -1 /* HOISTED */);
const _hoisted_2$b = /*#__PURE__*/createTextVNode(" Groups ");
const _hoisted_3$9 = { style: {"text-align":"right"} };


var script$v = {
  props: {
    repo : Object,
    name : String
},
  setup(__props) {

const props = __props;



const groups = ref(props.repo.groups);
const fields = props.repo.model.fields;

const cells = computed(() => {
    const group_cells = [];
    for(let i in fields) {
        const field = fields[i];
        if (field.type == "id") {
            if (field.reference_type == ReferenceTypes.REFERENCE) group_cells.push(field);
        } else if (field.type == "flag" || (field.type == "string" && field.isEnum())) {
            group_cells.push(field);
        }
    }
    return group_cells;
});


function update() {
    props.repo.groups = groups.value;
    props.repo.reload();
    trigger("group_form", props.name, groups.value);
} 

return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$13), {
    toggleable: true,
    collapsed: true
  }, {
    legend: withCtx(() => [
      _hoisted_1$d,
      _hoisted_2$b
    ]),
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(cells), (cell) => {
        return (openBlock(), createElementBlock("span", null, [
          createElementVNode("label", null, toDisplayString$1(cell.name), 1 /* TEXT */),
          createVNode(unref(script$1I), {
            name: "group",
            modelValue: groups.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((groups).value = $event)),
            value: cell.name
          }, null, 8 /* PROPS */, ["modelValue", "value"])
        ]))
      }), 256 /* UNKEYED_FRAGMENT */)),
      createElementVNode("p", _hoisted_3$9, [
        createVNode(unref(script$1L), {
          label: _ctx.$t('btns.filter'),
          onClick: update
        }, null, 8 /* PROPS */, ["label"])
      ])
    ]),
    _: 1 /* STABLE */
  }))
}
}

};

script$v.__file = "presstojam/src/components/group/group-form.vue";

class ReportData extends Data {
  constructor(model, field) {
    super(model);
    this._aggregate = null;
    this._filters = [];
    this._field = field;
    this._aggregate = "COUNT";
    this._groups = [];
    this._time_group;
    this._load_line_promise = null;
    this._data.value = [];
  }

  get filters() {
    return this._filters;
  }

  set filters(filters) {
    this._filters = filters;
  }

  get groups() {
    return this._groups;
  }

  set groups(groups) {
    this._groups = groups;
  }

  get aggregate() {
    return this._aggregate;
  }

  set aggregate(agg) {
    this._aggregate = agg;
  }

  set timegroup(timegroup) {
    this._time_group = timegroup;
  }

  get timegroup() {
    return this._time_group;
  }

  get field() {
    return this._field;
  }

  get type() {
    return "report";
  }

  getDataSets(response) {
    const data_sets = {};
    if (response.length == 0) return data_sets;

    if (this._groups.length == 0) {
      data_sets["main"] = [response[0].count];
    } else {
      for (const row of response) {
        let keys = [];

        for (const group of this._groups) {
          keys.push(group + ":" + row[group]);
        }

        const key = keys.join(", ");
        if (!data_sets[key]) data_sets[key] = [];
        data_sets[key].push(row.count);
      }
    }

    return data_sets;
  }

  load(type) {
    if (!this._load_promise) {
      this._is_loading.value = true;
      this._model.limit = 0;
      const groups = { ...this._groups
      };

      if (type == 'line') {
        if (this._time_group) {
          groups.push({
            name: '--created',
            func: 'DATEPART',
            args: {}
          });
        }
      }

      this._model.group = groups;
      this._load_promise = this._model.loadReport(this._filters, this._field, this._aggregate).then(response => {
        const data = this.getDataSets(response);
        const datasets = [];

        for (const key in data) {
          datasets.push({
            label: key,
            data: data[key]
          });
        }

        this._is_loading.value = false;
        this._data = datasets;
        return this._data;
      }).catch(e => {
        console.log(e);
        this._is_loading.value = false;
        throw e;
      });
    }

    return this._load_promise;
  }

  reload(type) {
    return this.load(type);
  }

}

var script$u = {
  name: 'Toolbar',
  props: {
    'aria-labelledby': {
      type: String,
      default: null
    }
  }
};
const _hoisted_1$c = ["aria-labelledby"];
const _hoisted_2$a = {
  class: "p-toolbar-group-left"
};
const _hoisted_3$8 = {
  class: "p-toolbar-group-right"
};

function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "p-toolbar p-component",
    role: "toolbar",
    "aria-labelledby": _ctx.ariaLabelledby
  }, [createElementVNode("div", _hoisted_2$a, [renderSlot(_ctx.$slots, "start")]), createElementVNode("div", _hoisted_3$8, [renderSlot(_ctx.$slots, "end")])], 8, _hoisted_1$c);
}

function styleInject$4(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$8 = "\n.p-toolbar {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: justify;\n        -ms-flex-pack: justify;\n            justify-content: space-between;\n    -ms-flex-wrap: wrap;\n        flex-wrap: wrap;\n}\n.p-toolbar-group-left,\n.p-toolbar-group-right {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n";
styleInject$4(css_248z$8);
script$u.render = render$8;

var script$t = {
  name: 'TabView',
  emits: ['update:activeIndex', 'tab-change', 'tab-click'],
  props: {
    activeIndex: {
      type: Number,
      default: 0
    },
    lazy: {
      type: Boolean,
      default: false
    },
    scrollable: {
      type: Boolean,
      default: false
    },
    tabindex: {
      type: Number,
      default: 0
    },
    selectOnFocus: {
      type: Boolean,
      default: false
    },
    previousButtonProps: null,
    nextButtonProps: null
  },

  data() {
    return {
      d_activeIndex: this.activeIndex,
      isPrevButtonDisabled: true,
      isNextButtonDisabled: false
    };
  },

  watch: {
    activeIndex(newValue) {
      this.d_activeIndex = newValue;
      this.scrollInView({
        index: newValue
      });
    }

  },

  mounted() {
    this.updateInkBar();
    this.scrollable && this.updateButtonState();
  },

  updated() {
    this.updateInkBar();
  },

  methods: {
    isTabPanel(child) {
      return child.type.name === 'TabPanel';
    },

    isTabActive(index) {
      return this.d_activeIndex === index;
    },

    getTabProp(tab, name) {
      return tab.props ? tab.props[name] : undefined;
    },

    getKey(tab, index) {
      return this.getTabProp(tab, 'header') || index;
    },

    getTabHeaderActionId(index) {
      return `${this.id}_${index}_header_action`;
    },

    getTabContentId(index) {
      return `${this.id}_${index}_content`;
    },

    onScroll(event) {
      this.scrollable && this.updateButtonState();
      event.preventDefault();
    },

    onPrevButtonClick() {
      const content = this.$refs.content;
      const width = DomHandler.getWidth(content) - this.getVisibleButtonWidths();
      const pos = content.scrollLeft - width;
      content.scrollLeft = pos <= 0 ? 0 : pos;
    },

    onNextButtonClick() {
      const content = this.$refs.content;
      const width = DomHandler.getWidth(content) - this.getVisibleButtonWidths();
      const pos = content.scrollLeft + width;
      const lastPos = content.scrollWidth - width;
      content.scrollLeft = pos >= lastPos ? lastPos : pos;
    },

    onTabClick(event, tab, index) {
      this.changeActiveIndex(event, tab, index);
      this.$emit('tab-click', {
        originalEvent: event,
        index
      });
    },

    onTabKeyDown(event, tab, index) {
      switch (event.code) {
        case 'ArrowLeft':
          this.onTabArrowLeftKey(event);
          break;

        case 'ArrowRight':
          this.onTabArrowRightKey(event);
          break;

        case 'Home':
          this.onTabHomeKey(event);
          break;

        case 'End':
          this.onTabEndKey(event);
          break;

        case 'PageDown':
          this.onPageDownKey(event);
          break;

        case 'PageUp':
          this.onPageUpKey(event);
          break;

        case 'Enter':
        case 'Space':
          this.onTabEnterKey(event, tab, index);
          break;
      }
    },

    onTabArrowRightKey(event) {
      const nextHeaderAction = this.findNextHeaderAction(event.target.parentElement);
      nextHeaderAction ? this.changeFocusedTab(event, nextHeaderAction) : this.onTabHomeKey(event);
      event.preventDefault();
    },

    onTabArrowLeftKey(event) {
      const prevHeaderAction = this.findPrevHeaderAction(event.target.parentElement);
      prevHeaderAction ? this.changeFocusedTab(event, prevHeaderAction) : this.onTabEndKey(event);
      event.preventDefault();
    },

    onTabHomeKey(event) {
      const firstHeaderAction = this.findFirstHeaderAction();
      this.changeFocusedTab(event, firstHeaderAction);
      event.preventDefault();
    },

    onTabEndKey(event) {
      const lastHeaderAction = this.findLastHeaderAction();
      this.changeFocusedTab(event, lastHeaderAction);
      event.preventDefault();
    },

    onPageDownKey(event) {
      this.scrollInView({
        index: this.$refs.nav.children.length - 2
      });
      event.preventDefault();
    },

    onPageUpKey(event) {
      this.scrollInView({
        index: 0
      });
      event.preventDefault();
    },

    onTabEnterKey(event, tab, index) {
      this.changeActiveIndex(event, tab, index);
      event.preventDefault();
    },

    findNextHeaderAction(tabElement, selfCheck = false) {
      const headerElement = selfCheck ? tabElement : tabElement.nextElementSibling;
      return headerElement ? DomHandler.hasClass(headerElement, 'p-disabled') || DomHandler.hasClass(headerElement, 'p-tabview-ink-bar') ? this.findNextHeaderAction(headerElement) : DomHandler.findSingle(headerElement, '.p-tabview-header-action') : null;
    },

    findPrevHeaderAction(tabElement, selfCheck = false) {
      const headerElement = selfCheck ? tabElement : tabElement.previousElementSibling;
      return headerElement ? DomHandler.hasClass(headerElement, 'p-disabled') || DomHandler.hasClass(headerElement, 'p-tabview-ink-bar') ? this.findPrevHeaderAction(headerElement) : DomHandler.findSingle(headerElement, '.p-tabview-header-action') : null;
    },

    findFirstHeaderAction() {
      return this.findNextHeaderAction(this.$refs.nav.firstElementChild, true);
    },

    findLastHeaderAction() {
      return this.findPrevHeaderAction(this.$refs.nav.lastElementChild, true);
    },

    changeActiveIndex(event, tab, index) {
      if (!this.getTabProp(tab, 'disabled') && this.d_activeIndex !== index) {
        this.d_activeIndex = index;
        this.$emit('update:activeIndex', index);
        this.$emit('tab-change', {
          originalEvent: event,
          index
        });
        this.scrollInView({
          index
        });
      }
    },

    changeFocusedTab(event, element) {
      if (element) {
        DomHandler.focus(element);
        this.scrollInView({
          element
        });

        if (this.selectOnFocus) {
          const index = parseInt(element.parentElement.dataset.index, 10);
          const tab = this.tabs[index];
          this.changeActiveIndex(event, tab, index);
        }
      }
    },

    scrollInView({
      element,
      index = -1
    }) {
      const currentElement = element || this.$refs.nav.children[index];

      if (currentElement) {
        currentElement.scrollIntoView && currentElement.scrollIntoView({
          block: 'nearest'
        });
      }
    },

    updateInkBar() {
      let tabHeader = this.$refs.nav.children[this.d_activeIndex];
      this.$refs.inkbar.style.width = DomHandler.getWidth(tabHeader) + 'px';
      this.$refs.inkbar.style.left = DomHandler.getOffset(tabHeader).left - DomHandler.getOffset(this.$refs.nav).left + 'px';
    },

    updateButtonState() {
      const content = this.$refs.content;
      const {
        scrollLeft,
        scrollWidth
      } = content;
      const width = DomHandler.getWidth(content);
      this.isPrevButtonDisabled = scrollLeft === 0;
      this.isNextButtonDisabled = parseInt(scrollLeft) === scrollWidth - width;
    },

    getVisibleButtonWidths() {
      const {
        prevBtn,
        nextBtn
      } = this.$refs;
      return [prevBtn, nextBtn].reduce((acc, el) => el ? acc + DomHandler.getWidth(el) : acc, 0);
    },

    getTabHeaderClass(tab, i) {
      return ['p-tabview-header', this.getTabProp(tab, 'headerClass'), {
        'p-highlight': this.d_activeIndex === i,
        'p-disabled': this.getTabProp(tab, 'disabled')
      }];
    },

    getTabContentClass(tab) {
      return ['p-tabview-panel', this.getTabProp(tab, 'contentClass')];
    }

  },
  computed: {
    contentClasses() {
      return ['p-tabview p-component', {
        'p-tabview-scrollable': this.scrollable
      }];
    },

    tabs() {
      return this.$slots.default().reduce((tabs, child) => {
        if (this.isTabPanel(child)) {
          tabs.push(child);
        } else if (child.children && child.children instanceof Array) {
          child.children.forEach(nestedChild => {
            if (this.isTabPanel(nestedChild)) {
              tabs.push(nestedChild);
            }
          });
        }

        return tabs;
      }, []);
    },

    prevButtonAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.previous : undefined;
    },

    nextButtonAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.next : undefined;
    },

    id() {
      return this.$attrs.id || UniqueComponentId();
    }

  },
  directives: {
    ripple: Ripple
  }
};
const _hoisted_1$b = {
  class: "p-tabview-nav-container"
};
const _hoisted_2$9 = ["tabindex", "aria-label"];

const _hoisted_3$7 = /*#__PURE__*/createElementVNode("span", {
  class: "pi pi-chevron-left",
  "aria-hidden": "true"
}, null, -1);

const _hoisted_4$6 = [_hoisted_3$7];
const _hoisted_5$6 = {
  ref: "nav",
  class: "p-tabview-nav",
  role: "tablist"
};
const _hoisted_6$5 = ["data-index"];
const _hoisted_7$3 = ["id", "tabindex", "aria-disabled", "aria-selected", "aria-controls", "onClick", "onKeydown"];
const _hoisted_8$2 = {
  key: 0,
  class: "p-tabview-title"
};
const _hoisted_9 = {
  ref: "inkbar",
  class: "p-tabview-ink-bar",
  role: "presentation",
  "aria-hidden": "true"
};
const _hoisted_10 = ["tabindex", "aria-label"];

const _hoisted_11 = /*#__PURE__*/createElementVNode("span", {
  class: "pi pi-chevron-right",
  "aria-hidden": "true"
}, null, -1);

const _hoisted_12 = [_hoisted_11];
const _hoisted_13 = {
  class: "p-tabview-panels"
};
const _hoisted_14 = ["aria-labelledby"];

function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_ripple = resolveDirective("ripple");

  return openBlock(), createElementBlock("div", {
    class: normalizeClass($options.contentClasses)
  }, [createElementVNode("div", _hoisted_1$b, [$props.scrollable && !$data.isPrevButtonDisabled ? withDirectives((openBlock(), createElementBlock("button", mergeProps({
    key: 0,
    ref: "prevBtn",
    type: "button",
    class: "p-tabview-nav-prev p-tabview-nav-btn p-link",
    tabindex: $props.tabindex,
    "aria-label": $options.prevButtonAriaLabel,
    onClick: _cache[0] || (_cache[0] = (...args) => $options.onPrevButtonClick && $options.onPrevButtonClick(...args))
  }, $props.previousButtonProps), _hoisted_4$6, 16, _hoisted_2$9)), [[_directive_ripple]]) : createCommentVNode("", true), createElementVNode("div", {
    ref: "content",
    class: "p-tabview-nav-content",
    onScroll: _cache[1] || (_cache[1] = (...args) => $options.onScroll && $options.onScroll(...args))
  }, [createElementVNode("ul", _hoisted_5$6, [(openBlock(true), createElementBlock(Fragment, null, renderList($options.tabs, (tab, i) => {
    return openBlock(), createElementBlock("li", mergeProps({
      key: $options.getKey(tab, i),
      style: $options.getTabProp(tab, 'headerStyle'),
      class: $options.getTabHeaderClass(tab, i),
      role: "presentation",
      "data-index": i
    }, $options.getTabProp(tab, 'headerProps')), [withDirectives((openBlock(), createElementBlock("a", mergeProps({
      id: $options.getTabHeaderActionId(i),
      class: "p-tabview-nav-link p-tabview-header-action",
      tabindex: $options.getTabProp(tab, 'disabled') || !$options.isTabActive(i) ? -1 : $props.tabindex,
      role: "tab",
      "aria-disabled": $options.getTabProp(tab, 'disabled'),
      "aria-selected": $options.isTabActive(i),
      "aria-controls": $options.getTabContentId(i),
      onClick: $event => $options.onTabClick($event, tab, i),
      onKeydown: $event => $options.onTabKeyDown($event, tab, i)
    }, $options.getTabProp(tab, 'headerActionProps')), [tab.props && tab.props.header ? (openBlock(), createElementBlock("span", _hoisted_8$2, toDisplayString$1(tab.props.header), 1)) : createCommentVNode("", true), tab.children && tab.children.header ? (openBlock(), createBlock(resolveDynamicComponent(tab.children.header), {
      key: 1
    })) : createCommentVNode("", true)], 16, _hoisted_7$3)), [[_directive_ripple]])], 16, _hoisted_6$5);
  }), 128)), createElementVNode("li", _hoisted_9, null, 512)], 512)], 544), $props.scrollable && !$data.isNextButtonDisabled ? withDirectives((openBlock(), createElementBlock("button", mergeProps({
    key: 1,
    ref: "nextBtn",
    type: "button",
    class: "p-tabview-nav-next p-tabview-nav-btn p-link",
    tabindex: $props.tabindex,
    "aria-label": $options.nextButtonAriaLabel,
    onClick: _cache[2] || (_cache[2] = (...args) => $options.onNextButtonClick && $options.onNextButtonClick(...args))
  }, $props.nextButtonProps), _hoisted_12, 16, _hoisted_10)), [[_directive_ripple]]) : createCommentVNode("", true)]), createElementVNode("div", _hoisted_13, [(openBlock(true), createElementBlock(Fragment, null, renderList($options.tabs, (tab, i) => {
    return openBlock(), createElementBlock(Fragment, {
      key: $options.getKey(tab, i)
    }, [($props.lazy ? $options.isTabActive(i) : true) ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
      key: 0,
      style: $options.getTabProp(tab, 'contentStyle'),
      class: $options.getTabContentClass(tab),
      role: "tabpanel",
      "aria-labelledby": $options.getTabHeaderActionId(i)
    }, $options.getTabProp(tab, 'contentProps')), [(openBlock(), createBlock(resolveDynamicComponent(tab)))], 16, _hoisted_14)), [[vShow, $props.lazy ? true : $options.isTabActive(i)]]) : createCommentVNode("", true)], 64);
  }), 128))])], 2);
}

function styleInject$3(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$7 = "\n.p-tabview-nav-container {\n    position: relative;\n}\n.p-tabview-scrollable .p-tabview-nav-container {\n    overflow: hidden;\n}\n.p-tabview-nav-content {\n    overflow-x: auto;\n    overflow-y: hidden;\n    scroll-behavior: smooth;\n    scrollbar-width: none;\n    -ms-scroll-chaining: contain auto;\n        overscroll-behavior: contain auto;\n}\n.p-tabview-nav {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    margin: 0;\n    padding: 0;\n    list-style-type: none;\n    -webkit-box-flex: 1;\n        -ms-flex: 1 1 auto;\n            flex: 1 1 auto;\n}\n.p-tabview-header-action {\n    cursor: pointer;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    position: relative;\n    text-decoration: none;\n    overflow: hidden;\n}\n.p-tabview-ink-bar {\n    display: none;\n    z-index: 1;\n}\n.p-tabview-header-action:focus {\n    z-index: 1;\n}\n.p-tabview-title {\n    line-height: 1;\n    white-space: nowrap;\n}\n.p-tabview-nav-btn {\n    position: absolute;\n    top: 0;\n    z-index: 2;\n    height: 100%;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n}\n.p-tabview-nav-prev {\n    left: 0;\n}\n.p-tabview-nav-next {\n    right: 0;\n}\n.p-tabview-nav-content::-webkit-scrollbar {\n    display: none;\n}\n";
styleInject$3(css_248z$7);
script$t.render = render$7;

var script$s = {
  name: 'TabPanel',
  props: {
    header: null,
    headerStyle: null,
    headerClass: null,
    headerProps: null,
    headerActionProps: null,
    contentStyle: null,
    contentClass: null,
    contentProps: null,
    disabled: Boolean
  }
};

function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}

script$s.render = render$6;

const _hoisted_1$a = /*#__PURE__*/createElementVNode("label", null, "Aggregates", -1 /* HOISTED */);



var script$r = {
  props: {
    schema : Object
},
  async setup(__props) {

let __temp, __restore;

const props = __props;

const summary_repo = new ReportData(props.schema.name);
(
  ([__temp,__restore] = withAsyncContext(() => summary_repo.load())),
  await __temp,
  __restore()
);

const repos = [];
for(let i in props.schema.numeric) {
    if (i == "--sort") continue;
    const repo = new ReportData(props.schema.name, props.schema.numeric[i]);
    (
  ([__temp,__restore] = withAsyncContext(() => repo.load())),
  await __temp,
  __restore()
);
    repos.push(repo);
}

//menu bar functions

const type = ref('bar');

function toggleType(itype) {
    type.value = itype;
}

const agg = ref('COUNT');
const timevalue = ref('daily');

const aggvalue = computed({
    get() {
        return agg.value;
    },
    set(val) {
        props.repo.aggregate = val;
        agg.value = val;
    }
});

const aggregates = [
    { name : 'count', value : 'COUNT'},
    { name : 'average', value : 'AVG'},
    { name : 'minimum', value : 'MIN'},
    { name : 'maximum', value : 'MAX'}
];

const time_groups = [
    { name : 'Hourly', value : 'hourly'},
    { name : 'Daily', value : 'daily'},
    { name : 'Weekly', value : 'weekly'},
    { name : 'Monthly', value : 'monthly'},
    { name : 'Yearly', value : 'yearly'}
];




//subscribe / unsubscribe

subscribe("group_form", props.schema.name, (name, groups) => {
    if (name == props.schema.name) {
         for(const repo of repos) {
            repo.groups = groups;
            repo.reload(type.value);
        }
    }
});


subscribe("filter_form", props.schema.name, (name, filters) => {
    if (name == props.schema.name) {
        for(const repo of repos) {
            repo.filters = filters;
            repo.reload();
        }
    }
});

onBeforeUnmount(() => {
    unsubscribe("group_form", props.schema.name);
    unsubscribe("filter_form", props.schema.name);
});



return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$1N), null, {
    title: withCtx(() => [
      createTextVNode(toDisplayString$1(_ctx.$t("models." + props.schema.name  + ".title")), 1 /* TEXT */)
    ]),
    content: withCtx(() => [
      createVNode(script$w, {
        repo: unref(summary_repo),
        name: props.schema.name
      }, null, 8 /* PROPS */, ["repo", "name"]),
      createVNode(script$v, {
        repo: unref(summary_repo),
        name: props.schema.name
      }, null, 8 /* PROPS */, ["repo", "name"]),
      createVNode(unref(script$u), null, {
        start: withCtx(() => [
          _hoisted_1$a,
          createVNode(unref(script$O), {
            optionValue: "value",
            optionLabel: "name",
            modelValue: unref(aggvalue),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (isRef(aggvalue) ? (aggvalue).value = $event : null)),
            options: aggregates
          }, null, 8 /* PROPS */, ["modelValue"]),
          withDirectives(createElementVNode("label", null, "Time Groups", 512 /* NEED_PATCH */), [
            [vShow, type.value=='line']
          ]),
          withDirectives(createVNode(unref(script$O), {
            optionValue: "value",
            optionLabel: "name",
            modelValue: timevalue.value,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((timevalue).value = $event)),
            options: time_groups
          }, null, 8 /* PROPS */, ["modelValue"]), [
            [vShow, type.value=='line']
          ])
        ]),
        end: withCtx(() => [
          (type.value=='bar')
            ? (openBlock(), createBlock(unref(script$1L), {
                key: 0,
                onClick: _cache[2] || (_cache[2] = $event => (toggleType('line'))),
                label: "Line Chart",
                icon: "pi pi-chart-line",
                class: "mr-2"
              }))
            : (openBlock(), createBlock(unref(script$1L), {
                key: 1,
                onClick: _cache[3] || (_cache[3] = $event => (toggleType('bar'))),
                label: "Bar Chart",
                icon: "pi pi-chart-bar",
                class: "mr-2"
              }))
        ]),
        _: 1 /* STABLE */
      }),
      createVNode(unref(script$t), null, {
        default: withCtx(() => [
          createVNode(unref(script$s), { header: "Summary" }, {
            default: withCtx(() => [
              createVNode(script$G, {
                repo: unref(summary_repo),
                type: type.value
              }, null, 8 /* PROPS */, ["repo", "type"])
            ]),
            _: 1 /* STABLE */
          }),
          (openBlock(), createElementBlock(Fragment, null, renderList(repos, (repo) => {
            return createVNode(unref(script$s), {
              header: _ctx.$t('models.' + props.schema.name + '.fields.' + repo.field + '.label')
            }, {
              default: withCtx(() => [
                createVNode(script$G, {
                  repo: repo,
                  type: type.value
                }, null, 8 /* PROPS */, ["repo", "type"])
              ]),
              _: 2 /* DYNAMIC */
            }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["header"])
          }), 64 /* STABLE_FRAGMENT */))
        ]),
        _: 1 /* STABLE */
      })
    ]),
    _: 1 /* STABLE */
  }))
}
}

};

script$r.__file = "presstojam/src/components/reports/report-display.vue";

var script$q = {
  props: {
    model : String
},
  setup(__props) {

const props = __props;



const entities = getEntities();

const report_models = [];

for(let i in entities) {
    const entity = entities[i];
    const parent = getRoot(entity);
    if (parent.name == props.model) {
        const obj = {name : entity.name, numeric : []};
        for(const field in entity.cells) {
            if (entity.cells[field].type == "number") {
                obj.numeric.push(field);
            }
        }
        report_models.push(obj);
    }
}


return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("div", null, [
    (openBlock(), createElementBlock(Fragment, null, renderList(report_models, (obj) => {
      return createVNode(script$r, {
        key: obj.name,
        schema: obj
      }, null, 8 /* PROPS */, ["schema"])
    }), 64 /* STABLE_FRAGMENT */))
  ]))
}
}

};

script$q.__file = "presstojam/src/components/reports/report.vue";

var report = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': script$q
});

var script$p = {
  name: 'Splitter',
  emits: ['resizestart', 'resizeend'],
  props: {
    layout: {
      type: String,
      default: 'horizontal'
    },
    gutterSize: {
      type: Number,
      default: 4
    },
    stateKey: {
      type: String,
      default: null
    },
    stateStorage: {
      type: String,
      default: 'session'
    },
    step: {
      type: Number,
      default: 5
    }
  },
  dragging: false,
  mouseMoveListener: null,
  mouseUpListener: null,
  touchMoveListener: null,
  touchEndListener: null,
  size: null,
  gutterElement: null,
  startPos: null,
  prevPanelElement: null,
  nextPanelElement: null,
  nextPanelSize: null,
  prevPanelSize: null,
  panelSizes: null,
  prevPanelIndex: null,
  timer: null,

  data() {
    return {
      prevSize: null
    };
  },

  mounted() {
    if (this.panels && this.panels.length) {
      let initialized = false;

      if (this.isStateful()) {
        initialized = this.restoreState();
      }

      if (!initialized) {
        let children = [...this.$el.children].filter(child => DomHandler.hasClass(child, 'p-splitter-panel'));
        let _panelSizes = [];
        this.panels.map((panel, i) => {
          let panelInitialSize = panel.props && panel.props.size ? panel.props.size : null;
          let panelSize = panelInitialSize || 100 / this.panels.length;
          _panelSizes[i] = panelSize;
          children[i].style.flexBasis = 'calc(' + panelSize + '% - ' + (this.panels.length - 1) * this.gutterSize + 'px)';
        });
        this.panelSizes = _panelSizes;
        this.prevSize = parseFloat(_panelSizes[0]).toFixed(4);
      }
    }
  },

  beforeUnmount() {
    this.clear();
    this.unbindMouseListeners();
  },

  methods: {
    isSplitterPanel(child) {
      return child.type.name === 'SplitterPanel';
    },

    onResizeStart(event, index, isKeyDown) {
      this.gutterElement = event.currentTarget || event.target.parentElement;
      this.size = this.horizontal ? DomHandler.getWidth(this.$el) : DomHandler.getHeight(this.$el);

      if (!isKeyDown) {
        this.dragging = true;
        this.startPos = this.layout === 'horizontal' ? event.pageX || event.changedTouches[0].pageX : event.pageY || event.changedTouches[0].pageY;
      }

      this.prevPanelElement = this.gutterElement.previousElementSibling;
      this.nextPanelElement = this.gutterElement.nextElementSibling;

      if (isKeyDown) {
        this.prevPanelSize = this.horizontal ? DomHandler.getOuterWidth(this.prevPanelElement, true) : DomHandler.getOuterHeight(this.prevPanelElement, true);
        this.nextPanelSize = this.horizontal ? DomHandler.getOuterWidth(this.nextPanelElement, true) : DomHandler.getOuterHeight(this.nextPanelElement, true);
      } else {
        this.prevPanelSize = 100 * (this.horizontal ? DomHandler.getOuterWidth(this.prevPanelElement, true) : DomHandler.getOuterHeight(this.prevPanelElement, true)) / this.size;
        this.nextPanelSize = 100 * (this.horizontal ? DomHandler.getOuterWidth(this.nextPanelElement, true) : DomHandler.getOuterHeight(this.nextPanelElement, true)) / this.size;
      }

      this.prevPanelIndex = index;
      this.$emit('resizestart', {
        originalEvent: event,
        sizes: this.panelSizes
      });
      DomHandler.addClass(this.gutterElement, 'p-splitter-gutter-resizing');
      DomHandler.addClass(this.$el, 'p-splitter-resizing');
    },

    onResize(event, step, isKeyDown) {
      let newPos, newPrevPanelSize, newNextPanelSize;

      if (isKeyDown) {
        if (this.horizontal) {
          newPrevPanelSize = 100 * (this.prevPanelSize + step) / this.size;
          newNextPanelSize = 100 * (this.nextPanelSize - step) / this.size;
        } else {
          newPrevPanelSize = 100 * (this.prevPanelSize - step) / this.size;
          newNextPanelSize = 100 * (this.nextPanelSize + step) / this.size;
        }
      } else {
        if (this.horizontal) newPos = event.pageX * 100 / this.size - this.startPos * 100 / this.size;else newPos = event.pageY * 100 / this.size - this.startPos * 100 / this.size;
        newPrevPanelSize = this.prevPanelSize + newPos;
        newNextPanelSize = this.nextPanelSize - newPos;
      }

      this.prevSize = parseFloat(newPrevPanelSize).toFixed(4);

      if (this.validateResize(newPrevPanelSize, newNextPanelSize)) {
        this.prevPanelElement.style.flexBasis = 'calc(' + newPrevPanelSize + '% - ' + (this.panels.length - 1) * this.gutterSize + 'px)';
        this.nextPanelElement.style.flexBasis = 'calc(' + newNextPanelSize + '% - ' + (this.panels.length - 1) * this.gutterSize + 'px)';
        this.panelSizes[this.prevPanelIndex] = newPrevPanelSize;
        this.panelSizes[this.prevPanelIndex + 1] = newNextPanelSize;
      }
    },

    onResizeEnd(event) {
      if (this.isStateful()) {
        this.saveState();
      }

      this.$emit('resizeend', {
        originalEvent: event,
        sizes: this.panelSizes
      });
      DomHandler.removeClass(this.gutterElement, 'p-splitter-gutter-resizing');
      DomHandler.removeClass(this.$el, 'p-splitter-resizing');
      this.clear();
    },

    repeat(event, index, step) {
      this.onResizeStart(event, index, true);
      this.onResize(event, step, true);
    },

    setTimer(event, index, step) {
      this.clearTimer();
      this.timer = setTimeout(() => {
        this.repeat(event, index, step);
      }, 40);
    },

    clearTimer() {
      if (this.timer) {
        clearTimeout(this.timer);
      }
    },

    onGutterKeyUp() {
      this.clearTimer();
      this.onResizeEnd();
    },

    onGutterKeyDown(event, index) {
      switch (event.code) {
        case 'ArrowLeft':
          {
            if (this.layout === 'horizontal') {
              this.setTimer(event, index, this.step * -1);
            }

            event.preventDefault();
            break;
          }

        case 'ArrowRight':
          {
            if (this.layout === 'horizontal') {
              this.setTimer(event, index, this.step);
            }

            event.preventDefault();
            break;
          }

        case 'ArrowDown':
          {
            if (this.layout === 'vertical') {
              this.setTimer(event, index, this.step * -1);
            }

            event.preventDefault();
            break;
          }

        case 'ArrowUp':
          {
            if (this.layout === 'vertical') {
              this.setTimer(event, index, this.step);
            }

            event.preventDefault();
            break;
          }
      }
    },

    onGutterMouseDown(event, index) {
      this.onResizeStart(event, index);
      this.bindMouseListeners();
    },

    onGutterTouchStart(event, index) {
      this.onResizeStart(event, index);
      this.bindTouchListeners();
      event.preventDefault();
    },

    onGutterTouchMove(event) {
      this.onResize(event);
      event.preventDefault();
    },

    onGutterTouchEnd(event) {
      this.onResizeEnd(event);
      this.unbindTouchListeners();
      event.preventDefault();
    },

    bindMouseListeners() {
      if (!this.mouseMoveListener) {
        this.mouseMoveListener = event => this.onResize(event);

        document.addEventListener('mousemove', this.mouseMoveListener);
      }

      if (!this.mouseUpListener) {
        this.mouseUpListener = event => {
          this.onResizeEnd(event);
          this.unbindMouseListeners();
        };

        document.addEventListener('mouseup', this.mouseUpListener);
      }
    },

    bindTouchListeners() {
      if (!this.touchMoveListener) {
        this.touchMoveListener = event => this.onResize(event.changedTouches[0]);

        document.addEventListener('touchmove', this.touchMoveListener);
      }

      if (!this.touchEndListener) {
        this.touchEndListener = event => {
          this.resizeEnd(event);
          this.unbindTouchListeners();
        };

        document.addEventListener('touchend', this.touchEndListener);
      }
    },

    validateResize(newPrevPanelSize, newNextPanelSize) {
      let prevPanelMinSize = ObjectUtils.getVNodeProp(this.panels[0], 'minSize');

      if (this.panels[0].props && prevPanelMinSize && prevPanelMinSize > newPrevPanelSize) {
        return false;
      }

      let newPanelMinSize = ObjectUtils.getVNodeProp(this.panels[1], 'minSize');

      if (this.panels[1].props && newPanelMinSize && newPanelMinSize > newNextPanelSize) {
        return false;
      }

      return true;
    },

    unbindMouseListeners() {
      if (this.mouseMoveListener) {
        document.removeEventListener('mousemove', this.mouseMoveListener);
        this.mouseMoveListener = null;
      }

      if (this.mouseUpListener) {
        document.removeEventListener('mouseup', this.mouseUpListener);
        this.mouseUpListener = null;
      }
    },

    unbindTouchListeners() {
      if (this.touchMoveListener) {
        document.removeEventListener('touchmove', this.touchMoveListener);
        this.touchMoveListener = null;
      }

      if (this.touchEndListener) {
        document.removeEventListener('touchend', this.touchEndListener);
        this.touchEndListener = null;
      }
    },

    clear() {
      this.dragging = false;
      this.size = null;
      this.startPos = null;
      this.prevPanelElement = null;
      this.nextPanelElement = null;
      this.prevPanelSize = null;
      this.nextPanelSize = null;
      this.gutterElement = null;
      this.prevPanelIndex = null;
    },

    isStateful() {
      return this.stateKey != null;
    },

    getStorage() {
      switch (this.stateStorage) {
        case 'local':
          return window.localStorage;

        case 'session':
          return window.sessionStorage;

        default:
          throw new Error(this.stateStorage + ' is not a valid value for the state storage, supported values are "local" and "session".');
      }
    },

    saveState() {
      this.getStorage().setItem(this.stateKey, JSON.stringify(this.panelSizes));
    },

    restoreState() {
      const storage = this.getStorage();
      const stateString = storage.getItem(this.stateKey);

      if (stateString) {
        this.panelSizes = JSON.parse(stateString);
        let children = [...this.$el.children].filter(child => DomHandler.hasClass(child, 'p-splitter-panel'));
        children.forEach((child, i) => {
          child.style.flexBasis = 'calc(' + this.panelSizes[i] + '% - ' + (this.panels.length - 1) * this.gutterSize + 'px)';
        });
        return true;
      }

      return false;
    }

  },
  computed: {
    containerClass() {
      return ['p-splitter p-component', 'p-splitter-' + this.layout];
    },

    panels() {
      const panels = [];
      this.$slots.default().forEach(child => {
        if (this.isSplitterPanel(child)) {
          panels.push(child);
        } else if (child.children instanceof Array) {
          child.children.forEach(nestedChild => {
            if (this.isSplitterPanel(nestedChild)) {
              panels.push(nestedChild);
            }
          });
        }
      });
      return panels;
    },

    gutterStyle() {
      if (this.horizontal) return {
        width: this.gutterSize + 'px'
      };else return {
        height: this.gutterSize + 'px'
      };
    },

    horizontal() {
      return this.layout === 'horizontal';
    }

  }
};
const _hoisted_1$9 = ["onMousedown", "onTouchstart", "onTouchmove", "onTouchend"];
const _hoisted_2$8 = ["aria-orientation", "aria-valuenow", "onKeydown"];

function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass($options.containerClass)
  }, [(openBlock(true), createElementBlock(Fragment, null, renderList($options.panels, (panel, i) => {
    return openBlock(), createElementBlock(Fragment, {
      key: i
    }, [(openBlock(), createBlock(resolveDynamicComponent(panel), {
      tabindex: "-1"
    })), i !== $options.panels.length - 1 ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "p-splitter-gutter",
      role: "separator",
      tabindex: "-1",
      onMousedown: $event => $options.onGutterMouseDown($event, i),
      onTouchstart: $event => $options.onGutterTouchStart($event, i),
      onTouchmove: $event => $options.onGutterTouchMove($event, i),
      onTouchend: $event => $options.onGutterTouchEnd($event, i)
    }, [createElementVNode("div", {
      class: "p-splitter-gutter-handle",
      tabindex: "0",
      style: normalizeStyle($options.gutterStyle),
      "aria-orientation": $props.layout,
      "aria-valuenow": $data.prevSize,
      onKeyup: _cache[0] || (_cache[0] = (...args) => $options.onGutterKeyUp && $options.onGutterKeyUp(...args)),
      onKeydown: $event => $options.onGutterKeyDown($event, i)
    }, null, 44, _hoisted_2$8)], 40, _hoisted_1$9)) : createCommentVNode("", true)], 64);
  }), 128))], 2);
}

function styleInject$2(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$6 = "\n.p-splitter {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-wrap: nowrap;\n        flex-wrap: nowrap;\n}\n.p-splitter-vertical {\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n        -ms-flex-direction: column;\n            flex-direction: column;\n}\n.p-splitter-panel {\n    -webkit-box-flex: 1;\n        -ms-flex-positive: 1;\n            flex-grow: 1;\n}\n.p-splitter-panel-nested {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n}\n.p-splitter-panel .p-splitter {\n    -webkit-box-flex: 1;\n        -ms-flex-positive: 1;\n            flex-grow: 1;\n    border: 0 none;\n}\n.p-splitter-gutter {\n    -webkit-box-flex: 0;\n        -ms-flex-positive: 0;\n            flex-grow: 0;\n    -ms-flex-negative: 0;\n        flex-shrink: 0;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    cursor: col-resize;\n}\n.p-splitter-horizontal.p-splitter-resizing {\n    cursor: col-resize;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n}\n.p-splitter-horizontal > .p-splitter-gutter > .p-splitter-gutter-handle {\n    height: 24px;\n    width: 100%;\n}\n.p-splitter-horizontal > .p-splitter-gutter {\n    cursor: col-resize;\n}\n.p-splitter-vertical.p-splitter-resizing {\n    cursor: row-resize;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n}\n.p-splitter-vertical > .p-splitter-gutter {\n    cursor: row-resize;\n}\n.p-splitter-vertical > .p-splitter-gutter > .p-splitter-gutter-handle {\n    width: 24px;\n    height: 100%;\n}\n";
styleInject$2(css_248z$6);
script$p.render = render$5;

var script$o = {
  name: 'SplitterPanel',
  props: {
    size: {
      type: Number,
      default: null
    },
    minSize: {
      type: Number,
      default: null
    }
  },
  computed: {
    containerClass() {
      return ['p-splitter-panel', {
        'p-splitter-panel-nested': this.isNested
      }];
    },

    isNested() {
      return this.$slots.default().some(child => {
        return child.type.name === 'Splitter';
      });
    }

  }
};

function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "container",
    class: normalizeClass($options.containerClass)
  }, [renderSlot(_ctx.$slots, "default")], 2);
}

script$o.render = render$4;

var script$n = {
  props: {
        id : {
            type : Number,
            default : 0
        },
        name : String
    },
  setup(__props) {

const props = __props;

    


      
    subscribe("form_saved", "create", (response, method, model) => {
        if (model.name == props.name && method == "post") {
            trigger("effect_created", props.name, response);
        }
    });

    onBeforeUnmount(() => {
        unsubscribe("form_saved", "create");
    });


return (_ctx, _cache) => {
  return (openBlock(), createBlock(script$X, {
    entity_name: __props.name,
    id: __props.id
  }, null, 8 /* PROPS */, ["entity_name", "id"]))
}
}

};

script$n.__file = "presstojam/src/components/effects/create-effect.vue";

var script$m = {
  props: {
       name : String,
       id : {
        type : Number,
        default : 0
       },
       model : Object
    },
  setup(__props) {

const props = __props;

    

    const i18n = inject("i18n");
    const t = i18n.t;

 
    const header = (props.model.parent) 
        ? "Add " + t("models." + props.model.name + ".title", 1) + " to " + t("models." + props.model.parent + ".title", 1)
        : "Create " + t("models." + props.model.name + ".title", 1);
    if (props.parent_id) props.parent_id;

    function createRow() {
      trigger("dialog_open",
        script$n, 
        {
            name : props.name,
            id : props.id
        }, 
        header);
    }
    
 

return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$1L), {
    label: "New",
    icon: "pi pi-plus",
    class: "p-button-success mr-2",
    onClick: createRow
  }))
}
}

};

script$m.__file = "presstojam/src/components/actions/create-action.vue";

const _hoisted_1$8 = /*#__PURE__*/createElementVNode("p", null, "Are you sure you want to delete:", -1 /* HOISTED */);
const _hoisted_2$7 = /*#__PURE__*/createTextVNode("Type ");
const _hoisted_3$6 = /*#__PURE__*/createTextVNode(" in the box below");
const _hoisted_4$5 = { class: "p-inputgroup" };
const _hoisted_5$5 = /*#__PURE__*/createTextVNode("Delete");
 
    
var script$l = {
  props: {
        name : String,
        data : Array,
        store : Object
    },
  setup(__props) {

const props = __props;

    const client = inject("client");

    


    const check_str = "delete";

    let delval = ref("");

    const disabled = computed(() => {
        return (delval.value == check_str) ? false : true;
    });

   
    function del() {
        let params = {};
        const keys = [];
     
        for(const row of props.data) {
            keys.push(row['--id']);
        }
        params["--id"] = keys;

        client.delete("/data/" +props.store.store.name, params)
        .then(() => {
            props.store.remove(keys);
            trigger("effect_deleted", props.name);
        })
        .catch(e => console.log(e));
    }
    


return (_ctx, _cache) => {
  return (openBlock(), createElementBlock(Fragment, null, [
    _hoisted_1$8,
    createElementVNode("ul", null, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(__props.data, (item) => {
        return (openBlock(), createElementBlock("li", null, toDisplayString$1(unref(getLabel)(__props.store.model.fields, item)), 1 /* TEXT */))
      }), 256 /* UNKEYED_FRAGMENT */))
    ]),
    createElementVNode("p", null, [
      _hoisted_2$7,
      createElementVNode("i", null, toDisplayString$1(check_str)),
      _hoisted_3$6
    ]),
    createElementVNode("div", _hoisted_4$5, [
      createVNode(unref(script$1M), {
        placeholder: check_str,
        modelValue: unref(delval),
        "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (isRef(delval) ? (delval).value = $event : delval = $event))
      }, null, 8 /* PROPS */, ["modelValue"]),
      createVNode(unref(script$1L), {
        label: "Delete",
        disabled: unref(disabled),
        icon: "pi pi-trash",
        onClick: del,
        class: "p-button-danger"
      }, {
        default: withCtx(() => [
          _hoisted_5$5
        ]),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["disabled"])
    ])
  ], 64 /* STABLE_FRAGMENT */))
}
}

};

script$l.__file = "presstojam/src/components/effects/delete-effect.vue";

var script$k = {
  props: {
        name : String,
        data : [Object, Array],
        store : Object
    },
  setup(__props) {

const props = __props;

    


    function delRow() {

        const arg_data = (Array.isArray(props.data)) ? props.data : [props.data];
        trigger(
            "dialog_open",
            script$l, 
            {
                name : props.name,
                data : arg_data,
                store : props.store
            }, 
            "Delete");
    }

    const disabled = computed(() => {
        return (!props.data) ? true : false;
    });



return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$1L), {
    label: "Delete",
    icon: "pi pi-trash",
    class: "p-button-danger",
    disabled: unref(disabled),
    onClick: delRow
  }, null, 8 /* PROPS */, ["disabled"]))
}
}

};

script$k.__file = "presstojam/src/components/actions/delete-action.vue";

/**!
 * Sortable 1.15.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var version$1 = "1.15.0";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}

var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};

function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}

function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}

function matches(
/**HTMLElement*/
el,
/**String*/
selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));

  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }

  return false;
}

function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}

function closest(
/**HTMLElement*/
el,
/**String*/
selector,
/**HTMLElement*/
ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;

    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }

      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }

  return null;
}

var R_SPACE = /\s+/g;

function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}

function css(el, prop, val) {
  var style = el && el.style;

  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }

      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }

      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}

function matrix(el, selfOnly) {
  var appliedTransforms = '';

  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');

      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */

    } while (!selfOnly && (el = el.parentNode));
  }

  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */

  return matrixFn && new matrixFn(appliedTransforms);
}

function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
        i = 0,
        n = list.length;

    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }

    return list;
  }

  return [];
}

function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;

  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */


function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;

  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }

  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11

    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */

      } while (container = container.parentNode);
    }
  }

  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
        scaleX = elMatrix && elMatrix.a,
        scaleY = elMatrix && elMatrix.d;

    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }

  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}
/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */


function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
      elSideVal = getRect(el)[elSide];
  /* jshint boss:true */

  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
        visible = void 0;

    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }

    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }

  return false;
}
/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */


function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0,
      i = 0,
      children = el.children;

  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }

      currentChild++;
    }

    i++;
  }

  return null;
}
/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */


function lastChild(el, selector) {
  var last = el.lastElementChild;

  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }

  return last || null;
}
/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */


function index$2(el, selector) {
  var index = 0;

  if (!el || !el.parentNode) {
    return -1;
  }
  /* jshint boss:true */


  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }

  return index;
}
/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */


function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
      offsetTop = 0,
      winScroller = getWindowScrollingElement();

  if (el) {
    do {
      var elMatrix = matrix(el),
          scaleX = elMatrix.a,
          scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }

  return [offsetLeft, offsetTop];
}
/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */


function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;

    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }

  return -1;
}

function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;

  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);

      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */

  } while (elem = elem.parentNode);

  return getWindowScrollingElement();
}

function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }

  return dst;
}

function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}

var _throttleTimeout;

function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
          _this = this;

      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }

      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}

function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}

function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}

function clone$2(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;

  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}

var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
      animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });

        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation


        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);

          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }

        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;

      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }

      var animating = false,
          animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
            target = state.target,
            fromRect = target.fromRect,
            toRect = getRect(target),
            prevFromRect = target.prevFromRect,
            prevToRect = target.prevToRect,
            animatingRect = state.rect,
            targetMatrix = matrix(target, true);

        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }

        target.toRect = toRect;

        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        } // if fromRect != toRect: animate


        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;

          if (!time) {
            time = _this.options.animation;
          }

          _this.animate(target, animatingRect, toRect, time);
        }

        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);

      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }

      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
            scaleX = elMatrix && elMatrix.a,
            scaleY = elMatrix && elMatrix.d,
            translateX = (currentRect.left - toRect.left) / (scaleX || 1),
            translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        this.forRepaintDummy = repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}

function repaint(target) {
  return target.offsetWidth;
}

function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins$1 = [];
var defaults$1 = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults$1) {
      if (defaults$1.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults$1[option];
      }
    }

    plugins$1.forEach(function (p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins$1.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;

    this.eventCanceled = false;

    evt.cancel = function () {
      _this.eventCanceled = true;
    };

    var eventNameGlobal = eventName + 'Global';
    plugins$1.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable: sortable
        }, evt));
      } // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined


      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins$1.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized; // Add default options from plugin

      _extends(defaults, initialized.defaults);
    });

    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);

      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins$1.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;

      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins$1.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
      rootEl = _ref.rootEl,
      name = _ref.name,
      targetEl = _ref.targetEl,
      cloneEl = _ref.cloneEl,
      toEl = _ref.toEl,
      fromEl = _ref.fromEl,
      oldIndex = _ref.oldIndex,
      newIndex = _ref.newIndex,
      oldDraggableIndex = _ref.oldDraggableIndex,
      newDraggableIndex = _ref.newDraggableIndex,
      originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
      options = sortable.options,
      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }

  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));

  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }

  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }

  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var _excluded = ["evt"];

var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      originalEvent = _ref.evt,
      data = _objectWithoutProperties(_ref, _excluded);

  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};

function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}

var dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    oldIndex,
    newIndex,
    oldDraggableIndex,
    newDraggableIndex,
    activeGroup,
    putSortable,
    awaitingDragStarted = false,
    ignoreNextClick = false,
    sortables = [],
    tapEvt,
    touchEvt,
    lastDx,
    lastDy,
    tapDistanceLeft,
    tapDistanceTop,
    moved,
    lastTarget,
    lastDirection,
    pastFirstInvertThresh = false,
    isCircumstantialInvert = false,
    targetMoveDistance,
    // For positioning ghost absolutely
ghostRelativeParent,
    ghostRelativeParentInitialScroll = [],
    // (left, top)
_silent = false,
    savedInputChecked = [];
/** @const */

var documentExists = typeof document !== 'undefined',
    PositionGhostAbsolutely = IOS,
    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
    // This will not pass for IE9, because IE9 DnD only works on anchors
supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
    supportCssPointerEvents = function () {
  if (!documentExists) return; // false when <= IE11

  if (IE11OrLess) {
    return false;
  }

  var el = document.createElement('x');
  el.style.cssText = 'pointer-events:auto';
  return el.style.pointerEvents === 'auto';
}(),
    _detectDirection = function _detectDirection(el, options) {
  var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

  if (elCSS.display === 'flex') {
    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
  }

  if (elCSS.display === 'grid') {
    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
  }

  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
    var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
  }

  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
},
    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
},

/**
 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
 * @param  {Number} x      X position
 * @param  {Number} y      Y position
 * @return {HTMLElement}   Element of the first found nearest Sortable
 */
_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
  var ret;
  sortables.some(function (sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable)) return;
    var rect = getRect(sortable),
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;

    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
},
    _prepareGroup = function _prepareGroup(options) {
  function toFn(value, pull) {
    return function (to, from, dragEl, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;

      if (value == null && (pull || sameGroup)) {
        // Default pull value
        // Default pull and put value if same group
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === 'clone') {
        return value;
      } else if (typeof value === 'function') {
        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }

  var group = {};
  var originalGroup = options.group;

  if (!originalGroup || _typeof(originalGroup) != 'object') {
    originalGroup = {
      name: originalGroup
    };
  }

  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
},
    _hideGhostForTarget = function _hideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', 'none');
  }
},
    _unhideGhostForTarget = function _unhideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', '');
  }
}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position


if (documentExists && !ChromeForAndroid) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}

var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;

    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

    if (nearest) {
      // Create imitation event
      var event = {};

      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }

      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;

      nearest[expando]._onDragOver(event);
    }
  }
};

var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */


function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }

  this.el = el; // root element

  this.options = options = _extends({}, options); // Export instance

  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults); // Set default options

  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }

  _prepareGroup(options); // Bind all private methods


  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  } // Setup drag mode


  this.nativeDraggable = options.forceFallback ? false : supportDraggable;

  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  } // Bind events


  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }

  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }

  sortables.push(this.el); // Restore sorting

  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

  _extends(this, AnimationStateManager());
}

Sortable.prototype =
/** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(
  /** Event|TouchEvent */
  evt) {
    if (!evt.cancelable) return;

    var _this = this,
        el = this.el,
        options = this.options,
        preventOnFilter = options.preventOnFilter,
        type = evt.type,
        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
        target = (touch || evt).target,
        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
        filter = options.filter;

    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.


    if (dragEl) {
      return;
    }

    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    } // cancel dnd if original target is content editable


    if (originalTarget.isContentEditable) {
      return;
    } // Safari ignores further event handling after mousedown


    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
      return;
    }

    target = closest(target, options.draggable, el, false);

    if (target && target.animated) {
      return;
    }

    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    } // Get the index of the dragged element within its parent


    oldIndex = index$2(target);
    oldDraggableIndex = index$2(target, options.draggable); // Check filter

    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });

        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);

        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });

          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });

      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    }

    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    } // Prepare `dragstart`


    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(
  /** Event */
  evt,
  /** Touch */
  touch,
  /** HTMLElement */
  target) {
    var _this = this,
        el = _this.el,
        options = _this.options,
        ownerDocument = el.ownerDocument,
        dragStartFn;

    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';

      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });

        if (Sortable.eventCanceled) {
          _this._onDrop();

          return;
        } // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove


        _this._disableDelayedDragEvents();

        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        } // Bind the events: dragstart/dragend


        _this._triggerDragStart(evt, touch); // Drag start event


        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        }); // Chosen item


        toggleClass(dragEl, options.chosenClass, true);
      }; // Disable "draggable"


      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mouseup', _this._onDrop);
      on(ownerDocument, 'touchend', _this._onDrop);
      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }

      pluginEvent('delayStart', this, {
        evt: evt
      }); // Delay is impossible for native DnD in Edge or IE

      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();

          return;
        } // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag


        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
  /** TouchEvent|PointerEvent **/
  e) {
    var touch = e.touches ? e.touches[0] : e;

    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);

    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(
  /** Event */
  evt,
  /** Touch */
  touch) {
    touch = touch || evt.pointerType == 'touch' && evt;

    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }

    try {
      if (document.selection) {
        // Timeout neccessary for IE9
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;

    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });

      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }

      var options = this.options; // Apply effect

      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost(); // Drag start event

      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;

      _hideGhostForTarget();

      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;

      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }

      dragEl.parentNode[expando]._isOutsideThisEl(target);

      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });

            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }

          target = parent; // store last element
        }
        /* jshint boss:true */
        while (parent = parent.parentNode);
      }

      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(
  /**TouchEvent*/
  evt) {
    if (tapEvt) {
      var options = this.options,
          fallbackTolerance = options.fallbackTolerance,
          fallbackOffset = options.fallbackOffset,
          touch = evt.touches ? evt.touches[0] : evt,
          ghostMatrix = ghostEl && matrix(ghostEl, true),
          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }

        this._onDragStart(evt, true);
      }

      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }

        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }

      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
          options = this.options; // Position absolutely

      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;

        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }

        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }

        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }

      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl); // Set transform-origin

      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart(
  /**Event*/
  evt,
  /**boolean*/
  fallback) {
    var _this = this;

    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });

    if (Sortable.eventCanceled) {
      this._onDrop();

      return;
    }

    pluginEvent('setupClone', this);

    if (!Sortable.eventCanceled) {
      cloneEl = clone$2(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';

      this._hideClone();

      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    } // #1143: IFrame support workaround


    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;

      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }

      _this._hideClone();

      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events

    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);

      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }

      on(document, 'drop', _this); // #1276 fix:

      css(dragEl, 'transform', 'translateZ(0)');
    }

    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;

    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(
  /**Event*/
  evt) {
    var el = this.el,
        target = evt.target,
        dragRect,
        targetRect,
        revert,
        options = this.options,
        group = options.group,
        activeSortable = Sortable.active,
        isOwner = activeGroup === group,
        canSort = options.sort,
        fromSortable = putSortable || activeSortable,
        vertical,
        _this = this,
        completedFired = false;

    if (_silent) return;

    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread2({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    } // Capture animation state


    function capture() {
      dragOverEvent('dragOverAnimationCapture');

      _this.captureAnimationState();

      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    } // Return invocation when dragEl is inserted (or completed)


    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }

        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }

        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        } // Animation


        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }

        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });

        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      } // Null lastTarget if it is not inside a previously swapped element


      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      } // no bubbling and not fallback


      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted


        !insertion && nearestEmptyInsertDetectEvent(evt);
      }

      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    } // Call when dragEl has been inserted


    function changed() {
      newIndex = index$2(dragEl);
      newDraggableIndex = index$2(dragEl, options.draggable);

      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }

    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }

    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;

    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }

    ignoreNextClick = false;

    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;

      if (revert) {
        parentEl = rootEl; // actualization

        capture();

        this._hideClone();

        dragOverEvent('revert');

        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }

        return completed(true);
      }

      var elLastChild = lastChild(el, options.draggable);

      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // Insert to end of list
        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        } // if there is a last element, it is the target


        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }

        if (target) {
          targetRect = getRect(target);
        }

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();

          if (elLastChild && elLastChild.nextSibling) {
            // the last draggable element is not the last node
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }

          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        // Insert to start of list
        var firstChild = getChild(el, 0, options, true);

        if (firstChild === dragEl) {
          return completed(false);
        }

        target = firstChild;
        targetRect = getRect(target);

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
            targetBeforeFirstSwap,
            differentLevel = dragEl.parentNode !== el,
            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
            side1 = vertical ? 'top' : 'left',
            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;

        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }

        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;

        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index$2(dragEl);

          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        } // If dragEl is already beside target: Do not insert


        if (direction === 0 || sibling === target) {
          return completed(false);
        }

        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
            after = false;
        after = direction === 1;

        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }

          _silent = true;
          setTimeout(_unsilent, 30);
          capture();

          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          } // Undo chrome's scroll adjustment (has no effect on other browsers)


          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }

          parentEl = dragEl.parentNode; // actualization
          // must be done before animation

          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }

          changed();
          return completed(true);
        }
      }

      if (el.contains(dragEl)) {
        return completed(false);
      }
    }

    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop(
  /**Event*/
  evt) {
    var el = this.el,
        options = this.options; // Get the index of the dragged element within its parent

    newIndex = index$2(dragEl);
    newDraggableIndex = index$2(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

    newIndex = index$2(dragEl);
    newDraggableIndex = index$2(dragEl, options.draggable);

    if (Sortable.eventCanceled) {
      this._nulling();

      return;
    }

    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);

    _cancelNextTick(this.cloneId);

    _cancelNextTick(this._dragStartId); // Unbind events


    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }

    this._offMoveEvents();

    this._offUpEvents();

    if (Safari) {
      css(document.body, 'user-select', '');
    }

    css(dragEl, 'transform', '');

    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }

      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }

      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }

        _disableDraggable(dragEl);

        dragEl.style['will-change'] = ''; // Remove classes
        // ghostClass is added in dragStarted

        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }

        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event

        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });

        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            }); // Remove event


            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            }); // drag from one list and drop into another


            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }

          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });

              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }

        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }

          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          }); // Save sorting


          this.save();
        }
      }
    }

    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(
  /**Event*/
  evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);

        break;

      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);

          _globalDragOver(evt);
        }

        break;

      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },

  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
        el,
        children = this.el.children,
        i = 0,
        n = children.length,
        options = this.options;

    for (; i < n; i++) {
      el = children[i];

      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }

    return order;
  },

  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {},
        rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];

      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },

  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },

  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },

  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;

    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);

      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }

      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },

  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);

    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    } // Remove draggable attributes


    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });

    this._onDrop();

    this._disableDelayedDragEvents();

    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');

      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }

      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();

      return;
    }

    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return; // show clone at dragEl or original position

      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }

      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }

      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};

function _globalDragOver(
/**Event*/
evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }

  evt.cancelable && evt.preventDefault();
}

function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
      sortable = fromEl[expando],
      onMoveFn = sortable.options.onMove,
      retVal; // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }

  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);

  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }

  return retVal;
}

function _disableDraggable(el) {
  el.draggable = false;
}

function _unsilent() {
  _silent = false;
}

function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}

function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}

function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
      targetLength = vertical ? targetRect.height : targetRect.width,
      targetS1 = vertical ? targetRect.top : targetRect.left,
      targetS2 = vertical ? targetRect.bottom : targetRect.right,
      invert = false;

  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }

      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }

  invert = invert || invertSwap;

  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }

  return 0;
}
/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */


function _getInsertDirection(target) {
  if (index$2(dragEl) < index$2(target)) {
    return 1;
  } else {
    return -1;
  }
}
/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */


function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
      i = str.length,
      sum = 0;

  while (i--) {
    sum += str.charCodeAt(i);
  }

  return sum.toString(36);
}

function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;

  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}

function _nextTick(fn) {
  return setTimeout(fn, 0);
}

function _cancelNextTick(id) {
  return clearTimeout(id);
} // Fixed #973:


if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
} // Export utils


Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone$2,
  index: index$2,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};
/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */

Sortable.get = function (element) {
  return element[expando];
};
/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */


Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }

    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */


Sortable.create = function (el, options) {
  return new Sortable(el, options);
}; // Export


Sortable.version = version$1;
var autoScrolls = [],
    scrollEl,
    scrollRootEl,
    scrolling = false,
    lastAutoScrollX,
    lastAutoScrollY,
    touchEvt$1,
    pointerElemChangedInterval;

function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    }; // Bind all private methods

    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }

  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;

      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent; // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)

      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }

      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;

      var x = (evt.touches ? evt.touches[0] : evt).clientX,
          y = (evt.touches ? evt.touches[0] : evt).clientY,
          elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt; // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good

      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

        var ogElemScroller = getParentAutoScrollElement(elem, true);

        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);

            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }

            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }

        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}

function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}

function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}

var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
      y = (evt.touches ? evt.touches[0] : evt).clientY,
      sens = options.scrollSensitivity,
      speed = options.scrollSpeed,
      winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
      scrollCustomFn; // New scroll root, set scrollEl

  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;

    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }

  var layersOut = 0;
  var currentParent = scrollEl;

  do {
    var el = currentParent,
        rect = getRect(el),
        top = rect.top,
        bottom = rect.bottom,
        left = rect.left,
        right = rect.right,
        width = rect.width,
        height = rect.height,
        canScrollX = void 0,
        canScrollY = void 0,
        scrollWidth = el.scrollWidth,
        scrollHeight = el.scrollHeight,
        elCSS = css(el),
        scrollPosX = el.scrollLeft,
        scrollPosY = el.scrollTop;

    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }

    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);

    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }

    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);

      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */

        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely

          }

          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }

          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }

    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));

  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      dragEl = _ref.dragEl,
      activeSortable = _ref.activeSortable,
      dispatchSortableEvent = _ref.dispatchSortableEvent,
      hideGhostForTarget = _ref.hideGhostForTarget,
      unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();

  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};

function Revert() {}

Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
        putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();

    if (putSortable) {
      putSortable.captureAnimationState();
    }

    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);

    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }

    this.sortable.animateAll();

    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};

_extends(Revert, {
  pluginName: 'revertOnSpill'
});

function Remove() {}

Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
        putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};

_extends(Remove, {
  pluginName: 'removeOnSpill'
});

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);

const _hoisted_1$7 = /*#__PURE__*/createTextVNode("New row created");
const _hoisted_2$6 = /*#__PURE__*/createTextVNode("Rows removed");
const _hoisted_3$5 = /*#__PURE__*/createTextVNode("Saved");


var script$j = {
  props: {
    name : {
      type : String,
      required : true
    },
    repo : Object
},
  setup(__props) {

const props = __props;



const store = props.repo.store;


const expanded = ref(false);
const delrow = ref(false);
const newrow = ref(false);
store.fields['--sort'];
const saved = ref(false);


store.setTableCells();
const cells = store.getEnabledSummaryCells();

const selected = ref(null);

const data = ref([]);
const active = ref({});

props.repo.load()
.then(() => {
   data.value = toTree(props.repo.data.value, store.fields);
});


//repo.active.value['--recursive'] = 0;

const expandedKeys = ref({});

const collapseAll = () => {
    expandedKeys.value = {};
    expanded.value = false;
};

const expandAll = () => {
    for (let node of data.value) {
        expandNode(node);
    }
    expandedKeys.value = {...expandedKeys.value};
    expanded.value = true;
};

const expandNode = (node) => {
    if (node.children && node.children.length) {
      expandedKeys.value[node.key] = true;
      for (let child of node.children) {
          expandNode(child);
      }
    }
};


function setActive(node) {
  active.value = node.data;
  saved.value = false;
}


subscribe("effect_created", props.name, (name, response) => {
  if (props.name == name) {
        newrow.value = true;
        props.repo.addRow(response);
        data.value = toTree(props.repo.data.value, store.fields);
        trigger("dialog_close");
    }
});


subscribe("effect_edited", props.name, (name, id) => {
  if (props.name == name) {
        props.repo.editRow(id);
        saved.value = true;
    }
});

subscribe("effect_deleted", props.name, (name, response) => {
    if (props.name == name) {
        delrow.value = true;
        trigger("dialog_close");
        props.repo.remove(response);
        data.value = toTree(props.repo.data.value, store.fields);
    }
});


onBeforeUnmount(() => {
  unsubscribe("effect_created", props.name);
  unsubscribe("effect_edited", props.name);
  unsubscribe("effect_deleted", props.name);
});


function makeSortable() {
  const ptrees = document.querySelectorAll(".p-tree-container, .p-treenode-children");
  for(const ptree of ptrees) {
    let sortable = new Sortable(ptree, {
      group : 'tree',
      sort : true,
      draggable : "li",
      onEnd : (evt) => {
          console.log("Order is", evt, sortable.toArray());
      }
    });
  }
}

onUpdated(() => {
  //get all elements with class of p tree container
  makeSortable();

});

onMounted(() => {
  makeSortable();
});


return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$p), null, {
    default: withCtx(() => [
      createVNode(unref(script$o), null, {
        default: withCtx(() => [
          (newrow.value)
            ? (openBlock(), createBlock(unref(script$1K), {
                key: 0,
                severity: "success"
              }, {
                default: withCtx(() => [
                  _hoisted_1$7
                ]),
                _: 1 /* STABLE */
              }))
            : createCommentVNode("v-if", true),
          (delrow.value)
            ? (openBlock(), createBlock(unref(script$1K), {
                key: 1,
                severity: "success"
              }, {
                default: withCtx(() => [
                  _hoisted_2$6
                ]),
                _: 1 /* STABLE */
              }))
            : createCommentVNode("v-if", true),
          createVNode(unref(script$u), { class: "mb-4" }, {
            start: withCtx(() => [
              (expanded.value)
                ? (openBlock(), createBlock(unref(script$1L), {
                    key: 0,
                    type: "button",
                    icon: "pi pi-minus",
                    label: "Collapse All",
                    onClick: collapseAll
                  }))
                : (openBlock(), createBlock(unref(script$1L), {
                    key: 1,
                    type: "button",
                    icon: "pi pi-plus",
                    label: "Expand All",
                    onClick: expandAll
                  }))
            ]),
            end: withCtx(() => [
              (unref(store).perms.includes('post'))
                ? (openBlock(), createBlock(script$m, {
                    key: 0,
                    name: __props.name,
                    model: unref(store),
                    id: parseInt(__props.repo.parent_id)
                  }, null, 8 /* PROPS */, ["name", "model", "id"]))
                : createCommentVNode("v-if", true)
            ]),
            _: 1 /* STABLE */
          }),
          createVNode(unref(script$1k), {
            value: data.value,
            selectionMode: "single",
            onNodeSelect: setActive,
            filter: true,
            filterMode: "lenient",
            selectionKeys: selected.value,
            "onUpdate:selectionKeys": _cache[0] || (_cache[0] = $event => ((selected).value = $event)),
            expandedKeys: expandedKeys.value
          }, {
            default: withCtx((slotProps) => [
              createElementVNode("div", {
                class: normalizeClass(["branch-id", slotProps.node.data['--id']])
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(cells), (cell) => {
                  return (openBlock(), createBlock(script$1q, {
                    row: slotProps.node.data,
                    field: cell
                  }, null, 8 /* PROPS */, ["row", "field"]))
                }), 256 /* UNKEYED_FRAGMENT */))
              ], 2 /* CLASS */)
            ]),
            _: 1 /* STABLE */
          }, 8 /* PROPS */, ["value", "selectionKeys", "expandedKeys"])
        ]),
        _: 1 /* STABLE */
      }),
      createVNode(unref(script$o), null, {
        default: withCtx(() => [
          (active.value['--id'])
            ? (openBlock(), createBlock(unref(script$Z), {
                header: _ctx.$t('models.' +unref(store).name + '.title'),
                key: active.value['--id']
              }, {
                icons: withCtx(() => [
                  (unref(store).audit)
                    ? (openBlock(), createBlock(script$J, {
                        key: 0,
                        model: unref(store),
                        data: active.value,
                        long: true
                      }, null, 8 /* PROPS */, ["model", "data"]))
                    : createCommentVNode("v-if", true),
                  (unref(store).perms.includes('delete'))
                    ? (openBlock(), createBlock(script$k, {
                        key: 1,
                        name: __props.name,
                        data: active.value,
                        store: __props.repo
                      }, null, 8 /* PROPS */, ["name", "data", "store"]))
                    : createCommentVNode("v-if", true),
                  createVNode(script$1p, {
                    model: unref(store).name,
                    id: active.value['--id']
                  }, null, 8 /* PROPS */, ["model", "id"]),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(store).actions, (component) => {
                    return (openBlock(), createBlock(resolveDynamicComponent(component.component), mergeProps({ data: active.value }, component.atts), null, 16 /* FULL_PROPS */, ["data"]))
                  }), 256 /* UNKEYED_FRAGMENT */))
                ]),
                default: withCtx(() => [
                  (saved.value)
                    ? (openBlock(), createBlock(unref(script$1K), {
                        key: 0,
                        severity: "success"
                      }, {
                        default: withCtx(() => [
                          _hoisted_3$5
                        ]),
                        _: 1 /* STABLE */
                      }))
                    : createCommentVNode("v-if", true),
                  (active.value['--id'])
                    ? (openBlock(), createBlock(script$P, {
                        key: 1,
                        id: active.value['--id'],
                        name: __props.name
                      }, null, 8 /* PROPS */, ["id", "name"]))
                    : createCommentVNode("v-if", true)
                ]),
                _: 1 /* STABLE */
              }, 8 /* PROPS */, ["header"]))
            : createCommentVNode("v-if", true)
        ]),
        _: 1 /* STABLE */
      })
    ]),
    _: 1 /* STABLE */
  }))
}
}

};

var css_248z$5 = "\n.tree-vue-vue-type-style-index-0-id-49a3d7ba-scoped-true-lang_wrapper__KEFQt[data-v-49a3d7ba] {\r\n  display : grid;\r\n  margin-left : 0;\r\n  margin-right : 0;\r\n  box-sizing : content-box;\n}\r\n\r\n";
styleInject$t(css_248z$5);

script$j.__scopeId = "data-v-49a3d7ba";
script$j.__file = "presstojam/src/components/tree/tree.vue";

var tree = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': script$j
});

//download.js v3.0, by dandavis; 2008-2014. [CCBY2] see http://danml.com/download.html for tests/usage
// v1 landed a FF+Chrome compat way of downloading strings to local un-named files, upgraded to use a hidden frame and optional mime
// v2 added named files via a[download], msSaveBlob, IE (10+) support, and window.URL support for larger+faster saves than dataURLs
// v3 added dataURL and Blob Input, bind-toggle arity, and legacy dataURL fallback was improved with force-download mime and base64 support
// data can be a string, Blob, File, or dataURL
function download(data, strFileName, strMimeType) {
  var self = window,
      // this script is only for browsers anyway...
  u = "application/octet-stream",
      // this default mime also triggers iframe downloads
  m = strMimeType || u,
      x = data,
      D = document,
      a = D.createElement("a"),
      z = function (a) {
    return String(a);
  },
      B = self.Blob || self.MozBlob || self.WebKitBlob || z,
      BB = self.MSBlobBuilder || self.WebKitBlobBuilder || self.BlobBuilder,
      fn = strFileName || "download",
      blob,
      b,
      fr; //if(typeof B.bind === 'function' ){ B=B.bind(self); }


  if (String(this) === "true") {
    //reverse arguments, allowing download.bind(true, "text/xml", "export.xml") to act as a callback
    x = [x, m];
    m = x[0];
    x = x[1];
  } //go ahead and download dataURLs right away


  if (String(x).match(/^data\:[\w+\-]+\/[\w+\-]+[,;]/)) {
    return navigator.msSaveBlob ? // IE10 can't do a[download], only Blobs:
    navigator.msSaveBlob(d2b(x), fn) : saver(x); // everyone else can save dataURLs un-processed
  } //end if dataURL passed?


  try {
    blob = x instanceof B ? x : new B([x], {
      type: m
    });
  } catch (y) {
    if (BB) {
      b = new BB();
      b.append([x]);
      blob = b.getBlob(m); // the blob
    }
  }

  function d2b(u) {
    var p = u.split(/[:;,]/),
        t = p[1],
        dec = p[2] == "base64" ? atob : decodeURIComponent,
        bin = dec(p.pop()),
        mx = bin.length,
        i = 0,
        uia = new Uint8Array(mx);

    for (i; i < mx; ++i) uia[i] = bin.charCodeAt(i);

    return new B([uia], {
      type: t
    });
  }

  function saver(url, winMode) {
    if ('download' in a) {
      //html5 A[download] 			
      a.href = url;
      a.setAttribute("download", fn);
      a.innerHTML = "downloading...";
      D.body.appendChild(a);
      setTimeout(function () {
        a.click();
        D.body.removeChild(a);

        if (winMode === true) {
          setTimeout(function () {
            self.URL.revokeObjectURL(a.href);
          }, 250);
        }
      }, 66);
      return true;
    } //do iframe dataURL download (old ch+FF):


    var f = D.createElement("iframe");
    D.body.appendChild(f);

    if (!winMode) {
      // force a mime that will download:
      url = "data:" + url.replace(/^data:([\w\/\-\+]+)/, u);
    }

    f.src = url;
    setTimeout(function () {
      D.body.removeChild(f);
    }, 333);
  } //end saver 


  if (navigator.msSaveBlob) {
    // IE10+ : (has Blob, but not a[download] or URL)
    return navigator.msSaveBlob(blob, fn);
  }

  if (self.URL) {
    // simple fast and modern way using Blob and URL:
    saver(self.URL.createObjectURL(blob), true);
  } else {
    // handle non-Blob()+non-URL browsers:
    if (typeof blob === "string" || blob.constructor === z) {
      try {
        return saver("data:" + m + ";base64," + self.btoa(blob));
      } catch (y) {
        return saver("data:" + m + "," + encodeURIComponent(blob));
      }
    } // Blob but not URL:


    fr = new FileReader();

    fr.onload = function (e) {
      saver(this.result);
    };

    fr.readAsDataURL(blob);
  }

  return true;
}

function buildData(data, headers) {
  let value = "";

  for (const rowObj of data) {
    for (const x in headers) {
      const header = headers[x].key;
      let new_val = rowObj[header];
      if (new_val) new_val = new_val.toString().replace(/\,/g, '');
      value += new_val; //add value to build an array.

      value += x < headers.length - 1 ? "," : "\n";
    }
  }

  return value;
}

function exportCSV(name) {
  const store = new Model(name);
  store.limit = 0;
  const cells = store.fields;
  const i18n = useI18n();
  const t = i18n.global.t;
  const headers = [];

  if (store.export_fields) {
    if (Array.isArray(store.export_fields)) {
      for (const index in store.export_fields) {
        headers.push({
          key: store.export_fields[index],
          label: t("models." + store.name + ".fields." + store.export_fields[index] + ".label")
        });
      }
    } else {
      for (const key in store.export_fields) {
        headers.push({
          key: key,
          label: store.export_fields[key]
        });
      }
    }
  } else {
    for (const key in cells) {
      if (key == "--owner" || key == "--parent") continue;
      headers.push({
        key: key,
        label: t("models." + store.name + ".fields." + key + ".label")
      });
    }
  }

  let value = "";

  for (const x in headers) {
    value += headers[x].label;
    value += x < headers.length - 1 ? "," : "\n";
  }

  store.load({}).then(data => {
    value += buildData(data, headers);
    download(value, store.name + '.csv');
  });
}

var script$i = {
  props: {
    name : String
},
  setup(__props) {




return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$1L), {
    label: "Export",
    icon: "pi pi-external-link",
    class: "p-button-help mr-2",
    onClick: _cache[0] || (_cache[0] = $event => (unref(exportCSV)(__props.name)))
  }))
}
}

};

script$i.__file = "presstojam/src/components/actions/export-action.vue";

const _hoisted_1$6 = { key: 0 };
const _hoisted_2$5 = /*#__PURE__*/createElementVNode("h3", null, "Column Headers", -1 /* HOISTED */);
const _hoisted_3$4 = { class: "p-inputgroup" };
const _hoisted_4$4 = ["onUpdate:modelValue"];
const _hoisted_5$4 = { class: "p-inputgroup-addon" };
const _hoisted_6$4 = ["onClick"];
const _hoisted_7$2 = { key: 1 };
const _hoisted_8$1 = /*#__PURE__*/createElementVNode("h3", null, "Results", -1 /* HOISTED */);


var script$h = {
  props: {
    name : String
},
  setup(__props) {

const props = __props;



const store = new Model(props.name);

const client = inject("client");

const is_passed = ref(false);
const success = ref(0);
const failed = ref(0);


let headers = [];
const oheaders = [];
for(let i in store.fields) {
    if (!store.fields[i].system) {
        headers.push(i);
        oheaders.push(i);
    }
}



function importCSV( evt ){
    const formData = new FormData();
    for(const key in oheaders) {
        formData.append("headers[" + oheaders[key] + "]", headers[key]);
    }
    formData.append("upload-csv", evt.files[0]);
    return client.post("/bulk/" + props.name, formData)
    .then(response => {
        is_passed.value = true;
        success.value = response.success;
        failed.value = response.failure;
    });
}


function refreshHeader(key, headers) {
    headers[key] = oheaders[key];
}



return (_ctx, _cache) => {
  return (is_passed.value == false)
    ? (openBlock(), createElementBlock("div", _hoisted_1$6, [
        _hoisted_2$5,
        createElementVNode("table", null, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(headers), (header, key) => {
            return (openBlock(), createElementBlock("tr", null, [
              createElementVNode("td", null, toDisplayString$1((key + 1)) + ".", 1 /* TEXT */),
              createElementVNode("td", null, [
                createElementVNode("div", _hoisted_3$4, [
                  withDirectives(createElementVNode("input", {
                    type: "text",
                    "onUpdate:modelValue": $event => ((unref(headers)[key]) = $event),
                    class: "form-control"
                  }, null, 8 /* PROPS */, _hoisted_4$4), [
                    [vModelText, unref(headers)[key]]
                  ]),
                  createElementVNode("span", _hoisted_5$4, [
                    createElementVNode("i", {
                      class: "pi pi-refresh",
                      onClick: $event => (refreshHeader(key, unref(headers))),
                      style: {"cursor":"pointer"}
                    }, null, 8 /* PROPS */, _hoisted_6$4)
                  ])
                ])
              ])
            ]))
          }), 256 /* UNKEYED_FRAGMENT */))
        ]),
        createElementVNode("div", null, [
          createVNode(unref(script$15), {
            name: "file",
            mode: "basic",
            customUpload: true,
            onUploader: importCSV,
            auto: true
          })
        ])
      ]))
    : (openBlock(), createElementBlock("div", _hoisted_7$2, [
        _hoisted_8$1,
        createElementVNode("p", null, "Passed: " + toDisplayString$1(success.value), 1 /* TEXT */),
        createElementVNode("p", null, "Failed: " + toDisplayString$1(failed.value), 1 /* TEXT */)
      ]))
}
}

};

script$h.__file = "presstojam/src/components/import/import.vue";

const _hoisted_1$5 = /*#__PURE__*/createTextVNode("Import");


    
var script$g = {
  props: {
        name : String
    },
  setup(__props) {

const props = __props;

    


    function toggleImport() {
        trigger(
            "dialog_open",
            script$h, 
            {
                name : props.name,
            },
            "Import"
        );
    }

return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$1L), {
    icon: "pi pi-upload",
    class: "mr-2",
    onClick: toggleImport
  }, {
    default: withCtx(() => [
      _hoisted_1$5
    ]),
    _: 1 /* STABLE */
  }))
}
}

};

script$g.__file = "presstojam/src/components/actions/import-action.vue";

var script$f = {
  props: {
        id : {
            type : Number,
            default : 0
        },
        name : String,
        model : Object
    },
  setup(__props) {

const props = __props;

    

    const i18n = inject("i18n");
    const t = i18n.t;

    const header = "Edit " + t("models." + props.model.name + ".title", 1);


    function editRow() {
        trigger(
            "dialog_open",
            script$P, 
            {
                id : props.id,
                name : props.name
            },
            header
        );
    }


return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$1L), {
    icon: "pi pi-pencil",
    class: "p-button-rounded p-button-success mr-2",
    onClick: editRow
  }))
}
}

};

script$f.__file = "presstojam/src/components/actions/edit-action.vue";

var script$e = {
  props: {
    name : String,
    id : Number
},
  setup(__props) {

const props = __props;




const repo  = new RepoData(props.name);

repo.parent_id = props.id;


return (_ctx, _cache) => {
  return (openBlock(), createBlock(script$d, {
    name: __props.name,
    key: __props.name,
    repo: unref(repo)
  }, null, 8 /* PROPS */, ["name", "repo"]))
}
}

};

script$e.__file = "presstojam/src/components/table/child-table.vue";

const _withScopeId$1 = n => (pushScopeId("data-v-29f6384d"),n=n(),popScopeId(),n);
const _hoisted_1$4 = { class: "gc-table" };
const _hoisted_2$4 = /*#__PURE__*/createTextVNode("New row created");
const _hoisted_3$3 = /*#__PURE__*/createTextVNode("Rows removed");
const _hoisted_4$3 = /*#__PURE__*/createTextVNode("Row Updated");
const _hoisted_5$3 = {
  key: 0,
  class: "p-input-icon-left mr-2"
};
const _hoisted_6$3 = /*#__PURE__*/ _withScopeId$1(() => /*#__PURE__*/createElementVNode("i", { class: "pi pi-search" }, null, -1 /* HOISTED */));
const _hoisted_7$1 = { key: 4 };




var script$d = {
  props: {
    repo : Object,
    name : String
},
  setup(__props) {

const props = __props;




const group = ref();
const selected = ref([]);
const search = ref();
const active_options = ref();
const newrow = ref(false);
const delrow = ref(false);
const editrow = ref(false);


const store = props.repo.store;

const max_cols = (!store.max_cols) ? 10 : store.max_cols;

//setup cells
//const has_export = true;
store.setTableCells();
const cells = store.getEnabledCells();
const col_expandable = (Object.keys(cells).length > max_cols) ? true : false;
const fixed_fields = [];
const optional_fields = [];


props.repo.load();


const fields = computed(() => {
    const fcells = {};
    for(let i of fixed_fields) {
        fcells[i] = cells[i];
    }

    if (active_options.value) {
        for(let i of active_options.value) {
            fcells[i] = cells[i];
        }
    }

    return fcells;
});


for(let i in cells) {
    if (!col_expandable || fixed_fields.length < max_cols)  
        fixed_fields.push(i);
    else if (col_expandable) 
        optional_fields.push(i);
}


subscribe("effect_created", props.name, (name, response) => {
    if (props.name == name) {
        newrow.value = true;
        props.repo.addRow(response);
        trigger("dialog_close");
    }
});


subscribe("effect_edited", props.name, (name, id) => {
    if (props.name == name) {
        props.repo.editRow(id);
        editrow.value = true;
        trigger("dialog_close");
    }
});


subscribe("effect_deleted", props.name, (name, response) => {
    if (props.name == name) {
        delrow.value = true;
        trigger("dialog_close");
        props.repo.remove(response);
    }
});


onBeforeUnmount(() => {
    unsubscribe("effect_created", props.name);
    unsubscribe("effect_updated", props.name);
    unsubscribe("effect_delete", props.name);
});


const children = (store.fields['--id']) ? store.fields['--id'].reference : [];
const has_primary = (children.length > 1) ? true : false;
const has_expandable = (children.length == 1) ? true : false;
const has_sort = store.fields['--sort'];
const sortable = (!props.nosort && !props.repo.hasPagination() && !has_sort) ? true : false;
const global_filter_fields = [];
if (!props.repo.hasPagination()) {
    for(let field in props.fields) {
        global_filter_fields.push(field);
    }
}

const atts = {};
const events = {};
let groupcell;
if (store.group) {
    atts.rowGroupMode = "subheader";
    atts.groupRowsBy=store.group;
} else if (store.distinguish) {
    let id = store.distinguish;
    atts.rowClass = function(data) {
        return id + "-" + data[id];
    };
}


const total_records = computed(() => {
    return props.repo.pagination.count.value;
});


if (props.repo.hasPagination()) {
    atts.lazy = true;
    atts.paginator = true;
    atts.rows = props.repo.pagination.rows_per_page;
    atts.paginatorTemplate="FirstPageLink PrevPageLink PageLinks NextPageLink LastPageLink";
    events.page = function(evt) {
        props.repo.setPagination(evt.page);
    };
}

groupcell = fields[store.group];

const filters = computed(() => {
    if (!props.search) return {};
    let filters = { 'global' : {  value : props.search, matchMode: FilterMatchMode.CONTAINS } };
    return filters;
});




function rowClass(data) {
    let classes = [];
    if (store.classes) {
        for(let cls of store.classes) {
            if (data[cls.att] == cls.value) classes.push(cls.class);
        }
    }
    return (classes.length) ? classes.join(" ") : null;
}

//expandable rows function
const expandedRows = ref([]);




function onRowReorder(e) {
   //need to emit
   store.saveOrder(e.value);
}



onMounted (() => {
    const groupclasses = store.groupclasses;
    if (groupclasses) {
        for(const cls in groupclasses) {
            const val = groupclasses[cls];
            
            //apply to the rows retroactively
            let tgs = group.value.getElementsByClassName(cls);
            for(let el of tgs) {
                if (el.classList.contains("ptj-group")) {
                    let pel=el.closest(".p-rowgroup-header");
                    pel.classList.add(val);
                    while(pel=pel.nextElementSibling) {
                        if (pel.classList.contains('p-rowgroup-header')) {
                            break;
                        }
                        pel.classList.add(val);
                    }
                }
            }
        }
    }

});






return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("div", _hoisted_1$4, [
    (__props.repo.pagination.rows_per_page && !unref(store).no_filter)
      ? (openBlock(), createBlock(script$w, {
          key: 0,
          repo: __props.repo
        }, null, 8 /* PROPS */, ["repo"]))
      : createCommentVNode("v-if", true),
    (newrow.value)
      ? (openBlock(), createBlock(unref(script$1K), {
          key: 1,
          severity: "success"
        }, {
          default: withCtx(() => [
            _hoisted_2$4
          ]),
          _: 1 /* STABLE */
        }))
      : createCommentVNode("v-if", true),
    (delrow.value)
      ? (openBlock(), createBlock(unref(script$1K), {
          key: 2,
          severity: "success"
        }, {
          default: withCtx(() => [
            _hoisted_3$3
          ]),
          _: 1 /* STABLE */
        }))
      : createCommentVNode("v-if", true),
    (editrow.value)
      ? (openBlock(), createBlock(unref(script$1K), {
          key: 3,
          severity: "success"
        }, {
          default: withCtx(() => [
            _hoisted_4$3
          ]),
          _: 1 /* STABLE */
        }))
      : createCommentVNode("v-if", true),
    createVNode(unref(script$u), { class: "mb-4" }, {
      start: withCtx(() => [
        (!__props.repo.pagination.rows_per_page)
          ? (openBlock(), createElementBlock("span", _hoisted_5$3, [
              _hoisted_6$3,
              createVNode(unref(script$1M), {
                modelValue: search.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((search).value = $event)),
                placeholder: "Keyword Search"
              }, null, 8 /* PROPS */, ["modelValue"])
            ]))
          : createCommentVNode("v-if", true),
        (unref(col_expandable))
          ? (openBlock(), createBlock(unref(script$D), {
              key: 1,
              modelValue: active_options.value,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((active_options).value = $event)),
              options: optional_fields,
              placeholder: "Select Columns",
              style: {"width":"20em"}
            }, null, 8 /* PROPS */, ["modelValue"]))
          : createCommentVNode("v-if", true)
      ]),
      end: withCtx(() => [
        (unref(store).import)
          ? (openBlock(), createBlock(script$g, {
              key: 0,
              name: __props.name
            }, null, 8 /* PROPS */, ["name"]))
          : createCommentVNode("v-if", true),
        (unref(store).export)
          ? (openBlock(), createBlock(script$i, {
              key: 1,
              name: __props.name
            }, null, 8 /* PROPS */, ["name"]))
          : createCommentVNode("v-if", true),
        (unref(store).perms.includes('post'))
          ? (openBlock(), createBlock(script$m, {
              key: 2,
              name: __props.name,
              model: unref(store),
              id: parseInt(__props.repo.parent_id)
            }, null, 8 /* PROPS */, ["name", "model", "id"]))
          : createCommentVNode("v-if", true),
        (unref(store).perms.includes('delete'))
          ? (openBlock(), createBlock(script$k, {
              key: 3,
              name: __props.name,
              data: selected.value.value,
              store: __props.repo
            }, null, 8 /* PROPS */, ["name", "data", "store"]))
          : createCommentVNode("v-if", true)
      ]),
      _: 1 /* STABLE */
    }),
    (__props.repo.pagination.rows_per_page)
      ? (openBlock(), createElementBlock("p", _hoisted_7$1, "Total Rows: " + toDisplayString$1(__props.repo.pagination.count), 1 /* TEXT */))
      : createCommentVNode("v-if", true),
    createElementVNode("div", {
      ref_key: "group",
      ref: group
    }, [
      createVNode(unref(script$M), mergeProps({
        value: __props.repo.data.value,
        selection: selected.value.value,
        "onUpdate:selection": _cache[2] || (_cache[2] = $event => ((selected.value.value) = $event)),
        dataKey: "--id",
        rowClass: rowClass,
        responsiveLayout: "stack",
        loading: __props.repo.is_loading.value,
        rowHover: true,
        onRowReorder: onRowReorder,
        expandedRows: expandedRows.value,
        "onUpdate:expandedRows": _cache[3] || (_cache[3] = $event => ((expandedRows).value = $event)),
        globalFilterFields: global_filter_fields,
        totalRecords: unref(total_records),
        filters: unref(filters)
      }, atts, toHandlers(events)), createSlots({
        expansion: withCtx((slotProps) => [
          createVNode(unref(script$1N), null, {
            title: withCtx(() => [
              createTextVNode(toDisplayString$1(_ctx.$t("models." + unref(store).children_models[0] + ".title")), 1 /* TEXT */)
            ]),
            content: withCtx(() => [
              (openBlock(), createBlock(script$e, {
                name: unref(store).children_models[0],
                id: slotProps.data['--id'],
                key: slotProps.data['--parent']
              }, null, 8 /* PROPS */, ["name", "id"]))
            ]),
            _: 2 /* DYNAMIC */
          }, 1024 /* DYNAMIC_SLOTS */)
        ]),
        default: withCtx(() => [
          (unref(has_expandable))
            ? (openBlock(), createBlock(unref(script$L), {
                key: 0,
                expander: true,
                headerStyle: "width: 3rem"
              }))
            : createCommentVNode("v-if", true),
          (unref(has_sort))
            ? (openBlock(), createBlock(unref(script$L), {
                key: 1,
                rowReorder: true,
                headerStyle: "width: 3rem",
                reorderableColumn: false
              }))
            : createCommentVNode("v-if", true),
          (unref(store).perms.includes('delete'))
            ? (openBlock(), createBlock(unref(script$L), {
                key: 2,
                selectionMode: "multiple",
                style: {"width":"3rem"},
                exportable: false
              }))
            : createCommentVNode("v-if", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(fields), (cell) => {
            return (openBlock(), createBlock(unref(script$L), {
              field: cell.slug,
              sortable: unref(sortable),
              header: _ctx.$t('models.' + cell.model + '.fields.' + cell.name + '.label'),
              key: cell.name
            }, {
              body: withCtx((slotProps) => [
                createVNode(script$1q, {
                  row: slotProps.data,
                  field: cell
                }, null, 8 /* PROPS */, ["row", "field"])
              ]),
              _: 2 /* DYNAMIC */
            }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["field", "sortable", "header"]))
          }), 128 /* KEYED_FRAGMENT */)),
          createVNode(unref(script$L), {
            exportable: false,
            style: {"min-width":"8rem"}
          }, {
            body: withCtx((slotProps) => [
              (unref(has_primary))
                ? (openBlock(), createBlock(script$1p, {
                    key: 0,
                    model: unref(store).name,
                    id: slotProps.data['--id']
                  }, null, 8 /* PROPS */, ["model", "id"]))
                : createCommentVNode("v-if", true),
              (unref(store).perms.includes('put'))
                ? (openBlock(), createBlock(script$f, {
                    key: 1,
                    id: slotProps.data['--id'],
                    name: __props.name,
                    model: unref(store)
                  }, null, 8 /* PROPS */, ["id", "name", "model"]))
                : createCommentVNode("v-if", true),
              (unref(store).audit)
                ? (openBlock(), createBlock(script$J, {
                    key: 2,
                    data: slotProps.data,
                    model: unref(store)
                  }, null, 8 /* PROPS */, ["data", "model"]))
                : createCommentVNode("v-if", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(store).actions, (component) => {
                return (openBlock(), createBlock(resolveDynamicComponent(component.component), mergeProps(component.atts, {
                  data: slotProps.data,
                  short: true
                }), null, 16 /* FULL_PROPS */, ["data"]))
              }), 256 /* UNKEYED_FRAGMENT */))
            ]),
            _: 1 /* STABLE */
          })
        ]),
        _: 2 /* DYNAMIC */
      }, [
        (atts.groupRowsBy)
          ? {
              name: "groupheader",
              fn: withCtx((slotProps) => [
                createElementVNode("div", {
                  class: normalizeClass(["ptj-group", slotProps.data[unref(groupcell).name]])
                }, [
                  createVNode(script$1q, {
                    row: slotProps.data,
                    field: unref(groupcell)
                  }, null, 8 /* PROPS */, ["row", "field"])
                ], 2 /* CLASS */)
              ])
            }
          : undefined
      ]), 1040 /* FULL_PROPS, DYNAMIC_SLOTS */, ["value", "selection", "loading", "expandedRows", "totalRecords", "filters"])
    ], 512 /* NEED_PATCH */)
  ]))
}
}

};

var css_248z$4 = "\ntable[data-v-29f6384d], thead[data-v-29f6384d], tbody[data-v-29f6384d], tr[data-v-29f6384d] {\r\n    width : 100%;\n}\n.table-display-vue-vue-type-style-index-0-id-29f6384d-scoped-true-lang_ptj-table-wrapper__fKjz7[data-v-29f6384d] {\r\n    position : relative;\n}\r\n\r\n\r\n";
styleInject$t(css_248z$4);

script$d.__scopeId = "data-v-29f6384d";
script$d.__file = "presstojam/src/components/table/table-display.vue";

var tableDisplay = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': script$d
});

/*

*/

var script$c = {
  props: {
    model : String,
    id : Number
},
  setup(__props) {

const props = __props;




const repo = new RepoData(props.model);
repo.parent_id = props.id;
const store =repo.store;

repo.load();

let is_recursive = false;
for(let i in store.fields) {
    if (store.fields[i].recursive) is_recursive = true;
}


const component = computed(() => {
    if (store.perms.includes("post") || store.perms.includes("put")) {
        return (is_recursive) ? script$j : script$d;
    } else {
        return (is_recursive) ?script$1o : script$1o;
    }
});

repo.trigger("mounted");


return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["gc-master", __props.model])
  }, [
    createVNode(script$Q, {
      name: __props.model,
      store: unref(repo)
    }, null, 8 /* PROPS */, ["name", "store"]),
    createVNode(unref(script$Z), {
      header: unref(store).title,
      class: normalizeClass(["gc-repo", __props.model])
    }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(unref(component)), {
          repo: unref(repo),
          name: __props.model
        }, null, 8 /* PROPS */, ["repo", "name"]))
      ]),
      _: 1 /* STABLE */
    }, 8 /* PROPS */, ["header", "class"])
  ], 2 /* CLASS */))
}
}

};

var css_248z$3 = "\ntable[data-v-e5ad478c], thead[data-v-e5ad478c], tbody[data-v-e5ad478c], tr[data-v-e5ad478c] {\r\n    width : 100%;\n}\n.repo-vue-vue-type-style-index-0-id-e5ad478c-scoped-true-lang_ptj-table-wrapper__8hxfO[data-v-e5ad478c] {\r\n    position : relative;\n}\r\n\r\n";
styleInject$t(css_248z$3);

script$c.__scopeId = "data-v-e5ad478c";
script$c.__file = "presstojam/src/components/repo/repo.vue";

class ActiveData extends Data {
  constructor(model, active_id) {
    super(model);
    this._active_id = active_id;
    this._data.value = {};
  }

  get type() {
    return "active";
  }

  get active_id() {
    return this._active_id;
  }

  load() {
    if (!this._load_promise) {
      this._is_loading.value = true;
      this._load_promise = this._model.loadActive({
        "--id": this._active_id
      });
    }

    this._load_promise.then(response => {
      this._is_loading.value = false;
      this._data.value = response;
      return response;
    }).catch(e => {
      console.log(e);
      this._is_loading.value = false;
      throw e;
    });

    return this._load_promise;
  }

  reload() {
    this._active.value = {};
    this._load_promise = null;
    return this.load();
  }

  overwrite(obj) {
    for (let i in obj) {
      this._data.value[i] = obj[i];
    }
  }

}

var script$b = {
  props: {
    model : String,
    id : Number
},
  setup(__props) {

const props = __props;



const repo = new RepoData(props.model);
repo.parent_id = props.id;
const store =repo.store;
repo.load();

let is_recursive = false;
for(let i in store.fields) {
    if (store.fields[i].recursive) is_recursive = true;
}

const component = computed(() => {
    if (store.perms.includes("post") || store.perms.includes("put")) {
        return (is_recursive) ? script$j : script$d;
    } else {
        return (is_recursive) ?script$1o : script$1o;
    }
});



return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$Z), {
    header: _ctx.$t('models.' + __props.model + '.title', 2),
    class: normalizeClass(["gc-child", __props.model])
  }, {
    default: withCtx(() => [
      (openBlock(), createBlock(resolveDynamicComponent(unref(component)), {
        repo: unref(repo),
        name: __props.model
      }, null, 8 /* PROPS */, ["repo", "name"]))
    ]),
    _: 1 /* STABLE */
  }, 8 /* PROPS */, ["header", "class"]))
}
}

};

script$b.__file = "presstojam/src/components/active/child-panel.vue";

const _hoisted_1$3 = { class: "row" };
const _hoisted_2$3 = ["header"];


var script$a = {
  props: {
    active : Object
},
  setup(__props) {

const props = __props;




const cells = props.active.store.getEnabledCells();
const store = props.active.model;


return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$Z), {
    header: _ctx.$t('models.' +unref(store).name + '.title')
  }, {
    icons: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(store).actions, (component) => {
        return (openBlock(), createBlock(resolveDynamicComponent(component.component), mergeProps({
          store: props.active
        }, component.atts), null, 16 /* FULL_PROPS */, ["store"]))
      }), 256 /* UNKEYED_FRAGMENT */))
    ]),
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(cells), (cell) => {
        return (openBlock(), createElementBlock("div", _hoisted_1$3, [
          createVNode(script$1q, {
            field: cell,
            row: __props.active.data.value
          }, null, 8 /* PROPS */, ["field", "row"])
        ]))
      }), 256 /* UNKEYED_FRAGMENT */)),
      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(store).fields['--id'].reference, (child) => {
        return (openBlock(), createElementBlock("div", {
          header: _ctx.$t('models.' + child + '.title', 2)
        }, [
          createVNode(script$b, { model: child }, null, 8 /* PROPS */, ["model"])
        ], 8 /* PROPS */, _hoisted_2$3))
      }), 256 /* UNKEYED_FRAGMENT */))
    ]),
    _: 1 /* STABLE */
  }, 8 /* PROPS */, ["header"]))
}
}

};

script$a.__file = "presstojam/src/components/active/view-model.vue";

var script$9 = {
  props: {
    active : Object
},
  setup(__props) {

const props = __props;

const i18n = inject("i18n");
const t = i18n.t;




const store = props.active.store;

const data = ref({});
props.active.load()
.then(response => {
    data.value = response;
})
.catch(e => console.log(e));


computed(() => {
    return t('models.' + store.name + '.title') + ': ' + getLabel(store.fields, data.value);
});

subscribe("form_saved", props.active.active_id, (response, method, model) => {
    if (model.name == store.name) {
        props.active.reload()
        .then(response => {
            data.value = response;
        })
        .catch(e => console.log(e));
    }
});

if (store.route && store.active && store.active.mounted) {
    onMounted(() => {
        store.active.mounted(store);
    });
}

onBeforeUnmount(() => {
    unsubscribe("form_saved", props.active.active_id);
});


return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$t), { lazy: "" }, {
    default: withCtx(() => [
      createVNode(unref(script$s), {
        header: unref(getLabel)(unref(store).fields, data.value)
      }, {
        default: withCtx(() => [
          createVNode(unref(script$Z), {
            header: _ctx.$t('models.' +unref(store).name + '.title')
          }, {
            icons: withCtx(() => [
              (unref(store).audit)
                ? (openBlock(), createBlock(script$J, {
                    key: 0,
                    model: unref(store),
                    data: data.value,
                    long: true
                  }, null, 8 /* PROPS */, ["model", "data"]))
                : createCommentVNode("v-if", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(store).actions, (component) => {
                return (openBlock(), createBlock(resolveDynamicComponent(component.component), mergeProps({ data: data.value }, component.atts), null, 16 /* FULL_PROPS */, ["data"]))
              }), 256 /* UNKEYED_FRAGMENT */))
            ]),
            default: withCtx(() => [
              (data.value['--id'])
                ? (openBlock(), createBlock(script$P, {
                    key: 0,
                    id: data.value['--id'],
                    name: unref(store).name
                  }, null, 8 /* PROPS */, ["id", "name"]))
                : createCommentVNode("v-if", true)
            ]),
            _: 1 /* STABLE */
          }, 8 /* PROPS */, ["header"])
        ]),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["header"]),
      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(store).fields['--id'].reference, (child) => {
        return (openBlock(), createBlock(unref(script$s), {
          header: _ctx.$t('models.' + child + '.title', 2)
        }, {
          default: withCtx(() => [
            createVNode(script$b, {
              model: child,
              id: __props.active.active_id
            }, null, 8 /* PROPS */, ["model", "id"])
          ]),
          _: 2 /* DYNAMIC */
        }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["header"]))
      }), 256 /* UNKEYED_FRAGMENT */))
    ]),
    _: 1 /* STABLE */
  }))
}
}

};

script$9.__file = "presstojam/src/components/active/tab-active.vue";

var script$8 = {
  props: {
    model : String,
    id : Number
},
  async setup(__props) {

let __temp, __restore;

const props = __props;



console.log("Model is", props.model);

const active = new ActiveData(props.model, props.id);
(
  ([__temp,__restore] = withAsyncContext(() => active.load())),
  await __temp,
  __restore()
);
const store = active.model;





return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("div", {
    class: normalizeClass([__props.model, "gc-detail"])
  }, [
    createVNode(script$Q, {
      name: __props.model,
      store: unref(active)
    }, null, 8 /* PROPS */, ["name", "store"]),
    (unref(store).perms.includes('put'))
      ? (openBlock(), createBlock(script$9, {
          key: 0,
          active: unref(active)
        }, null, 8 /* PROPS */, ["active"]))
      : (openBlock(), createBlock(script$a, {
          key: 1,
          active: unref(active)
        }, null, 8 /* PROPS */, ["active"]))
  ], 2 /* CLASS */))
}
}

};

script$8.__file = "presstojam/src/components/active/active.vue";

var script$7 = {
  name: 'Accordion',
  emits: ['update:activeIndex', 'tab-open', 'tab-close', 'tab-click'],
  props: {
    multiple: {
      type: Boolean,
      default: false
    },
    activeIndex: {
      type: [Number, Array],
      default: null
    },
    lazy: {
      type: Boolean,
      default: false
    },
    expandIcon: {
      type: String,
      default: 'pi pi-chevron-right'
    },
    collapseIcon: {
      type: String,
      default: 'pi pi-chevron-down'
    },
    tabindex: {
      type: Number,
      default: 0
    },
    selectOnFocus: {
      type: Boolean,
      default: false
    }
  },

  data() {
    return {
      d_activeIndex: this.activeIndex
    };
  },

  watch: {
    activeIndex(newValue) {
      this.d_activeIndex = newValue;
    }

  },
  methods: {
    isAccordionTab(child) {
      return child.type.name === 'AccordionTab';
    },

    isTabActive(index) {
      return this.multiple ? this.d_activeIndex && this.d_activeIndex.includes(index) : this.d_activeIndex === index;
    },

    getTabProp(tab, name) {
      return tab.props ? tab.props[name] : undefined;
    },

    getKey(tab, index) {
      return this.getTabProp(tab, 'header') || index;
    },

    getTabHeaderActionId(index) {
      return `${this.id}_${index}_header_action`;
    },

    getTabContentId(index) {
      return `${this.id}_${index}_content`;
    },

    onTabClick(event, tab, index) {
      this.changeActiveIndex(event, tab, index);
      this.$emit('tab-click', {
        originalEvent: event,
        index
      });
    },

    onTabKeyDown(event, tab, index) {
      switch (event.code) {
        case 'ArrowDown':
          this.onTabArrowDownKey(event);
          break;

        case 'ArrowUp':
          this.onTabArrowUpKey(event);
          break;

        case 'Home':
          this.onTabHomeKey(event);
          break;

        case 'End':
          this.onTabEndKey(event);
          break;

        case 'Enter':
        case 'Space':
          this.onTabEnterKey(event, tab, index);
          break;
      }
    },

    onTabArrowDownKey(event) {
      const nextHeaderAction = this.findNextHeaderAction(event.target.parentElement.parentElement);
      nextHeaderAction ? this.changeFocusedTab(event, nextHeaderAction) : this.onTabHomeKey(event);
      event.preventDefault();
    },

    onTabArrowUpKey(event) {
      const prevHeaderAction = this.findPrevHeaderAction(event.target.parentElement.parentElement);
      prevHeaderAction ? this.changeFocusedTab(event, prevHeaderAction) : this.onTabEndKey(event);
      event.preventDefault();
    },

    onTabHomeKey(event) {
      const firstHeaderAction = this.findFirstHeaderAction();
      this.changeFocusedTab(event, firstHeaderAction);
      event.preventDefault();
    },

    onTabEndKey(event) {
      const lastHeaderAction = this.findLastHeaderAction();
      this.changeFocusedTab(event, lastHeaderAction);
      event.preventDefault();
    },

    onTabEnterKey(event, tab, index) {
      this.changeActiveIndex(event, tab, index);
      event.preventDefault();
    },

    findNextHeaderAction(tabElement, selfCheck = false) {
      const nextTabElement = selfCheck ? tabElement : tabElement.nextElementSibling;
      const headerElement = DomHandler.findSingle(nextTabElement, '.p-accordion-header');
      return headerElement ? DomHandler.hasClass(headerElement, 'p-disabled') ? this.findNextHeaderAction(headerElement.parentElement) : DomHandler.findSingle(headerElement, '.p-accordion-header-action') : null;
    },

    findPrevHeaderAction(tabElement, selfCheck = false) {
      const prevTabElement = selfCheck ? tabElement : tabElement.previousElementSibling;
      const headerElement = DomHandler.findSingle(prevTabElement, '.p-accordion-header');
      return headerElement ? DomHandler.hasClass(headerElement, 'p-disabled') ? this.findPrevHeaderAction(headerElement.parentElement) : DomHandler.findSingle(headerElement, '.p-accordion-header-action') : null;
    },

    findFirstHeaderAction() {
      return this.findNextHeaderAction(this.$el.firstElementChild, true);
    },

    findLastHeaderAction() {
      return this.findPrevHeaderAction(this.$el.lastElementChild, true);
    },

    changeActiveIndex(event, tab, index) {
      if (!this.getTabProp(tab, 'disabled')) {
        const active = this.isTabActive(index);
        const eventName = active ? 'tab-close' : 'tab-open';

        if (this.multiple) {
          if (active) {
            this.d_activeIndex = this.d_activeIndex.filter(i => i !== index);
          } else {
            if (this.d_activeIndex) this.d_activeIndex.push(index);else this.d_activeIndex = [index];
          }
        } else {
          this.d_activeIndex = this.d_activeIndex === index ? null : index;
        }

        this.$emit('update:activeIndex', this.d_activeIndex);
        this.$emit(eventName, {
          originalEvent: event,
          index
        });
      }
    },

    changeFocusedTab(event, element) {
      if (element) {
        DomHandler.focus(element);

        if (this.selectOnFocus) {
          const index = parseInt(element.parentElement.parentElement.dataset.index, 10);
          const tab = this.tabs[index];
          this.changeActiveIndex(event, tab, index);
        }
      }
    },

    getTabClass(i) {
      return ['p-accordion-tab', {
        'p-accordion-tab-active': this.isTabActive(i)
      }];
    },

    getTabHeaderClass(tab, i) {
      return ['p-accordion-header', this.getTabProp(tab, 'headerClass'), {
        'p-highlight': this.isTabActive(i),
        'p-disabled': this.getTabProp(tab, 'disabled')
      }];
    },

    getTabHeaderIconClass(i) {
      return ['p-accordion-toggle-icon', this.isTabActive(i) ? this.collapseIcon : this.expandIcon];
    },

    getTabContentClass(tab) {
      return ['p-toggleable-content', this.getTabProp(tab, 'contentClass')];
    }

  },
  computed: {
    tabs() {
      return this.$slots.default().reduce((tabs, child) => {
        if (this.isAccordionTab(child)) {
          tabs.push(child);
        } else if (child.children && child.children instanceof Array) {
          child.children.forEach(nestedChild => {
            if (this.isAccordionTab(nestedChild)) {
              tabs.push(nestedChild);
            }
          });
        }

        return tabs;
      }, []);
    },

    id() {
      return this.$attrs.id || UniqueComponentId();
    }

  },
  directives: {
    ripple: Ripple
  }
};
const _hoisted_1$2 = {
  class: "p-accordion p-component"
};
const _hoisted_2$2 = ["data-index"];
const _hoisted_3$2 = ["id", "tabindex", "aria-disabled", "aria-expanded", "aria-controls", "onClick", "onKeydown"];
const _hoisted_4$2 = {
  key: 0,
  class: "p-accordion-header-text"
};
const _hoisted_5$2 = ["id", "aria-labelledby"];
const _hoisted_6$2 = {
  class: "p-accordion-content"
};

function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$2, [(openBlock(true), createElementBlock(Fragment, null, renderList($options.tabs, (tab, i) => {
    return openBlock(), createElementBlock("div", {
      key: $options.getKey(tab, i),
      class: normalizeClass($options.getTabClass(i)),
      "data-index": i
    }, [createElementVNode("div", mergeProps({
      style: $options.getTabProp(tab, 'headerStyle'),
      class: $options.getTabHeaderClass(tab, i)
    }, $options.getTabProp(tab, 'headerProps')), [createElementVNode("a", mergeProps({
      id: $options.getTabHeaderActionId(i),
      class: "p-accordion-header-link p-accordion-header-action",
      tabindex: $options.getTabProp(tab, 'disabled') ? -1 : $props.tabindex,
      role: "button",
      "aria-disabled": $options.getTabProp(tab, 'disabled'),
      "aria-expanded": $options.isTabActive(i),
      "aria-controls": $options.getTabContentId(i),
      onClick: $event => $options.onTabClick($event, tab, i),
      onKeydown: $event => $options.onTabKeyDown($event, tab, i)
    }, $options.getTabProp(tab, 'headerActionProps')), [createElementVNode("span", {
      class: normalizeClass($options.getTabHeaderIconClass(i)),
      "aria-hidden": "true"
    }, null, 2), tab.props && tab.props.header ? (openBlock(), createElementBlock("span", _hoisted_4$2, toDisplayString$1(tab.props.header), 1)) : createCommentVNode("", true), tab.children && tab.children.header ? (openBlock(), createBlock(resolveDynamicComponent(tab.children.header), {
      key: 1
    })) : createCommentVNode("", true)], 16, _hoisted_3$2)], 16), createVNode(Transition, {
      name: "p-toggleable-content"
    }, {
      default: withCtx(() => [($props.lazy ? $options.isTabActive(i) : true) ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        id: $options.getTabContentId(i),
        style: $options.getTabProp(tab, 'contentStyle'),
        class: $options.getTabContentClass(tab),
        role: "region",
        "aria-labelledby": $options.getTabHeaderActionId(i)
      }, $options.getTabProp(tab, 'contentProps')), [createElementVNode("div", _hoisted_6$2, [(openBlock(), createBlock(resolveDynamicComponent(tab)))])], 16, _hoisted_5$2)), [[vShow, $props.lazy ? true : $options.isTabActive(i)]]) : createCommentVNode("", true)]),
      _: 2
    }, 1024)], 10, _hoisted_2$2);
  }), 128))]);
}

function styleInject$1(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$2 = "\n.p-accordion-header-action {\n    cursor: pointer;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n    position: relative;\n    text-decoration: none;\n}\n.p-accordion-header-action:focus {\n    z-index: 1;\n}\n.p-accordion-header-text {\n    line-height: 1;\n}\n";
styleInject$1(css_248z$2);
script$7.render = render$3;

var script$6 = {
  name: 'AccordionTab',
  props: {
    header: null,
    headerStyle: null,
    headerClass: null,
    headerProps: null,
    headerActionProps: null,
    contentStyle: null,
    contentClass: null,
    contentProps: null,
    disabled: Boolean
  }
};

function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}

script$6.render = render$2;

const _withScopeId = n => (pushScopeId("data-v-70986bd9"),n=n(),popScopeId(),n);
const _hoisted_1$1 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/createElementVNode("p", null, "Schema:", -1 /* HOISTED */));
const _hoisted_2$1 = { style: {"position":"relative","margin-left":"20px","width":"70%"} };
const _hoisted_3$1 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/createElementVNode("tr", null, [
  /*#__PURE__*/createElementVNode("th", null, "Alias"),
  /*#__PURE__*/createElementVNode("th", null, "Type"),
  /*#__PURE__*/createElementVNode("th", null, "System"),
  /*#__PURE__*/createElementVNode("th", null, "Background Only"),
  /*#__PURE__*/createElementVNode("th", null, "Reference")
], -1 /* HOISTED */));
const _hoisted_4$1 = { key: 0 };
const _hoisted_5$1 = { key: 1 };
const _hoisted_6$1 = /*#__PURE__*/createTextVNode("Permissions: ");


var script$5 = {
  props: {
    route : Object
},
  setup(__props) {





return (_ctx, _cache) => {
  return (openBlock(), createElementBlock("div", null, [
    _hoisted_1$1,
    createElementVNode("table", _hoisted_2$1, [
      _hoisted_3$1,
      (openBlock(true), createElementBlock(Fragment, null, renderList(__props.route.schema, (field, alias) => {
        return (openBlock(), createElementBlock("tr", null, [
          createElementVNode("td", null, toDisplayString$1(alias), 1 /* TEXT */),
          createElementVNode("td", null, toDisplayString$1(field.type), 1 /* TEXT */),
          createElementVNode("td", null, toDisplayString$1((field.system) ? "yes" : "no"), 1 /* TEXT */),
          createElementVNode("td", null, toDisplayString$1((field.background) ? "yes" : "no"), 1 /* TEXT */),
          (field.reference && field.reference_type > 0)
            ? (openBlock(), createElementBlock("td", _hoisted_4$1, toDisplayString$1(field.reference), 1 /* TEXT */))
            : (openBlock(), createElementBlock("td", _hoisted_5$1, " "))
        ]))
      }), 256 /* UNKEYED_FRAGMENT */))
    ]),
    createElementVNode("p", null, [
      _hoisted_6$1,
      (openBlock(true), createElementBlock(Fragment, null, renderList(__props.route.perms, (perm) => {
        return (openBlock(), createElementBlock("span", null, toDisplayString$1(perm) + " ", 1 /* TEXT */))
      }), 256 /* UNKEYED_FRAGMENT */))
    ])
  ]))
}
}

};

var css_248z$1 = "\nth[data-v-70986bd9] { text-align : left;}\r\n";
styleInject$t(css_248z$1);

script$5.__scopeId = "data-v-70986bd9";
script$5.__file = "presstojam/src/components/dev/sitemap-node.vue";

var script$4 = {
  setup(__props) {

const routes = getEntities();


return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$Z), { header: "Routes" }, {
    default: withCtx(() => [
      createVNode(unref(script$7), null, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(routes), (route, uri) => {
            return (openBlock(), createBlock(unref(script$6), { header: uri }, {
              default: withCtx(() => [
                createVNode(script$5, { route: route }, null, 8 /* PROPS */, ["route"])
              ]),
              _: 2 /* DYNAMIC */
            }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["header"]))
          }), 256 /* UNKEYED_FRAGMENT */))
        ]),
        _: 1 /* STABLE */
      })
    ]),
    _: 1 /* STABLE */
  }))
}
}

};

script$4.__file = "presstojam/src/components/dev/sitemap.vue";

function render$1(_ctx, _cache) {
  return (openBlock(), createElementBlock("h1", null, "Sorry, this page no longer exists"))
}

const script$3 = {};


script$3.render = render$1;
script$3.__file = "presstojam/src/components/statuspages/missing-page.vue";

var script$2 = {
  setup(__props) {


const base = configs.get("base");
location.href = base + "/data/" + defaultEntity();
 

return (_ctx, _cache) => {
  return null
}
}

};

script$2.__file = "presstojam/src/components/setdefault.vue";

function createAppRouter() {
  const base = configs.get("base");
  const routes = configs.get("options.routes");

  if (routes && !Array.isArray(routes)) {
    throw "Routes must be an array";
  }

  const croutes = routes ? routes : []; //add base

  for (let route of croutes) {
    route.path = base + route.path;
  }

  croutes.push({
    path: base + "/user-login",
    component: script$1F,
    name: 'login',
    props: {}
  });
  croutes.push({
    path: base + "/data/:model/:id?",
    component: script$c,
    name: 'repo',
    props: route => ({
      model: route.params.model,
      id: parseInt(route.params.id)
    })
  });
  croutes.push({
    path: base + "/data/active/:model/:id",
    component: script$8,
    name: 'primary',
    props: route => ({
      model: route.params.model,
      is_active: true,
      id: parseInt(route.params.id)
    })
  });
  croutes.push({
    path: base + "/data/single/:model",
    component: script$I,
    name: 'single',
    props: route => ({
      model: route.params.model
    })
  });
  croutes.push({
    path: base + "/reports/:model",
    component: script$q,
    name: 'report',
    props: route => ({
      model: route.params.model
    })
  }); //croutes.push({ path : base + "/flow/:flow/:position?", component : PtjFlow.vue, name : 'flow', props : route => ({ flow : route.params.flow, position : parseInt(route.params.position) })});

  croutes.push({
    path: base + "/dev/site-map",
    component: script$4,
    name: 'sitemap'
  });
  croutes.push({
    path: base + "/",
    component: script$2,
    name: 'default'
  });
  croutes.push({
    path: '/:pathMatch(.*)*',
    component: script$3
  });
  const router = createRouter({
    history: createWebHistory(),
    routes: croutes
  });
  return router;
}

var script$1 = {
  name: 'Steps',
  props: {
    id: {
      type: String,
      default: UniqueComponentId()
    },
    model: {
      type: Array,
      default: null
    },
    readonly: {
      type: Boolean,
      default: true
    },
    exact: {
      type: Boolean,
      default: true
    }
  },

  mounted() {
    const firstItem = this.findFirstItem();
    firstItem.tabIndex = '0';
  },

  methods: {
    onItemClick(event, item, navigate) {
      if (this.disabled(item) || this.readonly) {
        event.preventDefault();
        return;
      }

      if (item.command) {
        item.command({
          originalEvent: event,
          item: item
        });
      }

      if (item.to && navigate) {
        navigate(event);
      }
    },

    onItemKeydown(event, item, navigate) {
      switch (event.code) {
        case 'ArrowRight':
          {
            this.navigateToNextItem(event.target);
            event.preventDefault();
            break;
          }

        case 'ArrowLeft':
          {
            this.navigateToPrevItem(event.target);
            event.preventDefault();
            break;
          }

        case 'Home':
          {
            this.navigateToFirstItem(event.target);
            event.preventDefault();
            break;
          }

        case 'End':
          {
            this.navigateToLastItem(event.target);
            event.preventDefault();
            break;
          }

        case 'Tab':
          //no op
          break;

        case 'Enter':
        case 'Space':
          {
            this.onItemClick(event, item, navigate);
            event.preventDefault();
            break;
          }
      }
    },

    navigateToNextItem(target) {
      const nextItem = this.findNextItem(target);
      nextItem && this.setFocusToMenuitem(target, nextItem);
    },

    navigateToPrevItem(target) {
      const prevItem = this.findPrevItem(target);
      prevItem && this.setFocusToMenuitem(target, prevItem);
    },

    navigateToFirstItem(target) {
      const firstItem = this.findFirstItem(target);
      firstItem && this.setFocusToMenuitem(target, firstItem);
    },

    navigateToLastItem(target) {
      const lastItem = this.findLastItem(target);
      lastItem && this.setFocusToMenuitem(target, lastItem);
    },

    findNextItem(item) {
      const nextItem = item.parentElement.nextElementSibling;
      return nextItem ? nextItem.children[0] : null;
    },

    findPrevItem(item) {
      const prevItem = item.parentElement.previousElementSibling;
      return prevItem ? prevItem.children[0] : null;
    },

    findFirstItem() {
      const firstSibling = DomHandler.findSingle(this.$refs.list, '.p-steps-item');
      return firstSibling ? firstSibling.children[0] : null;
    },

    findLastItem() {
      const siblings = DomHandler.find(this.$refs.list, '.p-steps-item');
      return siblings ? siblings[siblings.length - 1].children[0] : null;
    },

    setFocusToMenuitem(target, focusableItem) {
      target.tabIndex = '-1';
      focusableItem.tabIndex = '0';
      focusableItem.focus();
    },

    isActive(item) {
      return item.to ? this.$router.resolve(item.to).path === this.$route.path : false;
    },

    getItemClass(item) {
      return ['p-steps-item', item.class, {
        'p-highlight p-steps-current': this.isActive(item),
        'p-disabled': this.isItemDisabled(item)
      }];
    },

    linkClass(routerProps) {
      return ['p-menuitem-link', {
        'router-link-active': routerProps && routerProps.isActive,
        'router-link-active-exact': this.exact && routerProps && routerProps.isExactActive
      }];
    },

    isItemDisabled(item) {
      return this.disabled(item) || this.readonly && !this.isActive(item);
    },

    visible(item) {
      return typeof item.visible === 'function' ? item.visible() : item.visible !== false;
    },

    disabled(item) {
      return typeof item.disabled === 'function' ? item.disabled() : item.disabled;
    },

    label(item) {
      return typeof item.label === 'function' ? item.label() : item.label;
    }

  },
  computed: {
    containerClass() {
      return ['p-steps p-component', {
        'p-readonly': this.readonly
      }];
    }

  }
};
const _hoisted_1 = ["id"];
const _hoisted_2 = {
  ref: "list",
  class: "p-steps-list"
};
const _hoisted_3 = ["href", "aria-current", "onClick", "onKeydown"];
const _hoisted_4 = {
  class: "p-steps-number"
};
const _hoisted_5 = {
  class: "p-steps-title"
};
const _hoisted_6 = ["onKeydown"];
const _hoisted_7 = {
  class: "p-steps-number"
};
const _hoisted_8 = {
  class: "p-steps-title"
};

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_router_link = resolveComponent("router-link");

  return openBlock(), createElementBlock("nav", {
    id: $props.id,
    class: normalizeClass($options.containerClass)
  }, [createElementVNode("ol", _hoisted_2, [(openBlock(true), createElementBlock(Fragment, null, renderList($props.model, (item, index) => {
    return openBlock(), createElementBlock(Fragment, {
      key: item.to
    }, [$options.visible(item) ? (openBlock(), createElementBlock("li", {
      key: 0,
      class: normalizeClass($options.getItemClass(item)),
      style: normalizeStyle(item.style)
    }, [!_ctx.$slots.item ? (openBlock(), createElementBlock(Fragment, {
      key: 0
    }, [!$options.isItemDisabled(item) ? (openBlock(), createBlock(_component_router_link, {
      key: 0,
      to: item.to,
      custom: ""
    }, {
      default: withCtx(({
        navigate,
        href,
        isActive,
        isExactActive
      }) => [createElementVNode("a", {
        href: href,
        class: normalizeClass($options.linkClass({
          isActive,
          isExactActive
        })),
        tabindex: -1,
        "aria-current": isExactActive ? 'step' : undefined,
        onClick: $event => $options.onItemClick($event, item, navigate),
        onKeydown: $event => $options.onItemKeydown($event, item, navigate)
      }, [createElementVNode("span", _hoisted_4, toDisplayString$1(index + 1), 1), createElementVNode("span", _hoisted_5, toDisplayString$1($options.label(item)), 1)], 42, _hoisted_3)]),
      _: 2
    }, 1032, ["to"])) : (openBlock(), createElementBlock("span", {
      key: 1,
      class: normalizeClass($options.linkClass()),
      onKeydown: $event => $options.onItemKeydown($event, item)
    }, [createElementVNode("span", _hoisted_7, toDisplayString$1(index + 1), 1), createElementVNode("span", _hoisted_8, toDisplayString$1($options.label(item)), 1)], 42, _hoisted_6))], 64)) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.$slots.item), {
      key: 1,
      item: item
    }, null, 8, ["item"]))], 6)) : createCommentVNode("", true)], 64);
  }), 128))], 512)], 10, _hoisted_1);
}

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = "\n.p-steps {\n    position: relative;\n}\n.p-steps .p-steps-list {\n    padding: 0;\n    margin: 0;\n    list-style-type: none;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n}\n.p-steps-item {\n    position: relative;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n    -webkit-box-flex: 1;\n        -ms-flex: 1 1 auto;\n            flex: 1 1 auto;\n}\n.p-steps-item .p-menuitem-link {\n    display: -webkit-inline-box;\n    display: -ms-inline-flexbox;\n    display: inline-flex;\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n        -ms-flex-direction: column;\n            flex-direction: column;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    overflow: hidden;\n    text-decoration: none;\n}\n.p-steps.p-steps-readonly .p-steps-item {\n    cursor: auto;\n}\n.p-steps-item.p-steps-current .p-menuitem-link {\n    cursor: default;\n}\n.p-steps-title {\n    white-space: nowrap;\n}\n.p-steps-number {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    -webkit-box-pack: center;\n        -ms-flex-pack: center;\n            justify-content: center;\n}\n.p-steps-title {\n    display: block;\n}\n";
styleInject(css_248z);
script$1.render = render;

const flows = {};
function getFlow(key) {
  return flows[key];
}

var script = {
  props: {
    flow : String,
    position : Number,
    base : String
},
  setup(__props) {

const props = __props;



const flowObj = getFlow(props.flow);

const items = [];
const routes = flowObj.routes;
for(const i in routes) {
    const route = routes[i];
    items.push({ label : route.model, to : '/flows/' + props.flow + "/" + i});
}


return (_ctx, _cache) => {
  return (openBlock(), createBlock(unref(script$1), { model: items }))
}
}

};

script.__file = "presstojam/src/components/flow/flow.vue";

var flow = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': script
});

var index$1 = {
  install: (app, options) => {
    initConfigs(options);
    const router = createAppRouter();
    app.use(router);
    app.provide("router", router);
    const i18n = createI18n(options);
    app.provide("i18n", i18n.global);
    app.use(i18n);
    app.config.globalProperties.translate = i18n.global;
    app.use(PrimeVue);
    let client = getClient();
    app.provide("client", client);
    app.component("Controller", script$U);
  }
};

/*!
 * @kurkle/color v0.3.1
 * https://github.com/kurkle/color#readme
 * (c) 2022 Jukka Kurkela
 * Released under the MIT License
 */
function round(v) {
  return v + 0.5 | 0;
}

const lim = (v, l, h) => Math.max(Math.min(v, h), l);

function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}

function n2b(v) {
  return lim(round(v * 255), 0, 255);
}

function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}

function n2p(v) {
  return lim(round(v * 100), 0, 100);
}

const map$1 = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15,
  a: 10,
  b: 11,
  c: 12,
  d: 13,
  e: 14,
  f: 15
};
const hex = [...'0123456789ABCDEF'];

const h1 = b => hex[b & 0xF];

const h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];

const eq = b => (b & 0xF0) >> 4 === (b & 0xF);

const isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);

function hexParse(str) {
  var len = str.length;
  var ret;

  if (str[0] === '#') {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }

  return ret;
}

const alpha = (a, f) => a < 255 ? f(a) : '';

function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : undefined;
}

const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;

function hsl2rgbn(h, s, l) {
  const a = s * Math.min(l, 1 - l);

  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);

  return [f(0), f(8), f(4)];
}

function hsv2rgbn(h, s, v) {
  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);

  return [f(5), f(3), f(1)];
}

function hwb2rgbn(h, w, b) {
  const rgb = hsl2rgbn(h, 1, 0.5);
  let i;

  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }

  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }

  return rgb;
}

function hueValue(r, g, b, d, max) {
  if (r === max) {
    return (g - b) / d + (g < b ? 6 : 0);
  }

  if (g === max) {
    return (b - r) / d + 2;
  }

  return (r - g) / d + 4;
}

function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h, s, d;

  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h = hueValue(r, g, b, d, max);
    h = h * 60 + 0.5;
  }

  return [h | 0, s || 0, l];
}

function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}

function hsl2rgb(h, s, l) {
  return calln(hsl2rgbn, h, s, l);
}

function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}

function hsv2rgb(h, s, v) {
  return calln(hsv2rgbn, h, s, v);
}

function hue(h) {
  return (h % 360 + 360) % 360;
}

function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;

  if (!m) {
    return;
  }

  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }

  const h = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;

  if (m[1] === 'hwb') {
    v = hwb2rgb(h, p1, p2);
  } else if (m[1] === 'hsv') {
    v = hsv2rgb(h, p1, p2);
  } else {
    v = hsl2rgb(h, p1, p2);
  }

  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a: a
  };
}

function rotate(v, deg) {
  var h = rgb2hsl(v);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}

function hslString(v) {
  if (!v) {
    return;
  }

  const a = rgb2hsl(v);
  const h = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
}

const map$2 = {
  x: 'dark',
  Z: 'light',
  Y: 're',
  X: 'blu',
  W: 'gr',
  V: 'medium',
  U: 'slate',
  A: 'ee',
  T: 'ol',
  S: 'or',
  B: 'ra',
  C: 'lateg',
  D: 'ights',
  R: 'in',
  Q: 'turquois',
  E: 'hi',
  P: 'ro',
  O: 'al',
  N: 'le',
  M: 'de',
  L: 'yello',
  F: 'en',
  K: 'ch',
  G: 'arks',
  H: 'ea',
  I: 'ightg',
  J: 'wh'
};
const names$1 = {
  OiceXe: 'f0f8ff',
  antiquewEte: 'faebd7',
  aqua: 'ffff',
  aquamarRe: '7fffd4',
  azuY: 'f0ffff',
  beige: 'f5f5dc',
  bisque: 'ffe4c4',
  black: '0',
  blanKedOmond: 'ffebcd',
  Xe: 'ff',
  XeviTet: '8a2be2',
  bPwn: 'a52a2a',
  burlywood: 'deb887',
  caMtXe: '5f9ea0',
  KartYuse: '7fff00',
  KocTate: 'd2691e',
  cSO: 'ff7f50',
  cSnflowerXe: '6495ed',
  cSnsilk: 'fff8dc',
  crimson: 'dc143c',
  cyan: 'ffff',
  xXe: '8b',
  xcyan: '8b8b',
  xgTMnPd: 'b8860b',
  xWay: 'a9a9a9',
  xgYF: '6400',
  xgYy: 'a9a9a9',
  xkhaki: 'bdb76b',
  xmagFta: '8b008b',
  xTivegYF: '556b2f',
  xSange: 'ff8c00',
  xScEd: '9932cc',
  xYd: '8b0000',
  xsOmon: 'e9967a',
  xsHgYF: '8fbc8f',
  xUXe: '483d8b',
  xUWay: '2f4f4f',
  xUgYy: '2f4f4f',
  xQe: 'ced1',
  xviTet: '9400d3',
  dAppRk: 'ff1493',
  dApskyXe: 'bfff',
  dimWay: '696969',
  dimgYy: '696969',
  dodgerXe: '1e90ff',
  fiYbrick: 'b22222',
  flSOwEte: 'fffaf0',
  foYstWAn: '228b22',
  fuKsia: 'ff00ff',
  gaRsbSo: 'dcdcdc',
  ghostwEte: 'f8f8ff',
  gTd: 'ffd700',
  gTMnPd: 'daa520',
  Way: '808080',
  gYF: '8000',
  gYFLw: 'adff2f',
  gYy: '808080',
  honeyMw: 'f0fff0',
  hotpRk: 'ff69b4',
  RdianYd: 'cd5c5c',
  Rdigo: '4b0082',
  ivSy: 'fffff0',
  khaki: 'f0e68c',
  lavFMr: 'e6e6fa',
  lavFMrXsh: 'fff0f5',
  lawngYF: '7cfc00',
  NmoncEffon: 'fffacd',
  ZXe: 'add8e6',
  ZcSO: 'f08080',
  Zcyan: 'e0ffff',
  ZgTMnPdLw: 'fafad2',
  ZWay: 'd3d3d3',
  ZgYF: '90ee90',
  ZgYy: 'd3d3d3',
  ZpRk: 'ffb6c1',
  ZsOmon: 'ffa07a',
  ZsHgYF: '20b2aa',
  ZskyXe: '87cefa',
  ZUWay: '778899',
  ZUgYy: '778899',
  ZstAlXe: 'b0c4de',
  ZLw: 'ffffe0',
  lime: 'ff00',
  limegYF: '32cd32',
  lRF: 'faf0e6',
  magFta: 'ff00ff',
  maPon: '800000',
  VaquamarRe: '66cdaa',
  VXe: 'cd',
  VScEd: 'ba55d3',
  VpurpN: '9370db',
  VsHgYF: '3cb371',
  VUXe: '7b68ee',
  VsprRggYF: 'fa9a',
  VQe: '48d1cc',
  VviTetYd: 'c71585',
  midnightXe: '191970',
  mRtcYam: 'f5fffa',
  mistyPse: 'ffe4e1',
  moccasR: 'ffe4b5',
  navajowEte: 'ffdead',
  navy: '80',
  Tdlace: 'fdf5e6',
  Tive: '808000',
  TivedBb: '6b8e23',
  Sange: 'ffa500',
  SangeYd: 'ff4500',
  ScEd: 'da70d6',
  pOegTMnPd: 'eee8aa',
  pOegYF: '98fb98',
  pOeQe: 'afeeee',
  pOeviTetYd: 'db7093',
  papayawEp: 'ffefd5',
  pHKpuff: 'ffdab9',
  peru: 'cd853f',
  pRk: 'ffc0cb',
  plum: 'dda0dd',
  powMrXe: 'b0e0e6',
  purpN: '800080',
  YbeccapurpN: '663399',
  Yd: 'ff0000',
  Psybrown: 'bc8f8f',
  PyOXe: '4169e1',
  saddNbPwn: '8b4513',
  sOmon: 'fa8072',
  sandybPwn: 'f4a460',
  sHgYF: '2e8b57',
  sHshell: 'fff5ee',
  siFna: 'a0522d',
  silver: 'c0c0c0',
  skyXe: '87ceeb',
  UXe: '6a5acd',
  UWay: '708090',
  UgYy: '708090',
  snow: 'fffafa',
  sprRggYF: 'ff7f',
  stAlXe: '4682b4',
  tan: 'd2b48c',
  teO: '8080',
  tEstN: 'd8bfd8',
  tomato: 'ff6347',
  Qe: '40e0d0',
  viTet: 'ee82ee',
  JHt: 'f5deb3',
  wEte: 'ffffff',
  wEtesmoke: 'f5f5f5',
  Lw: 'ffff00',
  LwgYF: '9acd32'
};

function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map$2);
  let i, j, k, ok, nk;

  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];

    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map$2[k]);
    }

    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];
  }

  return unpacked;
}

let names;

function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }

  const a = names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}

const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;

function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;

  if (!m) {
    return;
  }

  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }

  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}

function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}

const to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;

const from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);

function interpolate$1(rgb1, rgb2, t) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}

function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}

function clone$1(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}

function fromObject(input) {
  var v = {
    r: 0,
    g: 0,
    b: 0,
    a: 255
  };

  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = {
        r: input[0],
        g: input[1],
        b: input[2],
        a: 255
      };

      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone$1(input, {
      r: 0,
      g: 0,
      b: 0,
      a: 1
    });
    v.a = n2b(v.a);
  }

  return v;
}

function functionParse(str) {
  if (str.charAt(0) === 'r') {
    return rgbParse(str);
  }

  return hueParse(str);
}

class Color {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }

    const type = typeof input;
    let v;

    if (type === 'object') {
      v = fromObject(input);
    } else if (type === 'string') {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }

    this._rgb = v;
    this._valid = !!v;
  }

  get valid() {
    return this._valid;
  }

  get rgb() {
    var v = clone$1(this._rgb);

    if (v) {
      v.a = b2n(v.a);
    }

    return v;
  }

  set rgb(obj) {
    this._rgb = fromObject(obj);
  }

  rgbString() {
    return this._valid ? rgbString(this._rgb) : undefined;
  }

  hexString() {
    return this._valid ? hexString(this._rgb) : undefined;
  }

  hslString() {
    return this._valid ? hslString(this._rgb) : undefined;
  }

  mix(color, weight) {
    if (color) {
      const c1 = this.rgb;
      const c2 = color.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
      w2 = 1 - w1;
      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }

    return this;
  }

  interpolate(color, t) {
    if (color) {
      this._rgb = interpolate$1(this._rgb, color._rgb, t);
    }

    return this;
  }

  clone() {
    return new Color(this.rgb);
  }

  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }

  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }

  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }

  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }

  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }

  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }

  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }

  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }

  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }

  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }

}

/*!
 * Chart.js v4.1.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
/**
 * @namespace Chart.helpers
 */

/**
* An empty function that can be used, for example, for optional callback.
*/

function noop() {
  /* noop */
}
/**
 * Returns a unique id, sequentially generated from a global variable.
 */


const uid = (() => {
  let id = 0;
  return () => id++;
})();
/**
 * Returns true if `value` is neither null nor undefined, else returns false.
 * @param value - The value to test.
 * @since 2.7.0
 */


function isNullOrUndef(value) {
  return value === null || typeof value === 'undefined';
}
/**
 * Returns true if `value` is an array (including typed arrays), else returns false.
 * @param value - The value to test.
 * @function
 */


function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }

  const type = Object.prototype.toString.call(value);

  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {
    return true;
  }

  return false;
}
/**
 * Returns true if `value` is an object (excluding null), else returns false.
 * @param value - The value to test.
 * @since 2.7.0
 */


function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === '[object Object]';
}
/**
 * Returns true if `value` is a finite number, else returns false
 * @param value  - The value to test.
 */


function isNumberFinite(value) {
  return (typeof value === 'number' || value instanceof Number) && isFinite(+value);
}
/**
 * Returns `value` if finite, else returns `defaultValue`.
 * @param value - The value to return if defined.
 * @param defaultValue - The value to return if `value` is not finite.
 */


function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
/**
 * Returns `value` if defined, else returns `defaultValue`.
 * @param value - The value to return if defined.
 * @param defaultValue - The value to return if `value` is undefined.
 */


function valueOrDefault(value, defaultValue) {
  return typeof value === 'undefined' ? defaultValue : value;
}

const toPercentage = (value, dimension) => typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : +value / dimension;

const toDimension = (value, dimension) => typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value;
/**
 * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
 * value returned by `fn`. If `fn` is not a function, this method returns undefined.
 * @param fn - The function to call.
 * @param args - The arguments with which `fn` should be called.
 * @param [thisArg] - The value of `this` provided for the call to `fn`.
 */


function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === 'function') {
    return fn.apply(thisArg, args);
  }
}

function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;

  if (isArray(loopable)) {
    len = loopable.length;

    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;

    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
/**
 * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
 * @param a0 - The array to compare
 * @param a1 - The array to compare
 * @private
 */


function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;

  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }

  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];

    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }

  return true;
}
/**
 * Returns a deep copy of `source` without keeping references on objects and arrays.
 * @param source - The value to clone.
 */


function clone(source) {
  if (isArray(source)) {
    return source.map(clone);
  }

  if (isObject(source)) {
    const target = Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;

    for (; k < klen; ++k) {
      target[keys[k]] = clone(source[keys[k]]);
    }

    return target;
  }

  return source;
}

function isValidKey(key) {
  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;
}
/**
 * The default merger when Chart.helpers.merge is called without merger option.
 * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
 * @private
 */


function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }

  const tval = target[key];
  const sval = source[key];

  if (isObject(tval) && isObject(sval)) {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    merge(tval, sval, options);
  } else {
    target[key] = clone(sval);
  }
}

function merge(target, source, options) {
  const sources = isArray(source) ? source : [source];
  const ilen = sources.length;

  if (!isObject(target)) {
    return target;
  }

  options = options || {};
  const merger = options.merger || _merger;
  let current;

  for (let i = 0; i < ilen; ++i) {
    current = sources[i];

    if (!isObject(current)) {
      continue;
    }

    const keys = Object.keys(current);

    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, current, options);
    }
  }

  return target;
}

function mergeIf(target, source) {
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  return merge(target, source, {
    merger: _mergerIf
  });
}
/**
 * Merges source[key] in target[key] only if target[key] is undefined.
 * @private
 */


function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }

  const tval = target[key];
  const sval = source[key];

  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone(sval);
  }
}


const keyResolvers = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  '': v => v,
  // default resolvers
  x: o => o.x,
  y: o => o.y
};
/**
 * @private
 */

function _splitKey(key) {
  const parts = key.split('.');
  const keys = [];
  let tmp = '';

  for (const part of parts) {
    tmp += part;

    if (tmp.endsWith('\\')) {
      tmp = tmp.slice(0, -1) + '.';
    } else {
      keys.push(tmp);
      tmp = '';
    }
  }

  return keys;
}

function _getKeyResolver(key) {
  const keys = _splitKey(key);

  return obj => {
    for (const k of keys) {
      if (k === '') {
        break;
      }

      obj = obj && obj[k];
    }

    return obj;
  };
}

function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));

  return resolver(obj);
}
/**
 * @private
 */


function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

const defined = value => typeof value !== 'undefined';

const isFunction = value => typeof value === 'function'; // Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384


const setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }

  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }

  return true;
};
/**
 * @param e - The event
 * @private
 */


function _isClickEvent(e) {
  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';
}
/**
 * @alias Chart.helpers.math
 * @namespace
 */


const PI = Math.PI;
const TAU = 2 * PI;
const PITAU = TAU + PI;
const INFINITY = Number.POSITIVE_INFINITY;
const RAD_PER_DEG = PI / 180;
const HALF_PI = PI / 2;
const QUARTER_PI = PI / 4;
const TWO_THIRDS_PI = PI * 2 / 3;
const log10 = Math.log10;
const sign = Math.sign;

function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
/**
 * Implementation of the nice number algorithm used in determining where axis labels will go
 */


function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
/**
 * Returns an array of factors sorted from 1 to sqrt(value)
 * @private
 */


function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;

  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }

  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }

  result.sort((a, b) => a - b).pop();
  return result;
}

function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
/**
 * @private
 */


function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;

  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];

    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}

function toRadians(degrees) {
  return degrees * (PI / 180);
}

function toDegrees(radians) {
  return radians * (180 / PI);
}
/**
 * Returns the number of decimal places
 * i.e. the number of digits after the decimal point, of the value of this Number.
 * @param x - A number.
 * @returns The number of decimal places.
 * @private
 */


function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }

  let e = 1;
  let p = 0;

  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }

  return p;
} // Gets the angle from vertical upright to the point about a centre.


function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

  if (angle < -0.5 * PI) {
    angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
  }

  return {
    angle,
    distance: radialDistanceFromCenter
  };
}

function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
/**
 * Shortest distance between angles, in either direction.
 * @private
 */


function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
/**
 * Normalize angle to be between 0 and 2*PI
 * @private
 */


function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
/**
 * @private
 */


function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);

  const s = _normalizeAngle(start);

  const e = _normalizeAngle(end);

  const angleToStart = _normalizeAngle(s - a);

  const angleToEnd = _normalizeAngle(e - a);

  const startToAngle = _normalizeAngle(a - s);

  const endToAngle = _normalizeAngle(a - e);

  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
/**
 * Limit `value` between `min` and `max`
 * @param value
 * @param min
 * @param max
 * @private
 */


function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
/**
 * @param {number} value
 * @private
 */


function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
/**
 * @param value
 * @param start
 * @param end
 * @param [epsilon]
 * @private
 */


function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}

function _lookup(table, value, cmp) {
  cmp = cmp || (index => table[index] < value);

  let hi = table.length - 1;
  let lo = 0;
  let mid;

  while (hi - lo > 1) {
    mid = lo + hi >> 1;

    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }

  return {
    lo,
    hi
  };
}
/**
 * Binary search
 * @param table - the table search. must be sorted!
 * @param key - property name for the value in each entry
 * @param value - value to find
 * @param last - lookup last index
 * @private
 */


const _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? index => {
  const ti = table[index][key];
  return ti < value || ti === value && table[index + 1][key] === value;
} : index => table[index][key] < value);
/**
 * Reverse binary search
 * @param table - the table search. must be sorted!
 * @param key - property name for the value in each entry
 * @param value - value to find
 * @private
 */


const _rlookupByKey = (table, key, value) => _lookup(table, value, index => table[index][key] >= value);
/**
 * Return subset of `values` between `min` and `max` inclusive.
 * Values are assumed to be in sorted order.
 * @param values - sorted array of values
 * @param min - min value
 * @param max - max value
 */


function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;

  while (start < end && values[start] < min) {
    start++;
  }

  while (end > start && values[end - 1] > max) {
    end--;
  }

  return start > 0 || end < values.length ? values.slice(start, end) : values;
}

const arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];

function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);

    return;
  }

  Object.defineProperty(array, '_chartjs', {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [listener]
    }
  });
  arrayEvents.forEach(key => {
    const method = '_onData' + _capitalize(key);

    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,

      value(...args) {
        const res = base.apply(this, args);

        array._chartjs.listeners.forEach(object => {
          if (typeof object[method] === 'function') {
            object[method](...args);
          }
        });

        return res;
      }

    });
  });
}

function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;

  if (!stub) {
    return;
  }

  const listeners = stub.listeners;
  const index = listeners.indexOf(listener);

  if (index !== -1) {
    listeners.splice(index, 1);
  }

  if (listeners.length > 0) {
    return;
  }

  arrayEvents.forEach(key => {
    delete array[key];
  });
  delete array._chartjs;
}
/**
 * @param items
 */


function _arrayUnique(items) {
  const set = new Set();
  let i, ilen;

  for (i = 0, ilen = items.length; i < ilen; ++i) {
    set.add(items[i]);
  }

  if (set.size === ilen) {
    return items;
  }

  return Array.from(set);
}
/**
* Request animation polyfill
*/


const requestAnimFrame = function () {
  if (typeof window === 'undefined') {
    return function (callback) {
      return callback();
    };
  }

  return window.requestAnimationFrame;
}();
/**
 * Throttles calling `fn` once per animation frame
 * Latest arguments are used on the actual call
 */


function throttled(fn, thisArg) {
  let argsToUse = [];
  let ticking = false;
  return function (...args) {
    // Save the args for use later
    argsToUse = args;

    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, argsToUse);
      });
    }
  };
}
/**
 * Debounces calling `fn` for `delay` ms
 */


function debounce(fn, delay) {
  let timeout;
  return function (...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }

    return delay;
  };
}
/**
 * Converts 'start' to 'left', 'end' to 'right' and others to 'center'
 * @private
 */


const _toLeftRightCenter = align => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';
/**
 * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`
 * @private
 */


const _alignStartEnd = (align, start, end) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;
/**
 * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`
 * @private
 */


const _textX = (align, left, right, rtl) => {
  const check = rtl ? 'left' : 'right';
  return align === check ? right : align === 'center' ? (left + right) / 2 : left;
};
/**
 * Return start and count of visible points.
 * @private
 */


function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;

  if (meta._sorted) {
    const {
      iScale,
      _parsed
    } = meta;
    const axis = iScale.axis;
    const {
      min,
      max,
      minDefined,
      maxDefined
    } = iScale.getUserBounds();

    if (minDefined) {
      start = _limitValue(Math.min( // @ts-expect-error Need to type _parsed
      _lookupByKey(_parsed, iScale.axis, min).lo, // @ts-expect-error Need to fix types on _lookupByKey
      animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
    }

    if (maxDefined) {
      count = _limitValue(Math.max( // @ts-expect-error Need to type _parsed
      _lookupByKey(_parsed, iScale.axis, max, true).hi + 1, // @ts-expect-error Need to fix types on _lookupByKey
      animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }

  return {
    start,
    count
  };
}
/**
 * Checks if the scale ranges have changed.
 * @param {object} meta - dataset meta.
 * @returns {boolean}
 * @private
 */


function _scaleRangesChanged(meta) {
  const {
    xScale,
    yScale,
    _scaleRanges
  } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };

  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }

  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}

const atEdge = t => t === 0 || t === 1;

const elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));

const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
/**
 * Easing functions adapted from Robert Penner's easing equations.
 * @namespace Chart.helpers.easing.effects
 * @see http://www.robertpenner.com/easing/
 */


const effects = {
  linear: t => t,
  easeInQuad: t => t * t,
  easeOutQuad: t => -t * (t - 2),
  easeInOutQuad: t => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: t => t * t * t,
  easeOutCubic: t => (t -= 1) * t * t + 1,
  easeInOutCubic: t => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: t => t * t * t * t,
  easeOutQuart: t => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: t => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: t => t * t * t * t * t,
  easeOutQuint: t => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: t => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: t => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: t => Math.sin(t * HALF_PI),
  easeInOutSine: t => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: t => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: t => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: t => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: t => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: t => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),

  easeInOutElastic(t) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
  },

  easeInBack(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
  },

  easeOutBack(t) {
    const s = 1.70158;
    return (t -= 1) * t * ((s + 1) * t + s) + 1;
  },

  easeInOutBack(t) {
    let s = 1.70158;

    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
    }

    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
  },

  easeInBounce: t => 1 - effects.easeOutBounce(1 - t),

  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;

    if (t < 1 / d) {
      return m * t * t;
    }

    if (t < 2 / d) {
      return m * (t -= 1.5 / d) * t + 0.75;
    }

    if (t < 2.5 / d) {
      return m * (t -= 2.25 / d) * t + 0.9375;
    }

    return m * (t -= 2.625 / d) * t + 0.984375;
  },

  easeInOutBounce: t => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};

function isPatternOrGradient(value) {
  if (value && typeof value === 'object') {
    const type = value.toString();
    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';
  }

  return false;
}

function color(value) {
  return isPatternOrGradient(value) ? value : new Color(value);
}

function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
}

const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];
const colors = ['color', 'borderColor', 'backgroundColor'];

function applyAnimationsDefaults(defaults) {
  defaults.set('animation', {
    delay: undefined,
    duration: 1000,
    easing: 'easeOutQuart',
    fn: undefined,
    from: undefined,
    loop: undefined,
    to: undefined,
    type: undefined
  });
  defaults.describe('animation', {
    _fallback: false,
    _indexable: false,
    _scriptable: name => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn'
  });
  defaults.set('animations', {
    colors: {
      type: 'color',
      properties: colors
    },
    numbers: {
      type: 'number',
      properties: numbers
    }
  });
  defaults.describe('animations', {
    _fallback: 'animation'
  });
  defaults.set('transitions', {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: 'transparent'
        },
        visible: {
          type: 'boolean',
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: 'transparent'
        },
        visible: {
          type: 'boolean',
          easing: 'linear',
          fn: v => v | 0
        }
      }
    }
  });
}

function applyLayoutsDefaults(defaults) {
  defaults.set('layout', {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}

const intlCache = new Map();

function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);

  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }

  return formatter;
}

function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}

const formatters = {
  values(value) {
    return isArray(value) ? value : '' + value;
  },

  numeric(tickValue, index, ticks) {
    if (tickValue === 0) {
      return '0';
    }

    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;

    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));

      if (maxTick < 1e-4 || maxTick > 1e+15) {
        notation = 'scientific';
      }

      delta = calculateDelta(tickValue, ticks);
    }

    const logDelta = log10(Math.abs(delta));
    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  },

  logarithmic(tickValue, index, ticks) {
    if (tickValue === 0) {
      return '0';
    }

    const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));

    if ([1, 2, 3, 5, 10, 15].includes(remain) || index > 0.8 * ticks.length) {
      return formatters.numeric.call(this, tickValue, index, ticks);
    }

    return '';
  }

};

function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;

  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }

  return delta;
}

var Ticks = {
  formatters
};

function applyScaleDefaults(defaults) {
  defaults.set('scale', {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: 'ticks',
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0.0,
      width: 1
    },
    title: {
      display: false,
      text: '',
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: '',
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: 'center',
      crossAlign: 'near',
      showLabelBackdrop: false,
      backdropColor: 'rgba(255, 255, 255, 0.75)',
      backdropPadding: 2
    }
  });
  defaults.route('scale.ticks', 'color', '', 'color');
  defaults.route('scale.grid', 'color', '', 'borderColor');
  defaults.route('scale.border', 'color', '', 'borderColor');
  defaults.route('scale.title', 'color', '', 'color');
  defaults.describe('scale', {
    _fallback: false,
    _scriptable: name => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',
    _indexable: name => name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash'
  });
  defaults.describe('scales', {
    _fallback: 'scale'
  });
  defaults.describe('scale.ticks', {
    _scriptable: name => name !== 'backdropPadding' && name !== 'callback',
    _indexable: name => name !== 'backdropPadding'
  });
}

const overrides = Object.create(null);
const descriptors = Object.create(null);

function getScope$1(node, key) {
  if (!key) {
    return node;
  }

  const keys = key.split('.');

  for (let i = 0, n = keys.length; i < n; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = Object.create(null));
  }

  return node;
}

function set(root, scope, values) {
  if (typeof scope === 'string') {
    return merge(getScope$1(root, scope), values);
  }

  return merge(getScope$1(root, ''), scope);
}

class Defaults {
  constructor(_descriptors, _appliers) {
    this.animation = undefined;
    this.backgroundColor = 'rgba(0,0,0,0.1)';
    this.borderColor = 'rgba(0,0,0,0.1)';
    this.color = '#666';
    this.datasets = {};

    this.devicePixelRatio = context => context.chart.platform.getDevicePixelRatio();

    this.elements = {};
    this.events = ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: 'normal',
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};

    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);

    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);

    this.hoverColor = (ctx, options) => getHoverColor(options.color);

    this.indexAxis = 'x';
    this.interaction = {
      mode: 'nearest',
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = undefined;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors);
    this.apply(_appliers);
  }

  set(scope, values) {
    return set(this, scope, values);
  }

  get(scope) {
    return getScope$1(this, scope);
  }

  describe(scope, values) {
    return set(descriptors, scope, values);
  }

  override(scope, values) {
    return set(overrides, scope, values);
  }

  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = '_' + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,

        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];

          if (isObject(local)) {
            return Object.assign({}, target, local);
          }

          return valueOrDefault(local, target);
        },

        set(value) {
          this[privateName] = value;
        }

      }
    });
  }

  apply(appliers) {
    appliers.forEach(apply => apply(this));
  }

}

var defaults = /* #__PURE__ */new Defaults({
  _scriptable: name => !name.startsWith('on'),
  _indexable: name => name !== 'events',
  hover: {
    _fallback: 'interaction'
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults]);

function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }

  return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;
}

function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];

  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }

  if (textWidth > longest) {
    longest = textWidth;
  }

  return longest;
}

function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];

  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }

  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;

  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];

    if (thing !== undefined && thing !== null && isArray(thing) !== true) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];

        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }

  ctx.restore();
  const gcLen = gc.length / 2;

  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }

    gc.splice(0, gcLen);
  }

  return longest;
}

function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}

function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext('2d');
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}

function drawPoint(ctx, options, x, y) {
  drawPointLegend(ctx, options, x, y, null);
}

function drawPointLegend(ctx, options, x, y, w) {
  let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;

  if (style && typeof style === 'object') {
    type = style.toString();

    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }

  if (isNaN(radius) || radius <= 0) {
    return;
  }

  ctx.beginPath();

  switch (style) {
    default:
      if (w) {
        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
      } else {
        ctx.arc(x, y, radius, 0, TAU);
      }

      ctx.closePath();
      break;

    case 'triangle':
      width = w ? w / 2 : radius;
      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      ctx.closePath();
      break;

    case 'rectRounded':
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;

    case 'rect':
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        width = w ? w / 2 : size;
        ctx.rect(x - width, y - size, 2 * width, 2 * size);
        break;
      }

      rad += QUARTER_PI;

    case 'rectRot':
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      ctx.closePath();
      break;

    case 'crossRot':
      rad += QUARTER_PI;

    case 'cross':
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;

    case 'star':
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      rad += QUARTER_PI;
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;

    case 'line':
      xOffset = w ? w / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      break;

    case 'dash':
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
      break;

    case false:
      ctx.closePath();
      break;
  }

  ctx.fill();

  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}

function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}

function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}

function unclipArea(ctx) {
  ctx.restore();
}

function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }

  if (mode === 'middle') {
    const midpoint = (previous.x + target.x) / 2.0;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === 'after' !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }

  ctx.lineTo(target.x, target.y);
}

function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }

  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}

function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray(text) ? text : [text];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);

  for (i = 0; i < lines.length; ++i) {
    line = lines[i];

    if (opts.backdrop) {
      drawBackdrop(ctx, opts.backdrop);
    }

    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }

      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }

      ctx.strokeText(line, x, y, opts.maxWidth);
    }

    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += font.lineHeight;
  }

  ctx.restore();
}

function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }

  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }

  if (opts.color) {
    ctx.fillStyle = opts.color;
  }

  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }

  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}

function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}

function drawBackdrop(ctx, opts) {
  const oldColor = ctx.fillStyle;
  ctx.fillStyle = opts.color;
  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx.fillStyle = oldColor;
}

function addRoundedRectPath(ctx, rect) {
  const {
    x,
    y,
    w,
    h,
    radius
  } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
  ctx.lineTo(x, y + h - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h);
  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}

const LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
const FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
/**
 * @alias Chart.helpers.options
 * @namespace
 */

/**
* Converts the given line height `value` in pixels for a specific font `size`.
* @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
* @param size - The font size (in pixels) used to resolve relative `value`.
* @returns The effective line height in pixels (size * 1.2 if value is invalid).
* @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
* @since 2.7.0
*/

function toLineHeight(value, size) {
  const matches = ('' + value).match(LINE_HEIGHT);

  if (!matches || matches[1] === 'normal') {
    return size * 1.2;
  }

  value = +matches[2];

  switch (matches[3]) {
    case 'px':
      return value;

    case '%':
      value /= 100;
      break;
  }

  return size * value;
}

const numberOrZero = v => +v || 0;

function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value) ? objProps ? prop => valueOrDefault(value[prop], value[props[prop]]) : prop => value[prop] : () => value;

  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }

  return ret;
}
/**
 * Converts the given value into a TRBL object.
 * @param value - If a number, set the value to all TRBL component,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 *  x / y are shorthands for same value for left/right and top/bottom.
 * @returns The padding values (top, right, bottom, left)
 * @since 3.0.0
 */


function toTRBL(value) {
  return _readValueToProps(value, {
    top: 'y',
    right: 'x',
    bottom: 'y',
    left: 'x'
  });
}
/**
 * Converts the given value into a TRBL corners object (similar with css border-radius).
 * @param value - If a number, set the value to all TRBL corner components,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)
 * @since 3.0.0
 */


function toTRBLCorners(value) {
  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);
}
/**
 * Converts the given value into a padding object with pre-computed width/height.
 * @param value - If a number, set the value to all TRBL component,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 *  x / y are shorthands for same value for left/right and top/bottom.
 * @returns The padding values (top, right, bottom, left, width, height)
 * @since 2.7.0
 */


function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
/**
 * Parses font options and returns the font object.
 * @param options - A object that contains font options to be parsed.
 * @param fallback - A object that contains fallback font options.
 * @return The font object.
 * @private
 */


function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);

  if (typeof size === 'string') {
    size = parseInt(size, 10);
  }

  let style = valueOrDefault(options.style, fallback.style);

  if (style && !('' + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = undefined;
  }

  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ''
  };
  font.string = toFontString(font);
  return font;
}
/**
 * Evaluates the given `inputs` sequentially and returns the first defined value.
 * @param inputs - An array of values, falling back to the last value.
 * @param context - If defined and the current value is a function, the value
 * is called with `context` as first argument and the result becomes the new input.
 * @param index - If defined and the current value is an array, the value
 * at `index` become the new input.
 * @param info - object to return information about resolution in
 * @param info.cacheable - Will be set to `false` if option is not cacheable.
 * @since 2.7.0
 */


function resolve(inputs, context, index, info) {
  let cacheable = true;
  let i, ilen, value;

  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];

    if (value === undefined) {
      continue;
    }

    if (context !== undefined && typeof value === 'function') {
      value = value(context);
      cacheable = false;
    }

    if (index !== undefined && isArray(value)) {
      value = value[index % value.length];
      cacheable = false;
    }

    if (value !== undefined) {
      if (info && !cacheable) {
        info.cacheable = false;
      }

      return value;
    }
  }
}
/**
 * @param minmax
 * @param grace
 * @param beginAtZero
 * @private
 */


function _addGrace(minmax, grace, beginAtZero) {
  const {
    min,
    max
  } = minmax;
  const change = toDimension(grace, (max - min) / 2);

  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;

  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}

function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}

function _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
  if (!defined(fallback)) {
    fallback = _resolve('_fallback', scopes);
  }

  const cache = {
    [Symbol.toStringTag]: 'Object',
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: rootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: scope => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },

    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },

    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },

    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },

    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },

    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },

    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }

  });
}

function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: ctx => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: scope => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },

    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },

    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
        enumerable: true,
        configurable: true
      } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },

    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },

    has(target, prop) {
      return Reflect.has(proxy, prop);
    },

    ownKeys() {
      return Reflect.ownKeys(proxy);
    },

    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }

  });
}

function _descriptors(proxy, defaults = {
  scriptable: true,
  indexable: true
}) {
  const {
    _scriptable = defaults.scriptable,
    _indexable = defaults.indexable,
    _allKeys = defaults.allKeys
  } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}

const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;

const needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters' && (Object.getPrototypeOf(value) === null || value.constructor === Object);

function _cached(target, prop, resolve) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }

  const value = resolve();
  target[prop] = value;
  return value;
}

function _resolveWithContext(target, prop, receiver) {
  const {
    _proxy,
    _context,
    _subProxy,
    _descriptors: descriptors
  } = target;
  let value = _proxy[prop];

  if (isFunction(value) && descriptors.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }

  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors.isIndexable);
  }

  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);
  }

  return value;
}

function _resolveScriptable(prop, value, target, receiver) {
  const {
    _proxy,
    _context,
    _subProxy,
    _stack
  } = target;

  if (_stack.has(prop)) {
    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);
  }

  _stack.add(prop);

  value = value(_context, _subProxy || receiver);

  _stack.delete(prop);

  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }

  return value;
}

function _resolveArray(prop, value, target, isIndexable) {
  const {
    _proxy,
    _context,
    _subProxy,
    _descriptors: descriptors
  } = target;

  if (defined(_context.index) && isIndexable(prop)) {
    value = value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;

    const scopes = _proxy._scopes.filter(s => s !== arr);

    value = [];

    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));
    }
  }

  return value;
}

function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}

const getScope = (key, parent) => key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;

function addScopes(set, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);

    if (scope) {
      set.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);

      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
      return null;
    }
  }

  return false;
}

function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [...parentScopes, ...rootScopes];
  const set = new Set();
  set.add(value);
  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);

  if (key === null) {
    return false;
  }

  if (defined(fallback) && fallback !== prop) {
    key = addScopesFromKey(set, allScopes, fallback, key, value);

    if (key === null) {
      return false;
    }
  }

  return _createResolver(Array.from(set), [''], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}

function addScopesFromKey(set, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set, allScopes, key, fallback, item);
  }

  return key;
}

function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();

  if (!(prop in parent)) {
    parent[prop] = {};
  }

  const target = parent[prop];

  if (isArray(target) && isObject(value)) {
    return value;
  }

  return target || {};
}

function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;

  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);

    if (defined(value)) {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}

function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }

    const value = scope[key];

    if (defined(value)) {
      return value;
    }
  }
}

function getKeysFromAllScopes(target) {
  let keys = target._keys;

  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }

  return keys;
}

function resolveKeysFromAllScopes(scopes) {
  const set = new Set();

  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {
      set.add(key);
    }
  }

  return Array.from(set);
}

function _parseObjectDataRadialScale(meta, data, start, count) {
  const {
    iScale
  } = meta;
  const {
    key = 'r'
  } = this._parsing;
  const parsed = new Array(count);
  let i, ilen, index, item;

  for (i = 0, ilen = count; i < ilen; ++i) {
    index = i + start;
    item = data[index];
    parsed[i] = {
      r: iScale.parse(resolveObjectKey(item, key), index)
    };
  }

  return parsed;
}

const EPSILON = Number.EPSILON || 1e-14;

const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];

const getValueAxis = indexAxis => indexAxis === 'x' ? 'y' : 'x';

function splineCurve(firstPoint, middlePoint, afterPoint, t) {
  // Props to Rob Spencer at scaled innovation for his post on splining between points
  // http://scaledinnovation.com/analytics/splines/aboutSplines.html
  // This function must also respect "skipped" points
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12); // If all points are the same, s01 & s02 will be inf

  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t * s01; // scaling factor for triangle Ta

  const fb = t * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
/**
 * Adjust tangents to ensure monotonic properties
 */


function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);

  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);

    if (!pointCurrent || !pointAfter) {
      continue;
    }

    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }

    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);

    if (squaredMagnitude <= 9) {
      continue;
    }

    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}

function monotoneCompute(points, mK, indexAxis = 'x') {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);

  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);

    if (!pointCurrent) {
      continue;
    }

    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];

    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }

    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
/**
 * This function calculates Bézier control points in a similar way than |splineCurve|,
 * but preserves monotonicity of the provided data and ensures no local extremums are added
 * between the dataset discrete points due to the interpolation.
 * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
 */


function splineCurveMonotone(points, indexAxis = 'x') {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen); // Calculate slopes (deltaK) and initialize tangents (mK)

  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);

  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);

    if (!pointCurrent) {
      continue;
    }

    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis]; // In the case of two points that appear at the same x pixel, slopeDeltaX is 0

      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }

    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
  }

  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}

function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}

function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;

  let inAreaNext = _isPointInArea(points[0], area);

  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);

    if (!inArea) {
      continue;
    }

    point = points[i];

    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }

    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
/**
 * @private
 */


function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i, ilen, point, controlPoints; // Only consider points that are drawn in case the spanGaps option is used

  if (options.spanGaps) {
    points = points.filter(pt => !pt.skip);
  }

  if (options.cubicInterpolationMode === 'monotone') {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];

    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }

  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
/**
 * Note: typedefs are auto-exported, so use a made-up `dom` namespace where
 * necessary to avoid duplicates with `export * from './helpers`; see
 * https://github.com/microsoft/TypeScript/issues/46011
 * @typedef { import('../core/core.controller.js').default } dom.Chart
 * @typedef { import('../../types').ChartEvent } ChartEvent
 */

/**
* @private
*/


function _isDomSupported() {
  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * @private
 */


function _getParentNode(domNode) {
  let parent = domNode.parentNode;

  if (parent && parent.toString() === '[object ShadowRoot]') {
    parent = parent.host;
  }

  return parent;
}
/**
 * convert max-width/max-height values that may be percentages into a number
 * @private
 */


function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;

  if (typeof styleValue === 'string') {
    valueInPixels = parseInt(styleValue, 10);

    if (styleValue.indexOf('%') !== -1) {
      // percentage * size in dimension
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }

  return valueInPixels;
}

const getComputedStyle$1 = element => element.ownerDocument.defaultView.getComputedStyle(element, null);

function getStyle(el, property) {
  return getComputedStyle$1(el).getPropertyValue(property);
}

const positions = ['top', 'right', 'bottom', 'left'];

function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? '-' + suffix : '';

  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;
  }

  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}

const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
/**
 * @param e
 * @param canvas
 * @returns Canvas position
 */


function getCanvasPosition(e, canvas) {
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const {
    offsetX,
    offsetY
  } = source;
  let box = false;
  let x, y;

  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }

  return {
    x,
    y,
    box
  };
}
/**
 * Gets an event's x, y coordinates, relative to the chart area
 * @param event
 * @param chart
 * @returns x and y coordinates of the event
 */


function getRelativePosition(event, chart) {
  if ('native' in event) {
    return event;
  }

  const {
    canvas,
    currentDevicePixelRatio
  } = chart;
  const style = getComputedStyle$1(canvas);
  const borderBox = style.boxSizing === 'border-box';
  const paddings = getPositionedStyle(style, 'padding');
  const borders = getPositionedStyle(style, 'border', 'width');
  const {
    x,
    y,
    box
  } = getCanvasPosition(event, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let {
    width,
    height
  } = chart;

  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }

  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}

function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;

  if (width === undefined || height === undefined) {
    const container = _getParentNode(canvas);

    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect(); // this is the border box of the container

      const containerStyle = getComputedStyle$1(container);
      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');
      const containerPadding = getPositionedStyle(containerStyle, 'padding');
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');
    }
  }

  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}

const round1 = v => Math.round(v * 10) / 10; // eslint-disable-next-line complexity


function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle$1(canvas);
  const margins = getPositionedStyle(style, 'margin');
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let {
    width,
    height
  } = containerSize;

  if (style.boxSizing === 'content-box') {
    const borders = getPositionedStyle(style, 'border', 'width');
    const paddings = getPositionedStyle(style, 'padding');
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }

  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));

  if (width && !height) {
    // https://github.com/chartjs/Chart.js/issues/4659
    // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)
    height = round1(width / 2);
  }

  const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;

  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
    height = containerSize.height;
    width = round1(Math.floor(height * aspectRatio));
  }

  return {
    width,
    height
  };
}
/**
 * @param chart
 * @param forceRatio
 * @param forceStyle
 * @returns True if the canvas context size or transformation has changed.
 */


function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = Math.floor(chart.height);
  chart.width = Math.floor(chart.width);
  const canvas = chart.canvas; // If no style has been set on the canvas, the render size is used as display size,
  // making the chart visually bigger, so let's enforce it to the "correct" values.
  // See https://github.com/chartjs/Chart.js/issues/3575

  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }

  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }

  return false;
}
/**
 * Detects support for options object argument in addEventListener.
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
 * @private
 */


const supportsEventListenerOptions = function () {
  let passiveSupported = false;

  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }

    };
    window.addEventListener('test', null, options);
    window.removeEventListener('test', null, options);
  } catch (e) {// continue regardless of error
  }

  return passiveSupported;
}();
/**
 * The "used" size is the final value of a dimension property after all calculations have
 * been performed. This method uses the computed style of `element` but returns undefined
 * if the computed style is not expressed in pixels. That can happen in some cases where
 * `element` has a size relative to its parent and this last one is not yet displayed,
 * for example because of `display: none` on a parent node.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
 * @returns Size in pixels or undefined if unknown.
 */


function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : undefined;
}
/**
 * @private
 */


function _pointInLine(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: p1.y + t * (p2.y - p1.y)
  };
}
/**
 * @private
 */


function _steppedInterpolation(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
  };
}
/**
 * @private
 */


function _bezierInterpolation(p1, p2, t, mode) {
  const cp1 = {
    x: p1.cp2x,
    y: p1.cp2y
  };
  const cp2 = {
    x: p2.cp1x,
    y: p2.cp1y
  };

  const a = _pointInLine(p1, cp1, t);

  const b = _pointInLine(cp1, cp2, t);

  const c = _pointInLine(cp2, p2, t);

  const d = _pointInLine(a, b, t);

  const e = _pointInLine(b, c, t);

  return _pointInLine(d, e, t);
}

const getRightToLeftAdapter = function (rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },

    setWidth(w) {
      width = w;
    },

    textAlign(align) {
      if (align === 'center') {
        return align;
      }

      return align === 'right' ? 'left' : 'right';
    },

    xPlus(x, value) {
      return x - value;
    },

    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }

  };
};

const getLeftToRightAdapter = function () {
  return {
    x(x) {
      return x;
    },

    setWidth(w) {},

    textAlign(align) {
      return align;
    },

    xPlus(x, value) {
      return x + value;
    },

    leftForLtr(x, _itemWidth) {
      return x;
    }

  };
};

function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}

function overrideTextDirection(ctx, direction) {
  let style, original;

  if (direction === 'ltr' || direction === 'rtl') {
    style = ctx.canvas.style;
    original = [style.getPropertyValue('direction'), style.getPropertyPriority('direction')];
    style.setProperty('direction', direction, 'important');
    ctx.prevTextDirection = original;
  }
}

function restoreTextDirection(ctx, original) {
  if (original !== undefined) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty('direction', original[0], original[1]);
  }
}

function propertyFn(property) {
  if (property === 'angle') {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }

  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: x => x
  };
}

function normalizeSegment({
  start,
  end,
  count,
  loop,
  style
}) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}

function getSegment(segment, points, bounds) {
  const {
    property,
    start: startBound,
    end: endBound
  } = bounds;
  const {
    between,
    normalize
  } = propertyFn(property);
  const count = points.length;
  let {
    start,
    end,
    loop
  } = segment;
  let i, ilen;

  if (loop) {
    start += count;
    end += count;

    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }

      start--;
      end--;
    }

    start %= count;
    end %= count;
  }

  if (end < start) {
    end += count;
  }

  return {
    start,
    end,
    loop,
    style: segment.style
  };
}

function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [segment];
  }

  const {
    property,
    start: startBound,
    end: endBound
  } = bounds;
  const count = points.length;
  const {
    compare,
    between,
    normalize
  } = propertyFn(property);
  const {
    start,
    end,
    loop,
    style
  } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;

  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;

  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);

  const shouldStart = () => inside || startIsBefore();

  const shouldStop = () => !inside || endIsBefore();

  for (let i = start, prev = start; i <= end; ++i) {
    point = points[i % count];

    if (point.skip) {
      continue;
    }

    value = normalize(point[property]);

    if (value === prevValue) {
      continue;
    }

    inside = between(value, startBound, endBound);

    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i : prev;
    }

    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({
        start: subStart,
        end: i,
        loop,
        count,
        style
      }));
      subStart = null;
    }

    prev = i;
    prevValue = value;
  }

  if (subStart !== null) {
    result.push(normalizeSegment({
      start: subStart,
      end,
      loop,
      count,
      style
    }));
  }

  return result;
}

function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;

  for (let i = 0; i < segments.length; i++) {
    const sub = _boundSegment(segments[i], line.points, bounds);

    if (sub.length) {
      result.push(...sub);
    }
  }

  return result;
}

function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;

  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }

  while (start < count && points[start].skip) {
    start++;
  }

  start %= count;

  if (loop) {
    end += start;
  }

  while (end > start && points[end % count].skip) {
    end--;
  }

  end %= count;
  return {
    start,
    end
  };
}

function solidSegments(points, start, max, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;

  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];

    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({
          start: start % count,
          end: (end - 1) % count,
          loop
        });
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;

      if (prev.skip) {
        start = end;
      }
    }

    prev = cur;
  }

  if (last !== null) {
    result.push({
      start: start % count,
      end: last % count,
      loop
    });
  }

  return result;
}

function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;

  if (!count) {
    return [];
  }

  const loop = !!line._loop;
  const {
    start,
    end
  } = findStartAndEnd(points, count, loop, spanGaps);

  if (spanGaps === true) {
    return splitByStyles(line, [{
      start,
      end,
      loop
    }], points, segmentOptions);
  }

  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}

function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }

  return doSplitByStyles(line, segments, points, segmentOptions);
}

function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();

  const baseStyle = readStyle(line.options);
  const {
    _datasetIndex: datasetIndex,
    options: {
      spanGaps
    }
  } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i = start;

  function addStyle(s, e, l, st) {
    const dir = spanGaps ? -1 : 1;

    if (s === e) {
      return;
    }

    s += count;

    while (points[s % count].skip) {
      s -= dir;
    }

    while (points[e % count].skip) {
      e += dir;
    }

    if (s % count !== e % count) {
      result.push({
        start: s % count,
        end: e % count,
        loop: l,
        style: st
      });
      prevStyle = st;
      start = e % count;
    }
  }

  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;

    for (i = start + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: 'segment',
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex
      })));

      if (styleChanged(style, prevStyle)) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }

      prev = pt;
      prevStyle = style;
    }

    if (start < i - 1) {
      addStyle(start, i - 1, segment.loop, prevStyle);
    }
  }

  return result;
}

function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}

function styleChanged(style, prevStyle) {
  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
}

/*!
 * Chart.js v4.1.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */

class Animator {
  constructor() {
    this._request = null;
    this._charts = new Map();
    this._running = false;
    this._lastDate = undefined;
  }

  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach(fn => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }

  _refresh() {
    if (this._request) {
      return;
    }

    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();

      this._request = null;

      if (this._running) {
        this._refresh();
      }
    });
  }

  _update(date = Date.now()) {
    let remaining = 0;

    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }

      const items = anims.items;
      let i = items.length - 1;
      let draw = false;
      let item;

      for (; i >= 0; --i) {
        item = items[i];

        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }

          item.tick(date);
          draw = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }

      if (draw) {
        chart.draw();

        this._notify(chart, anims, date, 'progress');
      }

      if (!items.length) {
        anims.running = false;

        this._notify(chart, anims, date, 'complete');

        anims.initial = false;
      }

      remaining += items.length;
    });

    this._lastDate = date;

    if (remaining === 0) {
      this._running = false;
    }
  }

  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);

    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }

    return anims;
  }

  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }

  add(chart, items) {
    if (!items || !items.length) {
      return;
    }

    this._getAnims(chart).items.push(...items);
  }

  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }

  start(chart) {
    const anims = this._charts.get(chart);

    if (!anims) {
      return;
    }

    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);

    this._refresh();
  }

  running(chart) {
    if (!this._running) {
      return false;
    }

    const anims = this._charts.get(chart);

    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }

    return true;
  }

  stop(chart) {
    const anims = this._charts.get(chart);

    if (!anims || !anims.items.length) {
      return;
    }

    const items = anims.items;
    let i = items.length - 1;

    for (; i >= 0; --i) {
      items[i].cancel();
    }

    anims.items = [];

    this._notify(chart, anims, Date.now(), 'complete');
  }

  remove(chart) {
    return this._charts.delete(chart);
  }

}

var animator = /* #__PURE__ */new Animator();
const transparent = 'transparent';
const interpolators = {
  boolean(from, to, factor) {
    return factor > 0.5 ? to : from;
  },

  color(from, to, factor) {
    const c0 = color(from || transparent);
    const c1 = c0.valid && color(to || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
  },

  number(from, to, factor) {
    return from + (to - from) * factor;
  }

};

class Animation {
  constructor(cfg, target, prop, to) {
    const currentValue = target[prop];
    to = resolve([cfg.to, to, currentValue, cfg.from]);
    const from = resolve([cfg.from, currentValue, to]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from;
    this._to = to;
    this._promises = undefined;
  }

  active() {
    return this._active;
  }

  update(cfg, to, date) {
    if (this._active) {
      this._notify(false);

      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([cfg.to, to, currentValue, cfg.from]);
      this._from = resolve([cfg.from, currentValue, to]);
    }
  }

  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;

      this._notify(false);
    }
  }

  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from = this._from;
    const loop = this._loop;
    const to = this._to;
    let factor;
    this._active = from !== to && (loop || elapsed < duration);

    if (!this._active) {
      this._target[prop] = to;

      this._notify(true);

      return;
    }

    if (elapsed < 0) {
      this._target[prop] = from;
      return;
    }

    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from, to, factor);
  }

  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({
        res,
        rej
      });
    });
  }

  _notify(resolved) {
    const method = resolved ? 'res' : 'rej';
    const promises = this._promises || [];

    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }

}

class Animations {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = new Map();
    this.configure(config);
  }

  configure(config) {
    if (!isObject(config)) {
      return;
    }

    const animationOptions = Object.keys(defaults.animation);
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach(key => {
      const cfg = config[key];

      if (!isObject(cfg)) {
        return;
      }

      const resolved = {};

      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }

      (isArray(cfg.properties) && cfg.properties || [key]).forEach(prop => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }

  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);

    if (!options) {
      return [];
    }

    const animations = this._createAnimations(options, newOptions);

    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {});
    }

    return animations;
  }

  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;

    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];

      if (prop.charAt(0) === '$') {
        continue;
      }

      if (prop === 'options') {
        animations.push(...this._animateOptions(target, values));
        continue;
      }

      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);

      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }

      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }

      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }

    return animations;
  }

  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }

    const animations = this._createAnimations(target, values);

    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }

}

function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);

  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];

    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }

  return Promise.all(running);
}

function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }

  let options = target.options;

  if (!options) {
    target.options = newOptions;
    return;
  }

  if (options.$shared) {
    target.options = options = Object.assign({}, options, {
      $shared: false,
      $animations: {}
    });
  }

  return options;
}

function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === undefined ? allowedOverflow : 0;
  const max = opts.max === undefined ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}

function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }

  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}

function toClip(value) {
  let t, r, b, l;

  if (isObject(value)) {
    t = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t = r = b = l = value;
  }

  return {
    top: t,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}

function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];

  const metasets = chart._getSortedDatasetMetas(filterVisible);

  let i, ilen;

  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }

  return keys;
}

function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === 'single';
  let i, ilen, datasetIndex, otherValue;

  if (value === null) {
    return;
  }

  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];

    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }

      break;
    }

    otherValue = stack.values[datasetIndex];

    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
      value += otherValue;
    }
  }

  return value;
}

function convertObjectDataToArray(data) {
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i, ilen, key;

  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    adata[i] = {
      x: key,
      y: data[key]
    };
  }

  return adata;
}

function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === undefined && meta.stack !== undefined;
}

function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}

function getUserBounds(scale) {
  const {
    min,
    max,
    minDefined,
    maxDefined
  } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}

function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}

function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];

    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }

  return null;
}

function updateStacks(controller, parsed) {
  const {
    chart,
    _cachedMeta: meta
  } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const {
    iScale,
    vScale,
    index: datasetIndex
  } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;

  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const {
      [iAxis]: index,
      [vAxis]: value
    } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
    const visualValues = stack._visualValues || (stack._visualValues = {});
    visualValues[datasetIndex] = value;
  }
}

function getFirstScaleId(chart, axis) {
  const scales = chart.scales;
  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();
}

function createDatasetContext(parent, index) {
  return createContext(parent, {
    active: false,
    dataset: undefined,
    datasetIndex: index,
    index,
    mode: 'default',
    type: 'dataset'
  });
}

function createDataContext(parent, index, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index,
    parsed: undefined,
    raw: undefined,
    element,
    index,
    mode: 'default',
    type: 'data'
  });
}

function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;

  if (!axis) {
    return;
  }

  items = items || meta._parsed;

  for (const parsed of items) {
    const stacks = parsed._stacks;

    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {
      return;
    }

    delete stacks[axis][datasetIndex];

    if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {
      delete stacks[axis]._visualValues[datasetIndex];
    }
  }
}

const isDirectUpdateMode = mode => mode === 'reset' || mode === 'none';

const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);

const createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
  keys: getSortedDatasetIndices(chart, true),
  values: null
};

class DatasetController {
  static defaults = {};
  static datasetElementType = null;
  static dataElementType = null;

  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = undefined;
    this._parsing = false;
    this._data = undefined;
    this._objectData = undefined;
    this._sharedOptions = undefined;
    this._drawStart = undefined;
    this._drawCount = undefined;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = undefined;
    this._syncList = [];
    this.datasetElementType = new.target.datasetElementType;
    this.dataElementType = new.target.dataElementType;
    this.initialize();
  }

  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();

    if (this.options.fill && !this.chart.isPluginEnabled('filler')) {
      console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
  }

  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }

    this.index = datasetIndex;
  }

  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();

    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;

    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }

  getDataset() {
    return this.chart.data.datasets[this.index];
  }

  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }

  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }

  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }

  reset() {
    this._update('reset');
  }

  _destroy() {
    const meta = this._cachedMeta;

    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }

    if (meta._stacked) {
      clearStacks(meta);
    }
  }

  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;

    if (isObject(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }

      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }

      this._syncList = [];
      this._data = data;
    }
  }

  addElements() {
    const meta = this._cachedMeta;

    this._dataCheck();

    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }

  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;

    this._dataCheck();

    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);

    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }

    this._resyncElements(resetNewElements);

    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }

  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }

  parse(start, count) {
    const {
      _cachedMeta: meta,
      _data: data
    } = this;
    const {
      iScale,
      _stacked
    } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;

    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }

      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];

      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];

        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }

          prev = cur;
        }
      }

      meta._sorted = sorted;
    }

    if (_stacked) {
      updateStacks(this, parsed);
    }
  }

  parsePrimitiveData(meta, data, start, count) {
    const {
      iScale,
      vScale
    } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index;

    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index], index),
        [vAxis]: vScale.parse(data[index], index)
      };
    }

    return parsed;
  }

  parseArrayData(meta, data, start, count) {
    const {
      xScale,
      yScale
    } = meta;
    const parsed = new Array(count);
    let i, ilen, index, item;

    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(item[0], index),
        y: yScale.parse(item[1], index)
      };
    }

    return parsed;
  }

  parseObjectData(meta, data, start, count) {
    const {
      xScale,
      yScale
    } = meta;
    const {
      xAxisKey = 'x',
      yAxisKey = 'y'
    } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index, item;

    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
      };
    }

    return parsed;
  }

  getParsed(index) {
    return this._cachedMeta._parsed[index];
  }

  getDataElement(index) {
    return this._cachedMeta.data[index];
  }

  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]._visualValues
    };
    return applyStack(stack, value, meta.index, {
      mode
    });
  }

  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];

    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }

    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }

  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;

    const otherScale = this._getOtherScale(scale);

    const stack = createStack(canStack, meta, this.chart);
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    const {
      min: otherMin,
      max: otherMax
    } = getUserBounds(otherScale);
    let i, parsed;

    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }

    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }

      this.updateRangeFromParsed(range, scale, parsed, stack);

      if (sorted) {
        break;
      }
    }

    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }

        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }

    return range;
  }

  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;

    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];

      if (isNumberFinite(value)) {
        values.push(value);
      }
    }

    return values;
  }

  getMaxOverflow() {
    return false;
  }

  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',
      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''
    };
  }

  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || 'default');
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }

  update(mode) {}

  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;

    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }

    for (i = start; i < start + count; ++i) {
      const element = elements[i];

      if (element.hidden) {
        continue;
      }

      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }

    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }

  getStyle(index, active) {
    const mode = active ? 'active' : 'default';
    return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
  }

  getContext(index, active, mode) {
    const dataset = this.getDataset();
    let context;

    if (index >= 0 && index < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
      context.parsed = this.getParsed(index);
      context.raw = dataset.data[index];
      context.index = context.dataIndex = index;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }

    context.active = !!active;
    context.mode = mode;
    return context;
  }

  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }

  resolveDataElementOptions(index, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index);
  }

  _resolveElementOptions(elementType, mode = 'default', index) {
    const active = mode === 'active';
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + '-' + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index);

    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }

    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names = Object.keys(defaults.elements[elementType]);

    const context = () => this.getContext(index, active, mode);

    const values = config.resolveNamedOptions(scopes, names, context, prefixes);

    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }

    return values;
  }

  _resolveAnimations(index, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];

    if (cached) {
      return cached;
    }

    let options;

    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index, active, transition));
    }

    const animations = new Animations(chart, options && options.animations);

    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }

    return animations;
  }

  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }

    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }

  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }

  _getSharedOptions(start, mode) {
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return {
      sharedOptions,
      includeOptions
    };
  }

  updateElement(element, index, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index, mode).update(element, properties);
    }
  }

  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);
    }
  }

  _setStyle(element, index, mode, active) {
    element.active = active;
    const options = this.getStyle(index, active);

    this._resolveAnimations(index, mode, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }

  removeHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, 'active', false);
  }

  setHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, 'active', true);
  }

  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;

    if (element) {
      this._setStyle(element, undefined, 'active', false);
    }
  }

  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;

    if (element) {
      this._setStyle(element, undefined, 'active', true);
    }
  }

  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements = this._cachedMeta.data;

    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }

    this._syncList = [];
    const numMeta = elements.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);

    if (count) {
      this.parse(0, count);
    }

    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }

  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i;

    const move = arr => {
      arr.length += count;

      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };

    move(data);

    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }

    if (this._parsing) {
      move(meta._parsed);
    }

    this.parse(start, count);

    if (resetNewElements) {
      this.updateElements(data, start, count, 'reset');
    }
  }

  updateElements(element, start, count, mode) {}

  _removeElements(start, count) {
    const meta = this._cachedMeta;

    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);

      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }

    meta.data.splice(start, count);
  }

  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }

    this.chart._dataChanges.push([this.index, ...args]);
  }

  _onDataPush() {
    const count = arguments.length;

    this._sync(['_insertElements', this.getDataset().data.length - count, count]);
  }

  _onDataPop() {
    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);
  }

  _onDataShift() {
    this._sync(['_removeElements', 0, 1]);
  }

  _onDataSplice(start, count) {
    if (count) {
      this._sync(['_removeElements', start, count]);
    }

    const newCount = arguments.length - 2;

    if (newCount) {
      this._sync(['_insertElements', start, newCount]);
    }
  }

  _onDataUnshift() {
    this._sync(['_insertElements', 0, arguments.length]);
  }

}

function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];

    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }

    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }

  return scale._cache.$bar;
}

function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i, ilen, curr, prev;

  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }

    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }

    prev = curr;
  };

  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }

  prev = undefined;

  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }

  return min;
}

function computeFitCategoryTraits(index, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;

  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }

  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index] - size / 2
  };
}

function computeFlexCategoryTraits(index, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index];
  let prev = index > 0 ? pixels[index - 1] : null;
  let next = index < pixels.length - 1 ? pixels[index + 1] : null;
  const percent = options.categoryPercentage;

  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }

  if (next === null) {
    next = curr + curr - prev;
  }

  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}

function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;

  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }

  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}

function parseValue(entry, item, vScale, i) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }

  return item;
}

function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;

  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }

  return parsed;
}

function isFloatBar(custom) {
  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;
}

function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }

  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}

function borderProps(properties) {
  let reverse, start, end, top, bottom;

  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = 'left';
    end = 'right';
  } else {
    reverse = properties.base < properties.y;
    start = 'bottom';
    end = 'top';
  }

  if (reverse) {
    top = 'end';
    bottom = 'start';
  } else {
    top = 'start';
    bottom = 'end';
  }

  return {
    start,
    end,
    reverse,
    top,
    bottom
  };
}

function setBorderSkipped(properties, options, stack, index) {
  let edge = options.borderSkipped;
  const res = {};

  if (!edge) {
    properties.borderSkipped = res;
    return;
  }

  if (edge === true) {
    properties.borderSkipped = {
      top: true,
      right: true,
      bottom: true,
      left: true
    };
    return;
  }

  const {
    start,
    end,
    reverse,
    top,
    bottom
  } = borderProps(properties);

  if (edge === 'middle' && stack) {
    properties.enableBorderRadius = true;

    if ((stack._top || 0) === index) {
      edge = top;
    } else if ((stack._bottom || 0) === index) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }

  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}

function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }

  return edge;
}

function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}

function startEnd(v, start, end) {
  return v === 'start' ? start : v === 'end' ? end : v;
}

function setInflateAmount(properties, {
  inflateAmount
}, ratio) {
  properties.inflateAmount = inflateAmount === 'auto' ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}

class BarController extends DatasetController {
  static id = 'bar';
  static defaults = {
    datasetElementType: false,
    dataElementType: 'bar',
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: true,
    animations: {
      numbers: {
        type: 'number',
        properties: ['x', 'y', 'base', 'width', 'height']
      }
    }
  };
  static overrides = {
    scales: {
      _index_: {
        type: 'category',
        offset: true,
        grid: {
          offset: true
        }
      },
      _value_: {
        type: 'linear',
        beginAtZero: true
      }
    }
  };

  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }

  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }

  parseObjectData(meta, data, start, count) {
    const {
      iScale,
      vScale
    } = meta;
    const {
      xAxisKey = 'x',
      yAxisKey = 'y'
    } = this._parsing;
    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;

    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }

    return parsed;
  }

  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom = parsed._custom;

    if (custom && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }

  getMaxOverflow() {
    return 0;
  }

  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const {
      iScale,
      vScale
    } = meta;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? '[' + custom.start + ', ' + custom.end + ']' : '' + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }

  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }

  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }

  updateElements(bars, start, count, mode) {
    const reset = mode === 'reset';
    const {
      index,
      _cachedMeta: {
        vScale
      }
    } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();

    const ruler = this._getRuler();

    const {
      sharedOptions,
      includeOptions
    } = this._getSharedOptions(start, mode);

    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
        base,
        head: base
      } : this._calculateBarValuePixels(i);

      const ipixels = this._calculateBarIndexPixels(i, ruler);

      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };

      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);
      }

      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }

  _getStacks(last, dataIndex) {
    const {
      iScale
    } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter(meta => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];

    const skipNull = meta => {
      const parsed = meta.controller.getParsed(dataIndex);
      const val = parsed && parsed[meta.vScale.axis];

      if (isNullOrUndef(val) || isNaN(val)) {
        return true;
      }
    };

    for (const meta of metasets) {
      if (dataIndex !== undefined && skipNull(meta)) {
        continue;
      }

      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {
        stacks.push(meta.stack);
      }

      if (meta.index === last) {
        break;
      }
    }

    if (!stacks.length) {
      stacks.push(undefined);
    }

    return stacks;
  }

  _getStackCount(index) {
    return this._getStacks(undefined, index).length;
  }

  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);

    const index = name !== undefined ? stacks.indexOf(name) : -1;
    return index === -1 ? stacks.length - 1 : index;
  }

  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;

    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }

    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }

  _calculateBarValuePixels(index) {
    const {
      _cachedMeta: {
        vScale,
        _stacked,
        index: datasetIndex
      },
      options: {
        base: baseValue,
        minBarLength
      }
    } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;

    if (length !== value) {
      start = length - value;
      length = value;
    }

    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;

      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }

      start += value;
    }

    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);

    if (this.chart.getDataVisibility(index)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }

    size = head - base;

    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;

      if (value === actualBase) {
        base -= size / 2;
      }

      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max), min);
      head = base + size;

      if (_stacked && !floating) {
        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
      }
    }

    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }

    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }

  _calculateBarIndexPixels(index, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;

    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
      const range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);

      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);

      center = range.start + range.chunk * stackIndex + range.chunk / 2;
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }

    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }

  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;

    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null) {
        rects[i].draw(this._ctx);
      }
    }
  }

}

class BubbleController extends DatasetController {
  static id = 'bubble';
  static defaults = {
    datasetElementType: false,
    dataElementType: 'point',
    animations: {
      numbers: {
        type: 'number',
        properties: ['x', 'y', 'borderWidth', 'radius']
      }
    }
  };
  static overrides = {
    scales: {
      x: {
        type: 'linear'
      },
      y: {
        type: 'linear'
      }
    }
  };

  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }

  parsePrimitiveData(meta, data, start, count) {
    const parsed = super.parsePrimitiveData(meta, data, start, count);

    for (let i = 0; i < parsed.length; i++) {
      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
    }

    return parsed;
  }

  parseArrayData(meta, data, start, count) {
    const parsed = super.parseArrayData(meta, data, start, count);

    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
    }

    return parsed;
  }

  parseObjectData(meta, data, start, count) {
    const parsed = super.parseObjectData(meta, data, start, count);

    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
    }

    return parsed;
  }

  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max = 0;

    for (let i = data.length - 1; i >= 0; --i) {
      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
    }

    return max > 0 && max;
  }

  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const {
      xScale,
      yScale
    } = meta;
    const parsed = this.getParsed(index);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: labels[index] || '',
      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'
    };
  }

  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }

  updateElements(points, start, count, mode) {
    const reset = mode === 'reset';
    const {
      iScale,
      vScale
    } = this._cachedMeta;

    const {
      sharedOptions,
      includeOptions
    } = this._getSharedOptions(start, mode);

    const iAxis = iScale.axis;
    const vAxis = vScale.axis;

    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const parsed = !reset && this.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);

      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);

        if (reset) {
          properties.options.radius = 0;
        }
      }

      this.updateElement(point, i, properties, mode);
    }
  }

  resolveDataElementOptions(index, mode) {
    const parsed = this.getParsed(index);
    let values = super.resolveDataElementOptions(index, mode);

    if (values.$shared) {
      values = Object.assign({}, values, {
        $shared: false
      });
    }

    const radius = values.radius;

    if (mode !== 'active') {
      values.radius = 0;
    }

    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }

}

function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;

  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);

    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);

    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);

    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }

  return {
    ratioX,
    ratioY,
    offsetX,
    offsetY
  };
}

class DoughnutController extends DatasetController {
  static id = 'doughnut';
  static defaults = {
    datasetElementType: false,
    dataElementType: 'arc',
    animation: {
      animateRotate: true,
      animateScale: false
    },
    animations: {
      numbers: {
        type: 'number',
        properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']
      }
    },
    cutout: '50%',
    rotation: 0,
    circumference: 360,
    radius: '100%',
    spacing: 0,
    indexAxis: 'r'
  };
  static descriptors = {
    _scriptable: name => name !== 'spacing',
    _indexable: name => name !== 'spacing'
  };
  static overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;

            if (data.labels.length && data.datasets.length) {
              const {
                labels: {
                  pointStyle,
                  color
                }
              } = chart.legend.options;
              return data.labels.map((label, i) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  fontColor: color,
                  lineWidth: style.borderWidth,
                  pointStyle: pointStyle,
                  hidden: !chart.getDataVisibility(i),
                  index: i
                };
              });
            }

            return [];
          }

        },

        onClick(e, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }

      }
    }
  };

  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = undefined;
    this.outerRadius = undefined;
    this.offsetX = undefined;
    this.offsetY = undefined;
  }

  linkScales() {}

  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;

    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = i => +data[i];

      if (isObject(data[start])) {
        const {
          key = 'value'
        } = this._parsing;

        getter = i => +resolveObjectKey(data[i], key);
      }

      let i, ilen;

      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }

  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }

  _getCircumference() {
    return toRadians(this.options.circumference);
  }

  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;

    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
        const controller = this.chart.getDatasetMeta(i).controller;

        const rotation = controller._getRotation();

        const circumference = controller._getCircumference();

        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }

    return {
      rotation: min,
      circumference: max - min
    };
  }

  update(mode) {
    const chart = this.chart;
    const {
      chartArea
    } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);

    const chartWeight = this._getRingWeight(this.index);

    const {
      circumference,
      rotation
    } = this._getRotationExtents();

    const {
      ratioX,
      ratioY,
      offsetX,
      offsetY
    } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);

    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();

    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }

  _circumference(i, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;

    const circumference = this._getCircumference();

    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }

    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
  }

  updateElements(arcs, start, count, mode) {
    const reset = mode === 'reset';
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;

    const {
      sharedOptions,
      includeOptions
    } = this._getSharedOptions(start, mode);

    let startAngle = this._getRotation();

    let i;

    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset);
    }

    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset);

      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };

      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);
      }

      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
  }

  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;

    for (i = 0; i < metaData.length; i++) {
      const value = meta._parsed[i];

      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }

    return total;
  }

  calculateCircumference(value) {
    const total = this._cachedMeta.total;

    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }

    return 0;
  }

  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index], chart.options.locale);
    return {
      label: labels[index] || '',
      value
    };
  }

  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i, ilen, meta, controller, options;

    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }

    if (!arcs) {
      return 0;
    }

    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);

      if (options.borderAlign !== 'inner') {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }

    return max;
  }

  getMaxOffset(arcs) {
    let max = 0;

    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }

    return max;
  }

  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;

    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }

    return ringWeightOffset;
  }

  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }

  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }

}

class LineController extends DatasetController {
  static id = 'line';
  static defaults = {
    datasetElementType: 'line',
    dataElementType: 'point',
    showLine: true,
    spanGaps: false
  };
  static overrides = {
    scales: {
      _index_: {
        type: 'category'
      },
      _value_: {
        type: 'linear'
      }
    }
  };

  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }

  update(mode) {
    const meta = this._cachedMeta;
    const {
      dataset: line,
      data: points = [],
      _dataset
    } = meta;
    const animationsDisabled = this.chart._animationsDisabled;

    let {
      start,
      count
    } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);

    this._drawStart = start;
    this._drawCount = count;

    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }

    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);

    if (!this.options.showLine) {
      options.borderWidth = 0;
    }

    options.segment = this.options.segment;
    this.updateElement(line, undefined, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }

  updateElements(points, start, count, mode) {
    const reset = mode === 'reset';
    const {
      iScale,
      vScale,
      _stacked,
      _dataset
    } = this._cachedMeta;

    const {
      sharedOptions,
      includeOptions
    } = this._getSharedOptions(start, mode);

    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const {
      spanGaps,
      segment
    } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
    const end = start + count;
    const pointsCount = points.length;
    let prevParsed = start > 0 && this.getParsed(start - 1);

    for (let i = 0; i < pointsCount; ++i) {
      const point = points[i];
      const properties = directUpdate ? point : {};

      if (i < start || i >= end) {
        properties.skip = true;
        continue;
      }

      const parsed = this.getParsed(i);
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;

      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }

      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
      }

      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }

      prevParsed = parsed;
    }
  }

  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];

    if (!data.length) {
      return border;
    }

    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }

  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }

}

class PolarAreaController extends DatasetController {
  static id = 'polarArea';
  static defaults = {
    dataElementType: 'arc',
    animation: {
      animateRotate: true,
      animateScale: true
    },
    animations: {
      numbers: {
        type: 'number',
        properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']
      }
    },
    indexAxis: 'r',
    startAngle: 0
  };
  static overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;

            if (data.labels.length && data.datasets.length) {
              const {
                labels: {
                  pointStyle,
                  color
                }
              } = chart.legend.options;
              return data.labels.map((label, i) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  fontColor: color,
                  lineWidth: style.borderWidth,
                  pointStyle: pointStyle,
                  hidden: !chart.getDataVisibility(i),
                  index: i
                };
              });
            }

            return [];
          }

        },

        onClick(e, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }

      }
    },
    scales: {
      r: {
        type: 'radialLinear',
        angleLines: {
          display: false
        },
        beginAtZero: true,
        grid: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        startAngle: 0
      }
    }
  };

  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = undefined;
    this.outerRadius = undefined;
  }

  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index].r, chart.options.locale);
    return {
      label: labels[index] || '',
      value
    };
  }

  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }

  update(mode) {
    const arcs = this._cachedMeta.data;

    this._updateRadius();

    this.updateElements(arcs, 0, arcs.length, mode);
  }

  getMinMax() {
    const meta = this._cachedMeta;
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    meta.data.forEach((element, index) => {
      const parsed = this.getParsed(index).r;

      if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {
        if (parsed < range.min) {
          range.min = parsed;
        }

        if (parsed > range.max) {
          range.max = parsed;
        }
      }
    });
    return range;
  }

  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }

  updateElements(arcs, start, count, mode) {
    const reset = mode === 'reset';
    const chart = this.chart;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / this.countVisibleElements();

    for (i = 0; i < start; ++i) {
      angle += this._computeAngle(i, mode, defaultAngle);
    }

    for (i = start; i < start + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;

      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);

      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
      angle = endAngle;

      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }

        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }

      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)
      };
      this.updateElement(arc, i, properties, mode);
    }
  }

  countVisibleElements() {
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element, index) => {
      if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {
        count++;
      }
    });
    return count;
  }

  _computeAngle(index, mode, defaultAngle) {
    return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;
  }

}

class PieController extends DoughnutController {
  static id = 'pie';
  static defaults = {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: '100%'
  };
}

class RadarController extends DatasetController {
  static id = 'radar';
  static defaults = {
    datasetElementType: 'line',
    dataElementType: 'point',
    indexAxis: 'r',
    showLine: true,
    elements: {
      line: {
        fill: 'start'
      }
    }
  };
  static overrides = {
    aspectRatio: 1,
    scales: {
      r: {
        type: 'radialLinear'
      }
    }
  };

  getLabelAndValue(index) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: vScale.getLabels()[index],
      value: '' + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }

  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }

  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;

    if (mode !== 'resize') {
      const options = this.resolveDatasetElementOptions(mode);

      if (!this.options.showLine) {
        options.borderWidth = 0;
      }

      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, undefined, properties, mode);
    }

    this.updateElements(points, 0, points.length, mode);
  }

  updateElements(points, start, count, mode) {
    const scale = this._cachedMeta.rScale;
    const reset = mode === 'reset';

    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);
      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
      const x = reset ? scale.xCenter : pointPosition.x;
      const y = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      this.updateElement(point, i, properties, mode);
    }
  }

}

class ScatterController extends DatasetController {
  static id = 'scatter';
  static defaults = {
    datasetElementType: false,
    dataElementType: 'point',
    showLine: false,
    fill: false
  };
  static overrides = {
    interaction: {
      mode: 'point'
    },
    scales: {
      x: {
        type: 'linear'
      },
      y: {
        type: 'linear'
      }
    }
  };

  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const {
      xScale,
      yScale
    } = meta;
    const parsed = this.getParsed(index);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    return {
      label: labels[index] || '',
      value: '(' + x + ', ' + y + ')'
    };
  }

  update(mode) {
    const meta = this._cachedMeta;
    const {
      data: points = []
    } = meta;
    const animationsDisabled = this.chart._animationsDisabled;

    let {
      start,
      count
    } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);

    this._drawStart = start;
    this._drawCount = count;

    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }

    if (this.options.showLine) {
      const {
        dataset: line,
        _dataset
      } = meta;
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      options.segment = this.options.segment;
      this.updateElement(line, undefined, {
        animated: !animationsDisabled,
        options
      }, mode);
    }

    this.updateElements(points, start, count, mode);
  }

  addElements() {
    const {
      showLine
    } = this.options;

    if (!this.datasetElementType && showLine) {
      this.datasetElementType = this.chart.registry.getElement('line');
    }

    super.addElements();
  }

  updateElements(points, start, count, mode) {
    const reset = mode === 'reset';
    const {
      iScale,
      vScale,
      _stacked,
      _dataset
    } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const {
      spanGaps,
      segment
    } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
    let prevParsed = start > 0 && this.getParsed(start - 1);

    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;

      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }

      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
      }

      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }

      prevParsed = parsed;
    }

    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }

  getMaxOverflow() {
    const meta = this._cachedMeta;
    const data = meta.data || [];

    if (!this.options.showLine) {
      let max = 0;

      for (let i = data.length - 1; i >= 0; --i) {
        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
      }

      return max > 0 && max;
    }

    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;

    if (!data.length) {
      return border;
    }

    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }

}

var controllers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  BarController: BarController,
  BubbleController: BubbleController,
  DoughnutController: DoughnutController,
  LineController: LineController,
  PolarAreaController: PolarAreaController,
  PieController: PieController,
  RadarController: RadarController,
  ScatterController: ScatterController
});
/**
 * @namespace Chart._adapters
 * @since 2.8.0
 * @private
 */

function abstract() {
  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');
}
/**
 * Date adapter (current used by the time scale)
 * @namespace Chart._adapters._date
 * @memberof Chart._adapters
 * @private
 */


class DateAdapterBase {
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(members) {
    Object.assign(DateAdapterBase.prototype, members);
  }

  constructor(options) {
    this.options = options || {};
  } // eslint-disable-next-line @typescript-eslint/no-empty-function


  init() {}

  formats() {
    return abstract();
  }

  parse() {
    return abstract();
  }

  format() {
    return abstract();
  }

  add() {
    return abstract();
  }

  diff() {
    return abstract();
  }

  startOf() {
    return abstract();
  }

  endOf() {
    return abstract();
  }

}

var adapters = {
  _date: DateAdapterBase
};

function binarySearch(metaset, axis, value, intersect) {
  const {
    controller,
    data,
    _sorted
  } = metaset;
  const iScale = controller._cachedMeta.iScale;

  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;

    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === 'function' && el.getRange(axis);

      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return {
          lo: start.lo,
          hi: end.hi
        };
      }
    }
  }

  return {
    lo: 0,
    hi: data.length - 1
  };
}

function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];

  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const {
      index,
      data
    } = metasets[i];
    const {
      lo,
      hi
    } = binarySearch(metasets[i], axis, value, intersect);

    for (let j = lo; j <= hi; ++j) {
      const element = data[j];

      if (!element.skip) {
        handler(element, index, j);
      }
    }
  }
}

function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf('x') !== -1;
  const useY = axis.indexOf('y') !== -1;
  return function (pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}

function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];

  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }

  const evaluationFunc = function (element, datasetIndex, index) {
    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
      return;
    }

    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index
      });
    }
  };

  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}

function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];

  function evaluationFunc(element, datasetIndex, index) {
    const {
      startAngle,
      endAngle
    } = element.getProps(['startAngle', 'endAngle'], useFinalPosition);
    const {
      angle
    } = getAngleFromPoint(element, {
      x: position.x,
      y: position.y
    });

    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({
        element,
        datasetIndex,
        index
      });
    }
  }

  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}

function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;

  function evaluationFunc(element, datasetIndex, index) {
    const inRange = element.inRange(position.x, position.y, useFinalPosition);

    if (intersect && !inRange) {
      return;
    }

    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);

    if (!pointInArea && !inRange) {
      return;
    }

    const distance = distanceMetric(position, center);

    if (distance < minDistance) {
      items = [{
        element,
        datasetIndex,
        index
      }];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({
        element,
        datasetIndex,
        index
      });
    }
  }

  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}

function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }

  return axis === 'r' && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}

function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {
    if (element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index
      });
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });

  if (intersect && !intersectsItem) {
    return [];
  }

  return items;
}

var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || 'x';
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements = [];

      if (!items.length) {
        return [];
      }

      chart.getSortedVisibleDatasetMetas().forEach(meta => {
        const index = items[0].index;
        const element = meta.data[index];

        if (element && !element.skip) {
          elements.push({
            element,
            datasetIndex: meta.index,
            index
          });
        }
      });
      return elements;
    },

    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || 'xy';
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);

      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];

        for (let i = 0; i < data.length; ++i) {
          items.push({
            element: data[i],
            datasetIndex,
            index: i
          });
        }
      }

      return items;
    },

    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || 'xy';
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },

    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || 'xy';
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },

    x(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);
    },

    y(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);
    }

  }
};
const STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];

function filterByPosition(array, position) {
  return array.filter(v => v.pos === position);
}

function filterDynamicPositionByAxis(array, axis) {
  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}

function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}

function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;

  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({
      position: pos,
      options: {
        stack,
        stackWeight = 1
      }
    } = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }

  return layoutBoxes;
}

function buildStacks(layouts) {
  const stacks = {};

  for (const wrap of layouts) {
    const {
      stack,
      pos,
      stackWeight
    } = wrap;

    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }

    const _stack = stacks[stack] || (stacks[stack] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });

    _stack.count++;
    _stack.weight += stackWeight;
  }

  return stacks;
}

function setLayoutDims(layouts, params) {
  const stacks = buildStacks(layouts);
  const {
    vBoxMaxWidth,
    hBoxMaxHeight
  } = params;
  let i, ilen, layout;

  for (i = 0, ilen = layouts.length; i < ilen; ++i) {
    layout = layouts[i];
    const {
      fullSize
    } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;

    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }

  return stacks;
}

function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));
  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, 'chartArea'),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}

function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}

function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}

function updateDims(chartArea, params, layout, stacks) {
  const {
    pos,
    box
  } = layout;
  const maxPadding = chartArea.maxPadding;

  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }

    const stack = stacks[layout.stack] || {
      size: 0,
      count: 1
    };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }

  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }

  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? {
    same: widthChanged,
    other: heightChanged
  } : {
    same: heightChanged,
    other: widthChanged
  };
}

function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;

  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }

  chartArea.y += updatePos('top');
  chartArea.x += updatePos('left');
  updatePos('right');
  updatePos('bottom');
}

function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;

  function marginForPositions(positions) {
    const margin = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    positions.forEach(pos => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }

  return horizontal ? marginForPositions(['left', 'right']) : marginForPositions(['top', 'bottom']);
}

function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;

  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const {
      same,
      other
    } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;

    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }

  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}

function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}

function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let {
    x,
    y
  } = chartArea;

  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    };
    const weight = layout.stackWeight / stack.weight || 1;

    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;

      if (defined(stack.start)) {
        y = stack.start;
      }

      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }

      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height1 = chartArea.h * weight;
      const width1 = stack.size || box.width;

      if (defined(stack.start)) {
        x = stack.start;
      }

      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width1, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width1, height1);
      }

      stack.start = x;
      stack.placed += height1;
      x = box.right;
    }
  }

  chartArea.x = x;
  chartArea.y = y;
}

var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }

    item.fullSize = item.fullSize || false;
    item.position = item.position || 'top';
    item.weight = item.weight || 0;

    item._layers = item._layers || function () {
      return [{
        z: 0,

        draw(chartArea) {
          item.draw(chartArea);
        }

      }];
    };

    chart.boxes.push(item);
  },

  removeBox(chart, layoutItem) {
    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;

    if (index !== -1) {
      chart.boxes.splice(index, 1);
    }
  },

  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },

  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }

    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, box => {
      if (typeof box.beforeLayout === 'function') {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);

    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }

    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, layout => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }

};

class BasePlatform {
  acquireContext(canvas, aspectRatio) {}

  releaseContext(context) {
    return false;
  }

  addEventListener(chart, type, listener) {}

  removeEventListener(chart, type, listener) {}

  getDevicePixelRatio() {
    return 1;
  }

  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }

  isAttached(canvas) {
    return true;
  }

  updateConfig(config) {}

}

class BasicPlatform extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext('2d') || null;
  }

  updateConfig(config) {
    config.options.animation = false;
  }

}

const EXPANDO_KEY = '$chartjs';
const EVENT_TYPES = {
  touchstart: 'mousedown',
  touchmove: 'mousemove',
  touchend: 'mouseup',
  pointerenter: 'mouseenter',
  pointerdown: 'mousedown',
  pointermove: 'mousemove',
  pointerup: 'mouseup',
  pointerleave: 'mouseout',
  pointerout: 'mouseout'
};

const isNullOrEmpty = value => value === null || value === '';

function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute('height');
  const renderWidth = canvas.getAttribute('width');
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || 'block';
  style.boxSizing = style.boxSizing || 'border-box';

  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, 'width');

    if (displayWidth !== undefined) {
      canvas.width = displayWidth;
    }
  }

  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === '') {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, 'height');

      if (displayHeight !== undefined) {
        canvas.height = displayHeight;
      }
    }
  }

  return canvas;
}

const eventListenerOptions = supportsEventListenerOptions ? {
  passive: true
} : false;

function addListener(node, type, listener) {
  node.addEventListener(type, listener, eventListenerOptions);
}

function removeListener(chart, type, listener) {
  chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}

function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const {
    x,
    y
  } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== undefined ? x : null,
    y: y !== undefined ? y : null
  };
}

function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}

function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver(entries => {
    let trigger = false;

    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }

    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}

function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver(entries => {
    let trigger = false;

    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }

    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}

const drpListeningCharts = new Map();
let oldDevicePixelRatio = 0;

function onWindowResize() {
  const dpr = window.devicePixelRatio;

  if (dpr === oldDevicePixelRatio) {
    return;
  }

  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}

function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener('resize', onWindowResize);
  }

  drpListeningCharts.set(chart, resize);
}

function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);

  if (!drpListeningCharts.size) {
    window.removeEventListener('resize', onWindowResize);
  }
}

function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;

  const container = canvas && _getParentNode(canvas);

  if (!container) {
    return;
  }

  const resize = throttled((width, height) => {
    const w = container.clientWidth;
    listener(width, height);

    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver(entries => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;

    if (width === 0 && height === 0) {
      return;
    }

    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}

function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }

  if (type === 'resize') {
    unlistenDevicePixelRatioChanges(chart);
  }
}

function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled(event => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart);
  addListener(canvas, type, proxy);
  return proxy;
}

class DomPlatform extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext('2d');

    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }

    return null;
  }

  releaseContext(context) {
    const canvas = context.canvas;

    if (!canvas[EXPANDO_KEY]) {
      return false;
    }

    const initial = canvas[EXPANDO_KEY].initial;
    ['height', 'width'].forEach(prop => {
      const value = initial[prop];

      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach(key => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }

  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }

  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];

    if (!proxy) {
      return;
    }

    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = undefined;
  }

  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }

  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }

  isAttached(canvas) {
    const container = _getParentNode(canvas);

    return !!(container && container.isConnected);
  }

}

function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }

  return DomPlatform;
}

class Element {
  static defaults = {};
  static defaultRoutes = undefined;
  active = false;

  tooltipPosition(useFinalPosition) {
    const {
      x,
      y
    } = this.getProps(['x', 'y'], useFinalPosition);
    return {
      x,
      y
    };
  }

  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }

  getProps(props, final) {
    const anims = this.$animations;

    if (!final || !anims) {
      // let's not create an object, if not needed
      return this;
    }

    const ret = {};
    props.forEach(prop => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }

}

function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const determinedMaxTicks = determineMaxTicks(scale);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];

  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }

  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);

  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);

    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }

    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }

  skip(ticks, newTicks, spacing);
  return newTicks;
}

function determineMaxTicks(scale) {
  const offset = scale.options.offset;

  const tickLength = scale._tickSize();

  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}

function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;

  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }

  const factors = _factorize(evenMajorSpacing);

  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];

    if (factor > spacing) {
      return factor;
    }
  }

  return Math.max(spacing, 1);
}

function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;

  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }

  return result;
}

function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);

  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}

function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);

  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }

  next = start;

  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }

  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}

function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;

  if (len < 2) {
    return false;
  }

  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }

  return diff;
}

const reverseAlign = align => align === 'left' ? 'right' : align === 'right' ? 'left' : align;

const offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;

function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;

  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }

  return result;
}

function getPixelForGridLine(scale, index, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex = Math.min(index, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex);
  let offset;

  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
    }

    lineValue += validIndex < index ? offset : -offset;

    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }

  return lineValue;
}

function garbageCollect(caches, length) {
  each(caches, cache => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;

    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }

      gc.splice(0, gcLen);
    }
  });
}

function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}

function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }

  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}

function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: 'scale'
  });
}

function createTickContext(parent, index, tick) {
  return createContext(parent, {
    tick,
    index,
    type: 'tick'
  });
}

function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);

  if (reverse && position !== 'right' || !reverse && position === 'right') {
    ret = reverseAlign(ret);
  }

  return ret;
}

function titleArgs(scale, offset, position, align) {
  const {
    top,
    left,
    bottom,
    right,
    chart
  } = scale;
  const {
    chartArea,
    scales
  } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;

  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);

    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === 'center') {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }

    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID1 = Object.keys(position)[0];
      const value1 = position[positionAxisID1];
      titleX = scales[positionAxisID1].getPixelForValue(value1) - width + offset;
    } else if (position === 'center') {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }

    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === 'left' ? -HALF_PI : HALF_PI;
  }

  return {
    titleX,
    titleY,
    maxWidth,
    rotation
  };
}

class Scale extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = undefined;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = undefined;
    this.bottom = undefined;
    this.left = undefined;
    this.right = undefined;
    this.width = undefined;
    this.height = undefined;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = undefined;
    this.maxHeight = undefined;
    this.paddingTop = undefined;
    this.paddingBottom = undefined;
    this.paddingLeft = undefined;
    this.paddingRight = undefined;
    this.axis = undefined;
    this.labelRotation = undefined;
    this.min = undefined;
    this.max = undefined;
    this._range = undefined;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = undefined;
    this._endPixel = undefined;
    this._reversePixels = false;
    this._userMax = undefined;
    this._userMin = undefined;
    this._suggestedMax = undefined;
    this._suggestedMin = undefined;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = undefined;
  }

  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }

  parse(raw, index) {
    return raw;
  }

  getUserBounds() {
    let {
      _userMin,
      _userMax,
      _suggestedMin,
      _suggestedMax
    } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }

  getMinMax(canStack) {
    let {
      min,
      max,
      minDefined,
      maxDefined
    } = this.getUserBounds();
    let range;

    if (minDefined && maxDefined) {
      return {
        min,
        max
      };
    }

    const metas = this.getMatchingVisibleMetas();

    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(this, canStack);

      if (!minDefined) {
        min = Math.min(min, range.min);
      }

      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }

    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }

  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }

  getTicks() {
    return this.ticks;
  }

  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }

  getLabelItems(chartArea = this.chart.chartArea) {
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));

    return items;
  }

  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }

  beforeUpdate() {
    callback(this.options.beforeUpdate, [this]);
  }

  update(maxWidth, maxHeight, margins) {
    const {
      beginAtZero,
      grace,
      ticks: tickOpts
    } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;

    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }

    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;

    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);

    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();

    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }

    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }

    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }

  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;

    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }

    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }

  afterUpdate() {
    callback(this.options.afterUpdate, [this]);
  }

  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [this]);
  }

  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }

    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }

  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [this]);
  }

  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [this]);
  }

  beforeDataLimits() {
    this._callHooks('beforeDataLimits');
  }

  determineDataLimits() {}

  afterDataLimits() {
    this._callHooks('afterDataLimits');
  }

  beforeBuildTicks() {
    this._callHooks('beforeBuildTicks');
  }

  buildTicks() {
    return [];
  }

  afterBuildTicks() {
    this._callHooks('afterBuildTicks');
  }

  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [this]);
  }

  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;

    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);
    }
  }

  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [this]);
  }

  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [this]);
  }

  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = this.ticks.length;
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;

    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }

    const labelSizes = this._getLabelSizes();

    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;

    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);

    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);

    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }

    this.labelRotation = labelRotation;
  }

  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [this]);
  }

  afterAutoSkip() {}

  beforeFit() {
    callback(this.options.beforeFit, [this]);
  }

  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const {
      chart,
      options: {
        ticks: tickOpts,
        title: titleOpts,
        grid: gridOpts
      }
    } = this;

    const display = this._isVisible();

    const isHorizontal = this.isHorizontal();

    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);

      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }

      if (tickOpts.display && this.ticks.length) {
        const {
          first,
          last,
          widest,
          highest
        } = this._getLabelSizes();

        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);

        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }

        this._calculatePadding(first, last, sin, cos);
      }
    }

    this._handleMargins();

    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }

  _calculatePadding(first, last, sin, cos) {
    const {
      ticks: {
        align,
        padding
      },
      position
    } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== 'top' && this.axis === 'x';

    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;

      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === 'start') {
        paddingRight = last.width;
      } else if (align === 'end') {
        paddingLeft = first.width;
      } else if (align !== 'inner') {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }

      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;

      if (align === 'start') {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === 'end') {
        paddingTop = last.height;
        paddingBottom = 0;
      }

      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }

  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }

  afterFit() {
    callback(this.options.afterFit, [this]);
  }

  isHorizontal() {
    const {
      axis,
      position
    } = this.options;
    return position === 'top' || position === 'bottom' || axis === 'x';
  }

  isFullSize() {
    return this.options.fullSize;
  }

  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;

    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }

    this.afterTickToLabelConversion();
  }

  _getLabelSizes() {
    let labelSizes = this._labelSizes;

    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;

      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }

      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
    }

    return labelSizes;
  }

  _computeLabelSizes(ticks, length) {
    const {
      ctx,
      _longestTextCache: caches
    } = this;
    const widths = [];
    const heights = [];
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;

    for (i = 0; i < length; ++i) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width = height = 0;

      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];

          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }

      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }

    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);

    const valueAt = idx => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    });

    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }

  getLabelForValue(value) {
    return value;
  }

  getPixelForValue(value, index) {
    return NaN;
  }

  getValueForPixel(pixel) {}

  getPixelForTick(index) {
    const ticks = this.ticks;

    if (index < 0 || index > ticks.length - 1) {
      return null;
    }

    return this.getPixelForValue(ticks[index].value);
  }

  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }

    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }

  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }

  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }

  getBaseValue() {
    const {
      min,
      max
    } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }

  getContext(index) {
    const ticks = this.ticks || [];

    if (index >= 0 && index < ticks.length) {
      const tick = ticks[index];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
    }

    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }

  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));

    const labelSizes = this._getLabelSizes();

    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
  }

  _isVisible() {
    const display = this.options.display;

    if (display !== 'auto') {
      return !!display;
    }

    return this.getMatchingVisibleMetas().length > 0;
  }

  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const {
      grid,
      position,
      border
    } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;

    const alignBorderValue = function (pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };

    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;

    if (position === 'top') {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === 'bottom') {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === 'left') {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === 'right') {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === 'x') {
      if (position === 'center') {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }

      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === 'y') {
      if (position === 'center') {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID1 = Object.keys(position)[0];
        const value1 = position[positionAxisID1];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID1].getPixelForValue(value1));
      }

      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }

    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));

    for (i = 0; i < ticksLength; i += step) {
      const context = this.getContext(i);
      const optsAtIndex = grid.setContext(context);
      const optsAtIndexBorder = border.setContext(context);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);

      if (lineValue === undefined) {
        continue;
      }

      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);

      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }

      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }

    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }

  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const {
      position,
      ticks: optionTicks
    } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const {
      align,
      crossAlign,
      padding,
      mirror
    } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = 'middle';

    if (position === 'top') {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === 'bottom') {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === 'left') {
      const ret = this._getYAxisLabelAlignment(tl);

      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === 'right') {
      const ret1 = this._getYAxisLabelAlignment(tl);

      textAlign = ret1.textAlign;
      x = ret1.x;
    } else if (axis === 'x') {
      if (position === 'center') {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }

      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === 'y') {
      if (position === 'center') {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID1 = Object.keys(position)[0];
        const value1 = position[positionAxisID1];
        x = this.chart.scales[positionAxisID1].getPixelForValue(value1);
      }

      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }

    if (axis === 'y') {
      if (align === 'start') {
        textBaseline = 'top';
      } else if (align === 'end') {
        textBaseline = 'bottom';
      }
    }

    const labelSizes = this._getLabelSizes();

    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;

      if (isHorizontal) {
        x = pixel;

        if (textAlign === 'inner') {
          if (i === ilen - 1) {
            tickTextAlign = !this.options.reverse ? 'right' : 'left';
          } else if (i === 0) {
            tickTextAlign = !this.options.reverse ? 'left' : 'right';
          } else {
            tickTextAlign = 'center';
          }
        }

        if (position === 'top') {
          if (crossAlign === 'near' || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === 'center') {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === 'near' || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === 'center') {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }

        if (mirror) {
          textOffset *= -1;
        }

        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
          x += lineHeight / 2 * Math.sin(rotation);
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }

      let backdrop;

      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = textOffset - labelPadding.top;
        let left = 0 - labelPadding.left;

        switch (textBaseline) {
          case 'middle':
            top -= height / 2;
            break;

          case 'bottom':
            top -= height;
            break;
        }

        switch (textAlign) {
          case 'center':
            left -= width / 2;
            break;

          case 'right':
            left -= width;
            break;
        }

        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }

      items.push({
        label,
        font,
        textOffset,
        options: {
          rotation,
          color,
          strokeColor,
          strokeWidth,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [x, y],
          backdrop
        }
      });
    }

    return items;
  }

  _getXAxisLabelAlignment() {
    const {
      position,
      ticks
    } = this.options;
    const rotation = -toRadians(this.labelRotation);

    if (rotation) {
      return position === 'top' ? 'left' : 'right';
    }

    let align = 'center';

    if (ticks.align === 'start') {
      align = 'left';
    } else if (ticks.align === 'end') {
      align = 'right';
    } else if (ticks.align === 'inner') {
      align = 'inner';
    }

    return align;
  }

  _getYAxisLabelAlignment(tl) {
    const {
      position,
      ticks: {
        crossAlign,
        mirror,
        padding
      }
    } = this.options;

    const labelSizes = this._getLabelSizes();

    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;

    if (position === 'left') {
      if (mirror) {
        x = this.right + padding;

        if (crossAlign === 'near') {
          textAlign = 'left';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x += widest / 2;
        } else {
          textAlign = 'right';
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;

        if (crossAlign === 'near') {
          textAlign = 'right';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x -= widest / 2;
        } else {
          textAlign = 'left';
          x = this.left;
        }
      }
    } else if (position === 'right') {
      if (mirror) {
        x = this.left + padding;

        if (crossAlign === 'near') {
          textAlign = 'right';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x -= widest / 2;
        } else {
          textAlign = 'left';
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;

        if (crossAlign === 'near') {
          textAlign = 'left';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x += widest / 2;
        } else {
          textAlign = 'right';
          x = this.right;
        }
      }
    } else {
      textAlign = 'right';
    }

    return {
      textAlign,
      x
    };
  }

  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }

    const chart = this.chart;
    const position = this.options.position;

    if (position === 'left' || position === 'right') {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }

    if (position === 'top' || position === 'bottom') {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }

  drawBackground() {
    const {
      ctx,
      options: {
        backgroundColor
      },
      left,
      top,
      width,
      height
    } = this;

    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }

  getLineWidthForValue(value) {
    const grid = this.options.grid;

    if (!this._isVisible() || !grid.display) {
      return 0;
    }

    const ticks = this.ticks;
    const index = ticks.findIndex(t => t.value === value);

    if (index >= 0) {
      const opts = grid.setContext(this.getContext(index));
      return opts.lineWidth;
    }

    return 0;
  }

  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;

    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));

    let i, ilen;

    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }

      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };

    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];

        if (grid.drawOnChartArea) {
          drawLine({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }

        if (grid.drawTicks) {
          drawLine({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }

  drawBorder() {
    const {
      chart,
      ctx,
      options: {
        border,
        grid
      }
    } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;

    if (!axisWidth) {
      return;
    }

    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;

    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }

    ctx.save();
    ctx.lineWidth = borderOpts.width;
    ctx.strokeStyle = borderOpts.color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }

  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;

    if (!optionTicks.display) {
      return;
    }

    const ctx = this.ctx;

    const area = this._computeLabelArea();

    if (area) {
      clipArea(ctx, area);
    }

    const items = this.getLabelItems(chartArea);

    for (const item of items) {
      const renderTextOptions = item.options;
      const tickFont = item.font;
      const label = item.label;
      const y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, renderTextOptions);
    }

    if (area) {
      unclipArea(ctx);
    }
  }

  drawTitle() {
    const {
      ctx,
      options: {
        position,
        title,
        reverse
      }
    } = this;

    if (!title.display) {
      return;
    }

    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;

    if (position === 'bottom' || position === 'center' || isObject(position)) {
      offset += padding.bottom;

      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }

    const {
      titleX,
      titleY,
      maxWidth,
      rotation
    } = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: 'middle',
      translation: [titleX, titleY]
    });
  }

  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }

    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }

  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    const bz = valueOrDefault(opts.border && opts.border.z, 0);

    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [{
        z: tz,
        draw: chartArea => {
          this.draw(chartArea);
        }
      }];
    }

    return [{
      z: gz,
      draw: chartArea => {
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawTitle();
      }
    }, {
      z: bz,
      draw: () => {
        this.drawBorder();
      }
    }, {
      z: tz,
      draw: chartArea => {
        this.drawLabels(chartArea);
      }
    }];
  }

  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + 'AxisID';
    const result = [];
    let i, ilen;

    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];

      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }

    return result;
  }

  _resolveTickFontOptions(index) {
    const opts = this.options.ticks.setContext(this.getContext(index));
    return toFont(opts.font);
  }

  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;

    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }

}

class TypedRegistry {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = Object.create(null);
  }

  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }

  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;

    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }

    const items = this.items;
    const id = item.id;
    const scope = this.scope + '.' + id;

    if (!id) {
      throw new Error('class does not have id: ' + item);
    }

    if (id in items) {
      return scope;
    }

    items[id] = item;
    registerDefaults(item, scope, parentScope);

    if (this.override) {
      defaults.override(item.id, item.overrides);
    }

    return scope;
  }

  get(id) {
    return this.items[id];
  }

  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;

    if (id in items) {
      delete items[id];
    }

    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];

      if (this.override) {
        delete overrides[id];
      }
    }
  }

}

function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(Object.create(null), [parentScope ? defaults.get(parentScope) : {}, defaults.get(scope), item.defaults]);
  defaults.set(scope, itemDefaults);

  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }

  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}

function routeDefaults(scope, routes) {
  Object.keys(routes).forEach(property => {
    const propertyParts = property.split('.');
    const sourceName = propertyParts.pop();
    const sourceScope = [scope].concat(propertyParts).join('.');
    const parts = routes[property].split('.');
    const targetName = parts.pop();
    const targetScope = parts.join('.');
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}

function isIChartComponent(proto) {
  return 'id' in proto && 'defaults' in proto;
}

class Registry {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);
    this.elements = new TypedRegistry(Element, 'elements');
    this.plugins = new TypedRegistry(Object, 'plugins');
    this.scales = new TypedRegistry(Scale, 'scales');
    this._typedRegistries = [this.controllers, this.scales, this.elements];
  }

  add(...args) {
    this._each('register', args);
  }

  remove(...args) {
    this._each('unregister', args);
  }

  addControllers(...args) {
    this._each('register', args, this.controllers);
  }

  addElements(...args) {
    this._each('register', args, this.elements);
  }

  addPlugins(...args) {
    this._each('register', args, this.plugins);
  }

  addScales(...args) {
    this._each('register', args, this.scales);
  }

  getController(id) {
    return this._get(id, this.controllers, 'controller');
  }

  getElement(id) {
    return this._get(id, this.elements, 'element');
  }

  getPlugin(id) {
    return this._get(id, this.plugins, 'plugin');
  }

  getScale(id) {
    return this._get(id, this.scales, 'scale');
  }

  removeControllers(...args) {
    this._each('unregister', args, this.controllers);
  }

  removeElements(...args) {
    this._each('unregister', args, this.elements);
  }

  removePlugins(...args) {
    this._each('unregister', args, this.plugins);
  }

  removeScales(...args) {
    this._each('unregister', args, this.scales);
  }

  _each(method, args, typedRegistry) {
    [...args].forEach(arg => {
      const reg = typedRegistry || this._getRegistryForType(arg);

      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, item => {
          const itemReg = typedRegistry || this._getRegistryForType(item);

          this._exec(method, itemReg, item);
        });
      }
    });
  }

  _exec(method, registry, component) {
    const camelMethod = _capitalize(method);

    callback(component['before' + camelMethod], [], component);
    registry[method](component);
    callback(component['after' + camelMethod], [], component);
  }

  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];

      if (reg.isForType(type)) {
        return reg;
      }
    }

    return this.plugins;
  }

  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);

    if (item === undefined) {
      throw new Error('"' + id + '" is not a registered ' + type + '.');
    }

    return item;
  }

}

var registry = /* #__PURE__ */new Registry();

class PluginService {
  constructor() {
    this._init = [];
  }

  notify(chart, hook, args, filter) {
    if (hook === 'beforeInit') {
      this._init = this._createDescriptors(chart, true);

      this._notify(this._init, chart, 'install');
    }

    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);

    const result = this._notify(descriptors, chart, hook, args);

    if (hook === 'afterDestroy') {
      this._notify(descriptors, chart, 'stop');

      this._notify(this._init, chart, 'uninstall');
    }

    return result;
  }

  _notify(descriptors, chart, hook, args) {
    args = args || {};

    for (const descriptor of descriptors) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [chart, args, descriptor.options];

      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }

    return true;
  }

  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = undefined;
    }
  }

  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }

    const descriptors = this._cache = this._createDescriptors(chart);

    this._notifyStateChanges(chart);

    return descriptors;
  }

  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
  }

  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors = this._cache;

    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));

    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');

    this._notify(diff(descriptors, previousDescriptors), chart, 'start');
  }

}

function allPlugins(config) {
  const localIds = {};
  const plugins = [];
  const keys = Object.keys(registry.plugins.items);

  for (let i = 0; i < keys.length; i++) {
    plugins.push(registry.getPlugin(keys[i]));
  }

  const local = config.plugins || [];

  for (let i1 = 0; i1 < local.length; i1++) {
    const plugin = local[i1];

    if (plugins.indexOf(plugin) === -1) {
      plugins.push(plugin);
      localIds[plugin.id] = true;
    }
  }

  return {
    plugins,
    localIds
  };
}

function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }

  if (options === true) {
    return {};
  }

  return options;
}

function createDescriptors(chart, {
  plugins,
  localIds
}, options, all) {
  const result = [];
  const context = chart.getContext();

  for (const plugin of plugins) {
    const id = plugin.id;
    const opts = getOpts(options[id], all);

    if (opts === null) {
      continue;
    }

    result.push({
      plugin,
      options: pluginOpts(chart.config, {
        plugin,
        local: localIds[id]
      }, opts, context)
    });
  }

  return result;
}

function pluginOpts(config, {
  plugin,
  local
}, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);

  if (local && plugin.defaults) {
    scopes.push(plugin.defaults);
  }

  return config.createResolver(scopes, context, [''], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}

function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';
}

function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;

  if (id === '_index_') {
    axis = indexAxis;
  } else if (id === '_value_') {
    axis = indexAxis === 'x' ? 'y' : 'x';
  }

  return axis;
}

function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? '_index_' : '_value_';
}

function axisFromPosition(position) {
  if (position === 'top' || position === 'bottom') {
    return 'x';
  }

  if (position === 'left' || position === 'right') {
    return 'y';
  }
}

function determineAxis(id, scaleOptions) {
  if (id === 'x' || id === 'y' || id === 'r') {
    return id;
  }

  id = scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.length > 1 && determineAxis(id[0].toLowerCase(), scaleOptions);

  if (id) {
    return id;
  }

  throw new Error(`Cannot determine type of '${name}' axis. Please provide 'axis' or 'position' option.`);
}

function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || {
    scales: {}
  };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const scales = Object.create(null);
  Object.keys(configScales).forEach(id => {
    const scaleConf = configScales[id];

    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }

    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }

    const axis = determineAxis(id, scaleConf);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    scales[id] = mergeIf(Object.create(null), [{
      axis
    }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
  });
  config.data.datasets.forEach(dataset => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach(defaultID => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + 'AxisID'] || axis;
      scales[id] = scales[id] || Object.create(null);
      mergeIf(scales[id], [{
        axis
      }, configScales[id], defaultScaleOptions[defaultID]]);
    });
  });
  Object.keys(scales).forEach(key => {
    const scale = scales[key];
    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);
  });
  return scales;
}

function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}

function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}

function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}

const keyCache = new Map();
const keysCached = new Set();

function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);

  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }

  return keys;
}

const addIfFound = (set, obj, key) => {
  const opts = resolveObjectKey(obj, key);

  if (opts !== undefined) {
    set.add(opts);
  }
};

class Config {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = new Map();
    this._resolverCache = new Map();
  }

  get platform() {
    return this._config.platform;
  }

  get type() {
    return this._config.type;
  }

  set type(type) {
    this._config.type = type;
  }

  get data() {
    return this._config.data;
  }

  set data(data) {
    this._config.data = initData(data);
  }

  get options() {
    return this._config.options;
  }

  set options(options) {
    this._config.options = options;
  }

  get plugins() {
    return this._config.plugins;
  }

  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }

  clearCache() {
    this._scopeCache.clear();

    this._resolverCache.clear();
  }

  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [[`datasets.${datasetType}`, '']]);
  }

  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [[`datasets.${datasetType}.transitions.${transition}`, `transitions.${transition}`], [`datasets.${datasetType}`, '']]);
  }

  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [[`datasets.${datasetType}.elements.${elementType}`, `datasets.${datasetType}`, `elements.${elementType}`, '']]);
  }

  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [[`plugins.${id}`, ...(plugin.additionalOptionScopes || [])]]);
  }

  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;

    let cache = _scopeCache.get(mainScope);

    if (!cache || resetCache) {
      cache = new Map();

      _scopeCache.set(mainScope, cache);
    }

    return cache;
  }

  getOptionScopes(mainScope, keyLists, resetCache) {
    const {
      options,
      type
    } = this;

    const cache = this._cachedScopes(mainScope, resetCache);

    const cached = cache.get(keyLists);

    if (cached) {
      return cached;
    }

    const scopes = new Set();
    keyLists.forEach(keys => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach(key => addIfFound(scopes, mainScope, key));
      }

      keys.forEach(key => addIfFound(scopes, options, key));
      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach(key => addIfFound(scopes, defaults, key));
      keys.forEach(key => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);

    if (array.length === 0) {
      array.push(Object.create(null));
    }

    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }

    return array;
  }

  chartOptionScopes() {
    const {
      options,
      type
    } = this;
    return [options, overrides[type] || {}, defaults.datasets[type] || {}, {
      type
    }, defaults, descriptors];
  }

  resolveNamedOptions(scopes, names, context, prefixes = ['']) {
    const result = {
      $shared: true
    };
    const {
      resolver,
      subPrefixes
    } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;

    if (needContext(resolver, names)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }

    for (const prop of names) {
      result[prop] = options[prop];
    }

    return result;
  }

  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {
    const {
      resolver
    } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context) ? _attachContext(resolver, context, undefined, descriptorDefaults) : resolver;
  }

}

function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);

  if (!cache) {
    cache = new Map();
    resolverCache.set(scopes, cache);
  }

  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);

  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);

    cached = {
      resolver,
      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))
    };
    cache.set(cacheKey, cached);
  }

  return cached;
}

const hasFunction = value => isObject(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);

function needContext(proxy, names) {
  const {
    isScriptable,
    isIndexable
  } = _descriptors(proxy);

  for (const prop of names) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];

    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }

  return false;
}

var version = "4.1.1";
const KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];

function positionIsHorizontal(position, axis) {
  return position === 'top' || position === 'bottom' || KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x';
}

function compare2Level(l1, l2) {
  return function (a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}

function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins('afterRender');
  callback(animationOptions && animationOptions.onComplete, [context], chart);
}

function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [context], chart);
}

function getCanvas(item) {
  if (_isDomSupported() && typeof item === 'string') {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }

  if (item && item.canvas) {
    item = item.canvas;
  }

  return item;
}

const instances = {};

const getChart = key => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter(c => c.canvas === canvas).pop();
};

function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);

  for (const key of keys) {
    const intKey = +key;

    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];

      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}

function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === 'mouseout') {
    return null;
  }

  if (isClick) {
    return lastEvent;
  }

  return e;
}

function getDatasetArea(meta) {
  const {
    xScale,
    yScale
  } = meta;

  if (xScale && yScale) {
    return {
      left: xScale.left,
      right: xScale.right,
      top: yScale.top,
      bottom: yScale.bottom
    };
  }
}

class Chart {
  static defaults = defaults;
  static instances = instances;
  static overrides = overrides;
  static registry = registry;
  static version = version;
  static getChart = getChart;

  static register(...items) {
    registry.add(...items);
    invalidatePlugins();
  }

  static unregister(...items) {
    registry.remove(...items);
    invalidatePlugins();
  }

  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);

    if (existingChart) {
      throw new Error('Canvas is already in use. Chart with ID \'' + existingChart.id + '\'' + ' must be destroyed before the canvas with ID \'' + existingChart.canvas.id + '\' can be reused.');
    }

    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = undefined;
    this.boxes = [];
    this.currentDevicePixelRatio = undefined;
    this.chartArea = undefined;
    this._active = [];
    this._lastEvent = undefined;
    this._listeners = {};
    this._responsiveListeners = undefined;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = undefined;
    this.$context = undefined;
    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;

    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }

    animator.listen(this, 'complete', onAnimationsComplete);
    animator.listen(this, 'progress', onAnimationProgress);

    this._initialize();

    if (this.attached) {
      this.update();
    }
  }

  get aspectRatio() {
    const {
      options: {
        aspectRatio,
        maintainAspectRatio
      },
      width,
      height,
      _aspectRatio
    } = this;

    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }

    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }

    return height ? width / height : null;
  }

  get data() {
    return this.config.data;
  }

  set data(data) {
    this.config.data = data;
  }

  get options() {
    return this._options;
  }

  set options(options) {
    this.config.options = options;
  }

  get registry() {
    return registry;
  }

  _initialize() {
    this.notifyPlugins('beforeInit');

    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }

    this.bindEvents();
    this.notifyPlugins('afterInit');
    return this;
  }

  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }

  stop() {
    animator.stop(this);
    return this;
  }

  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {
        width,
        height
      };
    }
  }

  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? 'resize' : 'attach';
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;

    if (!retinaScale(this, newRatio, true)) {
      return;
    }

    this.notifyPlugins('resize', {
      size: newSize
    });
    callback(options.onResize, [this, newSize], this);

    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }

  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }

  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales = this.scales;
    const updated = Object.keys(scales).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];

    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map(id => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === 'r';
        const isHorizontal = axis === 'x';
        return {
          options: scaleOptions,
          dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',
          dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'
        };
      }));
    }

    each(items, item => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);

      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }

      updated[id] = true;
      let scale = null;

      if (id in scales && scales[id].type === scaleType) {
        scale = scales[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales[scale.id] = scale;
      }

      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales[id];
      }
    });
    each(scales, scale => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }

  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);

    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }

      metasets.splice(numData, numMeta - numData);
    }

    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));
  }

  _removeUnreferencedMetasets() {
    const {
      _metasets: metasets,
      data: {
        datasets
      }
    } = this;

    if (metasets.length > datasets.length) {
      delete this._stacks;
    }

    metasets.forEach((meta, index) => {
      if (datasets.filter(x => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index);
      }
    });
  }

  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;

    this._removeUnreferencedMetasets();

    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;

      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i);

        meta = this.getDatasetMeta(i);
      }

      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = '' + dataset.label;
      meta.visible = this.isDatasetVisible(i);

      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const {
          datasetElementType,
          dataElementType
        } = defaults.datasets[type];
        Object.assign(ControllerClass, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }

    this._updateMetasets();

    return newControllers;
  }

  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }

  reset() {
    this._resetElements();

    this.notifyPlugins('reset');
  }

  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;

    this._updateScales();

    this._checkEventBindings();

    this._updateHiddenIndices();

    this._plugins.invalidate();

    if (this.notifyPlugins('beforeUpdate', {
      mode,
      cancelable: true
    }) === false) {
      return;
    }

    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins('beforeElementsUpdate');
    let minPadding = 0;

    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const {
        controller
      } = this.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }

    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;

    this._updateLayout(minPadding);

    if (!animsDisabled) {
      each(newControllers, controller => {
        controller.reset();
      });
    }

    this._updateDatasets(mode);

    this.notifyPlugins('afterUpdate', {
      mode
    });

    this._layers.sort(compare2Level('z', '_idx'));

    const {
      _active,
      _lastEvent
    } = this;

    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }

    this.render();
  }

  _updateScales() {
    each(this.scales, scale => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }

  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);

    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }

  _updateHiddenIndices() {
    const {
      _hiddenIndices
    } = this;
    const changes = this._getUniformDataChanges() || [];

    for (const {
      method,
      start,
      count
    } of changes) {
      const move = method === '_removeElements' ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }

  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;

    if (!_dataChanges || !_dataChanges.length) {
      return;
    }

    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;

    const makeSet = idx => new Set(_dataChanges.filter(c => c[0] === idx).map((c, i) => i + ',' + c.splice(1).join(',')));

    const changeSet = makeSet(0);

    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }

    return Array.from(changeSet).map(c => c.split(',')).map(a => ({
      method: a[1],
      start: +a[2],
      count: +a[3]
    }));
  }

  _updateLayout(minPadding) {
    if (this.notifyPlugins('beforeLayout', {
      cancelable: true
    }) === false) {
      return;
    }

    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, box => {
      if (noArea && box.position === 'chartArea') {
        return;
      }

      if (box.configure) {
        box.configure();
      }

      this._layers.push(...box._layers());
    }, this);

    this._layers.forEach((item, index) => {
      item._idx = index;
    });

    this.notifyPlugins('afterLayout');
  }

  _updateDatasets(mode) {
    if (this.notifyPlugins('beforeDatasetsUpdate', {
      mode,
      cancelable: true
    }) === false) {
      return;
    }

    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }

    for (let i1 = 0, ilen1 = this.data.datasets.length; i1 < ilen1; ++i1) {
      this._updateDataset(i1, isFunction(mode) ? mode({
        datasetIndex: i1
      }) : mode);
    }

    this.notifyPlugins('afterDatasetsUpdate', {
      mode
    });
  }

  _updateDataset(index, mode) {
    const meta = this.getDatasetMeta(index);
    const args = {
      meta,
      index,
      mode,
      cancelable: true
    };

    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {
      return;
    }

    meta.controller._update(mode);

    args.cancelable = false;
    this.notifyPlugins('afterDatasetUpdate', args);
  }

  render() {
    if (this.notifyPlugins('beforeRender', {
      cancelable: true
    }) === false) {
      return;
    }

    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({
        chart: this
      });
    }
  }

  draw() {
    let i;

    if (this._resizeBeforeDraw) {
      const {
        width,
        height
      } = this._resizeBeforeDraw;

      this._resize(width, height);

      this._resizeBeforeDraw = null;
    }

    this.clear();

    if (this.width <= 0 || this.height <= 0) {
      return;
    }

    if (this.notifyPlugins('beforeDraw', {
      cancelable: true
    }) === false) {
      return;
    }

    const layers = this._layers;

    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }

    this._drawDatasets();

    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }

    this.notifyPlugins('afterDraw');
  }

  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;

    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];

      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }

    return result;
  }

  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }

  _drawDatasets() {
    if (this.notifyPlugins('beforeDatasetsDraw', {
      cancelable: true
    }) === false) {
      return;
    }

    const metasets = this.getSortedVisibleDatasetMetas();

    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }

    this.notifyPlugins('afterDatasetsDraw');
  }

  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = getDatasetArea(meta) || this.chartArea;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };

    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {
      return;
    }

    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }

    meta.controller.draw();

    if (useClip) {
      unclipArea(ctx);
    }

    args.cancelable = false;
    this.notifyPlugins('afterDatasetDraw', args);
  }

  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }

  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];

    if (typeof method === 'function') {
      return method(this, e, options, useFinalPosition);
    }

    return [];
  }

  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter(x => x && x._dataset === dataset).pop();

    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }

    return meta;
  }

  getContext() {
    return this.$context || (this.$context = createContext(null, {
      chart: this,
      type: 'chart'
    }));
  }

  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }

  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];

    if (!dataset) {
      return false;
    }

    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;
  }

  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }

  toggleDataVisibility(index) {
    this._hiddenIndices[index] = !this._hiddenIndices[index];
  }

  getDataVisibility(index) {
    return !this._hiddenIndices[index];
  }

  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? 'show' : 'hide';
    const meta = this.getDatasetMeta(datasetIndex);

    const anims = meta.controller._resolveAnimations(undefined, mode);

    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {
        visible
      });
      this.update(ctx => ctx.datasetIndex === datasetIndex ? mode : undefined);
    }
  }

  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }

  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }

  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];

    if (meta && meta.controller) {
      meta.controller._destroy();
    }

    delete this._metasets[datasetIndex];
  }

  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);

    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }

  destroy() {
    this.notifyPlugins('beforeDestroy');
    const {
      canvas,
      ctx
    } = this;

    this._stop();

    this.config.clearCache();

    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }

    delete instances[this.id];
    this.notifyPlugins('afterDestroy');
  }

  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }

  bindEvents() {
    this.bindUserEvents();

    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }

  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;

    const _add = (type, listener) => {
      platform.addEventListener(this, type, listener);
      listeners[type] = listener;
    };

    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;

      this._eventHandler(e);
    };

    each(this.options.events, type => _add(type, listener));
  }

  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }

    const listeners = this._responsiveListeners;
    const platform = this.platform;

    const _add = (type, listener) => {
      platform.addEventListener(this, type, listener);
      listeners[type] = listener;
    };

    const _remove = (type, listener) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener);
        delete listeners[type];
      }
    };

    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };

    let detached;

    const attached = () => {
      _remove('attach', attached);

      this.attached = true;
      this.resize();

      _add('resize', listener);

      _add('detach', detached);
    };

    detached = () => {
      this.attached = false;

      _remove('resize', listener);

      this._stop();

      this._resize(0, 0);

      _add('attach', attached);
    };

    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }

  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = undefined;
  }

  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? 'set' : 'remove';
    let meta, item, i, ilen;

    if (mode === 'dataset') {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller['_' + prefix + 'DatasetHoverStyle']();
    }

    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;

      if (controller) {
        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);
      }
    }
  }

  getActiveElements() {
    return this._active || [];
  }

  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({
      datasetIndex,
      index
    }) => {
      const meta = this.getDatasetMeta(datasetIndex);

      if (!meta) {
        throw new Error('No dataset found at index ' + datasetIndex);
      }

      return {
        datasetIndex,
        element: meta.data[index],
        index
      };
    });
    const changed = !_elementsEqual(active, lastActive);

    if (changed) {
      this._active = active;
      this._lastEvent = null;

      this._updateHoverStyles(active, lastActive);
    }
  }

  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }

  isPluginEnabled(pluginId) {
    return this._plugins._cache.filter(p => p.plugin.id === pluginId).length === 1;
  }

  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;

    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));

    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);

    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }

    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }

  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    };

    const eventFilter = plugin => (plugin.options.events || this.options.events).includes(e.native.type);

    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {
      return;
    }

    const changed = this._handleEvent(e, replay, args.inChartArea);

    args.cancelable = false;
    this.notifyPlugins('afterEvent', args, eventFilter);

    if (changed || args.changed) {
      this.render();
    }

    return this;
  }

  _handleEvent(e, replay, inChartArea) {
    const {
      _active: lastActive = [],
      options
    } = this;
    const useFinalPosition = replay;

    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);

    const isClick = _isClickEvent(e);

    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);

    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [e, active, this], this);

      if (isClick) {
        callback(options.onClick, [e, active, this], this);
      }
    }

    const changed = !_elementsEqual(active, lastActive);

    if (changed || replay) {
      this._active = active;

      this._updateHoverStyles(active, lastActive, replay);
    }

    this._lastEvent = lastEvent;
    return changed;
  }

  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === 'mouseout') {
      return [];
    }

    if (!inChartArea) {
      return lastActive;
    }

    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }

}

function invalidatePlugins() {
  return each(Chart.instances, chart => chart._plugins.invalidate());
}

function clipArc(ctx, element, endAngle) {
  const {
    startAngle,
    pixelMargin,
    x,
    y,
    outerRadius,
    innerRadius
  } = element;
  let angleMargin = pixelMargin / outerRadius; // Draw an inner border by clipping the arc and drawing a double-width border
  // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders

  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);

  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }

  ctx.closePath();
  ctx.clip();
}

function toRadiusCorners(value) {
  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);
}
/**
 * Parse border radius from the provided options
 */


function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2); // Outer limits are complicated. We want to compute the available angular distance at
  // a radius of outerRadius - borderRadius because for small angular distances, this term limits.
  // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.
  //
  // If the borderRadius is large, that value can become negative.
  // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius
  // we know that the thickness term will dominate and compute the limits at that point

  const computeOuterLimit = val => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };

  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
/**
 * Convert (r, 𝜃) to (x, y)
 */


function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta)
  };
}
/**
 * Path the arc, respecting border radius by separating into left and right halves.
 *
 *   Start      End
 *
 *    1--->a--->2    Outer
 *   /           \
 *   8           3
 *   |           |
 *   |           |
 *   7           4
 *   \           /
 *    6<---b<---5    Inner
 */


function pathArc(ctx, element, offset, spacing, end, circular) {
  const {
    x,
    y,
    startAngle: start,
    pixelMargin,
    innerRadius: innerR
  } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha = end - start;

  if (spacing) {
    // When spacing is present, it is the same for all items
    // So we adjust the start and end angle of the arc such that
    // the distance is the same as it would be without the spacing
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
    spacingOffset = (alpha - adjustedAngle) / 2;
  }

  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const {
    outerStart,
    outerEnd,
    innerStart,
    innerEnd
  } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();

  if (circular) {
    // The first arc segments from point 1 to point a to point 2
    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle); // The corner segment from point 2 to point 3

    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    } // The line from point 3 to point 4


    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
    ctx.lineTo(p4.x, p4.y); // The corner segment from point 4 to point 5

    if (innerEnd > 0) {
      const pCenter1 = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
      ctx.arc(pCenter1.x, pCenter1.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    } // The inner arc from point 5 to point b to point 6


    const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
    ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true); // The corner segment from point 6 to point 7

    if (innerStart > 0) {
      const pCenter2 = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
      ctx.arc(pCenter2.x, pCenter2.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    } // The line from point 7 to point 8


    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
    ctx.lineTo(p8.x, p8.y); // The corner segment from point 8 to point 1

    if (outerStart > 0) {
      const pCenter3 = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
      ctx.arc(pCenter3.x, pCenter3.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x, y);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerEndX, outerEndY);
  }

  ctx.closePath();
}

function drawArc(ctx, element, offset, spacing, circular) {
  const {
    fullCircles,
    startAngle,
    circumference
  } = element;
  let endAngle = element.endAngle;

  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);

    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }

    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }

  pathArc(ctx, element, offset, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}

function drawBorder(ctx, element, offset, spacing, circular) {
  const {
    fullCircles,
    startAngle,
    circumference,
    options
  } = element;
  const {
    borderWidth,
    borderJoinStyle
  } = options;
  const inner = options.borderAlign === 'inner';

  if (!borderWidth) {
    return;
  }

  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || 'round';
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || 'bevel';
  }

  let endAngle = element.endAngle;

  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);

    for (let i = 0; i < fullCircles; ++i) {
      ctx.stroke();
    }

    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }

  if (inner) {
    clipArc(ctx, element, endAngle);
  }

  if (!fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.stroke();
  }
}

class ArcElement extends Element {
  static id = 'arc';
  static defaults = {
    borderAlign: 'center',
    borderColor: '#fff',
    borderJoinStyle: undefined,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: undefined,
    circular: true
  };
  static defaultRoutes = {
    backgroundColor: 'backgroundColor'
  };

  constructor(cfg) {
    super();
    this.options = undefined;
    this.circumference = undefined;
    this.startAngle = undefined;
    this.endAngle = undefined;
    this.innerRadius = undefined;
    this.outerRadius = undefined;
    this.pixelMargin = 0;
    this.fullCircles = 0;

    if (cfg) {
      Object.assign(this, cfg);
    }
  }

  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps(['x', 'y'], useFinalPosition);
    const {
      angle,
      distance
    } = getAngleFromPoint(point, {
      x: chartX,
      y: chartY
    });
    const {
      startAngle,
      endAngle,
      innerRadius,
      outerRadius,
      circumference
    } = this.getProps(['startAngle', 'endAngle', 'innerRadius', 'outerRadius', 'circumference'], useFinalPosition);
    const rAdjust = this.options.spacing / 2;

    const _circumference = valueOrDefault(circumference, endAngle - startAngle);

    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);

    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);

    return betweenAngles && withinRadius;
  }

  getCenterPoint(useFinalPosition) {
    const {
      x,
      y,
      startAngle,
      endAngle,
      innerRadius,
      outerRadius
    } = this.getProps(['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius', 'circumference'], useFinalPosition);
    const {
      offset,
      spacing
    } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }

  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }

  draw(ctx) {
    const {
      options,
      circumference
    } = this;
    const offset = (options.offset || 0) / 4;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;

    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }

    ctx.save();
    const halfAngle = (this.startAngle + this.endAngle) / 2;
    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
    const radiusOffset = offset * fix;
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, circular);
    ctx.restore();
  }

}

function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}

function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}

function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }

  if (options.tension || options.cubicInterpolationMode === 'monotone') {
    return _bezierCurveTo;
  }

  return lineTo;
}

function pathVars(points, segment, params = {}) {
  const count = points.length;
  const {
    start: paramsStart = 0,
    end: paramsEnd = count - 1
  } = params;
  const {
    start: segmentStart,
    end: segmentEnd
  } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}

function pathSegment(ctx, line, segment, params) {
  const {
    points,
    options
  } = line;
  const {
    count,
    start,
    loop,
    ilen
  } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let {
    move = true,
    reverse
  } = params || {};
  let i, point, prev;

  for (i = 0; i <= ilen; ++i) {
    point = points[(start + (reverse ? ilen - i : i)) % count];

    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }

    prev = point;
  }

  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }

  return !!loop;
}

function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const {
    count,
    start,
    ilen
  } = pathVars(points, segment, params);
  const {
    move = true,
    reverse
  } = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;

  const pointIndex = index => (start + (reverse ? ilen - index : index)) % count;

  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };

  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }

  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];

    if (point.skip) {
      continue;
    }

    const x = point.x;
    const y = point.y;
    const truncX = x | 0;

    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }

      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }

    lastY = y;
  }

  drawX();
}

function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}

function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }

  if (options.tension || options.cubicInterpolationMode === 'monotone') {
    return _bezierInterpolation;
  }

  return _pointInLine;
}

function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;

  if (!path) {
    path = line._path = new Path2D();

    if (line.path(path, start, count)) {
      path.closePath();
    }
  }

  setStyle(ctx, line.options);
  ctx.stroke(path);
}

function strokePathDirect(ctx, line, start, count) {
  const {
    segments,
    options
  } = line;

  const segmentMethod = _getSegmentMethod(line);

  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();

    if (segmentMethod(ctx, line, segment, {
      start,
      end: start + count - 1
    })) {
      ctx.closePath();
    }

    ctx.stroke();
  }
}

const usePath2D = typeof Path2D === 'function';

function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}

class LineElement extends Element {
  static id = 'line';
  static defaults = {
    borderCapStyle: 'butt',
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: 'miter',
    borderWidth: 3,
    capBezierPoints: true,
    cubicInterpolationMode: 'default',
    fill: false,
    spanGaps: false,
    stepped: false,
    tension: 0
  };
  static defaultRoutes = {
    backgroundColor: 'backgroundColor',
    borderColor: 'borderColor'
  };
  static descriptors = {
    _scriptable: true,
    _indexable: name => name !== 'borderDash' && name !== 'fill'
  };

  constructor(cfg) {
    super();
    this.animated = true;
    this.options = undefined;
    this._chart = undefined;
    this._loop = undefined;
    this._fullLoop = undefined;
    this._path = undefined;
    this._points = undefined;
    this._segments = undefined;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = undefined;

    if (cfg) {
      Object.assign(this, cfg);
    }
  }

  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;

    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;

      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);

      this._pointsUpdated = true;
    }
  }

  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }

  get points() {
    return this._points;
  }

  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }

  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }

  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }

  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;

    const segments = _boundSegments(this, {
      property,
      start: value,
      end: value
    });

    if (!segments.length) {
      return;
    }

    const result = [];

    const _interpolate = _getInterpolationMethod(options);

    let i, ilen;

    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const {
        start,
        end
      } = segments[i];
      const p1 = points[start];
      const p2 = points[end];

      if (p1 === p2) {
        result.push(p1);
        continue;
      }

      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));

      const interpolated = _interpolate(p1, p2, t, options.stepped);

      interpolated[property] = point[property];
      result.push(interpolated);
    }

    return result.length === 1 ? result[0] : result;
  }

  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);

    return segmentMethod(ctx, this, segment, params);
  }

  path(ctx, start, count) {
    const segments = this.segments;

    const segmentMethod = _getSegmentMethod(this);

    let loop = this._loop;
    start = start || 0;
    count = count || this.points.length - start;

    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, {
        start,
        end: start + count - 1
      });
    }

    return !!loop;
  }

  draw(ctx, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];

    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }

    if (this.animated) {
      this._pointsUpdated = false;
      this._path = undefined;
    }
  }

}

function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const {
    [axis]: value
  } = el.getProps([axis], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}

class PointElement extends Element {
  static id = 'point';
  /**
  * @type {any}
  */

  static defaults = {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: 'circle',
    radius: 3,
    rotation: 0
  };
  /**
  * @type {any}
  */

  static defaultRoutes = {
    backgroundColor: 'backgroundColor',
    borderColor: 'borderColor'
  };

  constructor(cfg) {
    super();
    this.options = undefined;
    this.parsed = undefined;
    this.skip = undefined;
    this.stop = undefined;

    if (cfg) {
      Object.assign(this, cfg);
    }
  }

  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const {
      x,
      y
    } = this.getProps(['x', 'y'], useFinalPosition);
    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }

  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, 'x', useFinalPosition);
  }

  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, 'y', useFinalPosition);
  }

  getCenterPoint(useFinalPosition) {
    const {
      x,
      y
    } = this.getProps(['x', 'y'], useFinalPosition);
    return {
      x,
      y
    };
  }

  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }

  draw(ctx, area) {
    const options = this.options;

    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }

    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }

  getRange() {
    const options = this.options || {}; // @ts-expect-error Fallbacks should never be hit in practice

    return options.radius + options.hitRadius;
  }

}

function getBarBounds(bar, useFinalPosition) {
  const {
    x,
    y,
    base,
    width,
    height
  } = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);
  let left, right, top, bottom, half;

  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }

  return {
    left,
    top,
    right,
    bottom
  };
}

function skipOrLimit(skip, value, min, max) {
  return skip ? 0 : _limitValue(value, min, max);
}

function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip.top, o.top, 0, maxH),
    r: skipOrLimit(skip.right, o.right, 0, maxW),
    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip.left, o.left, 0, maxW)
  };
}

function parseBorderRadius(bar, maxW, maxH) {
  const {
    enableBorderRadius
  } = bar.getProps(['enableBorderRadius']);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)
  };
}

function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}

function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
}

function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}

function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}

function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h,
    radius: rect.radius
  };
}

class BarElement extends Element {
  static id = 'bar';
  static defaults = {
    borderSkipped: 'start',
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: 'auto',
    pointStyle: undefined
  };
  static defaultRoutes = {
    backgroundColor: 'backgroundColor',
    borderColor: 'borderColor'
  };

  constructor(cfg) {
    super();
    this.options = undefined;
    this.horizontal = undefined;
    this.base = undefined;
    this.width = undefined;
    this.height = undefined;
    this.inflateAmount = undefined;

    if (cfg) {
      Object.assign(this, cfg);
    }
  }

  draw(ctx) {
    const {
      inflateAmount,
      options: {
        borderColor,
        backgroundColor
      }
    } = this;
    const {
      inner,
      outer
    } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();

    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill('evenodd');
    }

    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }

  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }

  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }

  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }

  getCenterPoint(useFinalPosition) {
    const {
      x,
      y,
      base,
      horizontal
    } = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }

  getRange(axis) {
    return axis === 'x' ? this.width / 2 : this.height / 2;
  }

}

var elements = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ArcElement: ArcElement,
  LineElement: LineElement,
  PointElement: PointElement,
  BarElement: BarElement
});
const BORDER_COLORS = ['rgb(54, 162, 235)', 'rgb(255, 99, 132)', 'rgb(255, 159, 64)', 'rgb(255, 205, 86)', 'rgb(75, 192, 192)', 'rgb(153, 102, 255)', 'rgb(201, 203, 207)' // grey
]; // Border colors with 50% transparency

const BACKGROUND_COLORS = /* #__PURE__ */BORDER_COLORS.map(color => color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));

function getBorderColor(i) {
  return BORDER_COLORS[i % BORDER_COLORS.length];
}

function getBackgroundColor(i) {
  return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
}

function colorizeDefaultDataset(dataset, i) {
  dataset.borderColor = getBorderColor(i);
  dataset.backgroundColor = getBackgroundColor(i);
  return ++i;
}

function colorizeDoughnutDataset(dataset, i) {
  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));
  return i;
}

function colorizePolarAreaDataset(dataset, i) {
  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));
  return i;
}

function getColorizer(chart) {
  let i = 0;
  return (dataset, datasetIndex) => {
    const controller = chart.getDatasetMeta(datasetIndex).controller;

    if (controller instanceof DoughnutController) {
      i = colorizeDoughnutDataset(dataset, i);
    } else if (controller instanceof PolarAreaController) {
      i = colorizePolarAreaDataset(dataset, i);
    } else if (controller) {
      i = colorizeDefaultDataset(dataset, i);
    }
  };
}

function containsColorsDefinitions(descriptors) {
  let k;

  for (k in descriptors) {
    if (descriptors[k].borderColor || descriptors[k].backgroundColor) {
      return true;
    }
  }

  return false;
}

var plugin_colors = {
  id: 'colors',
  defaults: {
    enabled: true,
    forceOverride: false
  },

  beforeLayout(chart, _args, options) {
    if (!options.enabled) {
      return;
    }

    const {
      options: {
        elements
      },
      data: {
        datasets
      }
    } = chart.config;

    if (!options.forceOverride && (containsColorsDefinitions(datasets) || elements && containsColorsDefinitions(elements))) {
      return;
    }

    const colorizer = getColorizer(chart);
    datasets.forEach(colorizer);
  }

};

function lttbDecimation(data, start, count, availableWidth, options) {
  const samples = options.samples || availableWidth;

  if (samples >= count) {
    return data.slice(start, start + count);
  }

  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a = start;
  let i, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a];

  for (i = 0; i < samples - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;

    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }

    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
    const {
      x: pointAx,
      y: pointAy
    } = data[a];
    maxArea = area = -1;

    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));

      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }

    decimated[sampledIndex++] = maxAreaPoint;
    a = nextA;
  }

  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}

function minMaxDecimation(data, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data[start].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;

  for (i = start; i < start + count; ++i) {
    point = data[i];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;

    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i;
      }

      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i - 1;

      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);

        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({ ...data[intermediateIndex1],
            x: avgX
          });
        }

        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({ ...data[intermediateIndex2],
            x: avgX
          });
        }
      }

      if (i > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }

      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i;
    }
  }

  return decimated;
}

function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, 'data', {
      value: data
    });
  }
}

function cleanDecimatedData(chart) {
  chart.data.datasets.forEach(dataset => {
    cleanDecimatedDataset(dataset);
  });
}

function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const {
    iScale
  } = meta;
  const {
    min,
    max,
    minDefined,
    maxDefined
  } = iScale.getUserBounds();

  if (minDefined) {
    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
  }

  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }

  return {
    start,
    count
  };
}

var plugin_decimation = {
  id: 'decimation',
  defaults: {
    algorithm: 'min-max',
    enabled: false
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }

    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const {
        _data,
        indexAxis
      } = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;

      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {
        return;
      }

      if (!meta.controller.supportsDecimation) {
        return;
      }

      const xAxis = chart.scales[meta.xAxisID];

      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {
        return;
      }

      if (chart.options.parsing) {
        return;
      }

      let {
        start,
        count
      } = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options.threshold || 4 * availableWidth;

      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }

      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, 'data', {
          configurable: true,
          enumerable: true,
          get: function () {
            return this._decimated;
          },
          set: function (d) {
            this._data = d;
          }
        });
      }

      let decimated;

      switch (options.algorithm) {
        case 'lttb':
          decimated = lttbDecimation(data, start, count, availableWidth, options);
          break;

        case 'min-max':
          decimated = minMaxDecimation(data, start, count, availableWidth);
          break;

        default:
          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }

      dataset._decimated = decimated;
    });
  },

  destroy(chart) {
    cleanDecimatedData(chart);
  }

};

function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];

  for (const segment of segments) {
    let {
      start,
      end
    } = segment;
    end = _findSegmentEnd(start, end, points);

    const bounds = _getBounds(property, points[start], points[end], segment.loop);

    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }

    const targetSegments = _boundSegments(target, bounds);

    for (const tgt of targetSegments) {
      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);

      const fillSources = _boundSegment(segment, points, subBounds);

      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, 'start', Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, 'end', Math.min)
          }
        });
      }
    }
  }

  return parts;
}

function _getBounds(property, first, last, loop) {
  if (loop) {
    return;
  }

  let start = first[property];
  let end = last[property];

  if (property === 'angle') {
    start = _normalizeAngle(start);
    end = _normalizeAngle(end);
  }

  return {
    property,
    start,
    end
  };
}

function _pointsFromSegments(boundary, line) {
  const {
    x = null,
    y = null
  } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({
    start,
    end
  }) => {
    end = _findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];

    if (y !== null) {
      points.push({
        x: first.x,
        y
      });
      points.push({
        x: last.x,
        y
      });
    } else if (x !== null) {
      points.push({
        x,
        y: first.y
      });
      points.push({
        x,
        y: last.y
      });
    }
  });
  return points;
}

function _findSegmentEnd(start, end, points) {
  for (; end > start; end--) {
    const point = points[end];

    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }

  return end;
}

function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }

  return a ? a[prop] : b ? b[prop] : 0;
}

function _createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;

  if (isArray(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = _pointsFromSegments(boundary, line);
  }

  return points.length ? new LineElement({
    points,
    options: {
      tension: 0
    },
    _loop,
    _fullLoop: _loop
  }) : null;
}

function _shouldApplyFill(source) {
  return source && source.fill !== false;
}

function _resolveTarget(sources, index, propagate) {
  const source = sources[index];
  let fill = source.fill;
  const visited = [index];
  let target;

  if (!propagate) {
    return fill;
  }

  while (fill !== false && visited.indexOf(fill) === -1) {
    if (!isNumberFinite(fill)) {
      return fill;
    }

    target = sources[fill];

    if (!target) {
      return false;
    }

    if (target.visible) {
      return fill;
    }

    visited.push(fill);
    fill = target.fill;
  }

  return false;
}

function _decodeFill(line, index, count) {
  const fill = parseFillOption(line);

  if (isObject(fill)) {
    return isNaN(fill.value) ? false : fill;
  }

  let target = parseFloat(fill);

  if (isNumberFinite(target) && Math.floor(target) === target) {
    return decodeTargetIndex(fill[0], index, target, count);
  }

  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;
}

function decodeTargetIndex(firstCh, index, target, count) {
  if (firstCh === '-' || firstCh === '+') {
    target = index + target;
  }

  if (target === index || target < 0 || target >= count) {
    return false;
  }

  return target;
}

function _getTargetPixel(fill, scale) {
  let pixel = null;

  if (fill === 'start') {
    pixel = scale.bottom;
  } else if (fill === 'end') {
    pixel = scale.top;
  } else if (isObject(fill)) {
    pixel = scale.getPixelForValue(fill.value);
  } else if (scale.getBasePixel) {
    pixel = scale.getBasePixel();
  }

  return pixel;
}

function _getTargetValue(fill, scale, startValue) {
  let value;

  if (fill === 'start') {
    value = startValue;
  } else if (fill === 'end') {
    value = scale.options.reverse ? scale.min : scale.max;
  } else if (isObject(fill)) {
    value = fill.value;
  } else {
    value = scale.getBaseValue();
  }

  return value;
}

function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);

  if (fill === undefined) {
    fill = !!options.backgroundColor;
  }

  if (fill === false || fill === null) {
    return false;
  }

  if (fill === true) {
    return 'origin';
  }

  return fill;
}

function _buildStackLine(source) {
  const {
    scale,
    index,
    line
  } = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index);
  linesBelow.push(_createBoundaryLine({
    x: null,
    y: scale.bottom
  }, line));

  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];

    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }

  return new LineElement({
    points,
    options: {}
  });
}

function getLinesBelow(scale, index) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas('line');

  for (let i = 0; i < metas.length; i++) {
    const meta = metas[i];

    if (meta.index === index) {
      break;
    }

    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }

  return below;
}

function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];

  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const {
      first,
      last,
      point
    } = findPoint(line, sourcePoint, 'x');

    if (!point || first && last) {
      continue;
    }

    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);

      if (!last) {
        break;
      }
    }
  }

  points.push(...postponed);
}

function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);

  if (!point) {
    return {};
  }

  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;

  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];

    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }

  return {
    first,
    last,
    point
  };
}

class simpleArc {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }

  pathSegment(ctx, bounds, opts) {
    const {
      x,
      y,
      radius
    } = this;
    bounds = bounds || {
      start: 0,
      end: TAU
    };
    ctx.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }

  interpolate(point) {
    const {
      x,
      y,
      radius
    } = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }

}

function _getTarget(source) {
  const {
    chart,
    fill,
    line
  } = source;

  if (isNumberFinite(fill)) {
    return getLineByIndex(chart, fill);
  }

  if (fill === 'stack') {
    return _buildStackLine(source);
  }

  if (fill === 'shape') {
    return true;
  }

  const boundary = computeBoundary(source);

  if (boundary instanceof simpleArc) {
    return boundary;
  }

  return _createBoundaryLine(boundary, line);
}

function getLineByIndex(chart, index) {
  const meta = chart.getDatasetMeta(index);
  const visible = meta && chart.isDatasetVisible(index);
  return visible ? meta.dataset : null;
}

function computeBoundary(source) {
  const scale = source.scale || {};

  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }

  return computeLinearBoundary(source);
}

function computeLinearBoundary(source) {
  const {
    scale = {},
    fill
  } = source;

  const pixel = _getTargetPixel(fill, scale);

  if (isNumberFinite(pixel)) {
    const horizontal = scale.isHorizontal();
    return {
      x: horizontal ? pixel : null,
      y: horizontal ? null : pixel
    };
  }

  return null;
}

function computeCircularBoundary(source) {
  const {
    scale,
    fill
  } = source;
  const options = scale.options;
  const length = scale.getLabels().length;
  const start = options.reverse ? scale.max : scale.min;

  const value = _getTargetValue(fill, scale, start);

  const target = [];

  if (options.grid.circular) {
    const center = scale.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }

  for (let i = 0; i < length; ++i) {
    target.push(scale.getPointPositionForValue(i, value));
  }

  return target;
}

function _drawfill(ctx, source, area) {
  const target = _getTarget(source);

  const {
    line,
    scale,
    axis
  } = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color = lineOpts.backgroundColor;
  const {
    above = color,
    below = color
  } = fillOption || {};

  if (target && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, {
      line,
      target,
      above,
      below,
      area,
      scale,
      axis
    });
    unclipArea(ctx);
  }
}

function doFill(ctx, cfg) {
  const {
    line,
    target,
    above,
    below,
    area,
    scale
  } = cfg;
  const property = line._loop ? 'angle' : cfg.axis;
  ctx.save();

  if (property === 'x' && below !== above) {
    clipVertical(ctx, target, area.top);
    fill(ctx, {
      line,
      target,
      color: above,
      scale,
      property
    });
    ctx.restore();
    ctx.save();
    clipVertical(ctx, target, area.bottom);
  }

  fill(ctx, {
    line,
    target,
    color: below,
    scale,
    property
  });
  ctx.restore();
}

function clipVertical(ctx, target, clipY) {
  const {
    segments,
    points
  } = target;
  let first = true;
  let lineLoop = false;
  ctx.beginPath();

  for (const segment of segments) {
    const {
      start,
      end
    } = segment;
    const firstPoint = points[start];

    const lastPoint = points[_findSegmentEnd(start, end, points)];

    if (first) {
      ctx.moveTo(firstPoint.x, firstPoint.y);
      first = false;
    } else {
      ctx.lineTo(firstPoint.x, clipY);
      ctx.lineTo(firstPoint.x, firstPoint.y);
    }

    lineLoop = !!target.pathSegment(ctx, segment, {
      move: lineLoop
    });

    if (lineLoop) {
      ctx.closePath();
    } else {
      ctx.lineTo(lastPoint.x, clipY);
    }
  }

  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}

function fill(ctx, cfg) {
  const {
    line,
    target,
    property,
    color,
    scale
  } = cfg;

  const segments = _segments(line, target, property);

  for (const {
    source: src,
    target: tgt,
    start,
    end
  } of segments) {
    const {
      style: {
        backgroundColor = color
      } = {}
    } = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop;

    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property);
      }

      const targetLoop = !!target.pathSegment(ctx, tgt, {
        move: lineLoop,
        reverse: true
      });
      loop = lineLoop && targetLoop;

      if (!loop) {
        interpolatedLineTo(ctx, target, start, property);
      }
    }

    ctx.closePath();
    ctx.fill(loop ? 'evenodd' : 'nonzero');
    ctx.restore();
  }
}

function clipBounds(ctx, scale, bounds) {
  const {
    top,
    bottom
  } = scale.chart.chartArea;
  const {
    property,
    start,
    end
  } = bounds || {};

  if (property === 'x') {
    ctx.beginPath();
    ctx.rect(start, top, end - start, bottom - top);
    ctx.clip();
  }
}

function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);

  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}

var index = {
  id: 'filler',

  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i, line, source;

    for (i = 0; i < count; ++i) {
      meta = chart.getDatasetMeta(i);
      line = meta.dataset;
      source = null;

      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i),
          index: i,
          fill: _decodeFill(line, i, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line
        };
      }

      meta.$filler = source;
      sources.push(source);
    }

    for (i = 0; i < count; ++i) {
      source = sources[i];

      if (!source || source.fill === false) {
        continue;
      }

      source.fill = _resolveTarget(sources, i, options.propagate);
    }
  },

  beforeDraw(chart, _args, options) {
    const draw = options.drawTime === 'beforeDraw';
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;

    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;

      if (!source) {
        continue;
      }

      source.line.updateControlPoints(area, source.axis);

      if (draw && source.fill) {
        _drawfill(chart.ctx, source, area);
      }
    }
  },

  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== 'beforeDatasetsDraw') {
      return;
    }

    const metasets = chart.getSortedVisibleDatasetMetas();

    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;

      if (_shouldApplyFill(source)) {
        _drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },

  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;

    if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {
      return;
    }

    _drawfill(chart.ctx, source, chart.chartArea);
  },

  defaults: {
    propagate: true,
    drawTime: 'beforeDatasetDraw'
  }
};

const getBoxSize = (labelOpts, fontSize) => {
  let {
    boxHeight = fontSize,
    boxWidth = fontSize
  } = labelOpts;

  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }

  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};

const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;

class Legend extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = undefined;
    this.columnSizes = undefined;
    this.lineWidths = undefined;
    this.maxHeight = undefined;
    this.maxWidth = undefined;
    this.top = undefined;
    this.bottom = undefined;
    this.left = undefined;
    this.right = undefined;
    this.height = undefined;
    this.width = undefined;
    this._margins = undefined;
    this.position = undefined;
    this.weight = undefined;
    this.fullSize = undefined;
  }

  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }

  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }

  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];

    if (labelOpts.filter) {
      legendItems = legendItems.filter(item => labelOpts.filter(item, this.chart.data));
    }

    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }

    if (this.options.reverse) {
      legendItems.reverse();
    }

    this.legendItems = legendItems;
  }

  fit() {
    const {
      options,
      ctx
    } = this;

    if (!options.display) {
      this.width = this.height = 0;
      return;
    }

    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;

    const titleHeight = this._computeTitleHeight();

    const {
      boxWidth,
      itemHeight
    } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;

    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
    }

    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }

  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const {
      ctx,
      maxWidth,
      options: {
        labels: {
          padding
        }
      }
    } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [0];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;

      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }

      hitboxes[i] = {
        left: 0,
        top,
        row,
        width: itemWidth,
        height: itemHeight
      };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }

  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
    const {
      ctx,
      maxHeight,
      options: {
        labels: {
          padding
        }
      }
    } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const {
        itemWidth,
        itemHeight
      } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);

      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }

      hitboxes[i] = {
        left,
        top: currentColHeight,
        col,
        width: itemWidth,
        height: itemHeight
      };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({
      width: currentColWidth,
      height: currentColHeight
    });
    return totalWidth;
  }

  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }

    const titleHeight = this._computeTitleHeight();

    const {
      legendHitBoxes: hitboxes,
      options: {
        align,
        labels: {
          padding
        },
        rtl
      }
    } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);

    if (this.isHorizontal()) {
      let row = 0;

      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);

      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }

        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;

      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);

      for (const hitbox1 of hitboxes) {
        if (hitbox1.col !== col) {
          col = hitbox1.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }

        hitbox1.top = top;
        hitbox1.left += this.left + padding;
        hitbox1.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox1.left), hitbox1.width);
        top += hitbox1.height + padding;
      }
    }
  }

  isHorizontal() {
    return this.options.position === 'top' || this.options.position === 'bottom';
  }

  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);

      this._draw();

      unclipArea(ctx);
    }
  }

  _draw() {
    const {
      options: opts,
      columnSizes,
      lineWidths,
      ctx
    } = this;
    const {
      align,
      labels: labelOpts
    } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const {
      padding
    } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign('left');
    ctx.textBaseline = 'middle';
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const {
      boxWidth,
      boxHeight,
      itemHeight
    } = getBoxSize(labelOpts, fontSize);

    const drawLegendBox = function (x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }

      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));

      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();

        if (Object.values(borderRadius).some(v => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }

        ctx.fill();

        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }

      ctx.restore();
    };

    const fillText = function (x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };

    const isHorizontal = this.isHorizontal();

    const titleHeight = this._computeTitleHeight();

    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }

    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor;
      ctx.fillStyle = legendItem.fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);

      if (isHorizontal) {
        if (i > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }

      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);

      if (isHorizontal) {
        cursor.x += width + padding;
      } else if (typeof legendItem.text !== 'string') {
        const fontLineHeight = labelFont.lineHeight;
        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight);
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }

  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);

    if (!titleOpts.display) {
      return;
    }

    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;

    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }

    const x = _alignStartEnd(position, left, left + maxWidth);

    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = 'middle';
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }

  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }

  _getLegendItemAt(x, y) {
    let i, hitBox, lh;

    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;

      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];

        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }

    return null;
  }

  handleEvent(e) {
    const opts = this.options;

    if (!isListened(e.type, opts)) {
      return;
    }

    const hoveredItem = this._getLegendItemAt(e.x, e.y);

    if (e.type === 'mousemove' || e.type === 'mouseout') {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);

      if (previous && !sameItem) {
        callback(opts.onLeave, [e, previous, this], this);
      }

      this._hoveredItem = hoveredItem;

      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [e, hoveredItem, this], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [e, hoveredItem, this], this);
    }
  }

}

function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
  return {
    itemWidth,
    itemHeight
  };
}

function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
  let legendItemText = legendItem.text;

  if (legendItemText && typeof legendItemText !== 'string') {
    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
  }

  return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}

function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
  let itemHeight = _itemHeight;

  if (typeof legendItem.text !== 'string') {
    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
  }

  return itemHeight;
}

function calculateLegendItemHeight(legendItem, fontLineHeight) {
  const labelHeight = legendItem.text ? legendItem.text.length + 0.5 : 0;
  return fontLineHeight * labelHeight;
}

function isListened(type, opts) {
  if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {
    return true;
  }

  if (opts.onClick && (type === 'click' || type === 'mouseup')) {
    return true;
  }

  return false;
}

var plugin_legend = {
  id: 'legend',
  _element: Legend,

  start(chart, _args, options) {
    const legend = chart.legend = new Legend({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },

  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },

  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },

  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },

  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },

  defaults: {
    display: true,
    position: 'top',
    align: 'center',
    fullSize: true,
    reverse: false,
    weight: 1000,

    onClick(e, legendItem, legend) {
      const index = legendItem.datasetIndex;
      const ci = legend.chart;

      if (ci.isDatasetVisible(index)) {
        ci.hide(index);
        legendItem.hidden = true;
      } else {
        ci.show(index);
        legendItem.hidden = false;
      }
    },

    onHover: null,
    onLeave: null,
    labels: {
      color: ctx => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,

      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const {
          labels: {
            usePointStyle,
            pointStyle,
            textAlign,
            color,
            useBorderRadius,
            borderRadius
          }
        } = chart.legend.options;
        return chart._getSortedDatasetMetas().map(meta => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
            datasetIndex: meta.index
          };
        }, this);
      }

    },
    title: {
      color: ctx => ctx.chart.options.color,
      display: false,
      position: 'center',
      text: ''
    }
  },
  descriptors: {
    _scriptable: name => !name.startsWith('on'),
    labels: {
      _scriptable: name => !['generateLabels', 'filter', 'sort'].includes(name)
    }
  }
};

class Title extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = undefined;
    this.top = undefined;
    this.bottom = undefined;
    this.left = undefined;
    this.right = undefined;
    this.width = undefined;
    this.height = undefined;
    this.position = undefined;
    this.weight = undefined;
    this.fullSize = undefined;
  }

  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;

    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }

    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);

    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;

    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }

  isHorizontal() {
    const pos = this.options.position;
    return pos === 'top' || pos === 'bottom';
  }

  _drawArgs(offset) {
    const {
      top,
      left,
      bottom,
      right,
      options
    } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;

    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === 'left') {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }

      maxWidth = bottom - top;
    }

    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }

  draw() {
    const ctx = this.ctx;
    const opts = this.options;

    if (!opts.display) {
      return;
    }

    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;

    const {
      titleX,
      titleY,
      maxWidth,
      rotation
    } = this._drawArgs(offset);

    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: 'middle',
      translation: [titleX, titleY]
    });
  }

}

function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}

var plugin_title = {
  id: 'title',
  _element: Title,

  start(chart, _args, options) {
    createTitle(chart, options);
  },

  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },

  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },

  defaults: {
    align: 'center',
    display: false,
    font: {
      weight: 'bold'
    },
    fullSize: true,
    padding: 10,
    position: 'top',
    text: '',
    weight: 2000
  },
  defaultRoutes: {
    color: 'color'
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
const map = new WeakMap();
var plugin_subtitle = {
  id: 'subtitle',

  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map.set(chart, title);
  },

  stop(chart) {
    layouts.removeBox(chart, map.get(chart));
    map.delete(chart);
  },

  beforeUpdate(chart, _args, options) {
    const title = map.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },

  defaults: {
    align: 'center',
    display: false,
    font: {
      weight: 'normal'
    },
    fullSize: true,
    padding: 0,
    position: 'top',
    text: '',
    weight: 1500
  },
  defaultRoutes: {
    color: 'color'
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
const positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }

    let i, len;
    let x = 0;
    let y = 0;
    let count = 0;

    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;

      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        x += pos.x;
        y += pos.y;
        ++count;
      }
    }

    return {
      x: x / count,
      y: y / count
    };
  },

  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }

    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;

    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;

      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);

        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }

    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }

    return {
      x,
      y
    };
  }

};

function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }

  return base;
}

function splitNewlines(str) {
  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
    return str.split('\n');
  }

  return str;
}

function createTooltipItem(chart, item) {
  const {
    element,
    datasetIndex,
    index
  } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const {
    label,
    value
  } = controller.getLabelAndValue(index);
  return {
    chart,
    label,
    parsed: controller.getParsed(index),
    raw: chart.data.datasets[datasetIndex].data[index],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index,
    datasetIndex,
    element
  };
}

function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const {
    body,
    footer,
    title
  } = tooltip;
  const {
    boxWidth,
    boxHeight
  } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;

  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }

  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }

  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }

  let widthPadding = 0;

  const maxLineWidth = function (line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };

  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, bodyItem => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return {
    width,
    height
  };
}

function determineYAlign(chart, size) {
  const {
    y,
    height
  } = size;

  if (y < height / 2) {
    return 'top';
  } else if (y > chart.height - height / 2) {
    return 'bottom';
  }

  return 'center';
}

function doesNotFitWithAlign(xAlign, chart, options, size) {
  const {
    x,
    width
  } = size;
  const caret = options.caretSize + options.caretPadding;

  if (xAlign === 'left' && x + width + caret > chart.width) {
    return true;
  }

  if (xAlign === 'right' && x - width - caret < 0) {
    return true;
  }
}

function determineXAlign(chart, options, size, yAlign) {
  const {
    x,
    width
  } = size;
  const {
    width: chartWidth,
    chartArea: {
      left,
      right
    }
  } = chart;
  let xAlign = 'center';

  if (yAlign === 'center') {
    xAlign = x <= (left + right) / 2 ? 'left' : 'right';
  } else if (x <= width / 2) {
    xAlign = 'left';
  } else if (x >= chartWidth - width / 2) {
    xAlign = 'right';
  }

  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = 'center';
  }

  return xAlign;
}

function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}

function alignX(size, xAlign) {
  let {
    x,
    width
  } = size;

  if (xAlign === 'right') {
    x -= width;
  } else if (xAlign === 'center') {
    x -= width / 2;
  }

  return x;
}

function alignY(size, yAlign, paddingAndSize) {
  let {
    y,
    height
  } = size;

  if (yAlign === 'top') {
    y += paddingAndSize;
  } else if (yAlign === 'bottom') {
    y -= height + paddingAndSize;
  } else {
    y -= height / 2;
  }

  return y;
}

function getBackgroundPoint(options, size, alignment, chart) {
  const {
    caretSize,
    caretPadding,
    cornerRadius
  } = options;
  const {
    xAlign,
    yAlign
  } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const {
    topLeft,
    topRight,
    bottomLeft,
    bottomRight
  } = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);

  if (yAlign === 'center') {
    if (xAlign === 'left') {
      x += paddingAndSize;
    } else if (xAlign === 'right') {
      x -= paddingAndSize;
    }
  } else if (xAlign === 'left') {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === 'right') {
    x += Math.max(topRight, bottomRight) + caretSize;
  }

  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}

function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === 'center' ? tooltip.x + tooltip.width / 2 : align === 'right' ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}

function getBeforeAfterBodyLines(callback) {
  return pushOrConcat([], splitNewlines(callback));
}

function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: 'tooltip'
  });
}

function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}

const defaultCallbacks = {
  beforeTitle: noop,

  title(tooltipItems) {
    if (tooltipItems.length > 0) {
      const item = tooltipItems[0];
      const labels = item.chart.data.labels;
      const labelCount = labels ? labels.length : 0;

      if (this && this.options && this.options.mode === 'dataset') {
        return item.dataset.label || '';
      } else if (item.label) {
        return item.label;
      } else if (labelCount > 0 && item.dataIndex < labelCount) {
        return labels[item.dataIndex];
      }
    }

    return '';
  },

  afterTitle: noop,
  beforeBody: noop,
  beforeLabel: noop,

  label(tooltipItem) {
    if (this && this.options && this.options.mode === 'dataset') {
      return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;
    }

    let label = tooltipItem.dataset.label || '';

    if (label) {
      label += ': ';
    }

    const value = tooltipItem.formattedValue;

    if (!isNullOrUndef(value)) {
      label += value;
    }

    return label;
  },

  labelColor(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      borderColor: options.borderColor,
      backgroundColor: options.backgroundColor,
      borderWidth: options.borderWidth,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderRadius: 0
    };
  },

  labelTextColor() {
    return this.options.bodyColor;
  },

  labelPointStyle(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      pointStyle: options.pointStyle,
      rotation: options.rotation
    };
  },

  afterLabel: noop,
  afterBody: noop,
  beforeFooter: noop,
  footer: noop,
  afterFooter: noop
};

function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
  const result = callbacks[name].call(ctx, arg);

  if (typeof result === 'undefined') {
    return defaultCallbacks[name].call(ctx, arg);
  }

  return result;
}

class Tooltip extends Element {
  static positioners = positioners;

  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = undefined;
    this._size = undefined;
    this._cachedAnimations = undefined;
    this._tooltipItems = [];
    this.$animations = undefined;
    this.$context = undefined;
    this.chart = config.chart;
    this.options = config.options;
    this.dataPoints = undefined;
    this.title = undefined;
    this.beforeBody = undefined;
    this.body = undefined;
    this.afterBody = undefined;
    this.footer = undefined;
    this.xAlign = undefined;
    this.yAlign = undefined;
    this.x = undefined;
    this.y = undefined;
    this.height = undefined;
    this.width = undefined;
    this.caretX = undefined;
    this.caretY = undefined;
    this.labelColors = undefined;
    this.labelPointStyles = undefined;
    this.labelTextColors = undefined;
  }

  initialize(options) {
    this.options = options;
    this._cachedAnimations = undefined;
    this.$context = undefined;
  }

  _resolveAnimations() {
    const cached = this._cachedAnimations;

    if (cached) {
      return cached;
    }

    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);

    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }

    return animations;
  }

  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }

  getTitle(context, options) {
    const {
      callbacks
    } = options;
    const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);
    const title = invokeCallbackWithFallback(callbacks, 'title', this, context);
    const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }

  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems));
  }

  getBody(tooltipItems, options) {
    const {
      callbacks
    } = options;
    const bodyItems = [];
    each(tooltipItems, context => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));
      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));
      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }

  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems));
  }

  getFooter(tooltipItems, options) {
    const {
      callbacks
    } = options;
    const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);
    const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);
    const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }

  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;

    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }

    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));
    }

    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }

    each(tooltipItems, context => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));
      labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));
      labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }

  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];

    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }

    this._tooltipItems = tooltipItems;
    this.$context = undefined;

    if (properties) {
      this._resolveAnimations().update(this, properties);
    }

    if (changed && options.external) {
      options.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay
      });
    }
  }

  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }

  getCaretPosition(tooltipPoint, size, options) {
    const {
      xAlign,
      yAlign
    } = this;
    const {
      caretSize,
      cornerRadius
    } = options;
    const {
      topLeft,
      topRight,
      bottomLeft,
      bottomRight
    } = toTRBLCorners(cornerRadius);
    const {
      x: ptX,
      y: ptY
    } = tooltipPoint;
    const {
      width,
      height
    } = size;
    let x1, x2, x3, y1, y2, y3;

    if (yAlign === 'center') {
      y2 = ptY + height / 2;

      if (xAlign === 'left') {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }

      x3 = x1;
    } else {
      if (xAlign === 'left') {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === 'right') {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }

      if (yAlign === 'top') {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }

      y3 = y1;
    }

    return {
      x1,
      x2,
      x3,
      y1,
      y2,
      y3
    };
  }

  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;

    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = 'middle';
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;

      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;

        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }

  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColors = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const {
      boxHeight,
      boxWidth,
      boxPadding
    } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, 'left', options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;

    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColors.borderColor;
      ctx.fillStyle = labelColors.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;
      ctx.strokeStyle = labelColors.borderColor;
      ctx.setLineDash(labelColors.borderDash || []);
      ctx.lineDashOffset = labelColors.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
      const borderRadius = toTRBLCorners(labelColors.borderRadius);

      if (Object.values(borderRadius).some(v => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }

    ctx.fillStyle = this.labelTextColors[i];
  }

  drawBody(pt, ctx, options) {
    const {
      body
    } = this;
    const {
      bodySpacing,
      bodyAlign,
      displayColors,
      boxHeight,
      boxWidth,
      boxPadding
    } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);

    const fillLineOfText = function (line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };

    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = 'middle';
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;

    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;

      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);

        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }

      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }

      each(bodyItem.after, fillLineOfText);
    }

    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }

  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;

    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = 'middle';
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;

      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }

  drawBackground(pt, ctx, tooltipSize, options) {
    const {
      xAlign,
      yAlign
    } = this;
    const {
      x,
      y
    } = pt;
    const {
      width,
      height
    } = tooltipSize;
    const {
      topLeft,
      topRight,
      bottomLeft,
      bottomRight
    } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);

    if (yAlign === 'top') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }

    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);

    if (yAlign === 'center' && xAlign === 'right') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }

    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);

    if (yAlign === 'bottom') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }

    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);

    if (yAlign === 'center' && xAlign === 'left') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }

    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();

    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }

  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;

    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);

      if (!position) {
        return;
      }

      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);

      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;

        this._resolveAnimations().update(this, point);
      }
    }
  }

  _willRender() {
    return !!this.opacity;
  }

  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;

    if (!opacity) {
      return;
    }

    this._updateAnimationTarget(options);

    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;

    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }

  getActiveElements() {
    return this._active || [];
  }

  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({
      datasetIndex,
      index
    }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);

      if (!meta) {
        throw new Error('Cannot find a dataset at index ' + datasetIndex);
      }

      return {
        datasetIndex,
        element: meta.data[index],
        index
      };
    });
    const changed = !_elementsEqual(lastActive, active);

    const positionChanged = this._positionChanged(active, eventPosition);

    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }

  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }

    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];

    const active = this._getActiveElements(e, lastActive, replay, inChartArea);

    const positionChanged = this._positionChanged(active, e);

    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;

    if (changed) {
      this._active = active;

      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }

    return changed;
  }

  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;

    if (e.type === 'mouseout') {
      return [];
    }

    if (!inChartArea) {
      return lastActive;
    }

    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);

    if (options.reverse) {
      active.reverse();
    }

    return active;
  }

  _positionChanged(active, e) {
    const {
      caretX,
      caretY,
      options
    } = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }

}

var plugin_tooltip = {
  id: 'tooltip',
  _element: Tooltip,
  positioners,

  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({
        chart,
        options
      });
    }
  },

  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },

  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },

  afterDraw(chart) {
    const tooltip = chart.tooltip;

    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };

      if (chart.notifyPlugins('beforeTooltipDraw', { ...args,
        cancelable: true
      }) === false) {
        return;
      }

      tooltip.draw(chart.ctx);
      chart.notifyPlugins('afterTooltipDraw', args);
    }
  },

  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;

      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },

  defaults: {
    enabled: true,
    external: null,
    position: 'average',
    backgroundColor: 'rgba(0,0,0,0.8)',
    titleColor: '#fff',
    titleFont: {
      weight: 'bold'
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: 'left',
    bodyColor: '#fff',
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: 'left',
    footerColor: '#fff',
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: 'bold'
    },
    footerAlign: 'left',
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: '#fff',
    displayColors: true,
    boxPadding: 0,
    borderColor: 'rgba(0,0,0,0)',
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: 'easeOutQuart'
    },
    animations: {
      numbers: {
        type: 'number',
        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY']
      },
      opacity: {
        easing: 'linear',
        duration: 200
      }
    },
    callbacks: defaultCallbacks
  },
  defaultRoutes: {
    bodyFont: 'font',
    footerFont: 'font',
    titleFont: 'font'
  },
  descriptors: {
    _scriptable: name => name !== 'filter' && name !== 'itemSort' && name !== 'external',
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: 'animation'
    }
  },
  additionalOptionScopes: ['interaction']
};
var plugins = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Colors: plugin_colors,
  Decimation: plugin_decimation,
  Filler: index,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
});

const addIfString = (labels, raw, index, addedLabels) => {
  if (typeof raw === 'string') {
    index = labels.push(raw) - 1;
    addedLabels.unshift({
      index,
      label: raw
    });
  } else if (isNaN(raw)) {
    index = null;
  }

  return index;
};

function findOrAddLabel(labels, raw, index, addedLabels) {
  const first = labels.indexOf(raw);

  if (first === -1) {
    return addIfString(labels, raw, index, addedLabels);
  }

  const last = labels.lastIndexOf(raw);
  return first !== last ? index : first;
}

const validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);

function _getLabelForValue(value) {
  const labels = this.getLabels();

  if (value >= 0 && value < labels.length) {
    return labels[value];
  }

  return value;
}

class CategoryScale extends Scale {
  static id = 'category';
  static defaults = {
    ticks: {
      callback: _getLabelForValue
    }
  };

  constructor(cfg) {
    super(cfg);
    this._startValue = undefined;
    this._valueRange = 0;
    this._addedLabels = [];
  }

  init(scaleOptions) {
    const added = this._addedLabels;

    if (added.length) {
      const labels = this.getLabels();

      for (const {
        index,
        label
      } of added) {
        if (labels[index] === label) {
          labels.splice(index, 1);
        }
      }

      this._addedLabels = [];
    }

    super.init(scaleOptions);
  }

  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }

    const labels = this.getLabels();
    index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
    return validIndex(index, labels.length - 1);
  }

  determineDataLimits() {
    const {
      minDefined,
      maxDefined
    } = this.getUserBounds();
    let {
      min,
      max
    } = this.getMinMax(true);

    if (this.options.bounds === 'ticks') {
      if (!minDefined) {
        min = 0;
      }

      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }

    this.min = min;
    this.max = max;
  }

  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);

    for (let value = min; value <= max; value++) {
      ticks.push({
        value
      });
    }

    return ticks;
  }

  getLabelForValue(value) {
    return _getLabelForValue.call(this, value);
  }

  configure() {
    super.configure();

    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }

  getPixelForValue(value) {
    if (typeof value !== 'number') {
      value = this.parse(value);
    }

    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }

  getPixelForTick(index) {
    const ticks = this.ticks;

    if (index < 0 || index > ticks.length - 1) {
      return null;
    }

    return this.getPixelForValue(ticks[index].value);
  }

  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }

  getBasePixel() {
    return this.bottom;
  }

}

function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const {
    bounds,
    step,
    min,
    max,
    precision,
    count,
    maxTicks,
    maxDigits,
    includeBounds
  } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const {
    min: rmin,
    max: rmax
  } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;

  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [{
      value: rmin
    }, {
      value: rmax
    }];
  }

  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);

  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }

  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }

  if (bounds === 'ticks') {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }

  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;

    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }

  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;

  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({
        value: min
      });

      if (niceMin < min) {
        j++;
      }

      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }

  for (; j < numSpaces; ++j) {
    ticks.push({
      value: Math.round((niceMin + j * spacing) * factor) / factor
    });
  }

  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({
        value: max
      });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({
      value: niceMax
    });
  }

  return ticks;
}

function relativeLabelSize(value, minSpacing, {
  horizontal,
  minRotation
}) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;
  const length = 0.75 * minSpacing * ('' + value).length;
  return Math.min(minSpacing / ratio, length);
}

class LinearScaleBase extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = undefined;
    this.end = undefined;
    this._startValue = undefined;
    this._endValue = undefined;
    this._valueRange = 0;
  }

  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }

    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }

    return +raw;
  }

  handleTickRangeOptions() {
    const {
      beginAtZero
    } = this.options;
    const {
      minDefined,
      maxDefined
    } = this.getUserBounds();
    let {
      min,
      max
    } = this;

    const setMin = v => min = minDefined ? min : v;

    const setMax = v => max = maxDefined ? max : v;

    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);

      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }

    if (min === max) {
      let offset = max === 0 ? 1 : Math.abs(max * 0.05);
      setMax(max + offset);

      if (!beginAtZero) {
        setMin(min - offset);
      }
    }

    this.min = min;
    this.max = max;
  }

  getTickLimit() {
    const tickOpts = this.options.ticks;
    let {
      maxTicksLimit,
      stepSize
    } = tickOpts;
    let maxTicks;

    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;

      if (maxTicks > 1000) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1000;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }

    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }

    return maxTicks;
  }

  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }

  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);

    if (opts.bounds === 'ticks') {
      _setMinAndMaxByKey(ticks, this, 'value');
    }

    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }

    return ticks;
  }

  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();

    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }

    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }

  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }

}

class LinearScale extends LinearScaleBase {
  static id = 'linear';
  static defaults = {
    ticks: {
      callback: Ticks.formatters.numeric
    }
  };

  determineDataLimits() {
    const {
      min,
      max
    } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }

  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;

    const tickFont = this._resolveTickFontOptions(0);

    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }

  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }

  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }

}

const log10Floor = v => Math.floor(log10(v));

const changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);

function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, log10Floor(tickVal));
  return remain === 1;
}

function steps(min, max, rangeExp) {
  const rangeStep = Math.pow(10, rangeExp);
  const start = Math.floor(min / rangeStep);
  const end = Math.ceil(max / rangeStep);
  return end - start;
}

function startExp(min, max) {
  const range = max - min;
  let rangeExp = log10Floor(range);

  while (steps(min, max, rangeExp) > 10) {
    rangeExp++;
  }

  while (steps(min, max, rangeExp) < 10) {
    rangeExp--;
  }

  return Math.min(rangeExp, log10Floor(min));
}

function generateTicks(generationOptions, {
  min,
  max
}) {
  min = finiteOrDefault(generationOptions.min, min);
  const ticks = [];
  const minExp = log10Floor(min);
  let exp = startExp(min, max);
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  const stepSize = Math.pow(10, exp);
  const base = minExp > exp ? Math.pow(10, minExp) : 0;
  const start = Math.round((min - base) * precision) / precision;
  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
  let significand = Math.floor((start - offset) / Math.pow(10, exp));
  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);

  while (value < max) {
    ticks.push({
      value,
      major: isMajor(value),
      significand
    });

    if (significand >= 10) {
      significand = significand < 15 ? 15 : 20;
    } else {
      significand++;
    }

    if (significand >= 20) {
      exp++;
      significand = 2;
      precision = exp >= 0 ? 1 : precision;
    }

    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
  }

  const lastTick = finiteOrDefault(generationOptions.max, value);
  ticks.push({
    value: lastTick,
    major: isMajor(lastTick),
    significand
  });
  return ticks;
}

class LogarithmicScale extends Scale {
  static id = 'logarithmic';
  static defaults = {
    ticks: {
      callback: Ticks.formatters.logarithmic,
      major: {
        enabled: true
      }
    }
  };

  constructor(cfg) {
    super(cfg);
    this.start = undefined;
    this.end = undefined;
    this._startValue = undefined;
    this._valueRange = 0;
  }

  parse(raw, index) {
    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);

    if (value === 0) {
      this._zero = true;
      return undefined;
    }

    return isNumberFinite(value) && value > 0 ? value : null;
  }

  determineDataLimits() {
    const {
      min,
      max
    } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;

    if (this.options.beginAtZero) {
      this._zero = true;
    }

    if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
    }

    this.handleTickRangeOptions();
  }

  handleTickRangeOptions() {
    const {
      minDefined,
      maxDefined
    } = this.getUserBounds();
    let min = this.min;
    let max = this.max;

    const setMin = v => min = minDefined ? min : v;

    const setMax = v => max = maxDefined ? max : v;

    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(changeExponent(min, -1));
        setMax(changeExponent(max, +1));
      }
    }

    if (min <= 0) {
      setMin(changeExponent(max, -1));
    }

    if (max <= 0) {
      setMax(changeExponent(min, +1));
    }

    this.min = min;
    this.max = max;
  }

  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);

    if (opts.bounds === 'ticks') {
      _setMinAndMaxByKey(ticks, this, 'value');
    }

    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }

    return ticks;
  }

  getLabelForValue(value) {
    return value === undefined ? '0' : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }

  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }

  getPixelForValue(value) {
    if (value === undefined || value === 0) {
      value = this.min;
    }

    if (value === null || isNaN(value)) {
      return NaN;
    }

    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }

  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }

}

function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;

  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }

  return 0;
}

function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [label];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}

function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }

  return {
    start: pos,
    end: pos + size
  };
}

function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;

  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;

    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);

    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }

  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}

function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;

  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }

  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}

function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const extra = getTickBackdropHeight(opts) / 2;
  const outerDistance = scale.drawingArea;
  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;

  for (let i = 0; i < valueCount; i++) {
    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const size = labelSizes[i];
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    items.push({
      x: pointLabelPosition.x,
      y,
      textAlign,
      left,
      top: y,
      right: left + size.w,
      bottom: y + size.h
    });
  }

  return items;
}

function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return 'center';
  } else if (angle < 180) {
    return 'left';
  }

  return 'right';
}

function leftForTextAlign(x, w, align) {
  if (align === 'right') {
    x -= w;
  } else if (align === 'center') {
    x -= w / 2;
  }

  return x;
}

function yForAngle(y, h, angle) {
  if (angle === 90 || angle === 270) {
    y -= h / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h;
  }

  return y;
}

function drawPointLabels(scale, labelCount) {
  const {
    ctx,
    options: {
      pointLabels
    }
  } = scale;

  for (let i = labelCount - 1; i >= 0; i--) {
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    const plFont = toFont(optsAtIndex.font);
    const {
      x,
      y,
      textAlign,
      left,
      top,
      right,
      bottom
    } = scale._pointLabelItems[i];
    const {
      backdropColor
    } = optsAtIndex;

    if (!isNullOrUndef(backdropColor)) {
      const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
      const padding = toPadding(optsAtIndex.backdropPadding);
      ctx.fillStyle = backdropColor;
      const backdropLeft = left - padding.left;
      const backdropTop = top - padding.top;
      const backdropWidth = right - left + padding.width;
      const backdropHeight = bottom - top + padding.height;

      if (Object.values(borderRadius).some(v => v !== 0)) {
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: backdropLeft,
          y: backdropTop,
          w: backdropWidth,
          h: backdropHeight,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
      }
    }

    renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign: textAlign,
      textBaseline: 'middle'
    });
  }
}

function pathRadiusLine(scale, radius, circular, labelCount) {
  const {
    ctx
  } = scale;

  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);

    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}

function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const {
    color,
    lineWidth
  } = gridLineOpts;

  if (!circular && !labelCount || !color || !lineWidth || radius < 0) {
    return;
  }

  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(borderOpts.dash);
  ctx.lineDashOffset = borderOpts.dashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}

function createPointLabelContext(parent, index, label) {
  return createContext(parent, {
    label,
    index,
    type: 'pointLabel'
  });
}

class RadialLinearScale extends LinearScaleBase {
  static id = 'radialLinear';
  static defaults = {
    display: true,
    animate: true,
    position: 'chartArea',
    angleLines: {
      display: true,
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0.0
    },
    grid: {
      circular: false
    },
    startAngle: 0,
    ticks: {
      showLabelBackdrop: true,
      callback: Ticks.formatters.numeric
    },
    pointLabels: {
      backdropColor: undefined,
      backdropPadding: 2,
      display: true,
      font: {
        size: 10
      },

      callback(label) {
        return label;
      },

      padding: 5,
      centerPointLabels: false
    }
  };
  static defaultRoutes = {
    'angleLines.color': 'borderColor',
    'pointLabels.color': 'color',
    'ticks.color': 'color'
  };
  static descriptors = {
    angleLines: {
      _fallback: 'grid'
    }
  };

  constructor(cfg) {
    super(cfg);
    this.xCenter = undefined;
    this.yCenter = undefined;
    this.drawingArea = undefined;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }

  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h) / 2);
  }

  determineDataLimits() {
    const {
      min,
      max
    } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }

  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }

  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index) => {
      const label = callback(this.options.pointLabels.callback, [value, index], this);
      return label || label === 0 ? label : '';
    }).filter((v, i) => this.chart.getDataVisibility(i));
  }

  fit() {
    const opts = this.options;

    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }

  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }

  getIndexAngle(index) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
  }

  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }

    const scalingFactor = this.drawingArea / (this.max - this.min);

    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }

    return (value - this.min) * scalingFactor;
  }

  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }

    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }

  getPointLabelContext(index) {
    const pointLabels = this._pointLabels || [];

    if (index >= 0 && index < pointLabels.length) {
      const pointLabel = pointLabels[index];
      return createPointLabelContext(this.getContext(), index, pointLabel);
    }
  }

  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }

  getPointPositionForValue(index, value) {
    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
  }

  getBasePosition(index) {
    return this.getPointPositionForValue(index || 0, this.getBaseValue());
  }

  getPointLabelPosition(index) {
    const {
      left,
      top,
      right,
      bottom
    } = this._pointLabelItems[index];
    return {
      left,
      top,
      right,
      bottom
    };
  }

  drawBackground() {
    const {
      backgroundColor,
      grid: {
        circular
      }
    } = this.options;

    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }

  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const {
      angleLines,
      grid,
      border
    } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position;

    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }

    if (grid.display) {
      this.ticks.forEach((tick, index) => {
        if (index !== 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const context = this.getContext(index);
          const optsAtIndex = grid.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
        }
      });
    }

    if (angleLines.display) {
      ctx.save();

      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const {
          color,
          lineWidth
        } = optsAtIndex;

        if (!lineWidth || !color) {
          continue;
        }

        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }

      ctx.restore();
    }
  }

  drawBorder() {}

  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;

    if (!tickOpts.display) {
      return;
    }

    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    this.ticks.forEach((tick, index) => {
      if (index === 0 && !opts.reverse) {
        return;
      }

      const optsAtIndex = tickOpts.setContext(this.getContext(index));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);

      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }

      renderText(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color
      });
    });
    ctx.restore();
  }

  drawTitle() {}

}

const INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1000
  },
  second: {
    common: true,
    size: 1000,
    steps: 60
  },
  minute: {
    common: true,
    size: 60000,
    steps: 60
  },
  hour: {
    common: true,
    size: 3600000,
    steps: 24
  },
  day: {
    common: true,
    size: 86400000,
    steps: 30
  },
  week: {
    common: false,
    size: 604800000,
    steps: 4
  },
  month: {
    common: true,
    size: 2.628e9,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7.884e9,
    steps: 4
  },
  year: {
    common: true,
    size: 3.154e10
  }
};
const UNITS = /* #__PURE__ */Object.keys(INTERVALS);

function sorter(a, b) {
  return a - b;
}

function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }

  const adapter = scale._adapter;
  const {
    parser,
    round,
    isoWeekday
  } = scale._parseOpts;
  let value = input;

  if (typeof parser === 'function') {
    value = parser(value);
  }

  if (!isNumberFinite(value)) {
    value = typeof parser === 'string' ? adapter.parse(value, parser) : adapter.parse(value);
  }

  if (value === null) {
    return null;
  }

  if (round) {
    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, 'isoWeek', isoWeekday) : adapter.startOf(value, round);
  }

  return +value;
}

function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;

  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;

    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }

  return UNITS[ilen - 1];
}

function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];

    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }

  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}

function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}

function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const {
      lo,
      hi
    } = _lookup(timestamps, time);

    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}

function setMajorTicks(scale, ticks, map, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index;

  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index = map[major];

    if (index >= 0) {
      ticks[index].major = true;
    }
  }

  return ticks;
}

function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map = {};
  const ilen = values.length;
  let i, value;

  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map[value] = i;
    ticks.push({
      value,
      major: false
    });
  }

  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
}

class TimeScale extends Scale {
  static id = 'time';
  static defaults = {
    bounds: 'data',
    adapters: {},
    time: {
      parser: false,
      unit: false,
      round: false,
      isoWeekday: false,
      minUnit: 'millisecond',
      displayFormats: {}
    },
    ticks: {
      source: 'auto',
      callback: false,
      major: {
        enabled: false
      }
    }
  };

  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = 'day';
    this._majorUnit = undefined;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = undefined;
  }

  init(scaleOpts, opts = {}) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }

  parse(raw, index) {
    if (raw === undefined) {
      return null;
    }

    return parse(this, raw);
  }

  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }

  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || 'day';
    let {
      min,
      max,
      minDefined,
      maxDefined
    } = this.getUserBounds();

    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }

      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }

    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());

      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {
        _applyBounds(this.getMinMax(false));
      }
    }

    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }

  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;

    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }

    return {
      min,
      max
    };
  }

  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();

    if (options.bounds === 'ticks' && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }

    const min = this.min;
    const max = this.max;

    const ticks = _filterBetween(timestamps, min, max);

    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);

    if (options.reverse) {
      ticks.reverse();
    }

    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }

  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map(tick => +tick.value));
    }
  }

  initOffsets(timestamps = []) {
    let start = 0;
    let end = 0;
    let first, last;

    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);

      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }

      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);

      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }

    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {
      start,
      end,
      factor: 1 / (start + 1 + end)
    };
  }

  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(options.ticks.stepSize, 1);
    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;

    if (hasWeekday) {
      first = +adapter.startOf(first, 'isoWeek', weekday);
    }

    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);

    if (adapter.diff(max, min, minor) > 100000 * stepSize) {
      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);
    }

    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();

    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }

    if (time === max || options.bounds === 'ticks' || count === 1) {
      addTick(ticks, time, timestamps);
    }

    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);
  }

  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;

    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }

    return adapter.format(value, timeOpts.displayFormats.datetime);
  }

  _tickFormatFunction(time, index, ticks, format) {
    const options = this.options;
    const formatter = options.ticks.callback;

    if (formatter) {
      return callback(formatter, [time, index, ticks], this);
    }

    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index];
    const major = majorUnit && majorFormat && tick && tick.major;
    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
  }

  generateTickLabels(ticks) {
    let i, ilen, tick;

    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }

  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }

  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }

  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }

  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);

    const tickFontSize = this._resolveTickFontOptions(0).size;

    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }

  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;

    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);

    const size = this._getLabelSize(exampleLabel);

    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }

  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;

    if (timestamps.length) {
      return timestamps;
    }

    const metas = this.getMatchingVisibleMetas();

    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }

    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }

    return this._cache.data = this.normalize(timestamps);
  }

  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;

    if (timestamps.length) {
      return timestamps;
    }

    const labels = this.getLabels();

    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }

    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }

  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }

}

function interpolate(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;

  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({
        lo,
        hi
      } = _lookupByKey(table, 'pos', val));
    }

    ({
      pos: prevSource,
      time: prevTarget
    } = table[lo]);
    ({
      pos: nextSource,
      time: nextTarget
    } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({
        lo,
        hi
      } = _lookupByKey(table, 'time', val));
    }

    ({
      time: prevSource,
      pos: prevTarget
    } = table[lo]);
    ({
      time: nextSource,
      pos: nextTarget
    } = table[hi]);
  }

  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}

class TimeSeriesScale extends TimeScale {
  static id = 'timeseries';
  static defaults = TimeScale.defaults;

  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = undefined;
    this._tableRange = undefined;
  }

  initOffsets() {
    const timestamps = this._getTimestampsForTable();

    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate(table, this.min);
    this._tableRange = interpolate(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }

  buildLookupTable(timestamps) {
    const {
      min,
      max
    } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;

    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];

      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }

    if (items.length < 2) {
      return [{
        time: min,
        pos: 0
      }, {
        time: max,
        pos: 1
      }];
    }

    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];

      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i / (ilen - 1)
        });
      }
    }

    return table;
  }

  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];

    if (timestamps.length) {
      return timestamps;
    }

    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();

    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }

    timestamps = this._cache.all = timestamps;
    return timestamps;
  }

  getDecimalForValue(value) {
    return (interpolate(this._table, value) - this._minPos) / this._tableRange;
  }

  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
  }

}

var scales = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CategoryScale: CategoryScale,
  LinearScale: LinearScale,
  LogarithmicScale: LogarithmicScale,
  RadialLinearScale: RadialLinearScale,
  TimeScale: TimeScale,
  TimeSeriesScale: TimeSeriesScale
});
const registerables = [controllers, elements, plugins, scales];

Chart.register(...registerables);

var auto = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': Chart,
  Ticks: Ticks,
  defaults: defaults,
  Animation: Animation,
  Animations: Animations,
  ArcElement: ArcElement,
  BarController: BarController,
  BarElement: BarElement,
  BasePlatform: BasePlatform,
  BasicPlatform: BasicPlatform,
  BubbleController: BubbleController,
  CategoryScale: CategoryScale,
  Chart: Chart,
  Colors: plugin_colors,
  DatasetController: DatasetController,
  Decimation: plugin_decimation,
  DomPlatform: DomPlatform,
  DoughnutController: DoughnutController,
  Element: Element,
  Filler: index,
  Interaction: Interaction,
  Legend: plugin_legend,
  LineController: LineController,
  LineElement: LineElement,
  LinearScale: LinearScale,
  LogarithmicScale: LogarithmicScale,
  PieController: PieController,
  PointElement: PointElement,
  PolarAreaController: PolarAreaController,
  RadarController: RadarController,
  RadialLinearScale: RadialLinearScale,
  Scale: Scale,
  ScatterController: ScatterController,
  SubTitle: plugin_subtitle,
  TimeScale: TimeScale,
  TimeSeriesScale: TimeSeriesScale,
  Title: plugin_title,
  Tooltip: plugin_tooltip,
  _adapters: adapters,
  _detectPlatform: _detectPlatform,
  animator: animator,
  controllers: controllers,
  elements: elements,
  layouts: layouts,
  plugins: plugins,
  registerables: registerables,
  registry: registry,
  scales: scales
});

export { account as Account, configs$1 as Configs, script$U as Controller, filter as Filter, flow as Flow, form as Form, report as Report, tableDisplay as Table, tree as Tree, viewField as ViewField, index$1 as default, download, getClient, initConfigs, slugTrail as slugtrail, subscribe, trigger, unsubscribe };
